<Type Name="ECDiffieHellman" FullName="System.Security.Cryptography.ECDiffieHellman">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b4ed87e32d598047c7b33c8ec5b55e24f72e1bac" /><Meta Name="ms.sourcegitcommit" Value="fbe36a3465a31f574ebd41192d31a74126cf757c" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="11/26/2019" /><Meta Name="ms.locfileid" Value="74546167" /></Metadata><TypeSignature Language="C#" Value="public abstract class ECDiffieHellman : System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ECDiffieHellman extends System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.ECDiffieHellman" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ECDiffieHellman&#xA;Inherits AsymmetricAlgorithm" />
  <TypeSignature Language="C++ CLI" Value="public ref class ECDiffieHellman abstract : System::Security::Cryptography::AsymmetricAlgorithm" />
  <TypeSignature Language="F#" Value="type ECDiffieHellman = class&#xA;    inherit AsymmetricAlgorithm" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
    <AssemblyVersion>4.3.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.AsymmetricAlgorithm</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="eb17f-101">Предоставляет абстрактный базовый класс, из которого создаются реализации алгоритма Диффи-Хеллмана на эллиптических кривых (ECDH).</span><span class="sxs-lookup"><span data-stu-id="eb17f-101">Provides an abstract base class that Elliptic Curve Diffie-Hellman (ECDH) algorithm implementations can derive from.</span></span> <span data-ttu-id="eb17f-102">Этот класс предоставляет базовый набор операций, которые должны поддерживать все реализации алгоритма ECDH.</span><span class="sxs-lookup"><span data-stu-id="eb17f-102">This class provides the basic set of operations that all ECDH implementations must support.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb17f-103">Этот класс служит абстрактным базовым классом для реализаций алгоритма ECDH.</span><span class="sxs-lookup"><span data-stu-id="eb17f-103">This class serves as the abstract base class for ECDH implementations.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ECDiffieHellman ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ECDiffieHellman();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="eb17f-104">Инициализирует новый экземпляр класса <see cref="T:System.Security.Cryptography.ECDiffieHellman" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-104">Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb17f-105">Этот конструктор вызывается классами, производными от класса <xref:System.Security.Cryptography.ECDiffieHellman>.</span><span class="sxs-lookup"><span data-stu-id="eb17f-105">This constructor is called by classes that derive from the <xref:System.Security.Cryptography.ECDiffieHellman> class.</span></span> <span data-ttu-id="eb17f-106">Класс <xref:System.Security.Cryptography.ECDiffieHellmanCng> является единственной реализацией, которая в настоящее время включена в [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</span><span class="sxs-lookup"><span data-stu-id="eb17f-106">The <xref:System.Security.Cryptography.ECDiffieHellmanCng> class is the only implementation that is currently included in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</span></span> <span data-ttu-id="eb17f-107">Сведения о том, как создать новую реализацию алгоритма Диффи-Хелмана на основе эллиптических кривых (ECDH), см. в описании метода <xref:System.Security.Cryptography.ECDiffieHellman.Create%2A>.</span><span class="sxs-lookup"><span data-stu-id="eb17f-107">For information about how to create a new implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm, see the <xref:System.Security.Cryptography.ECDiffieHellman.Create%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="eb17f-108">Создает новый экземпляр реализации алгоритма Диффи-Хеллмана на эллиптических кривых (ECDH).</span><span class="sxs-lookup"><span data-stu-id="eb17f-108">Creates a new instance of an implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create();" />
      <MemberSignature Language="F#" Value="static member Create : unit -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="eb17f-109">Создает новый экземпляр реализации по умолчанию алгоритма Диффи-Хеллмана на эллиптических кривых (ECDH).</span><span class="sxs-lookup"><span data-stu-id="eb17f-109">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></summary>
        <returns><span data-ttu-id="eb17f-110">Новый экземпляр реализации по умолчанию этого класса.</span><span class="sxs-lookup"><span data-stu-id="eb17f-110">A new instance of the default implementation of this class.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (curve As ECCurve) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::Security::Cryptography::ECCurve curve);" />
      <MemberSignature Language="F#" Value="static member Create : System.Security.Cryptography.ECCurve -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create curve" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="curve"><span data-ttu-id="eb17f-111">Кривая, используемая для создания новой пары открытого и закрытого ключей.</span><span class="sxs-lookup"><span data-stu-id="eb17f-111">The curve to use to generate a new public/private key-pair.</span></span></param>
        <summary><span data-ttu-id="eb17f-112">Создает новый экземпляр реализации по умолчанию алгоритма эллиптической кривой Диффи-Хелмана (ECDH) с новой парой открытого и закрытого ключей, созданных на основе указанной кривой.</span><span class="sxs-lookup"><span data-stu-id="eb17f-112">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with a new public/private key-pair generated over the specified curve.</span></span></summary>
        <returns><span data-ttu-id="eb17f-113">Новый экземпляр реализации по умолчанию алгоритма эллиптической кривой Диффи-Хелмана (ECDH).</span><span class="sxs-lookup"><span data-stu-id="eb17f-113">A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb17f-114">кривая должна проверяться (то есть она должна возвращать значение true при передаче в метод <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="eb17f-114">curve must validate (that is, it must return true when passed to the <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="eb17f-115">В Windows не поддерживаются кривые с характеристиками 2.</span><span class="sxs-lookup"><span data-stu-id="eb17f-115">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-116"><paramref name="curve" /> не выполняет проверку.</span><span class="sxs-lookup"><span data-stu-id="eb17f-116"><paramref name="curve" /> does not validate.</span></span></exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (parameters As ECParameters) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::Security::Cryptography::ECParameters parameters);" />
      <MemberSignature Language="F#" Value="static member Create : System.Security.Cryptography.ECParameters -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="parameters"><span data-ttu-id="eb17f-117">Параметры для алгоритма шифрования на основе эллиптических кривых (ECC).</span><span class="sxs-lookup"><span data-stu-id="eb17f-117">The parameters  for the elliptic curve cryptography (ECC) algorithm.</span></span></param>
        <summary><span data-ttu-id="eb17f-118">Создает новый экземпляр реализации по умолчанию алгоритма эллиптической кривой Диффи-Хелмана (ECDH) с ключом, описываемым указанным объектом <see cref="T:System.Security.Cryptography.ECParameters" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-118">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with the key described by the specified  <see cref="T:System.Security.Cryptography.ECParameters" /> object.</span></span></summary>
        <returns><span data-ttu-id="eb17f-119">Новый экземпляр реализации по умолчанию алгоритма эллиптической кривой Диффи-Хелмана (ECDH).</span><span class="sxs-lookup"><span data-stu-id="eb17f-119">A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb17f-120">`parameters` должен проверяться (то есть должен возвращать `true`) при передаче в метод <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="eb17f-120">`parameters` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="eb17f-121">Параметры по неявным кривым не поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="eb17f-121">Parameters over implicit curves are not supported.</span></span>  
  
 <span data-ttu-id="eb17f-122">В Windows не поддерживаются кривые с характеристиками 2.</span><span class="sxs-lookup"><span data-stu-id="eb17f-122">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-123"><paramref name="parameters" /> не выполняет проверку.</span><span class="sxs-lookup"><span data-stu-id="eb17f-123"><paramref name="parameters" /> does not validate.</span></span></exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (string algorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(string algorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (algorithm As String) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::String ^ algorithm);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create algorithm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algorithm" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="algorithm"><span data-ttu-id="eb17f-124">Имя реализации алгоритма ECDH.</span><span class="sxs-lookup"><span data-stu-id="eb17f-124">The name of an implementation of the ECDH algorithm.</span></span></param>
        <summary><span data-ttu-id="eb17f-125">Создает новый экземпляр заданной реализации по умолчанию алгоритма Диффи-Хеллмана на эллиптических кривых (ECDH).</span><span class="sxs-lookup"><span data-stu-id="eb17f-125">Creates a new instance of the specified implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></summary>
        <returns><span data-ttu-id="eb17f-126">Новый экземпляр заданной реализации этого класса.</span><span class="sxs-lookup"><span data-stu-id="eb17f-126">A new instance of the specified implementation of this class.</span></span> <span data-ttu-id="eb17f-127">Если указанное название алгоритма не соответствует реализации ECDH, этот метод возвращает значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-127">If the specified algorithm name does not map to an ECDH implementation, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb17f-128">При разработке собственной реализации объекта <xref:System.Security.Cryptography.ECDiffieHellman> можно использовать перегрузку метода <xref:System.Security.Cryptography.ECDiffieHellman.Create%28System.String%29>, чтобы создать настраиваемую строку `algorithm`, указывающую реализацию.</span><span class="sxs-lookup"><span data-stu-id="eb17f-128">If you develop your own implementation of an <xref:System.Security.Cryptography.ECDiffieHellman> object, you can use the <xref:System.Security.Cryptography.ECDiffieHellman.Create%28System.String%29> method overload to create a custom `algorithm` string that specifies your implementation.</span></span>  
  
 <span data-ttu-id="eb17f-129">Параметр `algorithm` задает имя реализации алгоритма ECDH.</span><span class="sxs-lookup"><span data-stu-id="eb17f-129">The `algorithm` parameter specifies the name of an implementation of the ECDH algorithm.</span></span> <span data-ttu-id="eb17f-130">Все следующие строки относятся к одной и той же реализации, являющейся единственной реализацией, которая в настоящее время поддерживается [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]:</span><span class="sxs-lookup"><span data-stu-id="eb17f-130">The following strings all refer to the same implementation, which is the only implementation currently supported in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]:</span></span>  
  
-   <span data-ttu-id="eb17f-131">ECDH</span><span class="sxs-lookup"><span data-stu-id="eb17f-131">"ECDH"</span></span>  
  
-   <span data-ttu-id="eb17f-132">ECDiffieHellman</span><span class="sxs-lookup"><span data-stu-id="eb17f-132">"ECDiffieHellman"</span></span>  
  
-   <span data-ttu-id="eb17f-133">"ECDiffieHellmanCng"</span><span class="sxs-lookup"><span data-stu-id="eb17f-133">"ECDiffieHellmanCng"</span></span>  
  
-   <span data-ttu-id="eb17f-134">"System. Security. Cryptography. ECDiffieHellmanCng"</span><span class="sxs-lookup"><span data-stu-id="eb17f-134">"System.Security.Cryptography.ECDiffieHellmanCng"</span></span>  
  
 <span data-ttu-id="eb17f-135">Можно также указать имя настраиваемой реализации ECDH для параметра `algorithm`.</span><span class="sxs-lookup"><span data-stu-id="eb17f-135">You can also provide the name of a custom ECDH implementation for the `algorithm` parameter.</span></span> <span data-ttu-id="eb17f-136">В этом случае объект <xref:System.Security.Cryptography.CryptoConfig> будет использовать его для определения возможности создания объекта ECDH.</span><span class="sxs-lookup"><span data-stu-id="eb17f-136">If you do that, the <xref:System.Security.Cryptography.CryptoConfig> object will use it to determine whether an ECDH object can be created.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eb17f-137">Параметр <paramref name="algorithm" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-137">The <paramref name="algorithm" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHash">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="eb17f-138">Выполняет формирование ключа с использованием указанного хэш-алгоритма.</span><span class="sxs-lookup"><span data-stu-id="eb17f-138">Performs key derivation using a specified hash algorithm.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHash">
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] DeriveKeyFromHash(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveKeyFromHash (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHash(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHash (otherPartyPublicKey, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="eb17f-139">Открытый ключ другой стороны.</span><span class="sxs-lookup"><span data-stu-id="eb17f-139">The other party's public key.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="eb17f-140">Хэш-алгоритм, используемый для получения материала ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-140">The hash algorithm to use to derive the key material.</span></span></param>
        <summary><span data-ttu-id="eb17f-141">Выполняет формирование ключа с использованием указанного хэш-алгоритма.</span><span class="sxs-lookup"><span data-stu-id="eb17f-141">Performs key derivation using a specified hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="eb17f-142">Хэш общего секрета.</span><span class="sxs-lookup"><span data-stu-id="eb17f-142">The hash of the shared secret.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb17f-143">Эта перегрузка вызывает метод <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A>, передавая `null` в качестве значений в начале и в конце.</span><span class="sxs-lookup"><span data-stu-id="eb17f-143">This overload calls the <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A> method passing `null` as the prepend and append values.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eb17f-144">Размер кривой, используемой параметром <paramref name="otherPartyPublicKey" />, отличается от размера кривой из этого ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-144">The curve used by <paramref name="otherPartyPublicKey" /> has a different size than the curve from this key.</span></span>

<span data-ttu-id="eb17f-145">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-145">-or-</span></span>

<span data-ttu-id="eb17f-146">В параметре <paramref name="hashAlgorithm" /> не указан хэш.</span><span class="sxs-lookup"><span data-stu-id="eb17f-146">The <paramref name="hashAlgorithm" /> parameter does not specify a hash.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eb17f-147">Свойство <paramref name="otherPartyPublicKey" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-147"><paramref name="otherPartyPublicKey" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-148">Кривая, используемая параметром <paramref name="otherPartyPublicKey" />, отличается от кривой из этого ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-148">The curve used by <paramref name="otherPartyPublicKey" /> is different than the curve from this key.</span></span>

<span data-ttu-id="eb17f-149">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-149">-or-</span></span>

<span data-ttu-id="eb17f-150">Этот экземпляр представляет только открытый ключ.</span><span class="sxs-lookup"><span data-stu-id="eb17f-150">This instance represents only a public key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyFromHash">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyFromHash(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyFromHash (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHash(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHash (otherPartyPublicKey, hashAlgorithm, secretPrepend, secretAppend)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="secretAppend" Type="System.Byte[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="eb17f-151">Открытый ключ другой стороны.</span><span class="sxs-lookup"><span data-stu-id="eb17f-151">The other party's public key.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="eb17f-152">Хэш-алгоритм, используемый для получения материала ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-152">The hash algorithm to use to derive the key material.</span></span></param>
        <param name="secretPrepend"><span data-ttu-id="eb17f-153">Значение, добавляемое к производному секрету (в начало) перед хэшированием.</span><span class="sxs-lookup"><span data-stu-id="eb17f-153">A value to prepend to the derived secret before hashing.</span></span></param>
        <param name="secretAppend"><span data-ttu-id="eb17f-154">Значение, добавляемое к производному секрету перед хэшированием.</span><span class="sxs-lookup"><span data-stu-id="eb17f-154">A value to append to the derived secret before hashing.</span></span></param>
        <summary><span data-ttu-id="eb17f-155">При реализации в производном классе выполняет формирование ключа с использованием указанного хэш-алгоритма с дополнительными данными, добавленными в начале или конце.</span><span class="sxs-lookup"><span data-stu-id="eb17f-155">When implemented in a derived class, performs key derivation using a specified hash algorithm with optional prepended or appended data.</span></span></summary>
        <returns><span data-ttu-id="eb17f-156">Хэш общего секрета после добавления данных по запросу в начале или конце.</span><span class="sxs-lookup"><span data-stu-id="eb17f-156">The hash of the shared secret after prepending or appending data as requested.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="eb17f-157">Этот метод внутренне выполняет соглашение о ключе Диффи-Хелмана на основе эллиптических кривых для создания общего секрета (`z`).</span><span class="sxs-lookup"><span data-stu-id="eb17f-157">This method internally performs the Elliptic Curve Diffie-Hellman key agreement to produce the shared secret (`z`).</span></span>
<span data-ttu-id="eb17f-158">Возвращаемое значение этого метода является результатом `HASH(secretPrepend || z || secretAppend)` использования указанного алгоритма хэширования, где `||` обозначает объединение.</span><span class="sxs-lookup"><span data-stu-id="eb17f-158">The return value from this method is the result of `HASH(secretPrepend || z || secretAppend)` using the specified hash algorithm, where `||` signifies concatenation.</span></span>

<span data-ttu-id="eb17f-159">Если значение `secretPrepend` или `secretAppend` равно `null`, они рассматриваются как пустые массивы.</span><span class="sxs-lookup"><span data-stu-id="eb17f-159">If the value of `secretPrepend` or `secretAppend` is `null`, they are treated as empty arrays.</span></span>  

 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="eb17f-160">Производный класс должен переопределять этот метод.</span><span class="sxs-lookup"><span data-stu-id="eb17f-160">A derived class must override this method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eb17f-161">Размер кривой, используемой параметром <paramref name="otherPartyPublicKey" />, отличается от размера кривой из этого ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-161">The curve used by <paramref name="otherPartyPublicKey" /> has a different size than the curve from this key.</span></span>

<span data-ttu-id="eb17f-162">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-162">-or-</span></span>

<span data-ttu-id="eb17f-163">В параметре <paramref name="hashAlgorithm" /> не указан хэш.</span><span class="sxs-lookup"><span data-stu-id="eb17f-163">The <paramref name="hashAlgorithm" /> parameter does not specify a hash.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eb17f-164">Свойство <paramref name="otherPartyPublicKey" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-164"><paramref name="otherPartyPublicKey" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-165">Кривая, используемая параметром <paramref name="otherPartyPublicKey" />, отличается от кривой из этого ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-165">The curve used by <paramref name="otherPartyPublicKey" /> is different than the curve from this key.</span></span>

<span data-ttu-id="eb17f-166">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-166">-or-</span></span>

<span data-ttu-id="eb17f-167">Этот экземпляр представляет только открытый ключ.</span><span class="sxs-lookup"><span data-stu-id="eb17f-167">This instance represents only a public key.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHmac">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="eb17f-168">Выполняет формирование ключа с использованием указанного алгоритма HMAC.</span><span class="sxs-lookup"><span data-stu-id="eb17f-168">Performs key derivation using a specified HMAC (Hash-based Message Authentication Code) algorithm.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHmac">
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] DeriveKeyFromHmac(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] hmacKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveKeyFromHmac (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, hmacKey As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHmac(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ hmacKey);" />
      <MemberSignature Language="F#" Value="member this.DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHmac (otherPartyPublicKey, hashAlgorithm, hmacKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hmacKey" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="eb17f-169">Открытый ключ другой стороны.</span><span class="sxs-lookup"><span data-stu-id="eb17f-169">The other party's public key.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="eb17f-170">Хэш-алгоритм, используемый для получения материала ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-170">The hash algorithm to use to derive the key material.</span></span></param>
        <param name="hmacKey"><span data-ttu-id="eb17f-171">Ключ HMAC.</span><span class="sxs-lookup"><span data-stu-id="eb17f-171">The key for the HMAC.</span></span></param>
        <summary><span data-ttu-id="eb17f-172">Выполняет формирование ключа с использованием указанного алгоритма HMAC.</span><span class="sxs-lookup"><span data-stu-id="eb17f-172">Performs key derivation using a specified HMAC (Hash-based Message Authentication Code) algorithm.</span></span></summary>
        <returns><span data-ttu-id="eb17f-173">Код HMAC общего секрета.</span><span class="sxs-lookup"><span data-stu-id="eb17f-173">The HMAC of the shared secret.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb17f-174">Эта перегрузка вызывает метод <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac%2A>, передавая `null` в качестве значений в начале и в конце.</span><span class="sxs-lookup"><span data-stu-id="eb17f-174">This overload calls the <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac%2A> method passing `null` as the prepend and append values.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eb17f-175">Размер кривой, используемой параметром <paramref name="otherPartyPublicKey" />, отличается от размера кривой из этого ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-175">The curve used by <paramref name="otherPartyPublicKey" /> has a different size than the curve from this key.</span></span>

<span data-ttu-id="eb17f-176">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-176">-or-</span></span>

<span data-ttu-id="eb17f-177">В параметре <paramref name="hashAlgorithm" /> не указан хэш.</span><span class="sxs-lookup"><span data-stu-id="eb17f-177">The <paramref name="hashAlgorithm" /> parameter does not specify a hash.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eb17f-178">Свойство <paramref name="otherPartyPublicKey" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-178"><paramref name="otherPartyPublicKey" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-179">Кривая, используемая параметром <paramref name="otherPartyPublicKey" />, отличается от кривой из этого ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-179">The curve used by <paramref name="otherPartyPublicKey" /> is different than the curve from this key.</span></span>

<span data-ttu-id="eb17f-180">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-180">-or-</span></span>

<span data-ttu-id="eb17f-181">Этот экземпляр представляет только открытый ключ.</span><span class="sxs-lookup"><span data-stu-id="eb17f-181">This instance represents only a public key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyFromHmac">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyFromHmac(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] hmacKey, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyFromHmac (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, hmacKey As Byte(), secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHmac(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ hmacKey, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHmac (otherPartyPublicKey, hashAlgorithm, hmacKey, secretPrepend, secretAppend)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hmacKey" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="secretAppend" Type="System.Byte[]" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="eb17f-182">Открытый ключ другой стороны.</span><span class="sxs-lookup"><span data-stu-id="eb17f-182">The other party's public key.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="eb17f-183">Хэш-алгоритм, используемый для получения материала ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-183">The hash algorithm to use to derive the key material.</span></span></param>
        <param name="hmacKey"><span data-ttu-id="eb17f-184">Ключ HMAC.</span><span class="sxs-lookup"><span data-stu-id="eb17f-184">The key for the HMAC.</span></span></param>
        <param name="secretPrepend"><span data-ttu-id="eb17f-185">Значение, добавляемое к производному секрету (в начало) перед хэшированием.</span><span class="sxs-lookup"><span data-stu-id="eb17f-185">A value to prepend to the derived secret before hashing.</span></span></param>
        <param name="secretAppend"><span data-ttu-id="eb17f-186">Значение, добавляемое к производному секрету перед хэшированием.</span><span class="sxs-lookup"><span data-stu-id="eb17f-186">A value to append to the derived secret before hashing.</span></span></param>
        <summary><span data-ttu-id="eb17f-187">При реализации в производном классе выполняет формирование ключа с использованием указанного алгоритма HMAC с дополнительными данными, добавленными в начале или конце.</span><span class="sxs-lookup"><span data-stu-id="eb17f-187">When implemented in a derived class, performs key derivation using a specified HMAC (Hash-based Message Authentication Code) algorithm with optional prepended or appended data.</span></span></summary>
        <returns><span data-ttu-id="eb17f-188">Код HMAC общего секрета после добавления данных по запросу в начале или конце.</span><span class="sxs-lookup"><span data-stu-id="eb17f-188">The HMAC of the shared secret after prepending or appending data as requested.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="eb17f-189">Этот метод внутренне выполняет соглашение о ключе Диффи-Хелмана на основе эллиптических кривых для создания общего секрета (`z`).</span><span class="sxs-lookup"><span data-stu-id="eb17f-189">This method internally performs the Elliptic Curve Diffie-Hellman key agreement to produce the shared secret (`z`).</span></span>

<span data-ttu-id="eb17f-190">Если `hmacKey` `null`, возвращаемое значение этого метода является результатом `HMAC-HASH(z, secretPrepend || z || secretAppend)` с использованием указанного алгоритма HMAC, где `||` обозначает объединение.</span><span class="sxs-lookup"><span data-stu-id="eb17f-190">When `hmacKey` is `null`, the return value from this method is the result of `HMAC-HASH(z, secretPrepend || z || secretAppend)` using the specified HMAC algorithm, where `||` signifies concatenation.</span></span> <span data-ttu-id="eb17f-191">В противном случае возвращаемое значение этого метода является результатом `HMAC-HASH(hmacKey, secretPrepend || z || secretAppend)`.</span><span class="sxs-lookup"><span data-stu-id="eb17f-191">Otherwise, the return value from this method is the result of `HMAC-HASH(hmacKey, secretPrepend || z || secretAppend)`.</span></span>

<span data-ttu-id="eb17f-192">Если значение `secretPrepend` или `secretAppend` равно `null`, они рассматриваются как пустые массивы.</span><span class="sxs-lookup"><span data-stu-id="eb17f-192">If the value of `secretPrepend` or `secretAppend` is `null`, they are treated as empty arrays.</span></span>  

 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="eb17f-193">Производный класс должен переопределять этот метод.</span><span class="sxs-lookup"><span data-stu-id="eb17f-193">A derived class must override this method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eb17f-194">Размер кривой, используемой параметром <paramref name="otherPartyPublicKey" />, отличается от размера кривой из этого ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-194">The curve used by <paramref name="otherPartyPublicKey" /> has a different size than the curve from this key.</span></span>

<span data-ttu-id="eb17f-195">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-195">-or-</span></span>

<span data-ttu-id="eb17f-196">В параметре <paramref name="hashAlgorithm" /> не указан хэш.</span><span class="sxs-lookup"><span data-stu-id="eb17f-196">The <paramref name="hashAlgorithm" /> parameter does not specify a hash.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eb17f-197">Свойство <paramref name="otherPartyPublicKey" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-197"><paramref name="otherPartyPublicKey" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-198">Кривая, используемая параметром <paramref name="otherPartyPublicKey" />, отличается от кривой из этого ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-198">The curve used by <paramref name="otherPartyPublicKey" /> is different than the curve from this key.</span></span>

<span data-ttu-id="eb17f-199">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-199">-or-</span></span>

<span data-ttu-id="eb17f-200">Этот экземпляр представляет только открытый ключ.</span><span class="sxs-lookup"><span data-stu-id="eb17f-200">This instance represents only a public key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyMaterial">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyMaterial (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyMaterial(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyMaterial (otherPartyPublicKey As ECDiffieHellmanPublicKey) As Byte()" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyMaterial(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyMaterial : System.Security.Cryptography.ECDiffieHellmanPublicKey -&gt; byte[]&#xA;override this.DeriveKeyMaterial : System.Security.Cryptography.ECDiffieHellmanPublicKey -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyMaterial otherPartyPublicKey" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public abstract byte[] DeriveKeyMaterial (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey);" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function DeriveKeyMaterial (otherPartyPublicKey As ECDiffieHellmanPublicKey) As Byte()" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Byte&gt; ^ DeriveKeyMaterial(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey);" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyMaterial : System.Security.Cryptography.ECDiffieHellmanPublicKey -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyMaterial otherPartyPublicKey" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="eb17f-201">Открытый ключ другой стороны.</span><span class="sxs-lookup"><span data-stu-id="eb17f-201">The other party's public key.</span></span></param>
        <summary><span data-ttu-id="eb17f-202">При реализации в производном классе выполняет формирование ключа для общего секрета.</span><span class="sxs-lookup"><span data-stu-id="eb17f-202">When implemented in a derived class, performs a key derivation on the shared secret.</span></span></summary>
        <returns><span data-ttu-id="eb17f-203">Результат функции формирования ключа при использовании общего секрета в качестве входных данных.</span><span class="sxs-lookup"><span data-stu-id="eb17f-203">The result of the key derivation function, using the shared secret as an input.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="eb17f-204">Поведение этого метода по умолчанию эквивалентно вызову <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A> указывая SHA-256 в качестве хэш-алгоритма без значений в начале или в конце.</span><span class="sxs-lookup"><span data-stu-id="eb17f-204">The default behavior of this method is equivalent to calling <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A> specifying SHA-256 as the hash algorithm with no prepend or append values.</span></span>
<span data-ttu-id="eb17f-205">Некоторые реализации позволяют изменять поведение этого метода, и вызывающим объектам рекомендуется вызывать любой метод, который явно говорит о том, что он выполняет необходимое для этого ключевое образование.</span><span class="sxs-lookup"><span data-stu-id="eb17f-205">Some implementations allow the behavior of this method to be changed, and callers are advised to call whichever method explicitly says it performs the key derivation they need.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eb17f-206">Размер кривой, используемой параметром <paramref name="otherPartyPublicKey" />, отличается от размера кривой из этого ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-206">The curve used by <paramref name="otherPartyPublicKey" /> has a different size than the curve from this key.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eb17f-207">Свойство <paramref name="otherPartyPublicKey" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-207"><paramref name="otherPartyPublicKey" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-208">Кривая, используемая параметром <paramref name="otherPartyPublicKey" />, отличается от кривой из этого ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-208">The curve used by <paramref name="otherPartyPublicKey" /> is different than the curve from this key.</span></span>

<span data-ttu-id="eb17f-209">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-209">-or-</span></span>

<span data-ttu-id="eb17f-210">Этот экземпляр представляет только открытый ключ.</span><span class="sxs-lookup"><span data-stu-id="eb17f-210">This instance represents only a public key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyTls">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyTls (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, byte[] prfLabel, byte[] prfSeed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyTls(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, unsigned int8[] prfLabel, unsigned int8[] prfSeed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyTls (otherPartyPublicKey As ECDiffieHellmanPublicKey, prfLabel As Byte(), prfSeed As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyTls(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, cli::array &lt;System::Byte&gt; ^ prfLabel, cli::array &lt;System::Byte&gt; ^ prfSeed);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyTls : System.Security.Cryptography.ECDiffieHellmanPublicKey * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyTls : System.Security.Cryptography.ECDiffieHellmanPublicKey * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyTls (otherPartyPublicKey, prfLabel, prfSeed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="prfLabel" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="prfSeed" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="eb17f-211">Открытый ключ другой стороны.</span><span class="sxs-lookup"><span data-stu-id="eb17f-211">The other party's public key.</span></span></param>
        <param name="prfLabel"><span data-ttu-id="eb17f-212">Метка PRF с использованием кодировки ASCII.</span><span class="sxs-lookup"><span data-stu-id="eb17f-212">The ASCII-encoded PRF label.</span></span></param>
        <param name="prfSeed"><span data-ttu-id="eb17f-213">Начальное значение PRF (64-байтовое).</span><span class="sxs-lookup"><span data-stu-id="eb17f-213">The 64-byte PRF seed.</span></span></param>
        <summary><span data-ttu-id="eb17f-214">При реализации в производном классе выполняет формирование ключа с использованием псевдослучайной функции (PRF) протокола TLS 1.1.</span><span class="sxs-lookup"><span data-stu-id="eb17f-214">When implemented in a derived class, performs key derivation using the TLS (Transport Layer Security) 1.1 PRF (Pseudo-Random Function).</span></span></summary>
        <returns><span data-ttu-id="eb17f-215">Первые 48 байт, полученные из функции PRF TLS 1.1 с использованием общего секрета в качестве ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-215">The first 48 bytes from the TLS 1.1 PRF, using the shared secret as the key.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="eb17f-216">Этот метод внутренне выполняет соглашение о ключе Диффи-Хелмана на основе эллиптических кривых для создания общего секрета (`z`).</span><span class="sxs-lookup"><span data-stu-id="eb17f-216">This method internally performs the Elliptic Curve Diffie-Hellman key agreement to produce the shared secret (`z`).</span></span>

<span data-ttu-id="eb17f-217">Возвращаемое значение этого метода представляет собой 48-байтовый вывод функции TLS 1,1 PRF (псевдо-Random) `PRF(z, prfLabel, prfSeed)`.</span><span class="sxs-lookup"><span data-stu-id="eb17f-217">The return value of this method is a 48 byte output of the TLS 1.1 PRF (Pseudo-Random Function), `PRF(z, prfLabel, prfSeed)`.</span></span>

<span data-ttu-id="eb17f-218">Дополнительные сведения см. в [разделе 5 IETF RFC 4346](https://tools.ietf.org/html/rfc4346#section-5).</span><span class="sxs-lookup"><span data-stu-id="eb17f-218">For more information, see [IETF RFC 4346, section 5](https://tools.ietf.org/html/rfc4346#section-5).</span></span>

]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="eb17f-219">Производный класс должен переопределять этот метод.</span><span class="sxs-lookup"><span data-stu-id="eb17f-219">A derived class must override this method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="eb17f-220">Размер кривой, используемой параметром <paramref name="otherPartyPublicKey" />, отличается от размера кривой из этого ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-220">The curve used by <paramref name="otherPartyPublicKey" /> has a different size than the curve from this key.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="eb17f-221">Параметр <paramref name="otherPartyPublicKey" />, <paramref name="prfLabel" /> или <paramref name="prfSeed" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-221"><paramref name="otherPartyPublicKey" />, <paramref name="prfLabel" /> or <paramref name="prfSeed" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-222"><paramref name="prfSeed" /> — длина не соответствует 64 байтам.</span><span class="sxs-lookup"><span data-stu-id="eb17f-222"><paramref name="prfSeed" /> is not exactly 64 bytes in length.</span></span>

<span data-ttu-id="eb17f-223">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-223">-or-</span></span>

<span data-ttu-id="eb17f-224">Кривая, используемая параметром <paramref name="otherPartyPublicKey" />, отличается от кривой из этого ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-224">The curve used by <paramref name="otherPartyPublicKey" /> is different than the curve from this key.</span></span>

<span data-ttu-id="eb17f-225">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-225">-or-</span></span>

<span data-ttu-id="eb17f-226">Этот экземпляр представляет только открытый ключ.</span><span class="sxs-lookup"><span data-stu-id="eb17f-226">This instance represents only a public key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual byte[] ExportECPrivateKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ExportECPrivateKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportECPrivateKey" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportECPrivateKey () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ExportECPrivateKey();" />
      <MemberSignature Language="F#" Value="abstract member ExportECPrivateKey : unit -&gt; byte[]&#xA;override this.ExportECPrivateKey : unit -&gt; byte[]" Usage="eCDiffieHellman.ExportECPrivateKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="eb17f-227">Экспортирует текущий ключ в формате ECPrivateKey.</span><span class="sxs-lookup"><span data-stu-id="eb17f-227">Exports the current key in the ECPrivateKey format.</span></span></summary>
        <returns><span data-ttu-id="eb17f-228">Байтовый массив, содержащий представление этого ключа в формате ECPrivateKey.</span><span class="sxs-lookup"><span data-stu-id="eb17f-228">A byte array containing the ECPrivateKey representation of this key.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-229">Не удалось экспортировать ключ.</span><span class="sxs-lookup"><span data-stu-id="eb17f-229">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.ECDiffieHellman.TryExportECPrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="ExportExplicitParameters">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ECParameters ExportExplicitParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Security.Cryptography.ECParameters ExportExplicitParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportExplicitParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportExplicitParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ECParameters ExportExplicitParameters(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="abstract member ExportExplicitParameters : bool -&gt; System.Security.Cryptography.ECParameters&#xA;override this.ExportExplicitParameters : bool -&gt; System.Security.Cryptography.ECParameters" Usage="eCDiffieHellman.ExportExplicitParameters includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><span data-ttu-id="eb17f-230">Значение <see langword="true" /> для включения закрытых параметров; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-230"><see langword="true" /> to include private parameters; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="eb17f-231">При переопределении в производном классе экспортирует сведения об открытом или открытом и закрытом ключе, используя формат явной кривой в работающем разделе <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> в структуру <see cref="T:System.Security.Cryptography.ECParameters" /> таким образом, чтобы их можно было передать в метод <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-231">When overridden in a derived class, exports either the public or the public and private key information using the explicit curve form from a working <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> key to an <see cref="T:System.Security.Cryptography.ECParameters" /> structure so that it can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span></span></summary>
        <returns><span data-ttu-id="eb17f-232">Объект, представляющий точку на кривой для этого ключа, в формате явной кривой.</span><span class="sxs-lookup"><span data-stu-id="eb17f-232">An object that represents the point on the curve for this key, using the explicit curve format.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="eb17f-233">Производный класс должен переопределять этот метод.</span><span class="sxs-lookup"><span data-stu-id="eb17f-233">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExportParameters">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ECParameters ExportParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Security.Cryptography.ECParameters ExportParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ECParameters ExportParameters(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="abstract member ExportParameters : bool -&gt; System.Security.Cryptography.ECParameters&#xA;override this.ExportParameters : bool -&gt; System.Security.Cryptography.ECParameters" Usage="eCDiffieHellman.ExportParameters includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><span data-ttu-id="eb17f-234">Значение <see langword="true" /> для включения закрытых параметров; в противном случае — <see langword="false" /> для включения только открытых параметров.</span><span class="sxs-lookup"><span data-stu-id="eb17f-234"><see langword="true" /> to include private parameters; otherwise, <see langword="false" /> to include public parameters only.</span></span></param>
        <summary><span data-ttu-id="eb17f-235">При переопределении в производном классе экспортирует сведения об открытом или открытом и закрытом ключе из рабочего раздела <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> в структуру <see cref="T:System.Security.Cryptography.ECParameters" /> таким образом, чтобы их можно было передать в метод <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-235">When overridden in a derived class, exports either the public or the public and private key information from a working <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> key to an <see cref="T:System.Security.Cryptography.ECParameters" /> structure so that it can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span></span></summary>
        <returns><span data-ttu-id="eb17f-236">Объект, представляющий точку на кривой для этого ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-236">An object that represents the point on the curve for this key.</span></span> <span data-ttu-id="eb17f-237">Может передаваться в метод <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-237">It can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb17f-238">Если у кривой есть имя, свойство <xref:System.Security.Cryptography.ECParameters.Curve> содержит параметры именованной кривой; в противном случае он будет содержать явные параметры.</span><span class="sxs-lookup"><span data-stu-id="eb17f-238">If the curve has a name, the <xref:System.Security.Cryptography.ECParameters.Curve> property contains named curve parameters; otherwise, it will contain explicit parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="eb17f-239">Производный класс должен переопределять этот метод.</span><span class="sxs-lookup"><span data-stu-id="eb17f-239">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FromXmlString">
      <MemberSignature Language="C#" Value="public override void FromXmlString (string xmlString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXmlString(string xmlString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.FromXmlString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub FromXmlString (xmlString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXmlString(System::String ^ xmlString);" />
      <MemberSignature Language="F#" Value="override this.FromXmlString : string -&gt; unit" Usage="eCDiffieHellman.FromXmlString xmlString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlString" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="xmlString"><span data-ttu-id="eb17f-240">XML-строка, используемая для восстановления объекта <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-240">The XML string to use to reconstruct the <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> object.</span></span></param>
        <summary><span data-ttu-id="eb17f-241">Этот метод выдает исключение во всех случаях.</span><span class="sxs-lookup"><span data-stu-id="eb17f-241">This method throws in all cases.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="eb17f-242">Во всех случаях.</span><span class="sxs-lookup"><span data-stu-id="eb17f-242">In all cases.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GenerateKey">
      <MemberSignature Language="C#" Value="public virtual void GenerateKey (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateKey(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateKey (curve As ECCurve)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateKey(System::Security::Cryptography::ECCurve curve);" />
      <MemberSignature Language="F#" Value="abstract member GenerateKey : System.Security.Cryptography.ECCurve -&gt; unit&#xA;override this.GenerateKey : System.Security.Cryptography.ECCurve -&gt; unit" Usage="eCDiffieHellman.GenerateKey curve" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="curve"><span data-ttu-id="eb17f-243">Кривая, используемая для создания пары открытого и закрытого эфемерных ключей.</span><span class="sxs-lookup"><span data-stu-id="eb17f-243">The curve used to generate an ephemeral public/private key pair.</span></span></param>
        <summary><span data-ttu-id="eb17f-244">При переопределении в производном классе создает новую пару открытого и закрытого эфемерных ключей для указанной кривой.</span><span class="sxs-lookup"><span data-stu-id="eb17f-244">When overridden in a derived class, generates a new ephemeral public/private key pair for the specified curve.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb17f-245">`curve` необходимо проверить (то есть он должен возвращать `true`) при передаче в метод <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType>) и не должен быть неявным.</span><span class="sxs-lookup"><span data-stu-id="eb17f-245">`curve` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> method) and must not be implicit.</span></span>  
  
 <span data-ttu-id="eb17f-246">В Windows не поддерживаются кривые с характеристиками 2.</span><span class="sxs-lookup"><span data-stu-id="eb17f-246">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-247"><paramref name="curve" /> не выполняет проверку.</span><span class="sxs-lookup"><span data-stu-id="eb17f-247"><paramref name="curve" /> does not validate.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="eb17f-248">Производный класс должен переопределять этот метод.</span><span class="sxs-lookup"><span data-stu-id="eb17f-248">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual void ImportECPrivateKey (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportECPrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportECPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportECPrivateKey (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportECPrivateKey(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="abstract member ImportECPrivateKey : ReadOnlySpan&lt;byte&gt; * int -&gt; unit&#xA;override this.ImportECPrivateKey : ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="eCDiffieHellman.ImportECPrivateKey (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="eb17f-249">Байты структуры ECPrivateKey в кодировке ASN.1-BER.</span><span class="sxs-lookup"><span data-stu-id="eb17f-249">The bytes of an ECPrivateKey structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="eb17f-250">При возврате метода содержит значение, которое показывает количество символов, считанных из <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-250">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="eb17f-251">Этот параметр обрабатывается как неинициализированный.</span><span class="sxs-lookup"><span data-stu-id="eb17f-251">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="eb17f-252">Импортирует пару открытого и закрытого ключей из структуры ECPrivateKey и заменяет ключи для этого объекта.</span><span class="sxs-lookup"><span data-stu-id="eb17f-252">Imports the public/private keypair from an ECPrivateKey structure, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="eb17f-253">Этот метод поддерживает только двоичную (ЛИЧЕСТВО/CER/DER) кодировку Екприватекэй.</span><span class="sxs-lookup"><span data-stu-id="eb17f-253">This method only supports the binary (BER/CER/DER) encoding of ECPrivateKey.</span></span>
<span data-ttu-id="eb17f-254">Если значение в кодировке Base64 или в текстовом формате PEM, вызывающий объект должен в Base64-декодировать содержимое перед вызовом этого метода.</span><span class="sxs-lookup"><span data-stu-id="eb17f-254">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-255">Содержимое <paramref name="source" /> не представляет структуру PKCS#8 ECPrivateKey в кодировке ASN.1-BER.</span><span class="sxs-lookup"><span data-stu-id="eb17f-255">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 ECPrivateKey structure.</span></span>

<span data-ttu-id="eb17f-256">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-256">-or-</span></span>

<span data-ttu-id="eb17f-257">Ключ не импортирован.</span><span class="sxs-lookup"><span data-stu-id="eb17f-257">The key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; passwordBytes, ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportEncryptedPkcs8PrivateKey (passwordBytes As ReadOnlySpan(Of Byte), source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="eCDiffieHellman.ImportEncryptedPkcs8PrivateKey (passwordBytes, source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="passwordBytes"><span data-ttu-id="eb17f-258">Байты, используемые в качестве пароля при расшифровке материала ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-258">The bytes to use as a password when decrypting the key material.</span></span></param>
        <param name="source"><span data-ttu-id="eb17f-259">Байты структуры PKCS#8 EncryptedPrivateKeyInfo в кодировке ASN.1-BER.</span><span class="sxs-lookup"><span data-stu-id="eb17f-259">The bytes of a PKCS#8 EncryptedPrivateKeyInfo structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="eb17f-260">При возврате метода содержит значение, которое показывает количество символов, считанных из <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-260">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="eb17f-261">Этот параметр обрабатывается как неинициализированный.</span><span class="sxs-lookup"><span data-stu-id="eb17f-261">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="eb17f-262">Импортирует пару из открытого и закрытого ключей из структуры PKCS#8 EncryptedPrivateKeyInfo после расшифровки с помощью пароля на основе байтов, заменяя ключи для этого объекта.</span><span class="sxs-lookup"><span data-stu-id="eb17f-262">Imports the public/private keypair from a PKCS#8 EncryptedPrivateKeyInfo structure after decrypting with a byte-based password, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

 <span data-ttu-id="eb17f-263">Байты паролей передаются непосредственно в функцию формирования ключа (ПОДПРОГРАММ), используемую алгоритмом, указанным в содержимом Енкриптедприватекэйинфо.</span><span class="sxs-lookup"><span data-stu-id="eb17f-263">The password bytes are passed directly into the Key Derivation Function (KDF) used by the algorithm indicated by the EncryptedPrivateKeyInfo contents.</span></span>
<span data-ttu-id="eb17f-264">Это обеспечивает совместимость с другими системами, использующими кодировку текста, отличную от UTF-8, при обработке паролей с помощью PBKDF2 (функция наследования ключа на основе пароля 2).</span><span class="sxs-lookup"><span data-stu-id="eb17f-264">This enables compatibility with other systems which use a text encoding other than UTF-8 when processing passwords with PBKDF2 (Password-Based Key Derivation Function 2).</span></span>
<span data-ttu-id="eb17f-265">Этот метод поддерживает только двоичную (ЛИЧЕСТВО/CER/DER) кодировку Енкриптедприватекэйинфо.</span><span class="sxs-lookup"><span data-stu-id="eb17f-265">This method only supports the binary (BER/CER/DER) encoding of EncryptedPrivateKeyInfo.</span></span>
<span data-ttu-id="eb17f-266">Если значение в кодировке Base64 или в текстовом формате PEM, вызывающий объект должен в Base64-декодировать содержимое перед вызовом этого метода.</span><span class="sxs-lookup"><span data-stu-id="eb17f-266">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-267">Неправильный пароль.</span><span class="sxs-lookup"><span data-stu-id="eb17f-267">The password is incorrect.</span></span>

<span data-ttu-id="eb17f-268">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-268">-or-</span></span>

<span data-ttu-id="eb17f-269">Содержимое <paramref name="source" />, указывающее, что как функцию формирования ключа (KDF) следует использовать устаревшую версию PKCS#12 KDF, которая требует пароли на основе <see cref="T:System.Char" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-269">The contents of <paramref name="source" /> indicate the Key Derivation Function (KDF) to apply is the legacy PKCS#12 KDF, which requires <see cref="T:System.Char" />-based passwords.</span></span>

<span data-ttu-id="eb17f-270">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-270">-or-</span></span>

<span data-ttu-id="eb17f-271">Содержимое <paramref name="source" /> не представляет структуру PKCS#8 EncryptedPrivateKeyInfo в кодировке ASN.1-BER.</span><span class="sxs-lookup"><span data-stu-id="eb17f-271">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 EncryptedPrivateKeyInfo structure.</span></span>

<span data-ttu-id="eb17f-272">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-272">-or-</span></span>

<span data-ttu-id="eb17f-273">Содержимое <paramref name="source" /> указывает, что ключ относится к алгоритму, отличному от алгоритма, представленного этим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="eb17f-273">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="eb17f-274">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-274">-or-</span></span>

<span data-ttu-id="eb17f-275">Содержимое <paramref name="source" /> представляет ключ в неподдерживаемом формате.</span><span class="sxs-lookup"><span data-stu-id="eb17f-275">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="eb17f-276">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-276">-or-</span></span>

<span data-ttu-id="eb17f-277">Не удалось выполнить импорт ключа, зависящего от алгоритма.</span><span class="sxs-lookup"><span data-stu-id="eb17f-277">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;char&gt; password, ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;char&gt; password, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportEncryptedPkcs8PrivateKey (password As ReadOnlySpan(Of Char), source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;char&gt; password, ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="eCDiffieHellman.ImportEncryptedPkcs8PrivateKey (password, source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="eb17f-278">Пароль, используемый при расшифровке материала ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-278">The password to use for decrypting the key material.</span></span></param>
        <param name="source"><span data-ttu-id="eb17f-279">Байты структуры PKCS#8 EncryptedPrivateKeyInfo в кодировке ASN.1-BER.</span><span class="sxs-lookup"><span data-stu-id="eb17f-279">The bytes of a PKCS#8 EncryptedPrivateKeyInfo structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="eb17f-280">При возврате метода содержит значение, которое показывает количество символов, считанных из <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-280">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="eb17f-281">Этот параметр обрабатывается как неинициализированный.</span><span class="sxs-lookup"><span data-stu-id="eb17f-281">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="eb17f-282">Импортирует пару из открытого и закрытого ключей из структуры PKCS#8 EncryptedPrivateKeyInfo после расшифровки с помощью пароля на основе символов, заменяя ключи для этого объекта.</span><span class="sxs-lookup"><span data-stu-id="eb17f-282">Imports the public/private keypair from a PKCS#8 EncryptedPrivateKeyInfo structure after decrypting with a char-based password, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb17f-283">Если содержимое `source` указывает алгоритм, использующий PBKDF1 (функция формирования ключа на основе пароля 1) или PBKDF2 (функция формирования ключа на основе пароля 2), то пароль преобразуется в байты через кодировку UTF-8.</span><span class="sxs-lookup"><span data-stu-id="eb17f-283">When the contents of `source` indicate an algorithm that uses PBKDF1 (Password-Based Key Derivation Function 1) or PBKDF2 (Password-Based Key Derivation Function 2), the password is converted to bytes via the UTF-8 encoding.</span></span>
<span data-ttu-id="eb17f-284">Этот метод поддерживает только двоичную (ЛИЧЕСТВО/CER/DER) кодировку Енкриптедприватекэйинфо.</span><span class="sxs-lookup"><span data-stu-id="eb17f-284">This method only supports the binary (BER/CER/DER) encoding of EncryptedPrivateKeyInfo.</span></span>
<span data-ttu-id="eb17f-285">Если значение в кодировке Base64 или в текстовом формате PEM, вызывающий объект должен в Base64-декодировать содержимое перед вызовом этого метода.</span><span class="sxs-lookup"><span data-stu-id="eb17f-285">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-286">Неправильный пароль.</span><span class="sxs-lookup"><span data-stu-id="eb17f-286">The password is incorrect.</span></span>

<span data-ttu-id="eb17f-287">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-287">-or-</span></span>

<span data-ttu-id="eb17f-288">Содержимое <paramref name="source" /> не представляет структуру PKCS#8 EncryptedPrivateKeyInfo в кодировке ASN.1-BER.</span><span class="sxs-lookup"><span data-stu-id="eb17f-288">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 EncryptedPrivateKeyInfo structure.</span></span>

<span data-ttu-id="eb17f-289">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-289">-or-</span></span>

<span data-ttu-id="eb17f-290">Содержимое <paramref name="source" /> указывает, что ключ относится к алгоритму, отличному от алгоритма, представленного этим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="eb17f-290">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="eb17f-291">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-291">-or-</span></span>

<span data-ttu-id="eb17f-292">Содержимое <paramref name="source" /> представляет ключ в неподдерживаемом формате.</span><span class="sxs-lookup"><span data-stu-id="eb17f-292">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="eb17f-293">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-293">-or-</span></span>

<span data-ttu-id="eb17f-294">Не удалось выполнить импорт ключа, зависящего от алгоритма.</span><span class="sxs-lookup"><span data-stu-id="eb17f-294">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportParameters">
      <MemberSignature Language="C#" Value="public virtual void ImportParameters (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportParameters(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportParameters (parameters As ECParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportParameters(System::Security::Cryptography::ECParameters parameters);" />
      <MemberSignature Language="F#" Value="abstract member ImportParameters : System.Security.Cryptography.ECParameters -&gt; unit&#xA;override this.ImportParameters : System.Security.Cryptography.ECParameters -&gt; unit" Usage="eCDiffieHellman.ImportParameters parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="parameters"><span data-ttu-id="eb17f-295">Параметры кривой для импорта.</span><span class="sxs-lookup"><span data-stu-id="eb17f-295">The curve's parameters to import.</span></span></param>
        <summary><span data-ttu-id="eb17f-296">При переопределении в производном классе импортирует заданные параметры для <see cref="T:System.Security.Cryptography.ECCurve" /> как эфемерный ключ в текущий объект <see cref="T:System.Security.Cryptography.ECDiffieHellman" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-296">When overridden in a derived class, imports the specified parameters for an <see cref="T:System.Security.Cryptography.ECCurve" /> as an ephemeral key into the current <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb17f-297">`parameters` должен проверяться (то есть должен возвращать `true`) при передаче в метод <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="eb17f-297">`parameters` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="eb17f-298">Параметры по неявным кривым не поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="eb17f-298">Parameters over implicit curves are not supported.</span></span>  
  
 <span data-ttu-id="eb17f-299">В Windows не поддерживаются кривые с характеристиками 2.</span><span class="sxs-lookup"><span data-stu-id="eb17f-299">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-300"><paramref name="parameters" /> не выполняет проверку.</span><span class="sxs-lookup"><span data-stu-id="eb17f-300"><paramref name="parameters" /> does not validate.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="eb17f-301">Производный класс должен переопределять этот метод.</span><span class="sxs-lookup"><span data-stu-id="eb17f-301">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportPkcs8PrivateKey (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="eCDiffieHellman.ImportPkcs8PrivateKey (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="eb17f-302">Байты структуры PKCS#8 PrivateKeyInfo в кодировке ASN.1-BER.</span><span class="sxs-lookup"><span data-stu-id="eb17f-302">The bytes of a PKCS#8 PrivateKeyInfo structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="eb17f-303">При возврате метода содержит значение, которое показывает количество символов, считанных из <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-303">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="eb17f-304">Этот параметр обрабатывается как неинициализированный.</span><span class="sxs-lookup"><span data-stu-id="eb17f-304">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="eb17f-305">Импортирует пару из открытого и закрытого ключей из структуры PKCS#8 PrivateKeyInfo после расшифровки, заменяя ключи для этого объекта.</span><span class="sxs-lookup"><span data-stu-id="eb17f-305">Imports the public/private keypair from a PKCS#8 PrivateKeyInfo structure after decryption, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb17f-306">Этот метод поддерживает только двоичную (ЛИЧЕСТВО/CER/DER) кодировку Приватекэйинфо.</span><span class="sxs-lookup"><span data-stu-id="eb17f-306">This method only supports the binary (BER/CER/DER) encoding of PrivateKeyInfo.</span></span>
<span data-ttu-id="eb17f-307">Если значение в кодировке Base64 или в текстовом формате PEM, вызывающий объект должен в Base64-декодировать содержимое перед вызовом этого метода.</span><span class="sxs-lookup"><span data-stu-id="eb17f-307">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-308">Содержимое <paramref name="source" /> не представляет структуру PKCS#8 PrivateKeyInfo в кодировке ASN.1-BER.</span><span class="sxs-lookup"><span data-stu-id="eb17f-308">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 PrivateKeyInfo structure.</span></span>

<span data-ttu-id="eb17f-309">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-309">-or-</span></span>

<span data-ttu-id="eb17f-310">Содержимое <paramref name="source" /> указывает, что ключ относится к алгоритму, отличному от алгоритма, представленного этим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="eb17f-310">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="eb17f-311">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-311">-or-</span></span>

<span data-ttu-id="eb17f-312">Содержимое <paramref name="source" /> представляет ключ в неподдерживаемом формате.</span><span class="sxs-lookup"><span data-stu-id="eb17f-312">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="eb17f-313">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-313">-or-</span></span>

<span data-ttu-id="eb17f-314">Не удалось выполнить импорт ключа, зависящего от алгоритма.</span><span class="sxs-lookup"><span data-stu-id="eb17f-314">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportSubjectPublicKeyInfo">
      <MemberSignature Language="C#" Value="public override void ImportSubjectPublicKeyInfo (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportSubjectPublicKeyInfo(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportSubjectPublicKeyInfo (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportSubjectPublicKeyInfo(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportSubjectPublicKeyInfo : ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="eCDiffieHellman.ImportSubjectPublicKeyInfo (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="eb17f-315">Байты структуры X.509 SubjectPublicKeyInfo в кодировке ASN.1-DER.</span><span class="sxs-lookup"><span data-stu-id="eb17f-315">The bytes of an X.509 SubjectPublicKeyInfo structure in the ASN.1-DER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="eb17f-316">При возврате метода содержит значение, которое показывает количество символов, считанных из <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-316">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="eb17f-317">Этот параметр обрабатывается как неинициализированный.</span><span class="sxs-lookup"><span data-stu-id="eb17f-317">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="eb17f-318">Импортирует открытый ключ из структуры X.509 SubjectPublicKeyInfo после расшифровки, заменяя ключи для этого объекта.</span><span class="sxs-lookup"><span data-stu-id="eb17f-318">Imports the public key from an X.509 SubjectPublicKeyInfo structure after decryption, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb17f-319">Этот метод поддерживает только двоичное кодирование (DER) Субжектпубликкэйинфо.</span><span class="sxs-lookup"><span data-stu-id="eb17f-319">This method only supports the binary (DER) encoding of SubjectPublicKeyInfo.</span></span>
<span data-ttu-id="eb17f-320">Если значение в кодировке Base64 или в текстовом формате PEM, вызывающий объект должен в Base64-декодировать содержимое перед вызовом этого метода.</span><span class="sxs-lookup"><span data-stu-id="eb17f-320">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-321">Содержимое <paramref name="source" /> не представляет структуру X.509 SubjectPublicKeyInfo в кодировке ASN.1-DER.</span><span class="sxs-lookup"><span data-stu-id="eb17f-321">The contents of <paramref name="source" /> do not represent an ASN.1-DER-encoded X.509 SubjectPublicKeyInfo structure.</span></span>

<span data-ttu-id="eb17f-322">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-322">-or-</span></span>

<span data-ttu-id="eb17f-323">Содержимое <paramref name="source" /> указывает, что ключ относится к алгоритму, отличному от алгоритма, представленного этим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="eb17f-323">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="eb17f-324">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-324">-or-</span></span>

<span data-ttu-id="eb17f-325">Содержимое <paramref name="source" /> представляет ключ в неподдерживаемом формате.</span><span class="sxs-lookup"><span data-stu-id="eb17f-325">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="eb17f-326">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-326">-or-</span></span>

<span data-ttu-id="eb17f-327">Не удалось выполнить импорт ключа, зависящего от алгоритма.</span><span class="sxs-lookup"><span data-stu-id="eb17f-327">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public override string KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property KeyExchangeAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ KeyExchangeAlgorithm { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyExchangeAlgorithm : string" Usage="System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eb17f-328">Получает имя алгоритма обмена ключами.</span><span class="sxs-lookup"><span data-stu-id="eb17f-328">Gets the name of the key exchange algorithm.</span></span></summary>
        <value><span data-ttu-id="eb17f-329">Имя алгоритма обмена ключами.</span><span class="sxs-lookup"><span data-stu-id="eb17f-329">The name of the key exchange algorithm.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb17f-330">Реализация по умолчанию (без переопределения) этого свойства возвращает строку "ECDiffieHellman".</span><span class="sxs-lookup"><span data-stu-id="eb17f-330">The default (non-overridden) implementation of this property returns the string "ECDiffieHellman".</span></span>  
  
 <span data-ttu-id="eb17f-331">Это свойство наследуется от базового класса <xref:System.Security.Cryptography.AsymmetricAlgorithm>.</span><span class="sxs-lookup"><span data-stu-id="eb17f-331">This property is inherited from the <xref:System.Security.Cryptography.AsymmetricAlgorithm> base class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PublicKey">
      <MemberSignature Language="C#" Value="public abstract System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.PublicKey" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property PublicKey As ECDiffieHellmanPublicKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Security::Cryptography::ECDiffieHellmanPublicKey ^ PublicKey { System::Security::Cryptography::ECDiffieHellmanPublicKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PublicKey : System.Security.Cryptography.ECDiffieHellmanPublicKey" Usage="System.Security.Cryptography.ECDiffieHellman.PublicKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanPublicKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eb17f-332">Получает открытый ключ, используемый текущим экземпляром ECDH.</span><span class="sxs-lookup"><span data-stu-id="eb17f-332">Gets the public key that is being used by the current Elliptic Curve Diffie-Hellman (ECDH) instance.</span></span></summary>
        <value><span data-ttu-id="eb17f-333">Открытая часть пары ключей ECDH, используемая этим экземпляром <see cref="T:System.Security.Cryptography.ECDiffieHellman" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-333">The public part of the ECDH key pair that is being used by this <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> instance.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public override string SignatureAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SignatureAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SignatureAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SignatureAlgorithm { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SignatureAlgorithm : string" Usage="System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="eb17f-334">Получает имя алгоритма подписи.</span><span class="sxs-lookup"><span data-stu-id="eb17f-334">Gets the name of the signature algorithm.</span></span></summary>
        <value><span data-ttu-id="eb17f-335">Всегда <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-335">Always <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb17f-336">Это свойство наследуется от базового класса <xref:System.Security.Cryptography.AsymmetricAlgorithm>.</span><span class="sxs-lookup"><span data-stu-id="eb17f-336">This property is inherited from the <xref:System.Security.Cryptography.AsymmetricAlgorithm> base class.</span></span>  
  
 <span data-ttu-id="eb17f-337">Для формирования ключа используется алгоритм ECDH, а не цифровая подпись.</span><span class="sxs-lookup"><span data-stu-id="eb17f-337">The Elliptic Curve Diffie-Hellman (ECDH) algorithm is used for key derivation, not digital signature generation.</span></span> <span data-ttu-id="eb17f-338">Поэтому это свойство возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="eb17f-338">Therefore, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXmlString">
      <MemberSignature Language="C#" Value="public override string ToXmlString (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToXmlString(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ToXmlString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXmlString (includePrivateParameters As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToXmlString(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="override this.ToXmlString : bool -&gt; string" Usage="eCDiffieHellman.ToXmlString includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><span data-ttu-id="eb17f-339">Значение <see langword="true" /> для включения закрытых параметров; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-339"><see langword="true" /> to include private parameters; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="eb17f-340">Этот метод выдает исключение во всех случаях.</span><span class="sxs-lookup"><span data-stu-id="eb17f-340">This method throws in all cases.</span></span></summary>
        <returns><span data-ttu-id="eb17f-341">Этот метод не возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="eb17f-341">This method does not return a value.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="eb17f-342">Во всех случаях.</span><span class="sxs-lookup"><span data-stu-id="eb17f-342">In all cases.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryExportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual bool TryExportECPrivateKey (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryExportECPrivateKey(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportECPrivateKey(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryExportECPrivateKey (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryExportECPrivateKey(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TryExportECPrivateKey : Span&lt;byte&gt; * int -&gt; bool&#xA;override this.TryExportECPrivateKey : Span&lt;byte&gt; * int -&gt; bool" Usage="eCDiffieHellman.TryExportECPrivateKey (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="eb17f-343">Диапазон байт для получения данных ECPrivateKey.</span><span class="sxs-lookup"><span data-stu-id="eb17f-343">The byte span to receive the ECPrivateKey data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="eb17f-344">При возврате метода содержит значение, которое показывает количество байтов, записанных в <paramref name="destination" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-344">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="eb17f-345">Этот параметр обрабатывается как неинициализированный.</span><span class="sxs-lookup"><span data-stu-id="eb17f-345">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="eb17f-346">Пытается экспортировать текущий ключ в формате ECPrivateKey в предоставленный буфер.</span><span class="sxs-lookup"><span data-stu-id="eb17f-346">Attempts to export the current key in the ECPrivateKey format into a provided buffer.</span></span></summary>
        <returns><span data-ttu-id="eb17f-347"><see langword="true" />, если размер <paramref name="destination" /> достаточно велик, чтобы вместить выходные данные; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-347"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-348">Не удалось экспортировать ключ.</span><span class="sxs-lookup"><span data-stu-id="eb17f-348">The key could not be exported.</span></span></exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.ExportECPrivateKey()" />
      </Docs>
    </Member>
    <Member MemberName="TryExportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, class System.Security.Cryptography.PbeParameters pbeParameters, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, System::Security::Cryptography::PbeParameters ^ pbeParameters, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; * int -&gt; bool" Usage="eCDiffieHellman.TryExportEncryptedPkcs8PrivateKey (passwordBytes, pbeParameters, destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="passwordBytes"><span data-ttu-id="eb17f-349">Байты, используемые в качестве пароля при шифровании материала ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-349">The bytes to use as a password when encrypting the key material.</span></span></param>
        <param name="pbeParameters"><span data-ttu-id="eb17f-350">Параметры шифрования на основе пароля (PBE), используемые при шифровании материала ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-350">The password-based encryption (PBE) parameters to use when encrypting the key material.</span></span></param>
        <param name="destination"><span data-ttu-id="eb17f-351">Диапазон байтов для получения данных PKCS#8 EncryptedPrivateKeyInfo.</span><span class="sxs-lookup"><span data-stu-id="eb17f-351">The byte span to receive the PKCS#8 EncryptedPrivateKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="eb17f-352">При возврате метода содержит значение, которое показывает количество байтов, записанных в <paramref name="destination" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-352">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="eb17f-353">Этот параметр обрабатывается как неинициализированный.</span><span class="sxs-lookup"><span data-stu-id="eb17f-353">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="eb17f-354">Пытается экспортировать текущий ключ в формате PKCS#8 EncryptedPrivateKeyInfo в предоставленный буфер с использованием пароля на основе байтов.</span><span class="sxs-lookup"><span data-stu-id="eb17f-354">Attempts to export the current key in the PKCS#8 EncryptedPrivateKeyInfo format into a provided buffer, using a byte-based password.</span></span></summary>
        <returns><span data-ttu-id="eb17f-355"><see langword="true" />, если размер <paramref name="destination" /> достаточно велик, чтобы вместить выходные данные; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-355"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb17f-356">Байты паролей передаются непосредственно в функцию формирования ключа (ПОДПРОГРАММ), используемую алгоритмом, указанным в `pbeParameters`.</span><span class="sxs-lookup"><span data-stu-id="eb17f-356">The password bytes are passed directly into the Key Derivation Function (KDF) used by the algorithm indicated by `pbeParameters`.</span></span>
<span data-ttu-id="eb17f-357">Это обеспечивает совместимость с другими системами, использующими кодировку текста, отличную от UTF-8, при обработке паролей с помощью PBKDF2 (функция наследования ключа на основе пароля 2).</span><span class="sxs-lookup"><span data-stu-id="eb17f-357">This enables compatibility with other systems which use a text encoding other than UTF-8 when processing passwords with PBKDF2 (Password-Based Key Derivation Function 2).</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-358">Не удалось экспортировать ключ.</span><span class="sxs-lookup"><span data-stu-id="eb17f-358">The key could not be exported.</span></span>

<span data-ttu-id="eb17f-359">- или -</span><span class="sxs-lookup"><span data-stu-id="eb17f-359">-or-</span></span>

<span data-ttu-id="eb17f-360"><paramref name="pbeParameters" /> указывает, что следует использовать <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" />: это требует паролей на основе <see cref="T:System.Char" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-360"><paramref name="pbeParameters" /> indicates that <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> should be used, which requires <see cref="T:System.Char" />-based passwords.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;char&gt; password, System.Security.Cryptography.PbeParameters pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;char&gt; password, class System.Security.Cryptography.PbeParameters pbeParameters, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;char&gt; password, System::Security::Cryptography::PbeParameters ^ pbeParameters, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; * int -&gt; bool" Usage="eCDiffieHellman.TryExportEncryptedPkcs8PrivateKey (password, pbeParameters, destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="eb17f-361">Пароль, используемый при шифровании материала ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-361">The password to use when encrypting the key material.</span></span></param>
        <param name="pbeParameters"><span data-ttu-id="eb17f-362">Параметры шифрования на основе пароля (PBE), используемые при шифровании материала ключа.</span><span class="sxs-lookup"><span data-stu-id="eb17f-362">The password-based encryption (PBE) parameters to use when encrypting the key material.</span></span></param>
        <param name="destination"><span data-ttu-id="eb17f-363">Диапазон байтов для получения данных PKCS#8 EncryptedPrivateKeyInfo.</span><span class="sxs-lookup"><span data-stu-id="eb17f-363">The byte span to receive the PKCS#8 EncryptedPrivateKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="eb17f-364">При возврате метода содержит значение, которое показывает количество байтов, записанных в <paramref name="destination" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-364">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="eb17f-365">Этот параметр обрабатывается как неинициализированный.</span><span class="sxs-lookup"><span data-stu-id="eb17f-365">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="eb17f-366">Пытается экспортировать текущий ключ в формате PKCS#8 EncryptedPrivateKeyInfo в предоставленный буфер с использованием пароля на основе символов.</span><span class="sxs-lookup"><span data-stu-id="eb17f-366">Attempts to export the current key in the PKCS#8 EncryptedPrivateKeyInfo format into a provided buffer, using a char-based password.</span></span></summary>
        <returns><span data-ttu-id="eb17f-367"><see langword="true" />, если размер <paramref name="destination" /> достаточно велик, чтобы вместить выходные данные; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-367"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eb17f-368">Если `pbeParameters` указывает алгоритм, использующий PBKDF2 (функция формирования ключа на основе пароля 2), то пароль преобразуется в байты через кодировку UTF-8.</span><span class="sxs-lookup"><span data-stu-id="eb17f-368">When `pbeParameters` indicates an algorithm that uses PBKDF2 (Password-Based Key Derivation Function 2), the password is converted to bytes via the UTF-8 encoding.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-369">Не удалось экспортировать ключ.</span><span class="sxs-lookup"><span data-stu-id="eb17f-369">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportPkcs8PrivateKey (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportPkcs8PrivateKey(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function TryExportPkcs8PrivateKey (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportPkcs8PrivateKey(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportPkcs8PrivateKey : Span&lt;byte&gt; * int -&gt; bool" Usage="eCDiffieHellman.TryExportPkcs8PrivateKey (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="eb17f-370">Диапазон байтов для получения данных PKCS#8 PrivateKeyInfo.</span><span class="sxs-lookup"><span data-stu-id="eb17f-370">The byte span to receive the PKCS#8 PrivateKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="eb17f-371">При возврате метода содержит значение, которое показывает количество байтов, записанных в <paramref name="destination" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-371">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="eb17f-372">Этот параметр обрабатывается как неинициализированный.</span><span class="sxs-lookup"><span data-stu-id="eb17f-372">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="eb17f-373">Пытается экспортировать текущий ключ в формате PKCS#8 PrivateKeyInfo в предоставленный буфер.</span><span class="sxs-lookup"><span data-stu-id="eb17f-373">Attempts to export the current key in the PKCS#8 PrivateKeyInfo format into a provided buffer.</span></span></summary>
        <returns><span data-ttu-id="eb17f-374"><see langword="true" />, если размер <paramref name="destination" /> достаточно велик, чтобы вместить выходные данные; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-374"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-375">Не удалось экспортировать ключ.</span><span class="sxs-lookup"><span data-stu-id="eb17f-375">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportSubjectPublicKeyInfo">
      <MemberSignature Language="C#" Value="public override bool TryExportSubjectPublicKeyInfo (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportSubjectPublicKeyInfo(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function TryExportSubjectPublicKeyInfo (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportSubjectPublicKeyInfo(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportSubjectPublicKeyInfo : Span&lt;byte&gt; * int -&gt; bool" Usage="eCDiffieHellman.TryExportSubjectPublicKeyInfo (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="eb17f-376">Диапазон байтов для получения данных X.509 SubjectPublicKeyInfo.</span><span class="sxs-lookup"><span data-stu-id="eb17f-376">The byte span to receive the X.509 SubjectPublicKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="eb17f-377">При возврате метода содержит значение, которое показывает количество байтов, записанных в <paramref name="destination" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-377">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="eb17f-378">Этот параметр обрабатывается как неинициализированный.</span><span class="sxs-lookup"><span data-stu-id="eb17f-378">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="eb17f-379">Пытается экспортировать текущий ключ в формате X.509 SubjectPublicKeyInfo в предоставленный буфер.</span><span class="sxs-lookup"><span data-stu-id="eb17f-379">Attempts to export the current key in the X.509 SubjectPublicKeyInfo format into a provided buffer.</span></span></summary>
        <returns><span data-ttu-id="eb17f-380"><see langword="true" />, если размер <paramref name="destination" /> достаточно велик, чтобы вместить выходные данные; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="eb17f-380"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="eb17f-381">Не удалось экспортировать ключ.</span><span class="sxs-lookup"><span data-stu-id="eb17f-381">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportSubjectPublicKeyInfo" />
      </Docs>
    </Member>
  </Members>
</Type>
