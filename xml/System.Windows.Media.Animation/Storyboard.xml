<Type Name="Storyboard" FullName="System.Windows.Media.Animation.Storyboard">
  <Metadata><Meta Name="ms.openlocfilehash" Value="088e9871030da39eb83bd368e9532fcc3fa59426" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69438705" /></Metadata><TypeSignature Language="C#" Value="public class Storyboard : System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Storyboard extends System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Animation.Storyboard" />
  <TypeSignature Language="VB.NET" Value="Public Class Storyboard&#xA;Inherits ParallelTimeline" />
  <TypeSignature Language="C++ CLI" Value="public ref class Storyboard : System::Windows::Media::Animation::ParallelTimeline" />
  <TypeSignature Language="F#" Value="type Storyboard = class&#xA;    inherit ParallelTimeline" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Animation.ParallelTimeline</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Временная шкала контейнера, которая предоставляет объект и свойство, содержащие сведения о дочерних анимациях.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="interactively-controlling-storyboards"></a>Интерактивное управление раскадровкой  
 Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в разметке, укажите <xref:System.Windows.Media.Animation.BeginStoryboard.Name%2A> свойство <xref:System.Windows.Media.Animation.BeginStoryboard> объекта, который его создает; пример см. в разделе [как Используйте триггеры событий для управления раскадровкой после](~/docs/framework/wpf/graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md)ее запуска. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
## <a name="data-binding-and-animating-timelines"></a>Привязка данных и анимация временных шкал  
 Большинство свойств временной шкалы могут быть привязанными к данным или анимированными. Однако из-за способа работы системы управления временем привязанные к данным или анимированные временные шкалы не работают как другие привязанные к данным или анимированные объекты. Чтобы понять их поведение, полезно понять, что означает активация временной шкалы.  
  
 При активации временной шкалы создаются копии временной шкалы и ее дочерние временные шкалы. Эти копии заморожены (доступны только для чтения), <xref:System.Windows.Media.Animation.Clock> а объекты создаются из них. Эти объекты используются для выполнения фактических действий по анимации целевых свойств. Если временная шкала привязана к данным или анимирована, то при создании ее часов выполняется моментальный снимок текущих значений. Несмотря на то, что исходная временная шкала может продолжать изменяться, ее часы не поддерживаются.  
  
 Чтобы временная шкала отражала привязку данных или изменения анимации, ее часы необходимо создать повторно. Часы не создаются повторно автоматически. Ниже показано несколько способов применения изменений временной шкалы.  
  
-   Если временная шкала является или принадлежит к <xref:System.Windows.Media.Animation.Storyboard>, можно сделать так, чтобы она отражала изменения путем повторного применения раскадровки <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> <xref:System.Windows.Media.Animation.BeginStoryboard> с помощью метода или. Это имеет побочный эффект в виде перезапуска анимации. В коде можно использовать <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> метод, чтобы переместить раскадровку обратно в предыдущее расположение.  
  
-   Если вы применили анимацию непосредственно к свойству <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> с помощью метода, <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> вызовите метод еще раз и передайте ему измененную анимацию.  
  
-   Если вы работаете непосредственно на уровне часов, создайте и примените новый набор часов и используйте их для замены предыдущего набора созданных часов.  
  
 Пример анимации с привязкой к данным см. в разделе [Пример анимации по ключевым сплайнам](https://go.microsoft.com/fwlink/?LinkID=160011) .  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Storyboard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Storyboard();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Begin">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициирует набор анимаций, сопоставленных данному объекту <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin();" />
      <MemberSignature Language="F#" Value="member this.Begin : unit -&gt; unit" Usage="storyboard.Begin " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Применяет анимации, связанные с этим типом <see cref="T:System.Windows.Media.Animation.Storyboard" />, к целевым объектам и инициирует их.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, содержащийся в той же области имен, что и целевые объекты анимаций этой раскадровки. Анимации без типа <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> применяются к <paramref name="containingObject" />.</param>
        <summary>Применяет анимации, связанные с этим типом <see cref="T:System.Windows.Media.Animation.Storyboard" />, к целевым объектам и инициирует их.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если целевые свойства уже анимированы, они заменяются с <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> помощью поведения передачи.  
  
 Раскадровки, запущенные с помощью этого метода, не могут быть приостановлены, возобновлены или иным образом управляются в интерактивном режиме после запуска. Чтобы сделать раскадровку управляемой, используйте <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метод или. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A>  
  
 При запуске раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> инициируются события и <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
   
  
## Examples  
 В следующем примере используется раскадровка для анимации <xref:System.Windows.Media.TextEffect>. Объект <xref:System.Windows.Media.TextEffect> содержится<xref:System.Windows.FrameworkContentElement>в области имен.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardExample.cs#frameworkcontentelementstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardexample.vb#frameworkcontentelementstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, содержащийся в той же области имен, что и целевые объекты анимаций этой раскадровки. Анимации без типа <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> применяются к <paramref name="containingObject" />.</param>
        <summary>Применяет анимации, связанные с этим типом <see cref="T:System.Windows.Media.Animation.Storyboard" />, к целевым объектам и инициирует их.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если целевые свойства уже анимированы, они заменяются с <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> помощью поведения передачи.  
  
 Раскадровки, запущенные с помощью этого метода, не могут быть приостановлены, возобновлены или иным образом управляются в интерактивном режиме после запуска. Чтобы сделать раскадровку управляемой, используйте <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Boolean%29> метод или. <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Windows.Media.Animation.HandoffBehavior%2CSystem.Boolean%29>  
  
 При запуске раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> инициируются события и <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, содержащийся в той же области имен, что и целевые объекты анимаций этой раскадровки. Анимации без типа <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> применяются к <paramref name="containingObject" />.</param>
        <param name="isControllable">Значение <see langword="true" />, если управление раскадровкой должно осуществляться в интерактивном режиме; в противном случае — значение <see langword="false" />.</param>
        <summary>Применяет анимации, связанные с этим типом <see cref="T:System.Windows.Media.Animation.Storyboard" />, к целевым объектам и инициирует их.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если целевые свойства уже анимированы, они заменяются с <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> помощью поведения передачи.  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо указать то же `containingObject` самое при вызове методов, которые использовались для начала раскадровки.  
  
 При вызове <xref:System.Windows.Media.Animation.Clock> этого метода создаются объекты для раскадровки и все временные шкалы, которые она содержит. Эти часы хранятся в `containingObject`.  
  
 При запуске раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> инициируются события и <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
   
  
## Examples  
 В следующем примере используется управляемая раскадровка для анимации <xref:System.Windows.Media.TextEffect>. Объект <xref:System.Windows.Media.TextEffect> содержится<xref:System.Windows.FrameworkContentElement>в области имен.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, содержащийся в той же области имен, что и целевые объекты анимаций этой раскадровки. Анимации без типа <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> применяются к <paramref name="containingObject" />.</param>
        <param name="handoffBehavior">Поведение, которое должно использоваться в новой анимации для взаимодействия с любыми текущими анимациями.</param>
        <summary>Применяет анимации, сопоставленные объекту <see cref="T:System.Windows.Media.Animation.Storyboard" /> с их целевыми значениями, а также инициирует их с использованием заданного свойства <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При <xref:System.Windows.Media.Animation.Storyboard>применении, <xref:System.Windows.Media.Animation.AnimationTimeline>или <xref:System.Windows.Media.Animation.AnimationClock> к свойству с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>все <xref:System.Windows.Media.Animation.Clock> объекты, ранее связанные с этим свойством, продолжают потреблять системные ресурсы; система времени не Удалите эти часы автоматически.  
  
 Чтобы избежать проблем с производительностью при применении большого количества часов с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, следует удалить составные часы из анимированного свойства после их завершения. Есть несколько способов удаления часов.  
  
-   Чтобы удалить все часы из свойства, используйте <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> метод или <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> анимированного объекта. Укажите свойство, которое анимируется как первый параметр, а `null` в качестве второго. Это приведет к удалению всех часов анимации из свойства.  
  
-   Чтобы <xref:System.Windows.Media.Animation.AnimationClock> удалить определенное значение из списка часов, <xref:System.Windows.Media.Animation.Clock.Controller%2A> используйте свойство <xref:System.Windows.Media.Animation.ClockController>объекта <xref:System.Windows.Media.Animation.AnimationClock> для получения, а затем вызовите <xref:System.Windows.Media.Animation.ClockController.Remove%2A> метод класса <xref:System.Windows.Media.Animation.ClockController>. Обычно это делается в <xref:System.Windows.Media.Animation.Clock.Completed> обработчике событий для часов. Обратите внимание, что только корневые часы могут управляться <xref:System.Windows.Media.Animation.ClockController> <xref:System.Windows.Media.Animation.Clock.Controller%2A> ; свойство дочернего таймера `null`возвращает. Обратите внимание, <xref:System.Windows.Media.Animation.Clock.Completed> что событие не вызывается, если фактическая длительность часов бесконечно.  В этом случае пользователь должен определить, когда следует вызывать <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 В основном это проблема для анимации объектов, имеющих длинное время жизни.  Если объект уничтожается сборщиком мусора, его часы также отключаются и уничтожаются мусором.  
  
 Дополнительные сведения об объектах часов см. в разделе [Общие сведения о анимации и системе управления временем](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> В следующем примере используется <xref:System.Windows.Media.Animation.HandoffBehavior> для анимации при щелчке левой кнопкой мыши, а также <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> при нажатии пользователем правой кнопки.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, содержащийся в той же области имен, что и целевые объекты анимаций этой раскадровки. Анимации без типа <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> применяются к <paramref name="containingObject" />.</param>
        <param name="isControllable">Значение <see langword="true" />, если управление раскадровкой должно осуществляться в интерактивном режиме; в противном случае — значение <see langword="false" />.</param>
        <summary>Применяет анимации, связанные с этим типом <see cref="T:System.Windows.Media.Animation.Storyboard" />, к целевым объектам и инициирует их.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если целевые свойства уже анимированы, они заменяются с <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> помощью поведения передачи.  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки.  
  
 При вызове <xref:System.Windows.Media.Animation.Clock> этого метода создаются объекты для раскадровки и все временные шкалы, которые она содержит. Эти часы хранятся в `containingObject`.  
  
 При запуске раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> инициируются события и <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, для которого был применен указанный шаблон <paramref name="frameworkTemplate" />. Анимации без типа <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> применяются к <paramref name="containingObject" />.</param>
        <param name="frameworkTemplate">Анимируемый шаблон.</param>
        <summary>Применяет анимации, сопоставленные объекту <see cref="T:System.Windows.Media.Animation.Storyboard" /> с их целевыми значениями в указанном шаблоне, а также инициирует их.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если целевые свойства уже анимированы, они заменяются с <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> помощью поведения передачи.  
  
 При вызове <xref:System.Windows.Media.Animation.Clock> этого метода создаются объекты для раскадровки и все временные шкалы, которые она содержит. Эти часы хранятся в `containingObject`.  
  
 При запуске раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> инициируются события и <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, содержащийся в той же области имен, что и целевые объекты анимаций этой раскадровки. Анимации, в которых не указано свойство <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />, применяются к <paramref name="containingObject" />.</param>
        <param name="handoffBehavior">Поведение, которое должно использоваться в новой анимации для взаимодействия с любыми текущими анимациями.</param>
        <summary>Применяет анимации, сопоставленные объекту <see cref="T:System.Windows.Media.Animation.Storyboard" /> с их целевыми значениями, а также инициирует их с использованием заданного свойства <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> В следующем примере используется <xref:System.Windows.Media.Animation.HandoffBehavior> для анимации при щелчке левой кнопкой мыши, а также <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> при нажатии пользователем правой кнопки.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, содержащийся в той же области имен, что и целевые объекты анимаций этой раскадровки. Анимации, в которых не указано свойство <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />, применяются к <paramref name="containingObject" />.</param>
        <param name="handoffBehavior">Поведение, которое должно использоваться в новой анимации для взаимодействия с любыми текущими анимациями.</param>
        <param name="isControllable">Указывает, является ли анимация управляемой после запуска (можно ли ее приостановить).</param>
        <summary>Применяет анимации, сопоставленные объекту <see cref="T:System.Windows.Media.Animation.Storyboard" /> с их целевыми значениями, а также инициирует их с использованием заданного свойства <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если целевые свойства уже анимированы, они заменяются с использованием указанного поведения передачи.  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо указать то же `containingObject` самое при вызове методов, которые использовались для начала раскадровки.  
  
 При вызове <xref:System.Windows.Media.Animation.Clock> этого метода создаются объекты для раскадровки и все временные шкалы, которые она содержит. Эти часы хранятся в `containingObject`.  
  
 При запуске раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> инициируются события и <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
## <a name="using-the-compose-handoffbehavior"></a>Использование создания HandoffBehavior  
 При <xref:System.Windows.Media.Animation.Storyboard>применении, <xref:System.Windows.Media.Animation.AnimationTimeline>или <xref:System.Windows.Media.Animation.AnimationClock> к свойству с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>все <xref:System.Windows.Media.Animation.Clock> объекты, ранее связанные с этим свойством, продолжают потреблять системные ресурсы; система времени не Удалите эти часы автоматически.  
  
 Чтобы избежать проблем с производительностью при применении большого количества часов с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, следует удалить составные часы из анимированного свойства после их завершения. Есть несколько способов удаления часов.  
  
-   Чтобы удалить все часы из свойства, используйте <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> метод или <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> анимированного объекта. Укажите свойство, которое анимируется как первый параметр, а `null` в качестве второго. Это приведет к удалению всех часов анимации из свойства.  
  
-   Чтобы <xref:System.Windows.Media.Animation.AnimationClock> удалить определенное значение из списка часов, <xref:System.Windows.Media.Animation.Clock.Controller%2A> используйте свойство <xref:System.Windows.Media.Animation.ClockController>объекта <xref:System.Windows.Media.Animation.AnimationClock> для получения, а затем вызовите <xref:System.Windows.Media.Animation.ClockController.Remove%2A> метод класса <xref:System.Windows.Media.Animation.ClockController>. Обычно это делается в <xref:System.Windows.Media.Animation.Clock.Completed> обработчике событий для часов. Обратите внимание, что только корневые часы могут управляться <xref:System.Windows.Media.Animation.ClockController> <xref:System.Windows.Media.Animation.Clock.Controller%2A> ; свойство дочернего таймера `null`возвращает. Обратите внимание, <xref:System.Windows.Media.Animation.Clock.Completed> что событие не вызывается, если фактическая длительность часов бесконечно.  В этом случае пользователь должен определить, когда следует вызывать <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 В основном это проблема для анимации объектов, имеющих длинное время жизни.  Если объект уничтожается сборщиком мусора, его часы также отключаются и уничтожаются мусором.  
  
 Дополнительные сведения об объектах часов см. в разделе [Общие сведения о анимации и системе управления временем](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 В следующем примере используется управляемая раскадровка для анимации <xref:System.Windows.Media.TextEffect>. Объект <xref:System.Windows.Media.TextEffect> содержится<xref:System.Windows.FrameworkContentElement>в области имен.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> В следующем примере используется <xref:System.Windows.Media.Animation.HandoffBehavior> для анимации при щелчке левой кнопкой мыши, а также <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> при нажатии пользователем правой кнопки.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, для которого был применен указанный шаблон <paramref name="frameworkTemplate" />.  Анимации без типа <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> применяются к <paramref name="containingObject" />.</param>
        <param name="frameworkTemplate">Анимируемый шаблон.</param>
        <param name="isControllable">Значение <see langword="true" />, если управление раскадровкой должно осуществляться в интерактивном режиме; в противном случае — значение <see langword="false" />.</param>
        <summary>Применяет анимации, сопоставленные объекту <see cref="T:System.Windows.Media.Animation.Storyboard" /> с их целевыми значениями в указанном шаблоне, а также инициирует их.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если целевые свойства уже анимированы, они заменяются с <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> помощью поведения передачи.  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо указать то же `containingObject` самое при вызове методов, которые использовались для начала раскадровки.  
  
 При вызове <xref:System.Windows.Media.Animation.Clock> этого метода создаются объекты для раскадровки и все временные шкалы, которые она содержит. Эти часы хранятся в `containingObject`.  
  
 При запуске раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> инициируются события и <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, для которого был применен указанный шаблон <paramref name="frameworkTemplate" />. Анимации без типа <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> применяются к <paramref name="containingObject" />.</param>
        <param name="frameworkTemplate">Анимируемый шаблон.</param>
        <param name="handoffBehavior">Поведение, которое должно использоваться в новой анимации для взаимодействия с любыми текущими анимациями.</param>
        <summary>Применяет анимации, сопоставленные объекту <see cref="T:System.Windows.Media.Animation.Storyboard" /> с их целевыми значениями в указанном шаблоне, а также инициирует их.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове <xref:System.Windows.Media.Animation.Clock> этого метода создаются объекты для раскадровки и все временные шкалы, которые она содержит. Эти часы хранятся в `containingObject`.  
  
 При запуске раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> инициируются события и <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
## <a name="using-the-compose-handoffbehavior"></a>Использование создания HandoffBehavior  
 При <xref:System.Windows.Media.Animation.Storyboard>применении, <xref:System.Windows.Media.Animation.AnimationTimeline>или <xref:System.Windows.Media.Animation.AnimationClock> к свойству с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>все <xref:System.Windows.Media.Animation.Clock> объекты, ранее связанные с этим свойством, продолжают потреблять системные ресурсы; система времени не Удалите эти часы автоматически.  
  
 Чтобы избежать проблем с производительностью при применении большого количества часов с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, следует удалить составные часы из анимированного свойства после их завершения. Есть несколько способов удаления часов.  
  
-   Чтобы удалить все часы из свойства, используйте <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> метод или <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> анимированного объекта. Укажите свойство, которое анимируется как первый параметр, а `null` в качестве второго. Это приведет к удалению всех часов анимации из свойства.  
  
-   Чтобы <xref:System.Windows.Media.Animation.AnimationClock> удалить определенное значение из списка часов, <xref:System.Windows.Media.Animation.Clock.Controller%2A> используйте свойство <xref:System.Windows.Media.Animation.ClockController>объекта <xref:System.Windows.Media.Animation.AnimationClock> для получения, а затем вызовите <xref:System.Windows.Media.Animation.ClockController.Remove%2A> метод класса <xref:System.Windows.Media.Animation.ClockController>. Обычно это делается в <xref:System.Windows.Media.Animation.Clock.Completed> обработчике событий для часов. Обратите внимание, что только корневые часы могут управляться <xref:System.Windows.Media.Animation.ClockController> <xref:System.Windows.Media.Animation.Clock.Controller%2A> ; свойство дочернего таймера `null`возвращает. Обратите внимание, <xref:System.Windows.Media.Animation.Clock.Completed> что событие не вызывается, если фактическая длительность часов бесконечно.  В этом случае пользователь должен определить, когда следует вызывать <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 В основном это проблема для анимации объектов, имеющих длинное время жизни.  Если объект уничтожается сборщиком мусора, его часы также отключаются и уничтожаются мусором.  
  
 Дополнительные сведения об объектах часов см. в разделе [Общие сведения о анимации и системе управления временем](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, содержащийся в той же области имен, что и целевые объекты анимаций этой раскадровки. Анимации, в которых не указано свойство <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />, применяются к <paramref name="containingObject" />.</param>
        <param name="handoffBehavior">Поведение, которое должно использоваться в новой анимации для взаимодействия с любыми текущими анимациями.</param>
        <param name="isControllable">Указывает, является ли анимация управляемой после запуска (можно ли ее приостановить).</param>
        <summary>Применяет анимации, связанные с этим типом <see cref="T:System.Windows.Media.Animation.Storyboard" />, к целевым объектам и инициирует их.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки.  
  
 При вызове <xref:System.Windows.Media.Animation.Clock> этого метода создаются объекты для раскадровки и все временные шкалы, которые она содержит. Эти часы хранятся в `containingObject`.  
  
 При запуске раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> инициируются события и <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
## <a name="using-the-compose-handoffbehavior"></a>Использование создания HandoffBehavior  
 При <xref:System.Windows.Media.Animation.Storyboard>применении, <xref:System.Windows.Media.Animation.AnimationTimeline>или <xref:System.Windows.Media.Animation.AnimationClock> к свойству с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>все <xref:System.Windows.Media.Animation.Clock> объекты, ранее связанные с этим свойством, продолжают потреблять системные ресурсы; система времени не Удалите эти часы автоматически.  
  
 Чтобы избежать проблем с производительностью при применении большого количества часов с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, следует удалить составные часы из анимированного свойства после их завершения. Есть несколько способов удаления часов.  
  
-   Чтобы удалить все часы из свойства, используйте <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> метод или <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> анимированного объекта. Укажите свойство, которое анимируется как первый параметр, а `null` в качестве второго. Это приведет к удалению всех часов анимации из свойства.  
  
-   Чтобы <xref:System.Windows.Media.Animation.AnimationClock> удалить определенное значение из списка часов, <xref:System.Windows.Media.Animation.Clock.Controller%2A> используйте свойство <xref:System.Windows.Media.Animation.ClockController>объекта <xref:System.Windows.Media.Animation.AnimationClock> для получения, а затем вызовите <xref:System.Windows.Media.Animation.ClockController.Remove%2A> метод класса <xref:System.Windows.Media.Animation.ClockController>. Обычно это делается в <xref:System.Windows.Media.Animation.Clock.Completed> обработчике событий для часов. Обратите внимание, что только корневые часы могут управляться <xref:System.Windows.Media.Animation.ClockController> <xref:System.Windows.Media.Animation.Clock.Controller%2A> ; свойство дочернего таймера `null`возвращает. Обратите внимание, <xref:System.Windows.Media.Animation.Clock.Completed> что событие не вызывается, если фактическая длительность часов бесконечно.  В этом случае пользователь должен определить, когда следует вызывать <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 В основном это проблема для анимации объектов, имеющих длинное время жизни.  Если объект уничтожается сборщиком мусора, его часы также отключаются и уничтожаются мусором.  
  
 Дополнительные сведения об объектах часов см. в разделе [Общие сведения о анимации и системе управления временем](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 В следующем примере показано, как создать управляемую раскадровку.  
  
 [!code-csharp[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/animation_ovws_procedural_snip/CSharp/ControllableStoryboardExample.cs#controllablestoryboardexamplewholepage)]
 [!code-vb[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animation_ovws_procedural_snip/visualbasic/controllablestoryboardexample.vb#controllablestoryboardexamplewholepage)]  
  
 <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> В следующем примере используется <xref:System.Windows.Media.Animation.HandoffBehavior> для анимации при щелчке левой кнопкой мыши, а также <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> при нажатии пользователем правой кнопки.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, для которого был применен указанный шаблон <paramref name="frameworkTemplate" />. Анимации без типа <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> применяются к <paramref name="containingObject" />.</param>
        <param name="frameworkTemplate">Анимируемый шаблон.</param>
        <param name="handoffBehavior">Поведение, которое должно использоваться в новой анимации для взаимодействия с любыми текущими анимациями.</param>
        <param name="isControllable">Значение <see langword="true" />, если управление раскадровкой должно осуществляться в интерактивном режиме; в противном случае — значение <see langword="false" />.</param>
        <summary>Применяет анимации, сопоставленные объекту <see cref="T:System.Windows.Media.Animation.Storyboard" /> с их целевыми значениями в указанном шаблоне, а также инициирует их.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы интерактивно управлять этой раскадровкой, необходимо указать то же `containingObject` самое при вызове методов, которые использовались для начала раскадровки.  
  
 При вызове <xref:System.Windows.Media.Animation.Clock> этого метода создаются объекты для раскадровки и все временные шкалы, которые она содержит. Эти часы хранятся в `containingObject`.  
  
 При запуске раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> инициируются события и <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> .  
  
## <a name="using-the-compose-handoffbehavior"></a>Использование создания HandoffBehavior  
 При <xref:System.Windows.Media.Animation.Storyboard>применении, <xref:System.Windows.Media.Animation.AnimationTimeline>или <xref:System.Windows.Media.Animation.AnimationClock> к свойству с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>все <xref:System.Windows.Media.Animation.Clock> объекты, ранее связанные с этим свойством, продолжают потреблять системные ресурсы; система времени не Удалите эти часы автоматически.  
  
 Чтобы избежать проблем с производительностью при применении большого количества часов с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, следует удалить составные часы из анимированного свойства после их завершения. Есть несколько способов удаления часов.  
  
-   Чтобы удалить все часы из свойства, используйте <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> метод или <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> анимированного объекта. Укажите свойство, которое анимируется как первый параметр, а `null` в качестве второго. Это приведет к удалению всех часов анимации из свойства.  
  
-   Чтобы <xref:System.Windows.Media.Animation.AnimationClock> удалить определенное значение из списка часов, <xref:System.Windows.Media.Animation.Clock.Controller%2A> используйте свойство <xref:System.Windows.Media.Animation.ClockController>объекта <xref:System.Windows.Media.Animation.AnimationClock> для получения, а затем вызовите <xref:System.Windows.Media.Animation.ClockController.Remove%2A> метод класса <xref:System.Windows.Media.Animation.ClockController>. Обычно это делается в <xref:System.Windows.Media.Animation.Clock.Completed> обработчике событий для часов. Обратите внимание, что только корневые часы могут управляться <xref:System.Windows.Media.Animation.ClockController> <xref:System.Windows.Media.Animation.Clock.Controller%2A> ; свойство дочернего таймера `null`возвращает. Обратите внимание, <xref:System.Windows.Media.Animation.Clock.Completed> что событие не вызывается, если фактическая длительность часов бесконечно.  В этом случае пользователь должен определить, когда следует вызывать <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 В основном это проблема для анимации объектов, имеющих длинное время жизни.  Если объект уничтожается сборщиком мусора, его часы также отключаются и уничтожаются мусором.  
  
 Дополнительные сведения об объектах часов см. в разделе [Общие сведения о анимации и системе управления временем](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.Storyboard Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Animation.Storyboard Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Storyboard" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::Storyboard ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Media.Animation.Storyboard" Usage="storyboard.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.Storyboard</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает изменяемый клон данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />, делая глубокие копии значений этого объекта. При копировании свойств зависимостей этот метод копирует ссылки на ресурсы и привязки данных (которые могут уже не быть разрешимыми), но не копирует анимации и их текущие значения.</summary>
        <returns>Изменяемая копия текущего объекта. Свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> клонированного объекта имеет значение <see langword="false" />, даже если свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> исходного объекта имеет значение <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для создания изменяемых копий замороженных <xref:System.Windows.Freezable> объектов (или любого <xref:System.Windows.Freezable> объекта). Для удобства этот метод затеняет унаследованную версию с реализацией со строгой типизацией.  
  
 Для получения дополнительной информации см. <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="storyboard.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый экземпляр класса <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Новый экземпляр <see cref="T:System.Windows.Media.Animation.Storyboard" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается внутренним образом <xref:System.Windows.Freezable.CreateInstance%2A> при создании новых экземпляров <xref:System.Windows.Media.Animation.Storyboard> класса для различных методов клонирования (таких как <xref:System.Windows.Freezable.Clone%2A> и <xref:System.Windows.Freezable.CloneCurrentValue%2A>).  
  
   
  
## Examples  
 В следующем примере показана типичная реализация <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Каждый <see cref="T:System.Windows.Media.Animation.Storyboard" /> подкласс должен реализовывать этот метод. Типичная реализация заключается в простом вызове конструктора без параметров класса и возврате результата.</para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentGlobalSpeed">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> Скорость часов — это скорость, с которой время в данный момент выполняется по сравнению с реальным временем.  
  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public double GetCurrentGlobalSpeed ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentGlobalSpeed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentGlobalSpeed();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : unit -&gt; double" Usage="storyboard.GetCurrentGlobalSpeed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Текущая глобальная скорость или 0, если часы остановлены.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, которые были созданы для данной раскадровки и ее дочерних элементов.</param>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Текущая глобальная скорость или <see langword="null" />, если часы остановлены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> Скорость часов — это скорость, с которой время в данный момент выполняется по сравнению с реальным временем.  
  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, которые были созданы для данной раскадровки и ее дочерних элементов.</param>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Текущая глобальная скорость или <see langword="null" />, если часы остановлены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> Скорость часов — это скорость, с которой время в данный момент выполняется по сравнению с реальным временем.  
  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentIteration">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public int GetCurrentIteration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetCurrentIteration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetCurrentIteration();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : unit -&gt; int" Usage="storyboard.GetCurrentIteration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Текущая итерация часов в текущем активном периоде либо значение <see langword="null" />, если часы остановлены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Первая итерация часов имеет значение 1.  
  
 Если эта раскадровка <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> имеет `true`параметр, то полная итерация состоит из пары "прямой-обратная", а не только для одного из этих сегментов.  
  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkContentElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkContentElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, которые были созданы для данной раскадровки и ее дочерних элементов.</param>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Текущая итерация часов в текущем активном периоде либо значение <see langword="null" />, если часы остановлены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Первая итерация часов имеет значение 1.  
  
 Если эта раскадровка <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> имеет `true`параметр, то полная итерация состоит из пары "прямой-обратная", а не только для одного из этих сегментов.  
  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, которые были созданы для данной раскадровки и ее дочерних элементов.</param>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Текущая итерация часов в текущем активном периоде либо значение <see langword="null" />, если часы остановлены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Первая итерация часов имеет значение 1.  
  
 Если временная шкала часов имеет <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> `true`параметр, то полная итерация состоит из пары "прямой-обратная", а не только для одного из этих сегментов.  
  
 Независимо от текущей итерации Поиск часов возвращает текущую итерацию в 1. Перезапуск часов также возвращает текущую итерацию в 1.  
  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentProgress">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public double GetCurrentProgress ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentProgress() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentProgress();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : unit -&gt; double" Usage="storyboard.GetCurrentProgress " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Значение <see langword="null" />, если часы имеют состояние <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, либо значение 0,0, если часы активны и объект <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> имеет параметр <see cref="P:System.Windows.Media.Animation.Timeline.Duration" />, равный <see cref="P:System.Windows.Duration.Forever" />; в обратном случае значение от 0,0 до 1,0, которое указывает текущее положение часов в текущей итерации. Значение 0,0 указывает, что часы находятся в начале, а значение 1,0 – в конце текущей итерации.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, которые были созданы для данной раскадровки и ее дочерних элементов.</param>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Значение <see langword="null" />, если часы имеют состояние <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, либо значение 0,0, если часы активны и объект <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> имеет параметр <see cref="P:System.Windows.Media.Animation.Timeline.Duration" />, равный <see cref="P:System.Windows.Duration.Forever" />; в обратном случае значение от 0,0 до 1,0, которое указывает текущее положение часов в текущей итерации. Значение 0,0 указывает, что часы находятся в начале, а значение 1,0 – в конце текущей итерации.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, которые были созданы для данной раскадровки и ее дочерних элементов.</param>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Значение <see langword="null" />, если часы имеют состояние <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, либо значение 0,0, если часы активны и объект <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> имеет параметр <see cref="P:System.Windows.Media.Animation.Timeline.Duration" />, равный <see cref="P:System.Windows.Duration.Forever" />; в обратном случае значение от 0,0 до 1,0, которое указывает текущее положение часов в текущей итерации. Значение 0,0 указывает, что часы находятся в начале, а значение 1,0 – в конце текущей итерации.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentState">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState () As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : unit -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Текущее состояние часов, созданных для данной раскадровки: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> или <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не указывает, приостановлена ли раскадровка. Чтобы определить, приостановлена ли раскадровка, используйте <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> метод.  
  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkContentElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkContentElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, которые были созданы для данной раскадровки и ее дочерних элементов.</param>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Текущее состояние часов, созданных для данной раскадровки: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> или <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не указывает, приостановлена ли раскадровка. Чтобы определить, приостановлена ли раскадровка, используйте <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> метод.  
  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, которые были созданы для данной раскадровки и ее дочерних элементов.</param>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Текущее состояние часов, созданных для данной раскадровки: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> или <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не указывает, приостановлена ли раскадровка. Чтобы определить, приостановлена ли раскадровка, используйте <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> метод.  
  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentTime">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public TimeSpan GetCurrentTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan GetCurrentTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime () As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TimeSpan GetCurrentTime();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : unit -&gt; TimeSpan" Usage="storyboard.GetCurrentTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Значение <see langword="null" />, если часы раскадровки имеют значение <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; в обратном случае – текущее время часов раскадровки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkContentElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkContentElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, которые были созданы для данной раскадровки и ее дочерних элементов.</param>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Значение <see langword="null" />, если часы раскадровки имеют значение <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; в обратном случае – текущее время часов раскадровки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, которые были созданы для данной раскадровки и ее дочерних элементов.</param>
        <summary>Извлекает свойство <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Значение <see langword="null" />, если часы раскадровки имеют значение <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; в обратном случае – текущее время часов раскадровки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetIsPaused">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, указывающее, приостановлен ли объект <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused();" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : unit -&gt; bool" Usage="storyboard.GetIsPaused " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, приостановлен ли объект <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Значение <see langword="true" />, если объект <see cref="T:System.Windows.Media.Animation.Clock" />, созданный для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />; в противном случае – значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkContentElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkContentElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <summary>Возвращает значение, указывающее, приостановлен ли объект <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Значение <see langword="true" />, если объект <see cref="T:System.Windows.Media.Animation.Clock" />, созданный для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />; в противном случае – значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <summary>Возвращает значение, указывающее, приостановлен ли объект <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Значение <see langword="true" />, если объект <see cref="T:System.Windows.Media.Animation.Clock" />, созданный для данного объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />; в противном случае – значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы использовать этот метод для получения сведений о часах раскадровки, раскадровка должна быть управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetTarget">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetTarget (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetTarget(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTarget(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTarget (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetTarget(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTarget : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.Media.Animation.Storyboard.GetTarget element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Шкала данных, из которой должны быть извлечено значение <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</param>
        <summary>Извлекает значение свойства <see cref="P:System.Windows.Media.Animation.Storyboard.Target" /> указанного объекта <see cref="T:System.Windows.Media.Animation.Timeline" />.</summary>
        <returns>Объект зависимостей, являющийся целевым значением параметра <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.Target%2A> Используйте присоединенное свойство с временными шкалами анимации, чтобы указать объект, на который они нацелены. Дополнительные сведения о работе нацеливания раскадровки см <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. в разделе. Дополнительные сведения о работе присоединенных свойств см. в разделе [Общие сведения](~/docs/framework/wpf/advanced/attached-properties-overview.md)о вложенных свойствах.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetName">
      <MemberSignature Language="C#" Value="public static string GetTargetName (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTargetName(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetName(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetName (element As DependencyObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTargetName(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetName : System.Windows.DependencyObject -&gt; string" Usage="System.Windows.Media.Animation.Storyboard.GetTargetName element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Шкала данных, из которой должны быть извлечено значение <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</param>
        <summary>Извлекает значение свойства <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> указанного объекта <see cref="T:System.Windows.Media.Animation.Timeline" />.</summary>
        <returns>Имя объекта зависимостей, являющегося целевым значением параметра <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод получает <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> присоединенное свойство для указанного объекта. Дополнительные сведения о работе нацеливания раскадровки см <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. в разделе. Дополнительные сведения о работе присоединенных свойств см. в разделе [Общие сведения](~/docs/framework/wpf/advanced/attached-properties-overview.md)о вложенных свойствах.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetProperty">
      <MemberSignature Language="C#" Value="public static System.Windows.PropertyPath GetTargetProperty (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.PropertyPath GetTargetProperty(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetProperty(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetProperty (element As DependencyObject) As PropertyPath" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::PropertyPath ^ GetTargetProperty(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetProperty : System.Windows.DependencyObject -&gt; System.Windows.PropertyPath" Usage="System.Windows.Media.Animation.Storyboard.GetTargetProperty element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Объект зависимостей, из которого необходимо получить значение <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />.</param>
        <summary>Извлекает значение свойства <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" /> указанного объекта <see cref="T:System.Windows.Media.Animation.Timeline" />.</summary>
        <returns>Свойство, являющееся целевым для свойства <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод получает <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> присоединенное свойство для указанного объекта. Дополнительные сведения о работе нацеливания раскадровки см <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> . в разделе присоединенное свойство. Дополнительные сведения о работе присоединенных свойств см. в разделе [Общие сведения](~/docs/framework/wpf/advanced/attached-properties-overview.md)о вложенных свойствах.  
  
 Обратите внимание, <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> что если параметр был задан в разметке, <xref:System.Windows.PropertyPath> этот метод возвращает пустое значение, так как ссылка на свойство разрешается и сохраняется внутренне при синтаксическом анализе.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pause">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Приостанавливает объект <see cref="T:System.Windows.Media.Animation.Clock" />, созданный для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause();" />
      <MemberSignature Language="F#" Value="member this.Pause : unit -&gt; unit" Usage="storyboard.Pause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Приостанавливает объект <see cref="T:System.Windows.Media.Animation.Clock" />, созданный для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод приостанавливает раскадровку, но не имеет различимый, если она неактивна или приостановлена в данный момент. В качестве побочного действия все связанные дочерние элементы также приостанавливаются.  
  
 Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
## <a name="beginning-a-paused-storyboard"></a>Начало приостановленной раскадровки  
 <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> При приостановке раскадровки она будет возобновлена и перезапущена. Однако это не то, что происходит. Метод фактически заменяет <xref:System.Windows.Media.Animation.Storyboard> приостановку новой неприостановленной версией. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Каждый раз <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> при вызове метода для раскадровки создаются объекты Clock. Эти часы распределяются по свойствам, которые они анимировать. Таким образом, при <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> повторном вызове метода он не перезапускает свои часы; он заменяет их новыми часами.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <summary>Приостанавливает <see cref="T:System.Windows.Media.Animation.Clock" /> указанного объекта <see cref="T:System.Windows.FrameworkContentElement" />, связанного с этим объектом <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод приостанавливает раскадровку, но не имеет различимый, если она неактивна или приостановлена в данный момент. В качестве побочного действия все связанные дочерние элементы также приостанавливаются.  
  
 Поиск приостановленной раскадровки не приводит к ее возобновлению. Единственный способ возобновить приостановленную раскадровку — использовать <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> метод. При повторном вызове метода приостановленная раскадровка заменяется на новую, что имеет вид возобновления. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A>  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Из пример см. в [разделе как Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 При приостановке часов раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> запускается событие.  
  
## <a name="beginning-a-paused-storyboard"></a>Начало приостановленной раскадровки  
 <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> При приостановке раскадровки она будет возобновлена и перезапущена. Однако это не то, что происходит. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Метод фактически заменяет себя неприостановленной версией. Каждый раз <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> при вызове метода для раскадровки создаются объекты Clock. Эти часы распределяются по свойствам, которые они анимировать. Таким образом, при <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> повторном вызове метода он не перезапускает свои часы; он заменяет их новыми часами.  
  
   
  
## Examples  
 В следующем примере используется управляемая раскадровка для анимации <xref:System.Windows.Media.TextEffect>. Объект <xref:System.Windows.Media.TextEffect> содержится<xref:System.Windows.FrameworkContentElement>в области имен.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <summary>Приостанавливает <see cref="T:System.Windows.Media.Animation.Clock" /> указанного объекта <see cref="T:System.Windows.FrameworkElement" />, связанного с этим объектом <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод приостанавливает раскадровку, но не имеет различимый, если она неактивна или приостановлена в данный момент. В качестве побочного действия все связанные дочерние элементы также приостанавливаются.  
  
 Поиск приостановленной раскадровки не приводит к ее возобновлению. Единственный способ возобновить приостановленную раскадровку — использовать <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> метод. При повторном вызове метода приостановленная раскадровка заменяется на новую, что имеет вид возобновления. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A>  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 При приостановке часов раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> запускается событие.  
  
## <a name="beginning-a-paused-storyboard"></a>Начало приостановленной раскадровки  
 <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> При приостановке раскадровки она будет возобновлена и перезапущена. Однако это не то, что происходит. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Метод фактически заменяет себя неприостановленной версией. Каждый раз <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> при вызове метода для раскадровки создаются объекты Clock. Эти часы распределяются по свойствам, которые они анимировать. Таким образом, при <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> повторном вызове метода он не перезапускает свои часы; он заменяет их новыми часами.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />. Анимации, относящиеся к этому объекту <see cref="T:System.Windows.Media.Animation.Storyboard" />, больше не влияют на свойства, которые они ранее анимировали, вне зависимости от значения их параметра <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove();" />
      <MemberSignature Language="F#" Value="member this.Remove : unit -&gt; unit" Usage="storyboard.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет объекты <see cref="T:System.Windows.Media.Animation.Clock" /> , созданные для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />. Анимации, относящиеся к этому объекту <see cref="T:System.Windows.Media.Animation.Storyboard" />, больше не влияют на свойства, которые они ранее анимировали, вне зависимости от значения их параметра <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 Все интерактивные действия <xref:System.Windows.Media.Animation.Clock>, выполняемые в, и <xref:System.Windows.Media.Animation.Storyboard>, следовательно, происходят в следующем такте обработчика времени, который происходит вскоре перед следующей прорисовкой. Это означает, что <xref:System.Windows.Media.Animation.Storyboard.Remove%2A> метод по-прежнему влияет на анимированные свойства до этого времени. Иными словами, при следующем отображении кадра раскадровка будет удалена. Если необходимо отсоединить анимацию от свойства до этого времени, используйте <xref:System.Windows.UIElement.BeginAnimation%2A> метод `animation` со значением `null`параметра.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <summary>Удаляет объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />. Анимации, относящиеся к этому объекту <see cref="T:System.Windows.Media.Animation.Storyboard" />, больше не влияют на свойства, которые они ранее анимировали, вне зависимости от значения их параметра <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 При удалении часов раскадровки вызывается <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> событие.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <summary>Удаляет объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />. Анимации, относящиеся к этому объекту <see cref="T:System.Windows.Media.Animation.Storyboard" />, больше не влияют на свойства, которые они ранее анимировали, вне зависимости от значения их параметра <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 При удалении часов раскадровки вызывается <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> событие.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Resume">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возобновляет таймер <see cref="T:System.Windows.Media.Animation.Clock" />, созданный для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="storyboard.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возобновляет таймер <see cref="T:System.Windows.Media.Animation.Clock" />, созданный для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <summary>Возобновляет таймер <see cref="T:System.Windows.Media.Animation.Clock" />, созданный для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возобновление раскадровки, которая не приостановлена, не оказывает никакого воздействия.  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 Поиск приостановленной раскадровки не приводит к ее возобновлению. Единственный способ возобновить приостановленную раскадровку — использовать <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> метод. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Вызов метода после начала раскадровки заменяет старую раскадровку, которая имеет внешний вид возобновления.  
  
 Возобновление приостановленной отсчета часов раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> вызывает событие.  
  
   
  
## Examples  
 В следующем примере используется управляемая раскадровка для анимации <xref:System.Windows.Media.TextEffect>. Объект <xref:System.Windows.Media.TextEffect> содержится<xref:System.Windows.FrameworkContentElement>в области имен.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <summary>Возобновляет таймер <see cref="T:System.Windows.Media.Animation.Clock" />, созданный для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возобновление раскадровки, которая не приостановлена, не оказывает никакого воздействия.  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 Поиск приостановленной раскадровки не приводит к ее возобновлению. Единственный способ возобновить приостановленную раскадровку — использовать <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> метод. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Вызов метода после начала раскадровки заменяет старую раскадровку, которая имеет внешний вид возобновления.  
  
 Возобновление приостановленной отсчета часов раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> вызывает событие.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Установка объекта <see cref="T:System.Windows.Media.Animation.Storyboard" /> в новую позицию в следующем тике часов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan -&gt; unit" Usage="storyboard.Seek offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Положительное или отрицательное значение, определяющее величину, на которую должна продвигаться вперед или назад шкала времени.</param>
        <summary>Выполняет поиск этого <see cref="T:System.Windows.Media.Animation.Storyboard" /> в указанной позиции. Объект <see cref="T:System.Windows.Media.Animation.Storyboard" /> выполняет запрошенный поиск, когда происходит следующий такт таймера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что операции поиска не занимают <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> раскадровку или <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> параметры. Раскадровка обрабатывается так, будто имеет <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> значение, равное <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>1 и нет.  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Положительное или отрицательное значение, определяющее величину, на которую временная шкала должна переместиться вперед или назад от заданного типа <paramref name="origin" />.</param>
        <param name="origin">Положение, с которого применяется <paramref name="offset" />.</param>
        <summary>Выполняет поиск этого <see cref="T:System.Windows.Media.Animation.Storyboard" /> в указанной позиции. Объект <see cref="T:System.Windows.Media.Animation.Storyboard" /> выполняет запрошенный поиск, когда происходит следующий такт таймера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что операции поиска не занимают <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> раскадровку или <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> параметры. Раскадровка обрабатывается так, будто имеет <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> значение, равное <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>1 и нет.  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <param name="offset">Положительное или отрицательное значение, определяющее величину, на которую временная шкала должна переместиться вперед или назад от заданного типа <paramref name="origin" />.</param>
        <param name="origin">Положение, с которого применяется <paramref name="offset" />.</param>
        <summary>Выполняет поиск этого <see cref="T:System.Windows.Media.Animation.Storyboard" /> в указанной позиции. Объект <see cref="T:System.Windows.Media.Animation.Storyboard" /> выполняет запрошенный поиск, когда происходит следующий такт таймера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что операции поиска не занимают <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> раскадровку или <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> параметры. Раскадровка обрабатывается так, будто имеет <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> значение, равное <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>1 и нет.  
  
 Этот метод изменяет значение часов <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> раскадровки на. <xref:System.Windows.Media.Animation.ClockState.Active> Этот метод не влияет на дерево времени до следующего завершения обработки тика. В качестве побочного результата соответствующие события также не вызываются до тех пор, пока не будут созданы.  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 При поиске раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> инициируются события и <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> .  
  
   
  
## Examples  
 В следующем примере показаны <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> методы и. <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <param name="offset">Положительное или отрицательное значение, определяющее величину, на которую временная шкала должна переместиться вперед или назад от заданного типа <paramref name="origin" />.</param>
        <param name="origin">Положение, с которого применяется <paramref name="offset" />.</param>
        <summary>Выполняет поиск этого <see cref="T:System.Windows.Media.Animation.Storyboard" /> в указанной позиции. Объект <see cref="T:System.Windows.Media.Animation.Storyboard" /> выполняет запрошенный поиск, когда происходит следующий такт таймера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что операции поиска не занимают <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> раскадровку или <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> параметры. Раскадровка обрабатывается так, будто имеет <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> значение, равное <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>1 и нет.  
  
 Этот метод изменяет значение часов <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> раскадровки на. <xref:System.Windows.Media.Animation.ClockState.Active> Этот метод не влияет на дерево времени до следующего завершения обработки тика. В качестве побочного результата соответствующие события также не вызываются до тех пор, пока не будут созданы.  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливать, возобновляться, искать, останавливать и удаляться, если она становится управляемой. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 При поиске раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> инициируются события и <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> .  
  
   
  
## Examples  
 В следующем примере показано, как выполнить поиск (Skip) до одной секунды после начала раскадровки.  
  
 [!code-csharp[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/SeekStoryboardExample.cs#seekstoryboardexamplewholepage)]
 [!code-vb[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/seekstoryboardexample.vb#seekstoryboardexamplewholepage)]  
  
 В следующем примере показаны <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> методы и. <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SeekAlignedToLastTick">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Немедленно (синхронно) выполняет поиск данного <see cref="T:System.Windows.Media.Animation.Storyboard" /> в новом расположении.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan -&gt; unit" Usage="storyboard.SeekAlignedToLastTick offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Положительное или отрицательное значение, определяющее величину, на которую должна продвигаться вперед или назад шкала времени.</param>
        <summary>Немедленно (синхронно) выполняет поиск данного <see cref="T:System.Windows.Media.Animation.Storyboard" /> в новом расположении.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>Выровняйте время <xref:System.Windows.Media.Animation.Storyboard> поиска с последним тактовым импульсом. Значения немедленно обновляются <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, чтобы отразить изменения из-за, хотя экран не отражает эти изменения до обновления экрана.  
  
 Обратите внимание, что операции поиска не занимают <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> раскадровку или <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> параметры. Раскадровка обрабатывается так, будто имеет <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> значение, равное <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>1 и нет.  
  
 Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Положительное или отрицательное значение, определяющее величину, на которую временная шкала должна переместиться вперед или назад от заданного типа <paramref name="origin" />.</param>
        <param name="origin">Положение, с которого применяется <paramref name="offset" />.</param>
        <summary>Немедленно (синхронно) выполняет поиск данного <see cref="T:System.Windows.Media.Animation.Storyboard" /> в новом расположении.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>Выровняйте время <xref:System.Windows.Media.Animation.Storyboard> поиска с последним тактовым импульсом. Значения немедленно обновляются <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, чтобы отразить изменения из-за, хотя экран не отражает эти изменения до обновления экрана.  
  
 Обратите внимание, что операции поиска не занимают <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> раскадровку или <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> параметры. Раскадровка обрабатывается так, будто имеет <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> значение, равное <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>1 и нет.  
  
 Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <param name="offset">Положительное или отрицательное значение, определяющее величину, на которую временная шкала должна переместиться вперед или назад от заданного типа <paramref name="origin" />.</param>
        <param name="origin">Положение, с которого применяется <paramref name="offset" />.</param>
        <summary>Немедленно (синхронно) выполняет поиск данного <see cref="T:System.Windows.Media.Animation.Storyboard" /> в новом расположении.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>Выровняйте время <xref:System.Windows.Media.Animation.Storyboard> поиска с последним тактовым импульсом. Значения немедленно обновляются <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, чтобы отразить изменения из-за, хотя экран не отражает эти изменения до обновления экрана.  
  
 Обратите внимание, что операции поиска не занимают <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> раскадровку или <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> параметры. Раскадровка обрабатывается так, будто имеет <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> значение, равное <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>1 и нет.  
  
 Этот метод изменяет значение часов <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> раскадровки на  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 При поиске раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> инициируются события и <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> .  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
   
  
## Examples  
 В следующем примере показаны <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> методы и. <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <param name="offset">Положительное или отрицательное значение, определяющее величину, на которую временная шкала должна переместиться вперед или назад от заданного типа <paramref name="origin" />.</param>
        <param name="origin">Положение, с которого применяется <paramref name="offset" />.</param>
        <summary>Немедленно (синхронно) выполняет поиск данного <see cref="T:System.Windows.Media.Animation.Storyboard" /> в новом расположении.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>Выровняйте время <xref:System.Windows.Media.Animation.Storyboard> поиска с последним тактовым импульсом. Значения немедленно обновляются <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, чтобы отразить изменения из-за, хотя экран не отражает эти изменения до обновления экрана.  
  
 Обратите внимание, что операции поиска не занимают <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> раскадровку или <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> параметры. Раскадровка обрабатывается так, будто имеет <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> значение, равное <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>1 и нет.  
  
 Этот метод изменяет значение часов <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> раскадровки на  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 При поиске раскадровки <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> инициируются события и <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> .  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
   
  
## Examples  
 В следующем примере показаны <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> методы и. <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSpeedRatio">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Устанавливает коэффициент скорости интерактивного взаимодействия для объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : double -&gt; unit" Usage="storyboard.SetSpeedRatio speedRatio" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="speedRatio">Конечное значение больше нуля, которое представляет новый коэффициент скорости интерактивного взаимодействия раскадровки. Это значение умножается на значение <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> раскадровки, чтобы определить действительную скорость раскадровки. Это значение не перезаписывает свойство <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> раскадровки. Например, при вызове этого метода с указанием скорости интерактивного взаимодействия 3 для раскадровки, свойство <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> которой имеет значение 0,5, итоговая скорость раскадровки составит 1,5.</param>
        <summary>Устанавливает коэффициент скорости интерактивного взаимодействия для объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkContentElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkContentElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkContentElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkContentElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkContentElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkContentElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <param name="speedRatio">Конечное значение больше нуля, которое представляет новый коэффициент скорости интерактивного взаимодействия раскадровки. Это значение умножается на значение <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> раскадровки, чтобы определить действительную скорость раскадровки. Это значение не перезаписывает свойство <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> раскадровки. Например, при вызове этого метода с указанием скорости интерактивного взаимодействия 3 для раскадровки, свойство <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> которой имеет значение 0,5, итоговая скорость раскадровки составит 1,5.</param>
        <summary>Устанавливает коэффициент скорости интерактивного взаимодействия для объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 Вызов этого метода вызывает <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> событие.  
  
   
  
## Examples  
 В следующем примере используется управляемая раскадровка для анимации <xref:System.Windows.Media.TextEffect>. Объект <xref:System.Windows.Media.TextEffect> содержится<xref:System.Windows.FrameworkContentElement>в области имен.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <param name="speedRatio">Конечное значение больше нуля, которое представляет новый коэффициент скорости интерактивного взаимодействия раскадровки. Это значение умножается на значение <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> раскадровки, чтобы определить действительную скорость раскадровки. Это значение не перезаписывает свойство <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> раскадровки. Например, при вызове этого метода с указанием скорости интерактивного взаимодействия 3 для раскадровки, свойство <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> которой имеет значение 0,5, итоговая скорость раскадровки составит 1,5.</param>
        <summary>Устанавливает коэффициент скорости интерактивного взаимодействия для объекта <see cref="T:System.Windows.Media.Animation.Clock" />, который был создан для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 Вызов этого метода вызывает <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> событие.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTarget">
      <MemberSignature Language="C#" Value="public static void SetTarget (System.Windows.DependencyObject element, System.Windows.DependencyObject value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTarget(class System.Windows.DependencyObject element, class System.Windows.DependencyObject value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTarget(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTarget (element As DependencyObject, value As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTarget(System::Windows::DependencyObject ^ element, System::Windows::DependencyObject ^ value);" />
      <MemberSignature Language="F#" Value="static member SetTarget : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTarget (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Объект <see cref="T:System.Windows.Media.Animation.Timeline" />, который должен быть целевым объектом для указанного объекта зависимостей.</param>
        <param name="value">Объект зависимостей для целевого объекта.</param>
        <summary>Делает целевой объект <see cref="T:System.Windows.Media.Animation.Timeline" /> объектом зависимостей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод задает <xref:System.Windows.Media.Animation.Storyboard.Target%2A> присоединенное свойство для указанного объекта. Дополнительные сведения о работе нацеливания раскадровки см <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. в разделе. Дополнительные сведения о работе присоединенных свойств см. в разделе [Общие сведения](~/docs/framework/wpf/advanced/attached-properties-overview.md)о вложенных свойствах.  
  
> [!NOTE]
>  Свойство не сериализуется, так как его можно установить в значение Any <xref:System.Windows.DependencyObject>. <xref:System.Windows.Media.Animation.Storyboard.Target%2A> Не гарантируется, что этот объект может быть правильно указан из XAML.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetName">
      <MemberSignature Language="C#" Value="public static void SetTargetName (System.Windows.DependencyObject element, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetName(class System.Windows.DependencyObject element, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetName(System.Windows.DependencyObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetName (element As DependencyObject, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetName(System::Windows::DependencyObject ^ element, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member SetTargetName : System.Windows.DependencyObject * string -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetName (element, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="element">Объект <see cref="T:System.Windows.Media.Animation.Timeline" />, который должен быть целевым объектом для указанного объекта зависимостей.</param>
        <param name="name">Имя объекта зависимостей, который будет целевым.</param>
        <summary>Делает указанный целевой объект <see cref="T:System.Windows.Media.Animation.Timeline" /> объектом зависимостей с указанным именем.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод задает <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> присоединенное свойство для указанного объекта. Дополнительные сведения о работе нацеливания раскадровки см <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. в разделе. Дополнительные сведения о работе присоединенных свойств см. в разделе [Общие сведения](~/docs/framework/wpf/advanced/attached-properties-overview.md)о вложенных свойствах.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetProperty">
      <MemberSignature Language="C#" Value="public static void SetTargetProperty (System.Windows.DependencyObject element, System.Windows.PropertyPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetProperty(class System.Windows.DependencyObject element, class System.Windows.PropertyPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetProperty(System.Windows.DependencyObject,System.Windows.PropertyPath)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetProperty (element As DependencyObject, path As PropertyPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetProperty(System::Windows::DependencyObject ^ element, System::Windows::PropertyPath ^ path);" />
      <MemberSignature Language="F#" Value="static member SetTargetProperty : System.Windows.DependencyObject * System.Windows.PropertyPath -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetProperty (element, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="path" Type="System.Windows.PropertyPath" />
      </Parameters>
      <Docs>
        <param name="element">Объект <see cref="T:System.Windows.Media.Animation.Timeline" />, с которым необходимо связать указанное свойство зависимостей.</param>
        <param name="path">Путь, который указывает на анимируемое свойство зависимостей.</param>
        <summary>Делает указанный целевой объект <see cref="T:System.Windows.Media.Animation.Timeline" /> заданным объектом зависимости.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод задает <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> присоединенное свойство для указанного объекта. Дополнительные сведения о работе нацеливания раскадровки см <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A>. в разделе. Дополнительные сведения о работе присоединенных свойств см. в разделе [Общие сведения](~/docs/framework/wpf/advanced/attached-properties-overview.md)о вложенных свойствах.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipToFill">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Перемещает текущее время <see cref="T:System.Windows.Media.Animation.Clock" /> этой раскадровки в конец активного периода.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill();" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : unit -&gt; unit" Usage="storyboard.SkipToFill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Перемещает текущее время <see cref="T:System.Windows.Media.Animation.Clock" /> этой раскадровки в конец активного периода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <summary>Перемещает текущее время <see cref="T:System.Windows.Media.Animation.Clock" /> этой раскадровки в конец активного периода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод увеличивает текущее время раскадровки до конца его активного периода; поведение раскадровки на этом этапе задается ее <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> параметром. Если <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> <xref:System.Windows.Media.Animation.FillBehavior.Stop>для <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>параметра задано значение, то раскадровка заполняется; если свойство имеет значение, раскадровка останавливается.  
  
 Вызов этого метода для раскадровки с бесконечным временем не оказывает влияния на бесконечное количество повторений. Вызов этого метода для неактивной раскадровки не имеет силы.  
  
 При переводе часов в период заполнения запустится <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> событие <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> и.  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
   
  
## Examples  
 В следующем примере используется управляемая раскадровка для анимации <xref:System.Windows.Media.TextEffect>. Объект <xref:System.Windows.Media.TextEffect> содержится<xref:System.Windows.FrameworkContentElement>в области имен.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <summary>Перемещает текущее время <see cref="T:System.Windows.Media.Animation.Clock" /> этой раскадровки в конец активного периода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод увеличивает текущее время раскадровки до конца его активного периода; поведение раскадровки на этом этапе задается ее <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> параметром. Если <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> <xref:System.Windows.Media.Animation.FillBehavior.Stop>для <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>параметра задано значение, то раскадровка заполняется; если свойство имеет значение, раскадровка останавливается.  
  
 Вызов этого метода для раскадровки с бесконечным временем не оказывает влияния на бесконечное количество повторений. Вызов этого метода для неактивной раскадровки не имеет силы.  
  
 При переводе часов в период заполнения запустится <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> событие <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> и.  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Stop">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Останавливает таймер <see cref="T:System.Windows.Media.Animation.Clock" />, созданный для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="storyboard.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Останавливает таймер <see cref="T:System.Windows.Media.Animation.Clock" />, созданный для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что остановка раскадровки <xref:System.Windows.Media.Animation.Timeline.Completed> не запускает событие.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <summary>Останавливает таймер <see cref="T:System.Windows.Media.Animation.Clock" />, созданный для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.ClockState.Stopped> Раскадровка больше не влияет на целевые свойства: свойства, которые были анимированы, возвращаются к предыдущим значениям.  
  
 Остановка часов запускает <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated>событияи , но не событие.<xref:System.Windows.Media.Animation.Timeline.Completed>  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
   
  
## Examples  
 В следующем примере используется управляемая раскадровка для анимации <xref:System.Windows.Media.TextEffect>. Объект <xref:System.Windows.Media.TextEffect> содержится<xref:System.Windows.FrameworkContentElement>в области имен.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Объект, заданный при вызове метода <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Этот объект содержит объекты <see cref="T:System.Windows.Media.Animation.Clock" />, созданные для этой раскадровки и ее дочерних элементов.</param>
        <summary>Останавливает таймер <see cref="T:System.Windows.Media.Animation.Clock" />, созданный для этого объекта <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.ClockState.Stopped> Раскадровка больше не влияет на целевые свойства: свойства, которые были анимированы, возвращаются к предыдущим значениям.  
  
 Остановка часов запускает <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated>событияи , но не событие.<xref:System.Windows.Media.Animation.Timeline.Completed>  
  
 Чтобы интерактивно управлять этой раскадровкой, необходимо использовать тот же `containingObject` параметр при вызове методов, которые использовались для начала раскадровки. Управляемая раскадровка может приостанавливаться, возобновляться, искать, останавливать и удаляться. Чтобы сделать раскадровку управляемой в коде, необходимо использовать соответствующую перегрузку <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> метода раскадровки и указать `true` , чтобы сделать ее управляемой. Пример см. в статье [Практическое руководство. Управление раскадровкой после ее](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md)запуска.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="ILAsm" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.Target" />
      <MemberSignature Language="VB.NET" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="F#" Value="see GetTarget, and SetTarget" Usage="see GetTarget, and SetTarget" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает или задает объект для анимации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Целевой объект должен быть объектом зависимости.  
  
> [!NOTE]
>  Свойство не сериализуется, так как его можно установить в значение Any <xref:System.Windows.DependencyObject>. <xref:System.Windows.Media.Animation.Storyboard.Target%2A> Нет гарантии, что этот объект может быть правильно указан в XAML.  
  
<a name="dependencyPropertyInfo_Target"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Media.Animation.Storyboard.TargetProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetName">
      <MemberSignature Language="C#" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="ILAsm" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      <MemberSignature Language="VB.NET" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="F#" Value="see GetTargetName, and SetTargetName" Usage="see GetTargetName, and SetTargetName" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает или задает имя объекта для анимации. Этот объект должен быть <see cref="T:System.Windows.FrameworkElement" />, <see cref="T:System.Windows.FrameworkContentElement" />, или <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задание этого свойства является необязательным. Если параметр <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> не указан, анимация раскадровки применяется к одному из следующих объектов:  
  
-   Если раскадровка, к которой относится анимация, была запущена <xref:System.Windows.Media.Animation.BeginStoryboard>с помощью, то целевой является <xref:System.Windows.Media.Animation.BeginStoryboard> элемент, владеющий действием, запускающим раскадровку.  
  
-   Если раскадровка была запущена с <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> помощью метода, <xref:System.Windows.FrameworkElement> то <xref:System.Windows.FrameworkContentElement> параметр или <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> задается при запуске раскадровки с помощью метода.  
  
 Если это свойство задано на временной шкале с дочерними объектами, то эти дочерние временные <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> шкалы наследуют родительский элемент, если только они не указывают их собственные.  
  
## <a name="making-an-object-targetable"></a>Как сделать объект целевым  
 При использовании [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]можно выполнить одно из следующих двух действий, чтобы сделать объект целевым для раскадровки:  
  
-   Если объект является <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement>или, задайте его <xref:System.Windows.FrameworkElement.Name%2A> свойство.  
  
-   Если объект является <xref:System.Windows.Freezable> или пользовательским <xref:System.Windows.FrameworkContentElement> или <xref:System.Windows.FrameworkContentElement>, назначьте ему имя с помощью расширения разметки для директивы [x:Name](~/docs/framework/xaml-services/x-name-directive.md) .  
  
 При использовании кода можно сделать объект целевым, используя <xref:System.Windows.NameScope.RegisterName%2A> метод, чтобы присвоить объекту имя.  
  
<a name="dependencyPropertyInfo_TargetName"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Media.Animation.Storyboard.TargetNameProperty>|  
|Свойства метаданных, для которых задано значение`true`|Нет|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetNameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetNameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetNameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetNameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetNameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetNameProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует присоединенное свойство <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует присоединенное свойство <see cref="P:System.Windows.Media.Animation.Storyboard.Target" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetPropertyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetPropertyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetPropertyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetPropertyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetPropertyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetPropertyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует присоединенное свойство <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
  </Members>
</Type>
