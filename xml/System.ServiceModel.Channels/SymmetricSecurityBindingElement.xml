<Type Name="SymmetricSecurityBindingElement" FullName="System.ServiceModel.Channels.SymmetricSecurityBindingElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5ac99fc2b34ec62583a51cdd086a6ceb689b355c" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70669556" /></Metadata><TypeSignature Language="C#" Value="public sealed class SymmetricSecurityBindingElement : System.ServiceModel.Channels.SecurityBindingElement, System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SymmetricSecurityBindingElement extends System.ServiceModel.Channels.SecurityBindingElement implements class System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SymmetricSecurityBindingElement&#xA;Inherits SecurityBindingElement&#xA;Implements IPolicyExportExtension" />
  <TypeSignature Language="C++ CLI" Value="public ref class SymmetricSecurityBindingElement sealed : System::ServiceModel::Channels::SecurityBindingElement, System::ServiceModel::Description::IPolicyExportExtension" />
  <TypeSignature Language="F#" Value="type SymmetricSecurityBindingElement = class&#xA;    inherit SecurityBindingElement&#xA;    interface IPolicyExportExtension" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.SecurityBindingElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IPolicyExportExtension</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет элемент пользовательской привязки, поддерживающий безопасность канала с помощью симметричного шифрования.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пользовательская привязка содержит коллекцию элементов привязки, упорядоченных определенным образом: элемент, представляющий верхнюю часть стека привязок, добавляется в первую очередь, затем — следующий более низкий элемент стека привязок и т. д.  
  
### <a name="to-add-this-class-to-a-binding"></a>Добавление этого класса в привязку  
  
1.  Создайте таблицу <xref:System.ServiceModel.Channels.BindingElementCollection>.  
  
2.  Создайте элементы пользовательской привязки, которые располагаются в стеке привязок выше этого элемента привязки, например необязательные элементы <xref:System.ServiceModel.Channels.TransactionFlowBindingElement> и <xref:System.ServiceModel.Channels.ReliableSessionBindingElement>.  
  
3.  Добавьте созданные элементы в упомянутом выше порядке в коллекцию <xref:System.ServiceModel.Channels.BindingElementCollection> с использованием метода <xref:System.ServiceModel.Channels.BindingElementCollection.InsertItem%2A>.  
  
4.  Создайте экземпляр элемента <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> и добавьте его в коллекцию.  
  
5.  Добавьте в коллекцию любые дополнительные элементы пользовательской привязки, такие как <xref:System.ServiceModel.Channels.TcpTransportBindingElement>.  
  
> [!NOTE]
>  После создания экземпляра этого объекта к свойствам его базового класса <xref:System.ServiceModel.Channels.SecurityBindingElement> следует относиться как к неизменяемым. Вызов `set` для некоторых свойств может иметь непредсказуемые последствия: привязка может повести себя, как если бы свойство сохранило свое прежнее значение, а на проблему может указывать только ошибка времени выполнения. Известно, что так ведут себя два свойства: <xref:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters.KeyType%2A> и <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A>. Возможно, это справедливо и для других свойств.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/a7c7747a-5b8c-463f-8493-7266dac75066">Как создать SecurityBindingElement для указанного режима проверки подлинности</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SymmetricSecurityBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SymmetricSecurityBindingElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SymmetricSecurityBindingElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано, как использовать этот конструктор.  
  
 [!code-csharp[c_CustomBinding#4](~/samples/snippets/csharp/VS_Snippets_CFX/c_custombinding/cs/c_custombinding.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SymmetricSecurityBindingElement (System.ServiceModel.Security.Tokens.SecurityTokenParameters protectionTokenParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ServiceModel.Security.Tokens.SecurityTokenParameters protectionTokenParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SymmetricSecurityBindingElement.#ctor(System.ServiceModel.Security.Tokens.SecurityTokenParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (protectionTokenParameters As SecurityTokenParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SymmetricSecurityBindingElement(System::ServiceModel::Security::Tokens::SecurityTokenParameters ^ protectionTokenParameters);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Channels.SymmetricSecurityBindingElement : System.ServiceModel.Security.Tokens.SecurityTokenParameters -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="new System.ServiceModel.Channels.SymmetricSecurityBindingElement protectionTokenParameters" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="protectionTokenParameters" Type="System.ServiceModel.Security.Tokens.SecurityTokenParameters" />
      </Parameters>
      <Docs>
        <param name="protectionTokenParameters"><see cref="T:System.ServiceModel.Security.Tokens.SecurityTokenParameters" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" /> с использованием заданных параметров маркера безопасности.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactoryCore&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="protected override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactoryCore&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactoryCore&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SymmetricSecurityBindingElement.BuildChannelFactoryCore``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function BuildChannelFactoryCore(Of TChannel) (context As BindingContext) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA;generic &lt;typename TChannel&gt;&#xA; override System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactoryCore(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelFactoryCore : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelFactory&lt;'Channel&gt;" Usage="symmetricSecurityBindingElement.BuildChannelFactoryCore context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">To be added.</typeparam>
        <param name="context">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListenerCore&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="protected override System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListenerCore&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListenerCore&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SymmetricSecurityBindingElement.BuildChannelListenerCore``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function BuildChannelListenerCore(Of TChannel As {Class, IChannel}) (context As BindingContext) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListenerCore(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelListenerCore : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelListener&lt;'Channel (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)&gt; (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="symmetricSecurityBindingElement.BuildChannelListenerCore context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">To be added.</typeparam>
        <param name="context">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElement Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElement Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SymmetricSecurityBindingElement.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Clone () As BindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ServiceModel::Channels::BindingElement ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.ServiceModel.Channels.BindingElement" Usage="symmetricSecurityBindingElement.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый экземпляр этого класса, инициализированный из текущего.</summary>
        <returns>Объект <see cref="T:System.ServiceModel.Channels.BindingElement" /> со значениями свойств, равными значениям свойств текущего экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При этом создается полная копия дерева объектов элементов текущей привязки, также называемая глубоким клоном. Глубокий клон объекта создает копию объекта и копию всего, на что прямо или косвенно ссылается этот объект. Это также называется копированием всего графа объекта. Возвращая глубокий клон, среда выполнения поддерживает ситуацию, при которой несколько пользовательских привязок имеют общий элемент пользовательской привязки. Если глубокий клон не возвращается, поведение среды выполнения является неопределенным.  
  
 Неполный клон объекта, напротив, является копией только данного объекта. Если в объекте содержатся ссылки на другие объекты, их копии не создаются в неполной копии. Вместо этого создаются копии ссылок на исходные объекты.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public override T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SymmetricSecurityBindingElement.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperty(Of T As Class) (context As BindingContext) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class override T GetProperty(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.GetProperty : System.ServiceModel.Channels.BindingContext -&gt; 'T (requires 'T : null)" Usage="symmetricSecurityBindingElement.GetProperty context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип возвращаемого объекта.</typeparam>
        <param name="context">Объект <see cref="T:System.ServiceModel.Channels.BindingContext" />.</param>
        <summary>Возвращает указанный объект из объекта <see cref="T:System.ServiceModel.Channels.BindingContext" />.</summary>
        <returns>Указанный объект типа <paramref name="T" /> из <see cref="T:System.ServiceModel.Channels.BindingContext" />, либо значение <see langword="null" />, если объект не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает указанный объект из базового класса или из какого-либо предка этого класса. Обычно возвращаемый объект — это коллекция свойств, например объект, реализующий интерфейс <xref:System.ServiceModel.Channels.ISecurityCapabilities>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageProtectionOrder">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Security.MessageProtectionOrder MessageProtectionOrder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.Security.MessageProtectionOrder MessageProtectionOrder" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SymmetricSecurityBindingElement.MessageProtectionOrder" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageProtectionOrder As MessageProtectionOrder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Security::MessageProtectionOrder MessageProtectionOrder { System::ServiceModel::Security::MessageProtectionOrder get(); void set(System::ServiceModel::Security::MessageProtectionOrder value); };" />
      <MemberSignature Language="F#" Value="member this.MessageProtectionOrder : System.ServiceModel.Security.MessageProtectionOrder with get, set" Usage="System.ServiceModel.Channels.SymmetricSecurityBindingElement.MessageProtectionOrder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.MessageProtectionOrder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает порядок шифрования и подписи сообщений для данной привязки.</summary>
        <value>Объект <see cref="T:System.ServiceModel.Security.MessageProtectionOrder" />, задающий способы защиты сообщения. Значение по умолчанию — <see cref="F:System.ServiceModel.Security.MessageProtectionOrder.SignBeforeEncrypt" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Если ни одна из частей сообщения не шифруется, элемент сигнатуры также не шифруется, даже если свойству <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.MessageProtectionOrder%2A> присвоено значение <xref:System.ServiceModel.Security.MessageProtectionOrder.SignBeforeEncryptAndEncryptSignature>. Такое поведение характерно даже для привязок, предоставленных системой. Однако код WSDL, созданный WCF, по-прежнему `<sp:EncryptSignature>` содержит утверждение.  
  
 Список членов и их описание см. в разделе <xref:System.ServiceModel.Security.MessageProtectionOrder>.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать это свойство.  
  
 [!code-csharp[c_CustomBinding#5](~/samples/snippets/csharp/VS_Snippets_CFX/c_custombinding/cs/c_custombinding.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметры <see langword="set" /> и <see langword="value" /> не определены.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProtectionTokenParameters">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Security.Tokens.SecurityTokenParameters ProtectionTokenParameters { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Security.Tokens.SecurityTokenParameters ProtectionTokenParameters" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SymmetricSecurityBindingElement.ProtectionTokenParameters" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionTokenParameters As SecurityTokenParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Security::Tokens::SecurityTokenParameters ^ ProtectionTokenParameters { System::ServiceModel::Security::Tokens::SecurityTokenParameters ^ get(); void set(System::ServiceModel::Security::Tokens::SecurityTokenParameters ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionTokenParameters : System.ServiceModel.Security.Tokens.SecurityTokenParameters with get, set" Usage="System.ServiceModel.Channels.SymmetricSecurityBindingElement.ProtectionTokenParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.Tokens.SecurityTokenParameters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает параметры маркера защиты.</summary>
        <value><see cref="T:System.ServiceModel.Security.Tokens.SecurityTokenParameters" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано, как задать это свойство.  
  
 [!code-csharp[c_CustomBinding#6](~/samples/snippets/csharp/VS_Snippets_CFX/c_custombinding/cs/c_custombinding.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequireSignatureConfirmation">
      <MemberSignature Language="C#" Value="public bool RequireSignatureConfirmation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RequireSignatureConfirmation" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SymmetricSecurityBindingElement.RequireSignatureConfirmation" />
      <MemberSignature Language="VB.NET" Value="Public Property RequireSignatureConfirmation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RequireSignatureConfirmation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RequireSignatureConfirmation : bool with get, set" Usage="System.ServiceModel.Channels.SymmetricSecurityBindingElement.RequireSignatureConfirmation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, показывающее, необходимо ли подтверждать сигнатуры сообщений.</summary>
        <value>Значение <see langword="true" />, если сигнатуры сообщений необходимо подтверждать; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство задает, необходимо ли шифровать сигнатура. Если задано значение `true`, необходимо шифровать основную сигнатура, а также любые элементы подтверждения сигнатуры. Если задано значение `false`, шифровать основную сигнатура, а также любые элементы подтверждения сигнатуры не нужно.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetKeyDerivation">
      <MemberSignature Language="C#" Value="public override void SetKeyDerivation (bool requireDerivedKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetKeyDerivation(bool requireDerivedKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SymmetricSecurityBindingElement.SetKeyDerivation(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetKeyDerivation (requireDerivedKeys As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetKeyDerivation(bool requireDerivedKeys);" />
      <MemberSignature Language="F#" Value="override this.SetKeyDerivation : bool -&gt; unit" Usage="symmetricSecurityBindingElement.SetKeyDerivation requireDerivedKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requireDerivedKeys" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="requireDerivedKeys">Значение <see langword="true" /> для указания, что производные ключи необходимы; в противном случае — значение <see langword="false" />.</param>
        <summary>Задает значение, показывающее, необходимы ли производные ключи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Производный ключ создается из существующего ключа и позволяет изменять ключ, используемый в ходе обмена данными. Это осложняет расшифровку обмена данными злоумышленником.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy">
      <MemberSignature Language="C#" Value="void IPolicyExportExtension.ExportPolicy (System.ServiceModel.Description.MetadataExporter exporter, System.ServiceModel.Description.PolicyConversionContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(class System.ServiceModel.Description.MetadataExporter exporter, class System.ServiceModel.Description.PolicyConversionContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SymmetricSecurityBindingElement.System#ServiceModel#Description#IPolicyExportExtension#ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)" />
      <MemberSignature Language="VB.NET" Value="Sub ExportPolicy (exporter As MetadataExporter, context As PolicyConversionContext) Implements IPolicyExportExtension.ExportPolicy" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System::ServiceModel::Description::MetadataExporter ^ exporter, System::ServiceModel::Description::PolicyConversionContext ^ context) = System::ServiceModel::Description::IPolicyExportExtension::ExportPolicy;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exporter" Type="System.ServiceModel.Description.MetadataExporter" />
        <Parameter Name="context" Type="System.ServiceModel.Description.PolicyConversionContext" />
      </Parameters>
      <Docs>
        <param name="exporter">Объект <see cref="T:System.ServiceModel.Description.MetadataExporter" />, который можно использовать для изменения процесса экспорта.</param>
        <param name="context">Объект <see cref="T:System.ServiceModel.Description.PolicyConversionContext" />, который можно использовать для вставки утверждения пользовательской политики.</param>
        <summary>Экспортирует утверждение пользовательской политики о привязках.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод записывает связанные с привязкой инструкции в сведения WSDL, предоставляемые определенным контрактом, и используется Windows Communication Foundation (WCF) для обмена данными с клиентами о существовании этого элемента пользовательской привязки в стеке привязки.  
  
 Этот метод принимает два параметра: <xref:System.ServiceModel.Description.MetadataExporter> и <xref:System.ServiceModel.Description.PolicyConversionContext>. Используйте методы <xref:System.ServiceModel.Description.PolicyConversionContext.GetBindingAssertions%2A>, <xref:System.ServiceModel.Description.PolicyConversionContext.GetMessageBindingAssertions%2A> и <xref:System.ServiceModel.Description.PolicyConversionContext.GetOperationBindingAssertions%2A>, чтобы получить коллекции утверждений политики, экспортированные в различные области. Затем воспользуйтесь этим методом, чтобы добавить в соответствующую коллекцию собственные утверждения политики.  
  
 Свойство <xref:System.ServiceModel.Description.PolicyConversionContext.Contract%2A> предоставляет объект <xref:System.ServiceModel.Description.ContractDescription> для экспортируемой конечной точки. Это позволяет данному методу правильно определить область экспортированных утверждений политики. Например, атрибуты безопасности в коде могут добавлять поведения в объект <xref:System.ServiceModel.Description.ContractDescription>, указывающие, куда должны быть добавлены утверждения политики безопасности.  
  
 После присоединения утверждений пользовательской политики к информации WSDL клиенты могут обнаруживать и импортировать утверждения пользовательской привязки, реализуя интерфейс <xref:System.ServiceModel.Description.IPolicyImportExtension>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SymmetricSecurityBindingElement.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="symmetricSecurityBindingElement.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строку, представляющую данный экземпляр <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" />.</summary>
        <returns>Строка, представляющая данный экземпляр <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные, возвращаемые методом <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.ToString%2A>, включают значения <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.MessageProtectionOrder%2A>, <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.RequireSignatureConfirmation%2A> и <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.ProtectionTokenParameters%2A> текущего экземпляра.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
