<Type Name="UTF32Encoding" FullName="System.Text.UTF32Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cbf31907bc117d2e37c236d41825262b5924cafa" /><Meta Name="ms.sourcegitcommit" Value="81ab118287bf69d10df7204c332592eac20b1b60" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/11/2019" /><Meta Name="ms.locfileid" Value="74998356" /></Metadata><TypeSignature Language="C#" Value="public sealed class UTF32Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit UTF32Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF32Encoding" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class UTF32Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF32Encoding sealed : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UTF32Encoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет кодировку символов Юникода в формате UTF-32.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодирование - это процесс преобразования набора символов Юникода в последовательность байтов. Декодирование — это процесс преобразования последовательности закодированных байтов в набор символов Юникода.  
  
 [Стандарт Юникода](https://go.microsoft.com/fwlink/?linkid=37123) присваивает каждому символу в каждом поддерживаемом скрипте кодовую точку (число). Формат преобразования Юникода (UTF) — это способ кодирования кодовой точки. [Стандарт Unicode](https://go.microsoft.com/fwlink/?linkid=37123) использует следующие утфс:  
  
-   UTF-8, который представляет каждую кодовую точку как последовательность из одного до четырех байтов.  
  
-   UTF-16, представляющий каждую кодовую точку как последовательность из одного до 2 16-разрядных целых чисел.  
  
-   UTF-32, представляющий каждую кодовую точку в виде 32-разрядного целого числа.  
  
 Дополнительные сведения о Утфс и других кодировках, поддерживаемых <xref:System.Text>, см. [в разделе кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).
  
 Класс <xref:System.Text.UTF32Encoding> представляет кодировку UTF-32. Кодировщик может использовать обратный порядок байтов (самый значащий байт) или обратный порядок байтов (минимальный значащий байт). Например, Латинская прописная буква A (кодовая точка U + 0041) сериализуется следующим образом (в шестнадцатеричном формате):  
  
-   Обратный порядок байтов с обратным порядком: 00 00 00 41  
  
-   Прямой порядок байтов: 41 00 00 00  
  
 Обычно более эффективно хранить символы Юникода с помощью собственного порядка байтов. Например, лучше использовать прямой порядок байтов на платформах с прямым порядком байтов, таких как компьютеры Intel. <xref:System.Text.UTF32Encoding> соответствует кодовым страницам Windows 12000 (с прямым порядком байтов) и 12001 (порядковый номер в байтах с обратным порядком байтов). Можно определить "порядок следования байтов" определенной архитектуры, вызвав метод <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType>.  
  
 При необходимости объект <xref:System.Text.UTF32Encoding> предоставляет метку порядка байтов (BOM), которая представляет собой массив байтов, который может быть префиксом последовательности байтов, полученной в результате процесса кодирования. Если преамбула содержит метку порядка байтов (BOM), она помогает декодеру определить порядок байтов и формат преобразования или кодировку UTF для массива байтов.  
  
 Если <xref:System.Text.UTF32Encoding> экземпляр настроен для предоставления спецификации, его можно извлечь, вызвав метод <xref:System.Text.UTF32Encoding.GetPreamble%2A>. в противном случае метод возвращает пустой массив. Обратите внимание, что, даже если объект <xref:System.Text.UTF32Encoding> настроен для поддержки спецификации, необходимо включить СПЕЦИФИКАЦИю в начало закодированного потока байтов. методы кодирования класса <xref:System.Text.UTF32Encoding> не делают это автоматически.  

> [!CAUTION]  
> Чтобы включить обнаружение ошибок и сделать экземпляр класса более безопасным, необходимо создать экземпляр объекта <xref:System.Text.UTF32Encoding>, вызвав конструктор <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> и установив для его аргумента `throwOnInvalidBytes` значение `true`. При обнаружении ошибок метод, который обнаруживает недопустимую последовательность символов или байтов, вызывает исключение <xref:System.ArgumentException>. Без обнаружения ошибок исключение не создается, а недопустимая последовательность обычно игнорируется.  
  
 Можно создать экземпляр объекта <xref:System.Text.UTF32Encoding> несколькими способами, в зависимости от того, нужно ли ему предоставлять метку порядка байтов (BOM), нужно ли использовать обратную или малую кодировку с обратным порядком байтов и следует ли включить обнаружение ошибок. В следующей таблице перечислены конструкторы <xref:System.Text.UTF32Encoding> и свойства <xref:System.Text.Encoding>, которые возвращают объект <xref:System.Text.UnicodeEncoding>.  
  
|Член|Порядок байтов|BOM|Обнаружение ошибок|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType>|С прямым порядком байтов|Да|Нет (замена резервного варианта)|  
|<xref:System.Text.UTF32Encoding.%23ctor?displayProperty=nameWithType>|С прямым порядком байтов|Да|Нет (замена резервного варианта)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Возможность настройки|Возможность настройки|Нет (замена резервного варианта)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Возможность настройки|Возможность настройки|Возможность настройки|  
  
 Метод <xref:System.Text.UTF32Encoding.GetByteCount%2A> определяет, сколько байт приводит к кодированию набора символов Юникода, а метод <xref:System.Text.UTF32Encoding.GetBytes%2A> выполняет фактическую кодировку.  
  
 Аналогичным образом, метод <xref:System.Text.UTF32Encoding.GetCharCount%2A> определяет, сколько символов приводит к декодированию последовательности байтов, а методы <xref:System.Text.UTF32Encoding.GetChars%2A> и <xref:System.Text.UTF32Encoding.GetString%2A> выполняют фактическое декодирование.  
  
 Для кодировщика или декодера, который может сохранять сведения о состоянии при кодировании или декодировании данных, охватывающих несколько блоков (например, строку 1 000 000 символов, закодированную в сегментах 100 000), используйте свойства <xref:System.Text.UTF32Encoding.GetEncoder%2A> и <xref:System.Text.UTF32Encoding.GetDecoder%2A> соответственно.  
  
   
  
## Examples  
 В следующем примере демонстрируется поведение объектов <xref:System.Text.UTF32Encoding> с включенным обнаружением ошибок и без него. Он создает массив байтов, последние четыре байта которого представляют недопустимую суррогатную пару. старший суррогат U + D8FF за пределами U + 01FF, который находится вне диапазона младших суррогатов (0xDC00 до 0xDFFF). Без обнаружения ошибок декодер UTF32 использует резервную замену, чтобы заменить недопустимую суррогатную пару СИМВОЛом замены (U + FFFD).  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 В следующем примере строка символов Юникода кодируется в массив байтов с помощью объекта <xref:System.Text.UTF32Encoding>. Затем массив байтов декодирован в строку, чтобы продемонстрировать отсутствие потери данных.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/snippet.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/snippet.vb#1)]  
  
 В следующем примере используется та же строка, что и в предыдущем, за исключением того, что она записывает закодированные байты в файл и добавляет префикс в байтовый поток с меткой порядка байтов (BOM). Затем он считывает файл двумя способами: в виде текстового файла с помощью объекта <xref:System.IO.StreamReader>; и в виде двоичного файла. Как и следовало бы ожидания, ни одна из строк для чтения не включает СПЕЦИФИКАЦИю.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/bom1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Text.UnicodeEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.UTF32Encoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.UTF32Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает экземпляр, который использует прямой порядок байтов, предоставляет метку порядка байтов Юникода и не создает исключение при обнаружении недопустимой кодировки.  
  
> [!CAUTION]
>  По соображениям безопасности следует включить обнаружение ошибок, вызвав конструктор <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> и установив для аргумента `throwOnInvalidCharacters` значение `true`.  
  
   
  
## Examples  
 В следующем примере извлекается и отображается метка порядка байтов для различных экземпляров <xref:System.Text.UTF32Encoding>.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF32Encoding : bool * bool -&gt; System.Text.UTF32Encoding" Usage="new System.Text.UTF32Encoding (bigEndian, byteOrderMark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">Значение <see langword="true" /> соответствует использованию обратного порядка байтов (самый старший байт располагается на первом месте); значение <see langword="false" /> соответствует использованию прямого порядка байтов (на первом месте находится самый младший байт).</param>
        <param name="byteOrderMark">Значение <see langword="true" /> указывает, что предоставляется метка порядка байтов Юникода; в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.UTF32Encoding" />. Параметры указывают, следует ли использовать обратный порядок байтов и возвращает ли метод <see cref="M:System.Text.UTF32Encoding.GetPreamble" /> метку порядка байтов Юникода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает экземпляр, который не создает исключение при обнаружении недопустимой кодировки.  
  
> [!CAUTION]
>  По соображениям безопасности следует включить обнаружение ошибок, вызвав конструктор <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> и установив для аргумента `throwOnInvalidCharacters` значение `true`.  
  
## Examples  
 В следующем примере извлекается и отображается метка порядка байтов для различных экземпляров <xref:System.Text.UTF32Encoding>.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidCharacters As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF32Encoding : bool * bool * bool -&gt; System.Text.UTF32Encoding" Usage="new System.Text.UTF32Encoding (bigEndian, byteOrderMark, throwOnInvalidCharacters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidCharacters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">Значение <see langword="true" /> соответствует использованию обратного порядка байтов (самый старший байт располагается на первом месте); значение <see langword="false" /> соответствует использованию прямого порядка байтов (на первом месте находится самый младший байт).</param>
        <param name="byteOrderMark">Значение <see langword="true" /> указывает, что предоставляется метка порядка байтов Юникода; в противном случае — значение <see langword="false" />.</param>
        <param name="throwOnInvalidCharacters"><see langword="true" />, чтобы указать, что следует выдавать исключение при обнаружении недопустимой кодировки; в противном случае — <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.UTF32Encoding" />. Параметры указывают, следует ли использовать обратный порядок байтов, должна ли предоставляться метка порядка байтов Юникода и следует ли создавать исключение при обнаружении недопустимой кодировки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `throwOnInvalidCharacters` `true`, метод, который обнаруживает недопустимую последовательность байтов, вызывает <xref:System.ArgumentException?displayProperty=nameWithType>. В противном случае метод не создает исключение, а недопустимая последовательность игнорируется.  
  
> [!CAUTION]
>  По соображениям безопасности следует включить обнаружение ошибок, вызвав конструктор <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> и установив для аргумента `throwOnInvalidCharacters` значение `true`.
  
## Examples  
 В следующем примере демонстрируется поведение <xref:System.Text.UTF32Encoding>, с включенным обнаружением ошибок и без.  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uTF32Encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект <see cref="T:System.Object" />, который требуется сравнить с текущим объектом.</param>
        <summary>Определяет, равен ли заданный объект <see cref="T:System.Object" /> текущему объекту <see cref="T:System.Text.UTF32Encoding" />.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="value" /> является экземпляром класса <see cref="T:System.Text.UTF32Encoding" /> и равен текущему объекту; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Два <xref:System.Text.UTF32Encoding> объектов считаются равными, если выполняются все перечисленные ниже условия.  
  
-   Оба объекта используют одинаковый порядок байтов.  
  
-   Оба объекта предоставляют метку порядка следования байтов или и то, и другое.  
  
-   Оба объекта используют один и тот же откат кодировщика.  
  
-   Оба объекта используют один и тот же откат декодера.  
  
   
  
## Examples  
 В следующем примере создаются объекты <xref:System.Text.UTF32Encoding> с использованием различных значений параметров, а затем они проверяются на равенство.  
  
 [!code-cpp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Подсчитывает количество байтов, полученных при кодировании набора символов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="uTF32Encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Объект <see cref="T:System.String" />, содержащий кодируемый набор символов.</param>
        <summary>Вычисляет количество байтов, полученных при кодировании символов в заданном объекте <see cref="T:System.String" />.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, необходимый <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения результирующих байтов, вызовите метод <xref:System.Text.UTF32Encoding.GetByteCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetByteCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Чтобы обеспечить правильную декодирование закодированных байтов при сохранении их в виде файла или потока, можно добавить префикс потока закодированных байтов в преамбулу. Вставка преамбулы в начало потока байтов (например, в начале последовательности байтов для занесения в файл) является обязанностью разработчика, а число байтов в преамбуле не отражается в значении, возвращаемом методом <xref:System.Text.UTF32Encoding.GetByteCount%2A>.  
  
   
  
## Examples  
 В следующем примере вызывается метод <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> и <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> для вычисления максимального и фактического числа байтов, необходимых для кодирования строки. Он также отображает фактическое число байтов, необходимых для хранения потока байтов с меткой порядка байтов.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и <paramref name="s" /> содержит недопустимую последовательность символов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (см. сведения о <see href="~/docs/standard/base-types/character-encoding.md">кодировке символов в .NET</see>) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF32Encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Указатель на первый кодируемый символ.</param>
        <param name="count">Число кодируемых символов.</param>
        <summary>Вычисляет число байтов, полученных при кодировании набора символов начиная с заданного указателя символа.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, необходимый <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения результирующих байтов, вызовите метод <xref:System.Text.UTF32Encoding.GetByteCount%2A>. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetByteCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Чтобы обеспечить правильную декодирование закодированных байтов при их сохранении в виде файла или потока, можно добавить префикс потока закодированных байтов в преамбулу. Вставка преамбулы в начало потока байтов (например, в начале последовательности байтов для занесения в файл) является обязанностью разработчика, а число байтов в преамбуле не отражается в значении, возвращаемом методом <xref:System.Text.UTF32Encoding.GetByteCount%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="count" /> меньше нуля.  
  
- или - 
Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и <paramref name="chars" /> содержит недопустимую последовательность символов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (см. сведения о <see href="~/docs/standard/base-types/character-encoding.md">кодировке символов в .NET</see>) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="uTF32Encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий набор кодируемых символов.</param>
        <param name="index">Индекс первого кодируемого символа.</param>
        <param name="count">Число кодируемых символов.</param>
        <summary>Вычисляет число байтов, полученных при кодировании набора символов из указанного массива символов.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, необходимый <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения результирующих байтов, вызовите метод <xref:System.Text.UTF32Encoding.GetByteCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetByteCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Чтобы обеспечить правильную декодирование закодированных байтов при их сохранении в виде файла или потока, можно добавить префикс потока закодированных байтов в преамбулу. Вставка преамбулы в начало потока байтов (например, в начале последовательности байтов для занесения в файл) является обязанностью разработчика, а число байтов в преамбуле не отражается в значении, возвращаемом методом <xref:System.Text.UTF32Encoding.GetByteCount%2A>.  
  
   
  
## Examples  
 В следующем примере массив заполняется прописными буквами латинского алфавита и строчными буквами, а также вызывается метод <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> для определения числа байтов, необходимых для кодирования символов нижнего регистра латинского алфавита. Затем эти сведения отображаются вместе с общим числом байтов, необходимых при добавлении метки порядка байтов. Он сравнивает это число со значением, возвращенным методом <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>, который указывает на максимальное число байтов, необходимое для кодирования символов нижнего регистра латиницы. В следующем примере массив заполняется сочетанием греческого и кириллицы-символов и вызывает метод <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, чтобы определить число байтов, необходимое для кодирования символов кириллицы. Затем эти сведения отображаются вместе с общим числом байтов, необходимых при добавлении метки порядка байтов. Он сравнивает это число со значением, возвращенным методом <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>, который указывает максимальное число байтов, необходимое для кодирования символов кириллицы.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
- или - 
 Параметры<paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="chars" />.  
  
- или - 
Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и <paramref name="chars" /> содержит недопустимую последовательность символов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (см. сведения о <see href="~/docs/standard/base-types/character-encoding.md">кодировке символов в .NET</see>) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Кодирует набор символов в последовательность байтов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF32Encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Указатель на первый кодируемый символ.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Указатель на положение, с которого начинается запись результирующей последовательности байтов.</param>
        <param name="byteCount">Максимальное число байтов для записи.</param>
        <summary>Кодирует набор символов, начало которого задается указателем символа, в последовательность байтов, которые сохраняются начиная с заданного указателя байта.</summary>
        <returns>Фактическое число байтов, записанных в местоположение, которое задано параметром <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, необходимый <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения результирующих байтов, вызовите метод <xref:System.Text.UTF32Encoding.GetByteCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetByteCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Данные для преобразования, например данные, считываемые из потока, могут быть доступны только в последовательных блоках. В этом случае, или если объем данных настолько велик, что необходимо разделить на меньшие блоки, приложение использует <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые методом <xref:System.Text.UTF32Encoding.GetDecoder%2A> или <xref:System.Text.UTF32Encoding.GetEncoder%2A> соответственно.  
  
> [!IMPORTANT]
>  Чтобы обеспечить правильную декодирование закодированных байтов при сохранении их в виде файла или потока, можно добавить префикс потока закодированных байтов в преамбулу. При вставке преамбулы в начало потока байтов (например, в начале последовательности байтов для занесения в файл) лежит ответственность за разработчика. Метод <xref:System.Text.UTF32Encoding.GetBytes%2A> не добавляет преамбулу к началу последовательности закодированных байтов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="chars" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="charCount" /> или <paramref name="byteCount" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и <paramref name="chars" /> содержит недопустимую последовательность символов.  
  
- или - 
 <paramref name="byteCount" /> меньше результирующего числа байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (см. сведения о <see href="~/docs/standard/base-types/character-encoding.md">кодировке символов в .NET</see>) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="uTF32Encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий набор кодируемых символов.</param>
        <param name="charIndex">Индекс первого кодируемого символа.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Массив байтов, в который будет помещена результирующая последовательность байтов.</param>
        <param name="byteIndex">Индекс, с которого начинается запись результирующей последовательности байтов.</param>
        <summary>Кодирует набор символов из заданного массива символов в указанный массив байтов.</summary>
        <returns>Фактическое число байтов, записанных в <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, необходимый <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения результирующих байтов, вызовите метод <xref:System.Text.UTF32Encoding.GetByteCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetByteCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Данные для преобразования, например данные, считываемые из потока, могут быть доступны только в последовательных блоках. В этом случае, или если объем данных настолько велик, что необходимо разделить на меньшие блоки, приложение использует <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые методом <xref:System.Text.UTF32Encoding.GetDecoder%2A> или <xref:System.Text.UTF32Encoding.GetEncoder%2A> соответственно.  
  
> [!IMPORTANT]
>  Чтобы обеспечить правильную декодирование закодированных байтов при сохранении их в виде файла или потока, можно добавить префикс потока закодированных байтов в преамбулу. При вставке преамбулы в начало потока байтов (например, в начале последовательности байтов для занесения в файл) лежит ответственность за разработчика. Метод <xref:System.Text.UTF32Encoding.GetBytes%2A> не добавляет преамбулу к началу последовательности закодированных байтов.
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования трех символов из массива символов, затем кодирует символы и отображает результирующие байты.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/VB/GetBytes_CharArr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="chars" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="charIndex" />, <paramref name="charCount" /> или <paramref name="byteIndex" /> меньше нуля.  
  
- или - 
 Параметры<paramref name="charIndex" /> и <paramref name="charCount" /> не указывают допустимый диапазон в <paramref name="chars" />.  
  
- или - 
 Значение параметра <paramref name="byteIndex" /> не является допустимым индексом в <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и <paramref name="chars" /> содержит недопустимую последовательность символов.  
  
- или - 
 Недостаточно емкости <paramref name="bytes" /> от <paramref name="byteIndex" /> до конца массива для размещения полученных байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (см. сведения о <see href="~/docs/standard/base-types/character-encoding.md">кодировке символов в .NET</see>) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="uTF32Encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Объект <see cref="T:System.String" />, содержащий кодируемый набор символов.</param>
        <param name="charIndex">Индекс первого кодируемого символа.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Массив байтов, в который будет помещена результирующая последовательность байтов.</param>
        <param name="byteIndex">Индекс, с которого начинается запись результирующей последовательности байтов.</param>
        <summary>Кодирует набор символов из заданного объекта <see cref="T:System.String" /> в указанный массив байтов.</summary>
        <returns>Фактическое число байтов, записанных в <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, необходимый <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения результирующих байтов, вызовите метод <xref:System.Text.UTF32Encoding.GetByteCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetByteCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Данные для преобразования, например данные, считываемые из потока, могут быть доступны только в последовательных блоках. В этом случае, или если объем данных настолько велик, что необходимо разделить на меньшие блоки, приложение использует <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые методом <xref:System.Text.UTF32Encoding.GetDecoder%2A> или <xref:System.Text.UTF32Encoding.GetEncoder%2A> соответственно.  
  
> [!IMPORTANT]
>  Чтобы обеспечить правильную декодирование закодированных байтов при сохранении их в виде файла или потока, можно добавить префикс потока закодированных байтов в преамбулу. При вставке преамбулы в начало потока байтов (например, в начале последовательности байтов для занесения в файл) лежит ответственность за разработчика. Метод <xref:System.Text.UTF32Encoding.GetBytes%2A> не добавляет преамбулу к началу последовательности закодированных байтов.
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования строки, затем кодируется строка и отображаются полученные байты.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="charIndex" />, <paramref name="charCount" /> или <paramref name="byteIndex" /> меньше нуля.  
  
- или - 
 Параметры<paramref name="charIndex" /> и <paramref name="charCount" /> не указывают допустимый диапазон в <paramref name="chars" />.  
  
- или - 
 Значение параметра <paramref name="byteIndex" /> не является допустимым индексом в <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и <paramref name="s" /> содержит недопустимую последовательность символов.  
  
- или - 
 Недостаточно емкости <paramref name="bytes" /> от <paramref name="byteIndex" /> до конца массива для размещения полученных байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (см. сведения о <see href="~/docs/standard/base-types/character-encoding.md">кодировке символов в .NET</see>) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вычисляет количество символов, полученных при декодировании последовательности байтов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF32Encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Указатель на первый декодируемый байт.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>Вычисляет количество символов, полученных при декодировании последовательности байтов начиная с заданного указателя байта.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding.GetCharCount%2A> вычисляет точный размер массива, необходимый методу <xref:System.Text.UTF32Encoding.GetChars%2A> для хранения результирующих символов. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetCharCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="count" /> меньше нуля.  
  
- или - 
Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и параметр <paramref name="bytes" /> содержит недопустимую последовательность байтов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (см. сведения о <see href="~/docs/standard/base-types/character-encoding.md">кодировке символов в .NET</see>) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="uTF32Encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="index">Индекс первого декодируемого байта.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>Вычисляет количество символов, полученных при декодировании последовательности байтов из заданного массива байтов.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.UTF32Encoding.GetCharCount%2A> вычисляет точный размер массива, необходимый методу <xref:System.Text.UTF32Encoding.GetChars%2A> для хранения результирующих символов. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetCharCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
   
  
## Examples  
 Следующий пример кодирует строку в массив байтов, а затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
- или - 
 Параметры<paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.  
  
- или - 
Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и параметр <paramref name="bytes" /> содержит недопустимую последовательность байтов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (см. сведения о <see href="~/docs/standard/base-types/character-encoding.md">кодировке символов в .NET</see>) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Декодирует последовательность байтов в набор символов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF32Encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Указатель на первый декодируемый байт.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <param name="chars">Указатель на положение, с которого начинается запись результирующего набора символов.</param>
        <param name="charCount">Наибольшее количество символов для записи.</param>
        <summary>Декодирует последовательность байтов, начало которой задается указателем байта, в набор символов, которые сохраняются начиная с заданного указателя символа.</summary>
        <returns>Фактическое число символов, записанных в местоположение, указанное с помощью параметра <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, требуемый <xref:System.Text.UTF32Encoding.GetChars%2A> для хранения полученных символов, вызовите метод <xref:System.Text.UTF32Encoding.GetCharCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetCharCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Если диапазон байтов для декодирования включает метку порядка байтов (BOM), а массив байтов был возвращен методом типа, не поддерживающим СПЕЦИФИКАЦИю, то символ U + ФФФЕ включается в массив символов, возвращаемый этим методом. Его можно удалить, вызвав метод <xref:System.String.TrimStart%2A?displayProperty=nameWithType>.  
  
 Данные для преобразования, например данные, считываемые из потока, могут быть доступны только в последовательных блоках. В этом случае, или если объем данных настолько велик, что необходимо разделить на меньшие блоки, приложение использует <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые методом <xref:System.Text.UTF32Encoding.GetDecoder%2A> или <xref:System.Text.UTF32Encoding.GetEncoder%2A> соответственно.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="byteCount" /> или <paramref name="charCount" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и параметр <paramref name="bytes" /> содержит недопустимую последовательность байтов.  
  
- или - 
 <paramref name="charCount" /> меньше результирующего числа символов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (см. сведения о <see href="~/docs/standard/base-types/character-encoding.md">кодировке символов в .NET</see>) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="uTF32Encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="byteIndex">Индекс первого декодируемого байта.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <param name="chars">Массив символов, в который будет помещен результирующий набор символов.</param>
        <param name="charIndex">Индекс, с которого начинается запись результирующего набора символов.</param>
        <summary>Декодирует последовательность байтов из заданного массива байтов в указанный массив символов.</summary>
        <returns>Фактическое число символов, записанных в <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, требуемый <xref:System.Text.UTF32Encoding.GetChars%2A> для хранения полученных символов, вызовите метод <xref:System.Text.UTF32Encoding.GetCharCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetCharCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Если диапазон байтов для декодирования включает метку порядка байтов (BOM), а массив байтов был возвращен методом типа, не поддерживающим СПЕЦИФИКАЦИю, то символ U + ФФФЕ включается в массив символов, возвращаемый этим методом. Его можно удалить, вызвав метод <xref:System.String.TrimStart%2A?displayProperty=nameWithType>.  
  
 Данные для преобразования, например данные, считываемые из потока, могут быть доступны только в последовательных блоках. В этом случае, или если объем данных настолько велик, что необходимо разделить на меньшие блоки, приложение использует <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые методом <xref:System.Text.UTF32Encoding.GetDecoder%2A> или <xref:System.Text.UTF32Encoding.GetEncoder%2A> соответственно.  
  
   
  
## Examples  
 Следующий пример кодирует строку в массив байтов, а затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="byteIndex" />, <paramref name="byteCount" /> или <paramref name="charIndex" /> меньше нуля.  
  
- или - 
 Параметры<paramref name="byteindex" /> и <paramref name="byteCount" /> не указывают допустимый диапазон в <paramref name="bytes" />.  
  
- или - 
 Значение параметра <paramref name="charIndex" /> не является допустимым индексом в <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и параметр <paramref name="bytes" /> содержит недопустимую последовательность байтов.  
  
- или - 
 Недостаточно емкости <paramref name="chars" /> от <paramref name="charIndex" /> до конца массива для размещения полученных символов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (см. сведения о <see href="~/docs/standard/base-types/character-encoding.md">кодировке символов в .NET</see>) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="uTF32Encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает средство декодирования, преобразующее последовательность байтов в кодировке UTF-32 в последовательность символов Юникода.</summary>
        <returns>Объект <see cref="T:System.Text.Decoder" />, преобразующий последовательность байтов в кодировке UTF-32 в последовательность символов Юникода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> преобразует последовательные блоки байтов в последовательные блоки символов таким же образом, как и метод <xref:System.Text.UTF32Encoding.GetChars%2A>. Однако <xref:System.Text.Decoder> сохраняет сведения о состоянии между вызовами, что позволяет правильно декодировать последовательности байтов, охватывающие блоки. <xref:System.Text.Decoder> также сохраняет конечные байты в конце блоков данных и использует конечные байты в следующей операции декодирования. Таким образом, <xref:System.Text.UTF32Encoding.GetDecoder%2A> и <xref:System.Text.UTF32Encoding.GetEncoder%2A> полезны для передачи по сети и операций с файлами, так как эти операции часто работают с блоками данных, а не с полным потоком данных.  
  
 Если обнаружение ошибок включено, то есть параметру `throwOnInvalidCharacters` конструктора было присвоено значение `true`, обнаружение ошибок также включается в <xref:System.Text.Decoder>, возвращаемом этим методом. Если обнаружение ошибок включено и обнаружена недопустимая последовательность, то состояние декодера не определено и обработка должна быть остановлена.  
  
   
  
## Examples  
 В следующем примере кодировщик и декодер используются для кодирования строки в массив байтов, а затем декодирования байтов в массив символов.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="uTF32Encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает средство кодирования, преобразующее последовательность символов Юникода в последовательность байтов в кодировке UTF-32.</summary>
        <returns>Объект <see cref="T:System.Text.Encoder" />, преобразующий последовательность символов Юникода в последовательность байтов в кодировке UTF-32.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> преобразует последовательные блоки символов в последовательные блоки байтов способом, аналогичным методу <xref:System.Text.UTF32Encoding.GetBytes%2A>. Однако <xref:System.Text.Encoder> сохраняет сведения о состоянии между вызовами, что позволяет правильно кодировать последовательности символов, охватывающие блоки. <xref:System.Text.Encoder> также сохраняет замыкающие символы в конце блоков данных и использует замыкающие символы в следующей операции кодирования. Например, блок данных может заканчиваться несоответствующим старшим символом-заместителем, а соответствующий нижний суррогат может находиться в следующем блоке данных. Таким образом, <xref:System.Text.UTF32Encoding.GetDecoder%2A> и <xref:System.Text.UTF32Encoding.GetEncoder%2A> полезны для передачи по сети и операций с файлами, так как эти операции часто работают с блоками данных, а не с полным потоком данных.  
  
 Если обнаружение ошибок включено, то есть параметру `throwOnInvalidCharacters` конструктора было присвоено значение `true`, обнаружение ошибок также включается в <xref:System.Text.Encoder>, возвращаемом этим методом. Если обнаружение ошибок включено и обнаружена недопустимая последовательность, состояние кодировщика не определено и обработка должна быть остановлена.  
  
   
  
## Examples  
 В следующем примере кодировщик и декодер используются для кодирования строки в массив байтов, а затем декодирования байтов в массив символов.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uTF32Encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код текущего экземпляра.</summary>
        <returns>Хэш-код для текущего объекта <see cref="T:System.Text.UTF32Encoding" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="uTF32Encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Число кодируемых символов.</param>
        <summary>Вычисляет максимальное количество байтов, полученных при кодировании заданного числа символов.</summary>
        <returns>Максимальное количество байтов, полученных при кодировании заданного количества символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, необходимый <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения результирующих байтов, вызовите метод <xref:System.Text.UTF32Encoding.GetByteCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetByteCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> является наихудшим числом, включая наихудший случай для выбранного в данный момент <xref:System.Text.EncoderFallback>. Если резервный вариант выбирается с потенциально большой строкой, <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> может возвращать большие значения.  
  
 В большинстве случаев этот метод возвращает разумные числа для небольших строк. В случае больших строк может потребоваться выбрать использование очень больших буферов и перехват ошибок в редких случаях, когда превышено разумный размер буфера. Вы также можете рассмотреть другой подход и использовать <xref:System.Text.UTF32Encoding.GetByteCount%2A> или <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> не имеет связи с <xref:System.Text.UTF32Encoding.GetChars%2A>. Если вам нужна аналогичная функция для использования с <xref:System.Text.UTF32Encoding.GetChars%2A>, используйте <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` не обязательно является тем же значением, что и `N* GetMaxByteCount(1)`.  
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования строки, затем кодируется строка и отображаются полученные байты.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="charCount" /> меньше нуля.  
  
- или - 
Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (см. сведения о <see href="~/docs/standard/base-types/character-encoding.md">кодировке символов в .NET</see>) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="uTF32Encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Число байтов для декодирования.</param>
        <summary>Вычисляет максимальное количество символов, полученных при декодировании заданного числа байтов.</summary>
        <returns>Максимальное количество символов, полученных при декодировании заданного количества байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, необходимый для хранения результирующих символов <xref:System.Text.UTF32Encoding.GetChars%2A>, вызовите метод <xref:System.Text.UTF32Encoding.GetCharCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetCharCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> является наихудшим числом, включая наихудший случай для выбранного в данный момент <xref:System.Text.DecoderFallback>. Если резервный вариант выбирается с потенциально большой строкой, <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> может возвращать большие значения.  
  
 В большинстве случаев этот метод возвращает разумные числа для небольших строк. В случае больших строк может потребоваться выбрать использование очень больших буферов и перехват ошибок в редких случаях, когда превышено разумный размер буфера. Вы также можете рассмотреть другой подход и использовать <xref:System.Text.UTF32Encoding.GetCharCount%2A> или <xref:System.Text.Decoder.Convert%2A>.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> не имеет связи с <xref:System.Text.UTF32Encoding.GetBytes%2A>. Если вам нужна аналогичная функция для использования с <xref:System.Text.UTF32Encoding.GetBytes%2A>, используйте <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` не обязательно является тем же значением, что и `N* GetMaxCharCount(1)`.  
  
## Examples  
 Следующий пример кодирует строку в массив байтов, а затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="byteCount" /> меньше нуля.  
  
- или - 
Результирующее число байтов больше максимального количества, которое можно вернуть как целочисленное значение.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (см. сведения о <see href="~/docs/standard/base-types/character-encoding.md">кодировке символов в .NET</see>) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="uTF32Encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает метку порядка байтов Юникода в кодировке UTF-32, если объект <see cref="T:System.Text.UTF32Encoding" /> настроен для ее предоставления.</summary>
        <returns>Массив байтов, содержащий метку порядка байтов Юникода, если объект <see cref="T:System.Text.UTF32Encoding" /> настроен для его предоставления. В противном случае этот метод возвращает массив байтов нулевой длины.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Text.UTF32Encoding> может предоставить преамбулу, которая представляет собой массив байтов, которые можно предварять на последовательность байтов, полученную в результате процесса кодирования. Предустановление последовательности закодированных байтов с помощью метки порядка байтов (кодовые точки U + 0000 U + FEFF) помогает декодеру определить порядок байтов и формат преобразования или UTF. Метка порядка байтов Юникода (BOM) сериализуется следующим образом (в шестнадцатеричном формате):  
  
-   Обратный порядок байтов с обратным порядком: 00 00 FE FF  
  
-   Прямой порядок байтов: FF FE 00 00  
  
 Можно создать экземпляр объекта <xref:System.Text.UTF32Encoding>, метод <xref:System.Text.UTF32Encoding.GetPreamble%2A> которого возвращает допустимый комплект, следующим образом.  
  
-   Путем извлечения объекта <xref:System.Text.UTF32Encoding>, возвращенного свойством <xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType>.  
  
-   Путем вызова конструктора <xref:System.Text.UTF32Encoding.%23ctor> без параметров для создания экземпляра объекта <xref:System.Text.UTF32Encoding>.  
  
-   Путем предоставления `true` в качестве значения аргумента `byteOrderMark` для конструкторов <xref:System.Text.UTF32Encoding.%23ctor%2A> и <xref:System.Text.UTF32Encoding.%23ctor%2A>.  
  
 Рекомендуется использовать СПЕЦИФИКАЦИю, так как она обеспечивает почти определенную идентификацию кодировки для файлов, которые в противном случае теряют ссылку на <xref:System.Text.UTF32Encoding> объект, например, непомеченные или неправильно помеченные веб-данные или случайные текстовые файлы, которые хранятся в случае отсутствия международных проблем или других данных. Часто проблемы пользователей могут быть устранены, если данные постоянно и правильно помечены тегами.  
  
 Для стандартов, предоставляющих тип кодировки, BOM является несколько избыточным. Однако его можно использовать, чтобы помочь серверу отправить правильный заголовок кодировки. Кроме того, его можно использовать в качестве резервного, если кодировка в противном случае будет потеряна.  
  
 Существует ряд недостатков использования спецификации. Например, знание того, как ограничить поля базы данных, использующие СПЕЦИФИКАЦИю, может оказаться затруднительным. Объединение файлов может быть проблемой, например, при слиянии файлов таким образом, что ненужный символ может оказаться в середине данных. Несмотря на множество недостатков, настоятельно рекомендуется использовать СПЕЦИФИКАЦИю.  
  
 Дополнительные сведения о порядке байтов и метке порядка байтов см. в стандарте Юникода на [домашней странице Юникода](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!IMPORTANT]
>  Чтобы обеспечить правильную декодирование закодированных байтов, следует добавить в байты префикс в формате преамбулы. Обратите внимание, что метод <xref:System.Text.UTF32Encoding.GetBytes%2A> не добавляет СПЕЦИФИКАЦИю к последовательности закодированных байтов; предоставление спецификации в начале соответствующего потока байтов является обязанностью разработчика.  
  
## Examples  
 В следующем примере кода извлекается и отображается метка порядка байтов для различных экземпляров <xref:System.Text.UTF32Encoding>.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 В следующем примере создаются два объекта <xref:System.Text.UTF32Encoding>, первая из которых не предоставляет СПЕЦИФИКАЦИю, а вторая —. Затем он вызывает метод <xref:System.Text.UTF32Encoding.GetPreamble%2A> для записи спецификации в файл перед записью строки в кодировке UTF-32. Как видно из выходных данных примера, файл, сохраняющий байты из второго кодировщика, содержит четыре дополнительных байта, которые первый.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/getpreamble1.vb#2)]  
  
 Можно также сравнить файлы с помощью команды `fc` в окне консоли или просмотреть файлы в текстовом редакторе, содержащем шестнадцатеричный режим представления. Обратите внимание, что при открытии файла в редакторе, поддерживающем UTF-32, спецификация не отображается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="uTF32Encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="index">Индекс первого декодируемого байта.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>Декодирует диапазон байтов из массива байтов в строку.</summary>
        <returns>Строка, содержащая результаты декодирования заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Если диапазон байтов для декодирования включает метку порядка байтов (BOM), а массив байтов был возвращен методом типа, не поддерживающего спецификацию спецификации, символ U + ФФФЕ включается в массив символов, возвращаемый этим методом. Его можно удалить, вызвав метод <xref:System.String.TrimStart%2A?displayProperty=nameWithType>.  
  
 Данные для преобразования, например данные, считываемые из потока, могут быть доступны только в последовательных блоках. В этом случае, или если объем данных настолько велик, что необходимо разделить на меньшие блоки, приложение должно использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые методом <xref:System.Text.UTF32Encoding.GetDecoder%2A> или методом <xref:System.Text.UTF32Encoding.GetEncoder%2A> соответственно.  
  
   
  
## Examples  
 В следующем примере строка кодируется в два массива байтов: один в порядке с прямым порядком байтов, а другой — в порядке с обратным порядком байтов. Затем байты декодированы обратно в строку.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/getstring.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString.vb#1)]  
  
 В следующем примере массив инициализируется путем вызова метода <xref:System.Text.UTF32Encoding.GetByteCount%2A>, чтобы точно определить, сколько байтов требуется для закодированной строки, а затем добавить размер метки порядка байтов (BOM). Затем в примере вызывается метод <xref:System.Text.UTF32Encoding.GetPreamble%2A> для сохранения спецификации в массив перед вызовом метода <xref:System.Text.UTF32Encoding.GetBytes%2A> для сохранения закодированных байтов в массиве. Затем в примере вызывается метод <xref:System.Text.UTF32Encoding.GetString%2A> для декодирования строки.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/GetString1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString1.vb#2)]  
  
 Обратите внимание, что в этом случае декодированная строка отличается от исходной строки, так как она начинается с 32-разрядной метки порядка байтов U + ФФФЕ U + 0000. Это означает, что две строки будут считаться неравными, и что если строка выводится, то спецификация будет отображаться как символ замены "?".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
- или - 
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Обнаружение ошибок включено, и параметр <paramref name="bytes" /> содержит недопустимую последовательность байтов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье <see href="~/docs/standard/base-types/character-encoding.md">Кодировка символов в .NET</see>).
  
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public override ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.UTF32Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.UTF32Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает метку порядка байтов Юникода в кодировке UTF-32, если объект настроен для ее предоставления.</summary>
        <value>Диапазон байтов, содержащий метку порядка байтов Юникода, если этот объект настроен для предоставления такого объекта; в противном случае — диапазон по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Text.UTF32Encoding> может предоставить преамбулу, которая представляет собой диапазон байтов, которые можно использовать в качестве префикса к последовательности байтов, полученной в результате процесса кодирования. Предустановление последовательности закодированных байтов с помощью метки порядка байтов (кодовые точки `U+0000` `U+FEFF`) помогает декодеру определить порядок байтов и формат преобразования или кодировку UTF. Метка порядка байтов Юникода (BOM) сериализуется следующим образом (в шестнадцатеричном формате):  
  
-   Порядок байт с обратным порядком байтов: `00 00 FE FF`  
  
-   Прямой порядок байтов: `FF FE 00 00`  
  
 Можно создать экземпляр объекта <xref:System.Text.UTF32Encoding>, свойство <xref:System.Text.UTF32Encoding.Preamble> которого является допустимой СПЕЦИФИКАЦИей, следующим образом.  
  
-   Путем извлечения объекта <xref:System.Text.UTF32Encoding>, возвращенного свойством <xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType>.  
  
-   Путем вызова конструктора <xref:System.Text.UTF32Encoding.%23ctor> без параметров для создания экземпляра объекта <xref:System.Text.UTF32Encoding>.  
  
-   Путем предоставления `true` в качестве значения аргумента `byteOrderMark` для конструкторов <xref:System.Text.UTF32Encoding.%23ctor%2A> и <xref:System.Text.UTF32Encoding.%23ctor%2A>.  
  
 Рекомендуется использовать СПЕЦИФИКАЦИю, так как она обеспечивает почти определенную идентификацию кодировки для файлов, которые в противном случае потеряют ссылку на объект <xref:System.Text.UTF32Encoding>, например, непомеченные или неправильно помеченные веб-данные или случайные текстовые файлы, хранящиеся в случае, если у бизнеса нет международных проблем или других данных. Часто проблемы пользователей могут быть устранены, если данные постоянно и правильно помечены тегами.  
  
 Для стандартов, предоставляющих тип кодировки, BOM является несколько избыточным. Однако его можно использовать, чтобы помочь серверу отправить правильный заголовок кодировки. Кроме того, его можно использовать в качестве резервного, если кодировка в противном случае будет потеряна.  
  
 Существует ряд недостатков использования спецификации. Например, знание того, как ограничить поля базы данных, использующие СПЕЦИФИКАЦИю, может оказаться затруднительным. Объединение файлов может быть проблемой, например, при слиянии файлов таким образом, что ненужный символ может оказаться в середине данных. Несмотря на множество недостатков, настоятельно рекомендуется использовать СПЕЦИФИКАЦИю.  
  
 Дополнительные сведения о порядке байтов и метке порядка байтов см. в стандарте Юникода на [домашней странице Юникода](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!IMPORTANT]
>  Чтобы обеспечить правильную декодирование закодированных байтов, следует добавить в байты префикс в формате преамбулы. Обратите внимание, что метод <xref:System.Text.UTF32Encoding.GetBytes%2A> не добавляет СПЕЦИФИКАЦИю к последовательности закодированных байтов; предоставление спецификации в начале соответствующего потока байтов является обязанностью разработчика.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
