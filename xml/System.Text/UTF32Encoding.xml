<Type Name="UTF32Encoding" FullName="System.Text.UTF32Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6090dc5b6caa657ce22059939ed5f0dbd147aaf6" /><Meta Name="ms.sourcegitcommit" Value="385ff23cc00fe9aa1c93460c62603b45c2041d0b" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="11/22/2019" /><Meta Name="ms.locfileid" Value="74388039" /></Metadata><TypeSignature Language="C#" Value="public sealed class UTF32Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit UTF32Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF32Encoding" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class UTF32Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF32Encoding sealed : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UTF32Encoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a UTF-32 encoding of Unicode characters.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодирование - это процесс преобразования набора символов Юникода в последовательность байтов. Декодирование — это процесс преобразования последовательности закодированных байтов в набор символов Юникода.  
  
 [Стандарт Юникода](https://go.microsoft.com/fwlink/?linkid=37123) присваивает каждому символу в каждом поддерживаемом скрипте кодовую точку (число). Формат преобразования Юникода (UTF) — это способ кодирования кодовой точки. [Стандарт Unicode](https://go.microsoft.com/fwlink/?linkid=37123) использует следующие утфс:  
  
-   UTF-8, который представляет каждую кодовую точку как последовательность из одного до четырех байтов.  
  
-   UTF-16, представляющий каждую кодовую точку как последовательность из одного до 2 16-разрядных целых чисел.  
  
-   UTF-32, представляющий каждую кодовую точку в виде 32-разрядного целого числа.  
  
 Дополнительные сведения о Утфс и других кодировках, поддерживаемых <xref:System.Text>, см. [в разделе кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).
  
 Класс <xref:System.Text.UTF32Encoding> представляет кодировку UTF-32. Кодировщик может использовать обратный порядок байтов (самый значащий байт) или обратный порядок байтов (минимальный значащий байт). Например, Латинская прописная буква A (кодовая точка U + 0041) сериализуется следующим образом (в шестнадцатеричном формате):  
  
-   Обратный порядок байтов с обратным порядком: 00 00 00 41  
  
-   Прямой порядок байтов: 41 00 00 00  
  
 Обычно более эффективно хранить символы Юникода с помощью собственного порядка байтов. Например, лучше использовать прямой порядок байтов на платформах с прямым порядком байтов, таких как компьютеры Intel. <xref:System.Text.UTF32Encoding> соответствует кодовым страницам Windows 12000 (с прямым порядком байтов) и 12001 (порядковый номер в байтах с обратным порядком байтов). Можно определить "порядок следования байтов" определенной архитектуры, вызвав метод <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType>.  
  
 При необходимости объект <xref:System.Text.UTF32Encoding> предоставляет метку порядка байтов (BOM), которая представляет собой массив байтов, который может быть префиксом последовательности байтов, полученной в результате процесса кодирования. Если преамбула содержит метку порядка байтов (BOM), она помогает декодеру определить порядок байтов и формат преобразования или кодировку UTF для массива байтов.  
  
 Если <xref:System.Text.UTF32Encoding> экземпляр настроен для предоставления спецификации, его можно извлечь, вызвав метод <xref:System.Text.UTF32Encoding.GetPreamble%2A>. в противном случае метод возвращает пустой массив. Обратите внимание, что, даже если объект <xref:System.Text.UTF32Encoding> настроен для поддержки спецификации, необходимо включить СПЕЦИФИКАЦИю в начало закодированного потока байтов. методы кодирования класса <xref:System.Text.UTF32Encoding> не делают это автоматически.  

> [!CAUTION]  
> Чтобы включить обнаружение ошибок и сделать экземпляр класса более безопасным, необходимо создать экземпляр объекта <xref:System.Text.UTF32Encoding>, вызвав конструктор <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> и установив для его аргумента `throwOnInvalidBytes` значение `true`. При обнаружении ошибок метод, который обнаруживает недопустимую последовательность символов или байтов, вызывает исключение <xref:System.ArgumentException>. Без обнаружения ошибок исключение не создается, а недопустимая последовательность обычно игнорируется.  
  
 Можно создать экземпляр объекта <xref:System.Text.UTF32Encoding> несколькими способами, в зависимости от того, нужно ли ему предоставлять метку порядка байтов (BOM), нужно ли использовать обратную или малую кодировку с обратным порядком байтов и следует ли включить обнаружение ошибок. В следующей таблице перечислены конструкторы <xref:System.Text.UTF32Encoding> и свойства <xref:System.Text.Encoding>, которые возвращают объект <xref:System.Text.UnicodeEncoding>.  
  
|Член|Порядок байтов|BOM|Обнаружение ошибок|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType>|С прямым порядком байтов|Да|Нет (замена резервного варианта)|  
|<xref:System.Text.UTF32Encoding.%23ctor?displayProperty=nameWithType>|С прямым порядком байтов|Да|Нет (замена резервного варианта)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Возможность настройки|Возможность настройки|Нет (замена резервного варианта)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Возможность настройки|Возможность настройки|Возможность настройки|  
  
 Метод <xref:System.Text.UTF32Encoding.GetByteCount%2A> определяет, сколько байт приводит к кодированию набора символов Юникода, а метод <xref:System.Text.UTF32Encoding.GetBytes%2A> выполняет фактическую кодировку.  
  
 Аналогичным образом, метод <xref:System.Text.UTF32Encoding.GetCharCount%2A> определяет, сколько символов приводит к декодированию последовательности байтов, а методы <xref:System.Text.UTF32Encoding.GetChars%2A> и <xref:System.Text.UTF32Encoding.GetString%2A> выполняют фактическое декодирование.  
  
 Для кодировщика или декодера, который может сохранять сведения о состоянии при кодировании или декодировании данных, охватывающих несколько блоков (например, строку 1 000 000 символов, закодированную в сегментах 100 000), используйте свойства <xref:System.Text.UTF32Encoding.GetEncoder%2A> и <xref:System.Text.UTF32Encoding.GetDecoder%2A> соответственно.  
  
   
  
## Examples  
 В следующем примере демонстрируется поведение объектов <xref:System.Text.UTF32Encoding> с включенным обнаружением ошибок и без него. Он создает массив байтов, последние четыре байта которого представляют недопустимую суррогатную пару. старший суррогат U + D8FF за пределами U + 01FF, который находится вне диапазона младших суррогатов (0xDC00 до 0xDFFF). Без обнаружения ошибок декодер UTF32 использует резервную замену, чтобы заменить недопустимую суррогатную пару СИМВОЛом замены (U + FFFD).  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 В следующем примере строка символов Юникода кодируется в массив байтов с помощью объекта <xref:System.Text.UTF32Encoding>. Затем массив байтов декодирован в строку, чтобы продемонстрировать отсутствие потери данных.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/snippet.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/snippet.vb#1)]  
  
 В следующем примере используется та же строка, что и в предыдущем, за исключением того, что она записывает закодированные байты в файл и добавляет префикс в байтовый поток с меткой порядка байтов (BOM). Затем он считывает файл двумя способами: в виде текстового файла с помощью объекта <xref:System.IO.StreamReader>; и в виде двоичного файла. Как и следовало бы ожидания, ни одна из строк для чтения не включает СПЕЦИФИКАЦИю.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/bom1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Text.UnicodeEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.UTF32Encoding" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.UTF32Encoding" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает экземпляр, который использует прямой порядок байтов, предоставляет метку порядка байтов Юникода и не создает исключение при обнаружении недопустимой кодировки.  
  
> [!CAUTION]
>  По соображениям безопасности следует включить обнаружение ошибок, вызвав конструктор <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> и установив для аргумента `throwOnInvalidCharacters` значение `true`.  
  
   
  
## Examples  
 В следующем примере извлекается и отображается метка порядка байтов для различных экземпляров <xref:System.Text.UTF32Encoding>.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF32Encoding : bool * bool -&gt; System.Text.UTF32Encoding" Usage="new System.Text.UTF32Encoding (bigEndian, byteOrderMark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian"><see langword="true" /> to use the big endian byte order (most significant byte first), or <see langword="false" /> to use the little endian byte order (least significant byte first).</param>
        <param name="byteOrderMark"><see langword="true" /> to specify that a Unicode byte order mark is provided; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.UTF32Encoding" /> class. Parameters specify whether to use the big endian byte order and whether the <see cref="M:System.Text.UTF32Encoding.GetPreamble" /> method returns a Unicode byte order mark.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает экземпляр, который не создает исключение при обнаружении недопустимой кодировки.  
  
> [!CAUTION]
>  По соображениям безопасности следует включить обнаружение ошибок, вызвав конструктор <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> и установив для аргумента `throwOnInvalidCharacters` значение `true`.  
  
## Examples  
 В следующем примере извлекается и отображается метка порядка байтов для различных экземпляров <xref:System.Text.UTF32Encoding>.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidCharacters As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF32Encoding : bool * bool * bool -&gt; System.Text.UTF32Encoding" Usage="new System.Text.UTF32Encoding (bigEndian, byteOrderMark, throwOnInvalidCharacters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidCharacters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian"><see langword="true" /> to use the big endian byte order (most significant byte first), or <see langword="false" /> to use the little endian byte order (least significant byte first).</param>
        <param name="byteOrderMark"><see langword="true" /> to specify that a Unicode byte order mark is provided; otherwise, <see langword="false" />.</param>
        <param name="throwOnInvalidCharacters"><see langword="true" /> to specify that an exception should be thrown when an invalid encoding is detected; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.UTF32Encoding" /> class. Parameters specify whether to use the big endian byte order, whether to provide a Unicode byte order mark, and whether to throw an exception when an invalid encoding is detected.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `throwOnInvalidCharacters` `true`, метод, который обнаруживает недопустимую последовательность байтов, вызывает <xref:System.ArgumentException?displayProperty=nameWithType>. В противном случае метод не создает исключение, а недопустимая последовательность игнорируется.  
  
> [!CAUTION]
>  По соображениям безопасности следует включить обнаружение ошибок, вызвав конструктор <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> и установив для аргумента `throwOnInvalidCharacters` значение `true`.
  
## Examples  
 В следующем примере демонстрируется поведение <xref:System.Text.UTF32Encoding>, с включенным обнаружением ошибок и без.  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uTF32Encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The <see cref="T:System.Object" /> to compare with the current object.</param>
        <summary>Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Text.UTF32Encoding" /> object.</summary>
        <returns><see langword="true" /> if <paramref name="value" /> is an instance of <see cref="T:System.Text.UTF32Encoding" /> and is equal to the current object; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Два <xref:System.Text.UTF32Encoding> объектов считаются равными, если выполняются все перечисленные ниже условия.  
  
-   Оба объекта используют одинаковый порядок байтов.  
  
-   Оба объекта предоставляют метку порядка следования байтов или и то, и другое.  
  
-   Оба объекта используют один и тот же откат кодировщика.  
  
-   Оба объекта используют один и тот же откат декодера.  
  
   
  
## Examples  
 В следующем примере создаются объекты <xref:System.Text.UTF32Encoding> с использованием различных значений параметров, а затем они проверяются на равенство.  
  
 [!code-cpp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calculates the number of bytes produced by encoding a set of characters.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="uTF32Encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The <see cref="T:System.String" /> containing the set of characters to encode.</param>
        <summary>Calculates the number of bytes produced by encoding the characters in the specified <see cref="T:System.String" />.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, необходимый <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения результирующих байтов, вызовите метод <xref:System.Text.UTF32Encoding.GetByteCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetByteCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Чтобы обеспечить правильную декодирование закодированных байтов при сохранении их в виде файла или потока, можно добавить префикс потока закодированных байтов в преамбулу. Вставка преамбулы в начало потока байтов (например, в начале последовательности байтов для занесения в файл) является обязанностью разработчика, а число байтов в преамбуле не отражается в значении, возвращаемом методом <xref:System.Text.UTF32Encoding.GetByteCount%2A>.  
  
   
  
## Examples  
 В следующем примере вызывается метод <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> и <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> для вычисления максимального и фактического числа байтов, необходимых для кодирования строки. Он также отображает фактическое число байтов, необходимых для хранения потока байтов с меткой порядка байтов.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="s" /> contains an invalid sequence of characters.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF32Encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A pointer to the first character to encode.</param>
        <param name="count">The number of characters to encode.</param>
        <summary>Calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, необходимый <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения результирующих байтов, вызовите метод <xref:System.Text.UTF32Encoding.GetByteCount%2A>. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetByteCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Чтобы обеспечить правильную декодирование закодированных байтов при их сохранении в виде файла или потока, можно добавить префикс потока закодированных байтов в преамбулу. Вставка преамбулы в начало потока байтов (например, в начале последовательности байтов для занесения в файл) является обязанностью разработчика, а число байтов в преамбуле не отражается в значении, возвращаемом методом <xref:System.Text.UTF32Encoding.GetByteCount%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> is less than zero.  
  
-or- 
The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="uTF32Encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the set of characters to encode.</param>
        <param name="index">The index of the first character to encode.</param>
        <param name="count">The number of characters to encode.</param>
        <summary>Calculates the number of bytes produced by encoding a set of characters from the specified character array.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, необходимый <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения результирующих байтов, вызовите метод <xref:System.Text.UTF32Encoding.GetByteCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetByteCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Чтобы обеспечить правильную декодирование закодированных байтов при их сохранении в виде файла или потока, можно добавить префикс потока закодированных байтов в преамбулу. Вставка преамбулы в начало потока байтов (например, в начале последовательности байтов для занесения в файл) является обязанностью разработчика, а число байтов в преамбуле не отражается в значении, возвращаемом методом <xref:System.Text.UTF32Encoding.GetByteCount%2A>.  
  
   
  
## Examples  
 В следующем примере массив заполняется прописными буквами латинского алфавита и строчными буквами, а также вызывается метод <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> для определения числа байтов, необходимых для кодирования символов нижнего регистра латинского алфавита. Затем эти сведения отображаются вместе с общим числом байтов, необходимых при добавлении метки порядка байтов. Он сравнивает это число со значением, возвращенным методом <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>, который указывает на максимальное число байтов, необходимое для кодирования символов нижнего регистра латиницы. В следующем примере массив заполняется сочетанием греческого и кириллицы-символов и вызывает метод <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, чтобы определить число байтов, необходимое для кодирования символов кириллицы. Затем эти сведения отображаются вместе с общим числом байтов, необходимых при добавлении метки порядка байтов. Он сравнивает это число со значением, возвращенным методом <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>, который указывает максимальное число байтов, необходимое для кодирования символов кириллицы.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> or <paramref name="count" /> is less than zero.  
  
-or- 
 <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.  
  
-or- 
The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Encodes a set of characters into a sequence of bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF32Encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A pointer to the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">A pointer to the location at which to start writing the resulting sequence of bytes.</param>
        <param name="byteCount">The maximum number of bytes to write.</param>
        <summary>Encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</summary>
        <returns>The actual number of bytes written at the location indicated by the <paramref name="bytes" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, необходимый <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения результирующих байтов, вызовите метод <xref:System.Text.UTF32Encoding.GetByteCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetByteCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Данные для преобразования, например данные, считываемые из потока, могут быть доступны только в последовательных блоках. В этом случае, или если объем данных настолько велик, что необходимо разделить на меньшие блоки, приложение использует <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые методом <xref:System.Text.UTF32Encoding.GetDecoder%2A> или <xref:System.Text.UTF32Encoding.GetEncoder%2A> соответственно.  
  
> [!IMPORTANT]
>  Чтобы обеспечить правильную декодирование закодированных байтов при сохранении их в виде файла или потока, можно добавить префикс потока закодированных байтов в преамбулу. При вставке преамбулы в начало потока байтов (например, в начале последовательности байтов для занесения в файл) лежит ответственность за разработчика. Метод <xref:System.Text.UTF32Encoding.GetBytes%2A> не добавляет преамбулу к началу последовательности закодированных байтов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> is <see langword="null" />.  
  
-or- 
 <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> or <paramref name="byteCount" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.  
  
-or- 
 <paramref name="byteCount" /> is less than the resulting number of bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="uTF32Encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the set of characters to encode.</param>
        <param name="charIndex">The index of the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">The byte array to contain the resulting sequence of bytes.</param>
        <param name="byteIndex">The index at which to start writing the resulting sequence of bytes.</param>
        <summary>Encodes a set of characters from the specified character array into the specified byte array.</summary>
        <returns>The actual number of bytes written into <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, необходимый <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения результирующих байтов, вызовите метод <xref:System.Text.UTF32Encoding.GetByteCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetByteCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Данные для преобразования, например данные, считываемые из потока, могут быть доступны только в последовательных блоках. В этом случае, или если объем данных настолько велик, что необходимо разделить на меньшие блоки, приложение использует <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые методом <xref:System.Text.UTF32Encoding.GetDecoder%2A> или <xref:System.Text.UTF32Encoding.GetEncoder%2A> соответственно.  
  
> [!IMPORTANT]
>  Чтобы обеспечить правильную декодирование закодированных байтов при сохранении их в виде файла или потока, можно добавить префикс потока закодированных байтов в преамбулу. При вставке преамбулы в начало потока байтов (например, в начале последовательности байтов для занесения в файл) лежит ответственность за разработчика. Метод <xref:System.Text.UTF32Encoding.GetBytes%2A> не добавляет преамбулу к началу последовательности закодированных байтов.
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования трех символов из массива символов, затем кодирует символы и отображает результирующие байты.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/VB/GetBytes_CharArr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> is <see langword="null" />.  
  
-or- 
 <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.  
  
-or- 
 <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.  
  
-or- 
 <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.  
  
-or- 
 <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="uTF32Encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">The <see cref="T:System.String" /> containing the set of characters to encode.</param>
        <param name="charIndex">The index of the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">The byte array to contain the resulting sequence of bytes.</param>
        <param name="byteIndex">The index at which to start writing the resulting sequence of bytes.</param>
        <summary>Encodes a set of characters from the specified <see cref="T:System.String" /> into the specified byte array.</summary>
        <returns>The actual number of bytes written into <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, необходимый <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения результирующих байтов, вызовите метод <xref:System.Text.UTF32Encoding.GetByteCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetByteCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Данные для преобразования, например данные, считываемые из потока, могут быть доступны только в последовательных блоках. В этом случае, или если объем данных настолько велик, что необходимо разделить на меньшие блоки, приложение использует <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые методом <xref:System.Text.UTF32Encoding.GetDecoder%2A> или <xref:System.Text.UTF32Encoding.GetEncoder%2A> соответственно.  
  
> [!IMPORTANT]
>  Чтобы обеспечить правильную декодирование закодированных байтов при сохранении их в виде файла или потока, можно добавить префикс потока закодированных байтов в преамбулу. При вставке преамбулы в начало потока байтов (например, в начале последовательности байтов для занесения в файл) лежит ответственность за разработчика. Метод <xref:System.Text.UTF32Encoding.GetBytes%2A> не добавляет преамбулу к началу последовательности закодированных байтов.
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования строки, затем кодируется строка и отображаются полученные байты.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> is <see langword="null" />.  
  
-or- 
 <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.  
  
-or- 
 <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.  
  
-or- 
 <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="s" /> contains an invalid sequence of characters.  
  
-or- 
 <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calculates the number of characters produced by decoding a sequence of bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF32Encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A pointer to the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>Calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</summary>
        <returns>The number of characters produced by decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding.GetCharCount%2A> вычисляет точный размер массива, необходимый методу <xref:System.Text.UTF32Encoding.GetChars%2A> для хранения результирующих символов. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetCharCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> is less than zero.  
  
-or- 
The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="uTF32Encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="index">The index of the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</summary>
        <returns>The number of characters produced by decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.UTF32Encoding.GetCharCount%2A> вычисляет точный размер массива, необходимый методу <xref:System.Text.UTF32Encoding.GetChars%2A> для хранения результирующих символов. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetCharCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
   
  
## Examples  
 Следующий пример кодирует строку в массив байтов, а затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> or <paramref name="count" /> is less than zero.  
  
-or- 
 <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.  
  
-or- 
The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Decodes a sequence of bytes into a set of characters.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF32Encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A pointer to the first byte to decode.</param>
        <param name="byteCount">The number of bytes to decode.</param>
        <param name="chars">A pointer to the location at which to start writing the resulting set of characters.</param>
        <param name="charCount">The maximum number of characters to write.</param>
        <summary>Decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</summary>
        <returns>The actual number of characters written at the location indicated by <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, требуемый <xref:System.Text.UTF32Encoding.GetChars%2A> для хранения полученных символов, вызовите метод <xref:System.Text.UTF32Encoding.GetCharCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetCharCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Если диапазон байтов для декодирования включает метку порядка байтов (BOM), а массив байтов был возвращен методом типа, не поддерживающим СПЕЦИФИКАЦИю, то символ U + ФФФЕ включается в массив символов, возвращаемый этим методом. Его можно удалить, вызвав метод <xref:System.String.TrimStart%2A?displayProperty=nameWithType>.  
  
 Данные для преобразования, например данные, считываемые из потока, могут быть доступны только в последовательных блоках. В этом случае, или если объем данных настолько велик, что необходимо разделить на меньшие блоки, приложение использует <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые методом <xref:System.Text.UTF32Encoding.GetDecoder%2A> или <xref:System.Text.UTF32Encoding.GetEncoder%2A> соответственно.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> is <see langword="null" />.  
  
-or- 
 <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> or <paramref name="charCount" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.  
  
-or- 
 <paramref name="charCount" /> is less than the resulting number of characters.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="uTF32Encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="byteIndex">The index of the first byte to decode.</param>
        <param name="byteCount">The number of bytes to decode.</param>
        <param name="chars">The character array to contain the resulting set of characters.</param>
        <param name="charIndex">The index at which to start writing the resulting set of characters.</param>
        <summary>Decodes a sequence of bytes from the specified byte array into the specified character array.</summary>
        <returns>The actual number of characters written into <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, требуемый <xref:System.Text.UTF32Encoding.GetChars%2A> для хранения полученных символов, вызовите метод <xref:System.Text.UTF32Encoding.GetCharCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetCharCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Если диапазон байтов для декодирования включает метку порядка байтов (BOM), а массив байтов был возвращен методом типа, не поддерживающим СПЕЦИФИКАЦИю, то символ U + ФФФЕ включается в массив символов, возвращаемый этим методом. Его можно удалить, вызвав метод <xref:System.String.TrimStart%2A?displayProperty=nameWithType>.  
  
 Данные для преобразования, например данные, считываемые из потока, могут быть доступны только в последовательных блоках. В этом случае, или если объем данных настолько велик, что необходимо разделить на меньшие блоки, приложение использует <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые методом <xref:System.Text.UTF32Encoding.GetDecoder%2A> или <xref:System.Text.UTF32Encoding.GetEncoder%2A> соответственно.  
  
   
  
## Examples  
 Следующий пример кодирует строку в массив байтов, а затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> is <see langword="null" />.  
  
-or- 
 <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" /> or <paramref name="byteCount" /> or <paramref name="charIndex" /> is less than zero.  
  
-or- 
 <paramref name="byteindex" /> and <paramref name="byteCount" /> do not denote a valid range in <paramref name="bytes" />.  
  
-or- 
 <paramref name="charIndex" /> is not a valid index in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.  
  
-or- 
 <paramref name="chars" /> does not have enough capacity from <paramref name="charIndex" /> to the end of the array to accommodate the resulting characters.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="uTF32Encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtains a decoder that converts a UTF-32 encoded sequence of bytes into a sequence of Unicode characters.</summary>
        <returns>A <see cref="T:System.Text.Decoder" /> that converts a UTF-32 encoded sequence of bytes into a sequence of Unicode characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> преобразует последовательные блоки байтов в последовательные блоки символов таким же образом, как и метод <xref:System.Text.UTF32Encoding.GetChars%2A>. Однако <xref:System.Text.Decoder> сохраняет сведения о состоянии между вызовами, что позволяет правильно декодировать последовательности байтов, охватывающие блоки. <xref:System.Text.Decoder> также сохраняет конечные байты в конце блоков данных и использует конечные байты в следующей операции декодирования. Таким образом, <xref:System.Text.UTF32Encoding.GetDecoder%2A> и <xref:System.Text.UTF32Encoding.GetEncoder%2A> полезны для передачи по сети и операций с файлами, так как эти операции часто работают с блоками данных, а не с полным потоком данных.  
  
 Если обнаружение ошибок включено, то есть параметру `throwOnInvalidCharacters` конструктора было присвоено значение `true`, обнаружение ошибок также включается в <xref:System.Text.Decoder>, возвращаемом этим методом. Если обнаружение ошибок включено и обнаружена недопустимая последовательность, то состояние декодера не определено и обработка должна быть остановлена.  
  
   
  
## Examples  
 В следующем примере кодировщик и декодер используются для кодирования строки в массив байтов, а затем декодирования байтов в массив символов.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="uTF32Encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtains an encoder that converts a sequence of Unicode characters into a UTF-32 encoded sequence of bytes.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> that converts a sequence of Unicode characters into a UTF-32 encoded sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> преобразует последовательные блоки символов в последовательные блоки байтов способом, аналогичным методу <xref:System.Text.UTF32Encoding.GetBytes%2A>. Однако <xref:System.Text.Encoder> сохраняет сведения о состоянии между вызовами, что позволяет правильно кодировать последовательности символов, охватывающие блоки. <xref:System.Text.Encoder> также сохраняет замыкающие символы в конце блоков данных и использует замыкающие символы в следующей операции кодирования. Например, блок данных может заканчиваться несоответствующим старшим символом-заместителем, а соответствующий нижний суррогат может находиться в следующем блоке данных. Таким образом, <xref:System.Text.UTF32Encoding.GetDecoder%2A> и <xref:System.Text.UTF32Encoding.GetEncoder%2A> полезны для передачи по сети и операций с файлами, так как эти операции часто работают с блоками данных, а не с полным потоком данных.  
  
 Если обнаружение ошибок включено, то есть параметру `throwOnInvalidCharacters` конструктора было присвоено значение `true`, обнаружение ошибок также включается в <xref:System.Text.Encoder>, возвращаемом этим методом. Если обнаружение ошибок включено и обнаружена недопустимая последовательность, состояние кодировщика не определено и обработка должна быть остановлена.  
  
   
  
## Examples  
 В следующем примере кодировщик и декодер используются для кодирования строки в массив байтов, а затем декодирования байтов в массив символов.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uTF32Encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for the current instance.</summary>
        <returns>The hash code for the current <see cref="T:System.Text.UTF32Encoding" /> object.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="uTF32Encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">The number of characters to encode.</param>
        <summary>Calculates the maximum number of bytes produced by encoding the specified number of characters.</summary>
        <returns>The maximum number of bytes produced by encoding the specified number of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, необходимый <xref:System.Text.UTF32Encoding.GetBytes%2A> для хранения результирующих байтов, вызовите метод <xref:System.Text.UTF32Encoding.GetByteCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetByteCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> является наихудшим числом, включая наихудший случай для выбранного в данный момент <xref:System.Text.EncoderFallback>. Если резервный вариант выбирается с потенциально большой строкой, <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> может возвращать большие значения.  
  
 В большинстве случаев этот метод возвращает разумные числа для небольших строк. В случае больших строк может потребоваться выбрать использование очень больших буферов и перехват ошибок в редких случаях, когда превышено разумный размер буфера. Вы также можете рассмотреть другой подход и использовать <xref:System.Text.UTF32Encoding.GetByteCount%2A> или <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> не имеет связи с <xref:System.Text.UTF32Encoding.GetChars%2A>. Если вам нужна аналогичная функция для использования с <xref:System.Text.UTF32Encoding.GetChars%2A>, используйте <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` не обязательно является тем же значением, что и `N* GetMaxByteCount(1)`.  
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования строки, затем кодируется строка и отображаются полученные байты.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> is less than zero.  
  
-or- 
The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="uTF32Encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">The number of bytes to decode.</param>
        <summary>Calculates the maximum number of characters produced by decoding the specified number of bytes.</summary>
        <returns>The maximum number of characters produced by decoding the specified number of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, необходимый для хранения результирующих символов <xref:System.Text.UTF32Encoding.GetChars%2A>, вызовите метод <xref:System.Text.UTF32Encoding.GetCharCount%2A>. Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>. Метод <xref:System.Text.UTF32Encoding.GetCharCount%2A> обычно выделяет меньше памяти, а метод <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> является наихудшим числом, включая наихудший случай для выбранного в данный момент <xref:System.Text.DecoderFallback>. Если резервный вариант выбирается с потенциально большой строкой, <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> может возвращать большие значения.  
  
 В большинстве случаев этот метод возвращает разумные числа для небольших строк. В случае больших строк может потребоваться выбрать использование очень больших буферов и перехват ошибок в редких случаях, когда превышено разумный размер буфера. Вы также можете рассмотреть другой подход и использовать <xref:System.Text.UTF32Encoding.GetCharCount%2A> или <xref:System.Text.Decoder.Convert%2A>.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> не имеет связи с <xref:System.Text.UTF32Encoding.GetBytes%2A>. Если вам нужна аналогичная функция для использования с <xref:System.Text.UTF32Encoding.GetBytes%2A>, используйте <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` не обязательно является тем же значением, что и `N* GetMaxCharCount(1)`.  
  
## Examples  
 Следующий пример кодирует строку в массив байтов, а затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> is less than zero.  
  
-or- 
The resulting number of bytes is greater than the maximum number that can be returned as an integer.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) 
-and- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="uTF32Encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a Unicode byte order mark encoded in UTF-32 format, if the <see cref="T:System.Text.UTF32Encoding" /> object is configured to supply one.</summary>
        <returns>A byte array containing the Unicode byte order mark, if the <see cref="T:System.Text.UTF32Encoding" /> object is configured to supply one. Otherwise, this method returns a zero-length byte array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Text.UTF32Encoding> может предоставить преамбулу, которая представляет собой массив байтов, которые можно предварять на последовательность байтов, полученную в результате процесса кодирования. Предустановление последовательности закодированных байтов с помощью метки порядка байтов (кодовые точки U + 0000 U + FEFF) помогает декодеру определить порядок байтов и формат преобразования или UTF. Метка порядка байтов Юникода (BOM) сериализуется следующим образом (в шестнадцатеричном формате):  
  
-   Обратный порядок байтов с обратным порядком: 00 00 FE FF  
  
-   Прямой порядок байтов: FF FE 00 00  
  
 Можно создать экземпляр объекта <xref:System.Text.UTF32Encoding>, метод <xref:System.Text.UTF32Encoding.GetPreamble%2A> которого возвращает допустимый комплект, следующим образом.  
  
-   Путем извлечения объекта <xref:System.Text.UTF32Encoding>, возвращенного свойством <xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType>.  
  
-   Путем вызова конструктора <xref:System.Text.UTF32Encoding.%23ctor> без параметров для создания экземпляра объекта <xref:System.Text.UTF32Encoding>.  
  
-   Путем предоставления `true` в качестве значения аргумента `byteOrderMark` для конструкторов <xref:System.Text.UTF32Encoding.%23ctor%2A> и <xref:System.Text.UTF32Encoding.%23ctor%2A>.  
  
 Рекомендуется использовать СПЕЦИФИКАЦИю, так как она обеспечивает почти определенную идентификацию кодировки для файлов, которые в противном случае теряют ссылку на <xref:System.Text.UTF32Encoding> объект, например, непомеченные или неправильно помеченные веб-данные или случайные текстовые файлы, которые хранятся в случае отсутствия международных проблем или других данных. Часто проблемы пользователей могут быть устранены, если данные постоянно и правильно помечены тегами.  
  
 Для стандартов, предоставляющих тип кодировки, BOM является несколько избыточным. Однако его можно использовать, чтобы помочь серверу отправить правильный заголовок кодировки. Кроме того, его можно использовать в качестве резервного, если кодировка в противном случае будет потеряна.  
  
 Существует ряд недостатков использования спецификации. Например, знание того, как ограничить поля базы данных, использующие СПЕЦИФИКАЦИю, может оказаться затруднительным. Объединение файлов может быть проблемой, например, при слиянии файлов таким образом, что ненужный символ может оказаться в середине данных. Несмотря на множество недостатков, настоятельно рекомендуется использовать СПЕЦИФИКАЦИю.  
  
 Дополнительные сведения о порядке байтов и метке порядка байтов см. в стандарте Юникода на [домашней странице Юникода](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!IMPORTANT]
>  Чтобы обеспечить правильную декодирование закодированных байтов, следует добавить в байты префикс в формате преамбулы. Обратите внимание, что метод <xref:System.Text.UTF32Encoding.GetBytes%2A> не добавляет СПЕЦИФИКАЦИю к последовательности закодированных байтов; предоставление спецификации в начале соответствующего потока байтов является обязанностью разработчика.  
  
## Examples  
 В следующем примере кода извлекается и отображается метка порядка байтов для различных экземпляров <xref:System.Text.UTF32Encoding>.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 В следующем примере создаются два объекта <xref:System.Text.UTF32Encoding>, первая из которых не предоставляет СПЕЦИФИКАЦИю, а вторая —. Затем он вызывает метод <xref:System.Text.UTF32Encoding.GetPreamble%2A> для записи спецификации в файл перед записью строки в кодировке UTF-32. Как видно из выходных данных примера, файл, сохраняющий байты из второго кодировщика, содержит четыре дополнительных байта, которые первый.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/getpreamble1.vb#2)]  
  
 Можно также сравнить файлы с помощью команды `fc` в окне консоли или просмотреть файлы в текстовом редакторе, содержащем шестнадцатеричный режим представления. Обратите внимание, что при открытии файла в редакторе, поддерживающем UTF-32, спецификация не отображается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="uTF32Encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="index">The index of the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>Decodes a range of bytes from a byte array into a string.</summary>
        <returns>A string that contains the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При обнаружении ошибок недействительная последовательность приводит к тому, что этот метод вызывает <xref:System.ArgumentException>. Без обнаружения ошибок недопустимые последовательности пропускаются, и исключение не создается.  
  
 Если диапазон байтов для декодирования включает метку порядка байтов (BOM), а массив байтов был возвращен методом типа, не поддерживающего спецификацию спецификации, символ U + ФФФЕ включается в массив символов, возвращаемый этим методом. Его можно удалить, вызвав метод <xref:System.String.TrimStart%2A?displayProperty=nameWithType>.  
  
 Данные для преобразования, например данные, считываемые из потока, могут быть доступны только в последовательных блоках. В этом случае, или если объем данных настолько велик, что необходимо разделить на меньшие блоки, приложение должно использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые методом <xref:System.Text.UTF32Encoding.GetDecoder%2A> или методом <xref:System.Text.UTF32Encoding.GetEncoder%2A> соответственно.  
  
   
  
## Examples  
 В следующем примере строка кодируется в два массива байтов: один в порядке с прямым порядком байтов, а другой — в порядке с обратным порядком байтов. Затем байты декодированы обратно в строку.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/getstring.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString.vb#1)]  
  
 В следующем примере массив инициализируется путем вызова метода <xref:System.Text.UTF32Encoding.GetByteCount%2A>, чтобы точно определить, сколько байтов требуется для закодированной строки, а затем добавить размер метки порядка байтов (BOM). Затем в примере вызывается метод <xref:System.Text.UTF32Encoding.GetPreamble%2A> для сохранения спецификации в массив перед вызовом метода <xref:System.Text.UTF32Encoding.GetBytes%2A> для сохранения закодированных байтов в массиве. Затем в примере вызывается метод <xref:System.Text.UTF32Encoding.GetString%2A> для декодирования строки.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/GetString1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString1.vb#2)]  
  
 Обратите внимание, что в этом случае декодированная строка отличается от исходной строки, так как она начинается с 32-разрядной метки порядка байтов U + ФФФЕ U + 0000. Это означает, что две строки будут считаться неравными, и что если строка выводится, то спецификация будет отображаться как символ замены "?".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> or <paramref name="count" /> is less than zero.  
  
-or- 
 <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for a complete explanation) 
-and- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public override ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.UTF32Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.UTF32Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a Unicode byte order mark encoded in UTF-32 format, if this object is configured to supply one.</summary>
        <value>Диапазон байтов, содержащий метку порядка байтов Юникода, если этот объект настроен для предоставления такого объекта; в противном случае — диапазон по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Text.UTF32Encoding> может предоставить преамбулу, которая представляет собой диапазон байтов, которые можно использовать в качестве префикса к последовательности байтов, полученной в результате процесса кодирования. Предустановление последовательности закодированных байтов с помощью метки порядка байтов (кодовые точки `U+0000` `U+FEFF`) помогает декодеру определить порядок байтов и формат преобразования или кодировку UTF. Метка порядка байтов Юникода (BOM) сериализуется следующим образом (в шестнадцатеричном формате):  
  
-   Порядок байт с обратным порядком байтов: `00 00 FE FF`  
  
-   Прямой порядок байтов: `FF FE 00 00`  
  
 Можно создать экземпляр объекта <xref:System.Text.UTF32Encoding>, свойство <xref:System.Text.UTF32Encoding.Preamble> которого является допустимой СПЕЦИФИКАЦИей, следующим образом.  
  
-   Путем извлечения объекта <xref:System.Text.UTF32Encoding>, возвращенного свойством <xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType>.  
  
-   Путем вызова конструктора <xref:System.Text.UTF32Encoding.%23ctor> без параметров для создания экземпляра объекта <xref:System.Text.UTF32Encoding>.  
  
-   Путем предоставления `true` в качестве значения аргумента `byteOrderMark` для конструкторов <xref:System.Text.UTF32Encoding.%23ctor%2A> и <xref:System.Text.UTF32Encoding.%23ctor%2A>.  
  
 Рекомендуется использовать СПЕЦИФИКАЦИю, так как она обеспечивает почти определенную идентификацию кодировки для файлов, которые в противном случае потеряют ссылку на объект <xref:System.Text.UTF32Encoding>, например, непомеченные или неправильно помеченные веб-данные или случайные текстовые файлы, хранящиеся в случае, если у бизнеса нет международных проблем или других данных. Часто проблемы пользователей могут быть устранены, если данные постоянно и правильно помечены тегами.  
  
 Для стандартов, предоставляющих тип кодировки, BOM является несколько избыточным. Однако его можно использовать, чтобы помочь серверу отправить правильный заголовок кодировки. Кроме того, его можно использовать в качестве резервного, если кодировка в противном случае будет потеряна.  
  
 Существует ряд недостатков использования спецификации. Например, знание того, как ограничить поля базы данных, использующие СПЕЦИФИКАЦИю, может оказаться затруднительным. Объединение файлов может быть проблемой, например, при слиянии файлов таким образом, что ненужный символ может оказаться в середине данных. Несмотря на множество недостатков, настоятельно рекомендуется использовать СПЕЦИФИКАЦИю.  
  
 Дополнительные сведения о порядке байтов и метке порядка байтов см. в стандарте Юникода на [домашней странице Юникода](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!IMPORTANT]
>  Чтобы обеспечить правильную декодирование закодированных байтов, следует добавить в байты префикс в формате преамбулы. Обратите внимание, что метод <xref:System.Text.UTF32Encoding.GetBytes%2A> не добавляет СПЕЦИФИКАЦИю к последовательности закодированных байтов; предоставление спецификации в начале соответствующего потока байтов является обязанностью разработчика.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
