<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2483338405b9410628ee67ae0439634a8f3ff1b5" /><Meta Name="ms.sourcegitcommit" Value="00194cfb0d5c4f2d3f620c0b561d50d547ce2f7f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/06/2019" /><Meta Name="ms.locfileid" Value="70389638" /></Metadata><TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет кодировку символов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодирование - это процесс преобразования набора символов Юникода в последовательность байтов. В отличие от декодирования — это процесс преобразования последовательности закодированных байтов в набор символов Юникода. Сведения о форматах преобразования Юникода (утфс) и других кодировках <xref:System.Text.Encoding>, поддерживаемых, см. [в разделе кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).  
  
 Обратите <xref:System.Text.Encoding> внимание, что предназначено для работы с символами Юникода вместо произвольных двоичных данных, таких как байтовые массивы. Если необходимо закодировать произвольные двоичные данные в текст, следует использовать протокол, такой как uuencode, который реализуется такими методами <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>, как.  
  
 .Net предоставляет следующие реализации <xref:System.Text.Encoding> класса для поддержки текущих кодировок Юникода и других кодировок:  
  
-   <xref:System.Text.ASCIIEncoding>кодирует символы Юникода как однострочные 7-разрядные символы ASCII. Эта кодировка поддерживает только символьные значения в диапазоне от U + 0000 до U + 007F. Кодовая страница 20127. Также доступно через <xref:System.Text.Encoding.ASCII%2A> свойство.  
  
-   <xref:System.Text.UTF7Encoding>кодирует символы Юникода в кодировке UTF-7. Эта кодировка поддерживает все значения символов Юникода. Кодовая страница 65000. Также доступно через <xref:System.Text.Encoding.UTF7%2A> свойство.  
  
-   <xref:System.Text.UTF8Encoding>кодирует символы Юникода в кодировке UTF-8. Эта кодировка поддерживает все значения символов Юникода. Кодовая страница 65001. Также доступно через <xref:System.Text.Encoding.UTF8%2A> свойство.  
  
-   <xref:System.Text.UnicodeEncoding>кодирует символы Юникода в кодировке UTF-16. Поддерживаются как прямой, так и обратный порядок байтов. Также доступно через <xref:System.Text.Encoding.Unicode%2A> свойство <xref:System.Text.Encoding.BigEndianUnicode%2A> и.  
  
-   <xref:System.Text.UTF32Encoding>кодирует символы Юникода в кодировке UTF-32. Поддерживаются как с прямым порядком байтов (кодовая страница 12000), так и с обратным порядком байтов (кодовая страница 12001). Также доступно через <xref:System.Text.Encoding.UTF32%2A> свойство.  
  
 Класс <xref:System.Text.Encoding> в основном предназначен для преобразования между различными кодировками и Юникодом. Часто один из производных классов Юникода является правильным выбором для вашего приложения.  
  
 Используйте метод для получения других кодировок и <xref:System.Text.Encoding.GetEncodings%2A> вызовите метод, чтобы получить список всех кодировок. <xref:System.Text.Encoding.GetEncoding%2A>  
  
 В следующей таблице перечислены кодировки, поддерживаемые .NET Framework и .NET Core. В нем перечислены номера кодовой страницы каждой кодировки и значения свойств кодировки <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> и <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> . Флажок в столбцах поддержка **.NET Framework** и **.NET Core** указывает на то, что кодовая страница изначально поддерживается этой реализацией .NET, независимо от базовой платформы. Для .NET Framework доступность других кодировок, перечисленных в таблице, зависит от операционной системы. Для .NET Core другие кодировки доступны с помощью <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> класса или путем наследования <xref:System.Text.EncodingProvider?displayProperty=nameWithType> от класса.  

> [!NOTE]
> Кодовые страницы <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> , свойства которых соответствуют международным стандартам, не обязательно полностью соответствуют этому стандарту. 

|Кодовая страница|name|Отображаемое имя|Поддержка .NET Framework| Поддержка .NET Core | 
|---------|----|------------|----------------------|-------------------|    
|37|IBM037|IBM EBCDIC (США-Канада)|||  
|437|IBM437|OEM США|||  
|500|IBM500|IBM EBCDIC (Международная)|||  
|708|ASMO-708|Арабский (ASMO 708)|||  
|720|DOS-720|Арабский (DOS)|||  
|737|ibm737|Греческий (DOS)|||  
|775|ibm775|Балтийская (DOS)|||  
|850|ibm850|Западная Европа (DOS)|||  
|852|ibm852|Центральноевропейская (DOS)|||  
|855|IBM855|OEM кириллица|||  
|857|ibm857|Турецкий (DOS)|||  
|858|IBM00858|OEM многоязычная латиница I|||  
|860|IBM860|Португальский (DOS)|||  
|861|ibm861|Исландский (DOS)|||  
|862|DOS-862|Иврит (DOS)|||  
|863|IBM863|Французская Канада (DOS)|||  
|864|IBM864|Арабский (864)|||  
|865|IBM865|Скандинавский (DOS)|||  
|866|cp866|Кириллица (DOS)|||  
|869|ibm869|Греческий, современный (DOS)|||  
|870|IBM870|IBM EBCDIC (многоязычная латиница-2)|||  
|874|Windows — 874|Тайский (Windows)|||  
|875|cp875|IBM EBCDIC (греческая современная)|||  
|932|shift_jis|Японская (Shift-JIS)|||  
|936|GB2312|Китайская упрощенная (GB2312)|✓||  
|949|ks_c_5601-1987|Корейский|||  
|950|традиционн|Китайская традиционная (Big5)|||  
|1026|IBM1026|IBM EBCDIC (турецкая латиница-5)|||  
|1047|IBM01047|IBM Latin-1|||  
|1140|IBM01140|IBM EBCDIC (США-Канада-евро)|||  
|1141|IBM01141|IBM EBCDIC (Германия-евро)|||  
|1142|IBM01142|IBM EBCDIC (Дания-Норвегия-евро)|||  
|1143|IBM01143|IBM EBCDIC (Финляндия-Швеция-евро)|||  
|1144|IBM01144|IBM EBCDIC (Италия-Европа)|||  
|1145|IBM01145|IBM EBCDIC (Испания-евро)|||  
|1146|IBM01146|IBM EBCDIC (Великобритания-Европа)|||  
|1147|IBM01147|IBM EBCDIC (Франция-евро)|||  
|1148|IBM01148|IBM EBCDIC (Международная Европа)|||  
|1149|IBM01149|IBM EBCDIC (Исландский-евро)|||  
|1200|UTF-16|Юникод|✓|✓|  
|1201|уникодефффе|Юникод (с обратным порядком байтов)|✓|✓|  
|1250|Windows — 1250|Центральная Европа (Windows)|||  
|1251|Windows — 1251|Кириллица (Windows)|||  
|1252|Windows — 1252|Западная Европа (Windows)|✓||  
|1253|Windows — 1253|Греческий (Windows)|||  
|1254|Windows — 1254|Турецкий (Windows)|||  
|1255|Windows — 1255|Иврит (Windows)|||  
|1256|Windows — 1256|Арабский (Windows)|||  
|1257|Windows — 1257|Балтийская (Windows)|||  
|1258|Windows — 1258|Вьетнамский (Windows)|||  
|1361|Johab|Корейский (Johab)|||  
|10000|«|Западная Европа (Mac)|||  
|10001|x-Mac-японская|Японская (Mac)|||  
|10002|x-Mac-чинесетрад|Китайская традиционная (Mac)|||  
|10003|x-Mac-Корейский|Корейский (Mac)|✓||  
|10004|x-Mac-Арабская|Арабский (Mac)|||  
|10005|x-Mac-иврит|Иврит (Mac)|||  
|10006|x-Mac-греческая|Греческий (Mac)|||  
|10007|x-Mac-кириллица|Кириллица (Mac)|||  
|10008|x-Mac-чинесесимп|Китайская, упрощенное письмо (Mac)|✓||  
|10010|x-Mac-румынская|Румынский (Mac)|||  
|10017|x-Mac-украинский|Украинский (Mac)|||  
|10021|x-Mac-тайский|Тайский (Mac)|||  
|10029|x-Mac-CE|Центральноевропейская (Mac)|||  
|10079|x-Mac-Исландский|Исландский (Mac)|||  
|10081|x-Mac-Турецкая|Турецкий (Mac)|||  
|10082|x-Mac-Хорватский|Хорватский (Mac)|||  
|12000|UTF-32|Юникод (UTF-32)|✓|✓|  
|12001|utf-32BE|Юникод (UTF-32 с обратным порядком байтов)|✓|✓|  
|20000|x-китайский — CNS|Китайская традиционная (CNS)|||  
|20001|x — cp20001|TCA Тайваньская|||  
|20002|x-китайский — Eten|Китайская традиционная (Eten)|||  
|20003|x — cp20003|IBM5550 Тайвань|||  
|20004|x — cp20004|Телетекст, Тайвань|||  
|20005|x — cp20005|Wang Тайвань|||  
|20105|x-IA5|Западная Европа (IA5)|||  
|20106|x-IA5-немецкий|Немецкий (IA5)|||  
|20107|x-IA5-шведский|Шведский (IA5)|||  
|20108|x-IA5-Норвежский|Норвежский (IA5)|||  
|20127|US-ASCII|US-ASCII|✓|✓|  
|20261|x — cp20261|Т. 61|||  
|20269|x — cp20269|ISO-6937|||  
|20273|IBM273|IBM EBCDIC (Германия)|||  
|20277|IBM277|IBM EBCDIC (Дания-Норвегия)|||  
|20278|IBM278|IBM EBCDIC (Финляндия-Швеция)|||  
|20280|IBM280|IBM EBCDIC (Италия)|||  
|20284|IBM284|IBM EBCDIC (Испания)|||  
|20285|IBM285|IBM EBCDIC (ВЕЛИКОБРИТАНИЯ)|||  
|20290|IBM290|IBM EBCDIC (японская катакана)|||  
|20297|IBM297|IBM EBCDIC (Франция)|||  
|20420|IBM420|IBM EBCDIC (Арабская)|||  
|20423|IBM423|IBM EBCDIC (греческая)|||  
|20424|IBM424|IBM EBCDIC (иврит)|||  
|20833|x-EBCDIC-Кореанекстендед|IBM EBCDIC (Корейская расширенная)|||  
|20838|IBM — тайский|IBM EBCDIC (тайский)|||  
|20866|koi8-r|Кириллица (KOI8-R)|||  
|20871|IBM871|IBM EBCDIC (исландский)|||  
|20880|IBM880|IBM EBCDIC (кириллица русская)|||  
|20905|IBM905|IBM EBCDIC (Турецкая)|||  
|20924|IBM00924|IBM Latin-1|||  
|20932|EUC-JP|Японская (JIS 0208-1990 и 0212-1990)|||  
|20936|x — cp20936|Китайская упрощенная (GB2312-80)|✓||  
|20949|x — cp20949|Корейский Wansung|✓||  
|21025|cp1025|IBM EBCDIC (кириллица, Сербский — Болгарский)|||  
|21866|koi8-u|Кириллица (KOI8-U)|||  
|28591|ISO-8859-1|Западная Европа (ISO)|✓|✓|  
|28592|ISO-8859-2|Центральноевропейская (ISO)|||  
|28593|ISO-8859-3|Латиница 3 (ISO)|||  
|28594|ISO-8859-4|Балтийская (ISO)|||  
|28595|ISO-8859-5|Кириллица (ISO)|||  
|28596|ISO-8859-6|Арабский (ISO)|||  
|28597|ISO-8859-7|Греческий (ISO)|||  
|28598|ISO-8859-8|Иврит (ISO-Visual)|✓||  
|28599|ISO-8859-9|Турецкий (ISO)|||  
|28603|ISO-8859-13|Эстонский (ISO)|||  
|28605|ISO-8859-15|Латиница 9 (ISO)|||  
|29001|x — Европа|Европа|||  
|38598|ISO-8859-8-i|Иврит (ISO-Logical)|✓||  
|50220|ISO-2022-JP|Японская (JIS)|✓||  
|50221|csISO2022JP|Японская (JIS, разрешить 1 байт Кана)|✓||  
|50222|ISO-2022-JP|Японская (JIS — разрешить 1 байт Кана-SO/SI)|✓||  
|50225|ISO-2022-kr|Корейский (ISO)|✓||  
|50227|x-cp50227|Китайская, упрощенное письмо (ISO-2022)|✓||  
|51932|EUC-JP|Японский (EUC)|✓||  
|51936|EUC-CN|Китайская упрощенная (EUC)|✓||  
|51949|euc-kr|Корейский (EUC)|✓||  
|52936|Гц-GB-2312|Китайская, упрощенное письмо (Гц)|✓||  
|54936|GB18030|Китайская, упрощенное письмо (GB18030)|✓||  
|57002|x-ISCII-de|ISCII — деванагари|✓||  
|57003|x-ISCII-составлять|ISCII Бенгальская|✓||  
|57004|x-ISCII-TA|ISCII — тамильский|✓||  
|57005|x-ISCII-TE|ISCII — телугу|✓||  
|57006|x-ISCII-AS|ISCII — Ассамская|✓||  
|57007|x-ISCII-или|ISCII — Ория|✓||  
|57008|x-ISCII-ка|ISCII — каннада|✓||  
|57009|x-ISCII-MA|ISCII — малаялам|✓||  
|57010|x-ISCII-gu|ISCII — гуджарати|✓||  
|57011|x-ISCII-PA|Панджаби ISCII|✓||  
|65000|UTF-7|Юникод (UTF-7)|✓|✓|  
|65001|UTF-8|Юникод (UTF-8)|✓|✓|  
  
 В следующем примере вызываются <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> методы <xref:System.Text.Encoding.GetEncoding%28System.String%29> и для получения кодировки кодовой страницы греческого языка (Windows). Он сравнивает <xref:System.Text.Encoding> объекты, возвращаемые вызовами методов, чтобы показать, что они равны, а затем Maps отображает кодовую точку Юникода и соответствующее значение кодовой страницы для каждого символа в греческом алфавите.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или, <xref:System.Text.Encoder> предоставленный <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метод, соответственно, производного класса.  
  
 Кодировщики UTF-16 и UTF-32 могут использовать обратный порядок байтов (самый значащий байт) или обратный порядок байтов (минимальный значащий байт). Например, Латинская прописная буква A (U + 0041) сериализуется следующим образом (в шестнадцатеричном формате):  
  
-   Порядковый номер UTF-16 с обратным порядком байтов: 00 41  
  
-   UTF-16 с прямым порядком байтов: 41 00  
  
-   UTF-32. обратный порядок байтов: 00 00 00 41  
  
-   UTF-32 с прямым порядком байтов: 41 00 00 00  
  
 Обычно более эффективно хранить символы Юникода с помощью собственного порядка байтов. Например, лучше использовать прямой порядок байтов на платформах с прямым порядком байтов, таких как компьютеры Intel.  
  
 <xref:System.Text.Encoding.GetPreamble%2A> Метод извлекает массив байтов, включающий метку порядка байтов (BOM). Если этот массив байтов имеет префикс в закодированном потоке, он позволяет декодеру указывать используемый формат кодирования.  
  
 Дополнительные сведения о порядке байтов и метке порядка байтов см. в стандарте Юникода на [домашней странице Юникода](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Обратите внимание, что классы кодирования позволяют ошибкам:  
  
-   Автоматическое изменение символа на символ "?".  
  
-   Используйте символ "лучше подходит".  
  
-   Измените поведение приложения с помощью <xref:System.Text.EncoderFallback> классов и <xref:System.Text.DecoderFallback> с помощью символа замены Юникода U + FFFD.  
  
 При любой ошибке потока данных следует вызывать исключение. Приложение либо использует флаг "throwOnError", если применимо, либо использует <xref:System.Text.EncoderExceptionFallback> классы <xref:System.Text.DecoderExceptionFallback> и. Резервные стратегии наилучшего соответствия часто не рекомендуются, так как это может привести к потере или путанице данных и медленнее, чем простые замены символов. Для кодировок ANSI наилучшее поведение используется по умолчанию.  
  
   
  
## Examples  
 В следующем примере строка из одной кодировки преобразуется в другую.  
  
> [!NOTE]
>  Массив Byte [] является единственным типом в этом примере, который содержит закодированные данные. Типы char и String .NET представляют собой Юникод, поэтому <xref:System.Text.Encoding.GetChars%2A> вызов декодирует данные обратно в Юникод.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.Encoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор переопределяется производными классами.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage">Идентификатор кодовой страницы предпочтительной кодировки.  
  
 -или-  
  
 0, если требуется использовать кодировку по умолчанию.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.Encoding" />, соответствующий заданной кодовой странице.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор переопределяется производными классами.  
  
 Вызовы этого конструктора из производного класса создают <xref:System.Text.Encoding> объект, который использует стратегию наилучшего соответствия для операций кодирования и декодирования. <xref:System.Text.Encoding.DecoderFallback%2A> Свойства и <xref:System.Text.Encoding.EncoderFallback%2A> доступны только для чтения и не могут быть изменены. Чтобы управлять резервной стратегией для класса, производного от <xref:System.Text.Encoding>, <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> вызовите конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="codePage" /> меньше нуля.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage">Идентификатор кодовой страницы кодировки.</param>
        <param name="encoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда символ не может быть закодирован с использованием текущей кодировки.</param>
        <param name="decoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда последовательность байтов не может быть декодирована с использованием текущей кодировки.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.Encoding" />, соответствующий заданной кодовой странице, с использованием указанных стратегий резервирования кодировщика и декодера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор имеет `protected`следующий приоритет: производные классы переопределяют его.  
  
 Этот конструктор вызывается из производного класса для управления стратегиями резервного кодирования и декодирования. Конструкторы <xref:System.Text.Encoding> классов создают объекты кодирования, предназначенные только для чтения, которые не допускают установку кодировщика или дерезерва декодера после создания объекта.  
  
 Если значение `decoderFallback` или равно null, в качестве соответствующей резервной стратегии используется стратегия наилучшего соответствия. `encoderFallback`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="codePage" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для набора символов ASCII (7-разрядных).</summary>
        <value>Кодировка набора символов ASCII (7-разрядных).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Символы ASCII ограничены самыми низкими 128 символами Юникода от U + 0000 до U + 007F.  
  
 При выборе кодировки ASCII для приложения учитывайте следующее.  
  
-   Кодировка ASCII обычно подходит для протоколов, требующих ASCII.  
  
-   Если требуется 8-разрядная кодировка (которая иногда ошибочно называется ASCII), рекомендуется использовать кодировку UTF-8 в кодировке ASCII. Для символов 0-7F результаты идентичны, но использование UTF-8 позволяет избежать потери данных, разрешая представление всех символов Юникода, которые можно представить. Обратите внимание, что кодировка ASCII имеет 8-разрядную неоднозначность, которая может допускать вредоносное использование, но кодировка UTF-8 устраняет неоднозначность в восьмом бите.  
  
-   До версии .NET Framework 2,0 .NET Framework допускало подмену, игнорируя восьмой бит. Начиная с .NET Framework 2,0, в процессе декодирования кодовые точки, не входящие в набор ASCII, переходят назад.  
  
 <xref:System.Text.ASCIIEncoding> Объект, возвращаемый этим свойством, может не иметь соответствующего поведения для приложения. Он использует резервный вариант замены, чтобы заменить каждую строку, которую не удается закодировать, и каждый байт, который не может быть декодирован символом вопросительного знака ("?"). Вместо этого можно <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> вызвать метод для создания экземпляра <xref:System.Text.ASCIIEncoding> объекта, резерв <xref:System.Text.EncoderFallbackException> которого <xref:System.Text.DecoderFallbackException>является либо или, как показано в следующем примере.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 В следующем примере демонстрируется воздействие кодировки ASCII на символы, находящиеся за пределами диапазона ASCII.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для формата UTF-16 с обратным порядком байтов.</summary>
        <value>Объект кодировки для формата UTF-16 с обратным порядком байтов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UnicodeEncoding> Объект, возвращаемый этим свойством, может не иметь соответствующего поведения для приложения. Он использует резервный вариант замены, чтобы заменить каждую строку, которую не удается закодировать, и каждый байт, который не может быть декодирован символом вопросительного знака ("?"). <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Вместо этого можно вызвать конструктор для создания экземпляра объекта с обратным порядком байтов <xref:System.Text.UnicodeEncoding> , резерв <xref:System.Text.EncoderFallbackException> которого <xref:System.Text.DecoderFallbackException>имеет значение или, как показано в следующем примере.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 Возвращаемый <xref:System.Text.UnicodeEncoding> объект имеет <xref:System.Text.Encoding.BodyName%2A>свойства <xref:System.Text.Encoding.HeaderName%2A>, и <xref:System.Text.Encoding.WebName%2A> , которые дают имя "уникодефффе". Несмотря на то, что метка порядка байтов в кодировке UTF-16 имеет шестнадцатеричное значение FEFF, было выбрано имя «Уникодефффе», поскольку метка порядка байтов отображается как шестнадцатеричная ФФФЕ на компьютерах Windows с прямым порядком байтов.  
  
   
  
## Examples  
 В следующем примере выполняется чтение текстового файла с кодировкой UTF-16 с обратным порядком байтов.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 В следующем примере определяется число байтов, необходимое для кодирования массива символов, символы кодируются и выводятся полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает имя текущей кодировки, которое может использоваться с тегами текста сообщения почтового агента.</summary>
        <value>Имя текущего объекта <see cref="T:System.Text.Encoding" />, которое может использоваться с тегами текста сообщения почтового агента.  
  
- или - 
Пустая строка (""), если текущий объект <see cref="T:System.Text.Encoding" /> не может использоваться.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если требуется кодировка для имени тела, следует вызвать метод <xref:System.Text.Encoding.GetEncoding%2A> <xref:System.Text.Encoding.BodyName%2A> со свойством. Часто метод извлекает другую кодировку из тестовой кодировки, предоставляемой в вызове. Обычно для получения такой кодировки требуются только приложения электронной почты. Большинство других приложений, которым необходимо описать кодировку, должны использовать <xref:System.Text.Encoding.WebName%2A>его.  
  
 В некоторых случаях значение <xref:System.Text.Encoding.BodyName%2A> свойства соответствует международным стандарту, который определяет эту кодировку. Это не означает, что реализация полностью соответствует этому стандарту.  
  
   
  
## Examples  
 В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки с одним или несколькими именами, отличающимися <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>от. Он отображается <xref:System.Text.Encoding.EncodingName%2A> , но не сравнивается с ним.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе создается неполная копия текущего объекта <see cref="T:System.Text.Encoding" />.</summary>
        <returns>Копия текущего объекта <see cref="T:System.Text.Encoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Копия доступна для записи, даже если исходный <xref:System.Text.Encoding> объект доступен только для чтения. Таким образом, свойства клона можно изменить.  
  
 Неполная копия объекта — это копия только объекта. Если объект содержит ссылки на другие объекты, то неполная копия не создает копии объектов, на которые они ссылаются. Вместо этого он ссылается на исходные объекты. В отличие от этого, глубокая копия объекта создает копию объекта и копию всех объектов, на которые прямо или косвенно ссылается этот объект.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает идентификатор кодовой страницы текущего объекта <see cref="T:System.Text.Encoding" />.</summary>
        <value>Идентификатор кодовой страницы текущего объекта <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки с одним или несколькими именами, отличающимися <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>от. Он отображается <xref:System.Text.Encoding.EncodingName%2A> , но не сравнивается с ним.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует массив байтов из одной кодировки в другую.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Формат кодировки параметра <paramref name="bytes" />.</param>
        <param name="dstEncoding">Целевой формат кодировки.</param>
        <param name="bytes">Преобразуемые байты.</param>
        <summary>Преобразует весь массив байтов из одной кодировки в другую.</summary>
        <returns>Массив типа <see cref="T:System.Byte" />, содержащий результаты преобразования <paramref name="bytes" /> из <paramref name="srcEncoding" /> в <paramref name="dstEncoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере строка в кодировке Юникод преобразуется в строку в кодировке ASCII. Поскольку объект кодировки ASCII, возвращаемый <xref:System.Text.Encoding.ASCII%2A> свойством, использует замену замены, а символ PI не является частью набора символов ASCII, символ PI заменяется вопросительным знаком, как показано в выходных данных примера.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="srcEncoding" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="dstEncoding" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 **srcEncoding.** Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 **dstEncoding.** Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Кодировка исходного массива, <paramref name="bytes" />.</param>
        <param name="dstEncoding">Кодировка выходного массива.</param>
        <param name="bytes">Преобразуемый массив байтов.</param>
        <param name="index">Индекс первого элемента преобразуемого массива байтов <paramref name="bytes" />.</param>
        <param name="count">Число байтов, которые требуется преобразовать.</param>
        <summary>Преобразует диапазон байтов в массиве байтов из одной кодировки в другую.</summary>
        <returns>Массив типа <see cref="T:System.Byte" />, содержащий результат преобразования диапазона байтов из массива <paramref name="bytes" /> из <paramref name="srcEncoding" /> в <paramref name="dstEncoding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="srcEncoding" /> — <see langword="null" />.  
  
-или- 
 <paramref name="dstEncoding" /> — <see langword="null" />.  
  
-или- 
 <paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> и <paramref name="count" /> не определяют допустимый диапазон в массиве байтов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 **srcEncoding.** Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 **dstEncoding.** Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DecoderFallback As DecoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback" Usage="System.Text.Encoding.DecoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Text.DecoderFallback" /> для текущего объекта <see cref="T:System.Text.Encoding" />.</summary>
        <value>Резервный объект декодера для текущего объекта <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallback> Объект представляет обработчик ошибок, который вызывается, когда закодированная последовательность байтов не может быть декодирована в символ. Поддерживается любой из следующих типов обработчиков:  
  
-   Резервный обработчик наилучшего соответствия, который заменяет байты, которые не могут быть декодированы с помощью подходящего символа замены.  
  
-   Резервный обработчик замены, который заменяет байты, которые не могут быть декодированы с помощью произвольного символа замены. В состав .NET входит один заменяющий резервный обработчик, <xref:System.Text.DecoderFallback>который по умолчанию заменяет байты, которые не могут быть декодированы символом вопросительного знака ("?").  
  
-   Обработчик отката исключений, который создает исключение, если не удается декодировать байты. .NET включает один обработчик <xref:System.Text.DecoderExceptionFallback>отката исключений, который <xref:System.Text.DecoderFallbackException> создает исключение, если не удается декодировать байты.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">В операции задания значением является <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Невозможно задать значение, поскольку текущий объект <see cref="T:System.Text.Encoding" /> предназначен только для чтения.</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает кодировку по умолчанию для данной реализации .NET.</summary>
        <value>Кодировка по умолчанию для этой реализации .NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Разные компьютеры могут использовать разные кодировки по умолчанию, а кодировка по умолчанию может измениться на одном компьютере. Если <xref:System.Text.Encoding.Default%2A> кодировка используется для кодирования и декодирования данных, потоков между компьютерами или извлеченных в разное время на одном компьютере, они могут неправильно преобразовать эти данные. Кроме того, кодировка, возвращаемая <xref:System.Text.Encoding.Default%2A> свойством, использует стратегию наилучшего соответствия для преобразования неподдерживаемых символов в символы, поддерживаемые кодовой страницей. По этим причинам использовать кодировку по умолчанию не рекомендуется. Чтобы обеспечить правильную декодирование закодированных байтов, следует использовать кодировку Юникода, например <xref:System.Text.UTF8Encoding> или. <xref:System.Text.UnicodeEncoding> Можно также использовать протокол более высокого уровня, чтобы убедиться в том, что для кодирования и декодирования используется один и тот же формат.  

### <a name="the-default-property-in-the-net-framework"></a>Свойство по умолчанию в .NET Framework

В .NET Framework на рабочем столе <xref:System.Text.Encoding.Default%2A> Windows свойство всегда получает активную кодовую страницу системы и <xref:System.Text.Encoding> создает объект, соответствующий ему. Активной кодовой страницей может быть кодовая страница ANSI, содержащая набор символов ASCII вместе с дополнительными символами, которые зависят от кодовой страницы. Поскольку все <xref:System.Text.Encoding.Default%2A> кодировки, основанные на кодовых страницах ANSI, теряют данные <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> , вместо них рекомендуется использовать кодировку. UTF-8 часто совпадает с диапазоном U + 00 до U + 7F, но может кодировать символы за пределами диапазона ASCII без потерь.

## <a name="the-default-property-on-net-core"></a>Свойство по умолчанию в .NET Core

В .NET Core <xref:System.Text.Encoding.Default%2A> свойство всегда возвращает значение <xref:System.Text.UTF8Encoding>. UTF-8 поддерживается во всех операционных системах (Windows, Linux и Max OS X), на которых работают приложения .NET Core.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EncoderFallback As EncoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback" Usage="System.Text.Encoding.EncoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Text.EncoderFallback" /> для текущего объекта <see cref="T:System.Text.Encoding" />.</summary>
        <value>Резервный объект кодировщика для текущего объекта <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.EncoderFallback> Объект представляет обработчик ошибок, который вызывается, когда символ не может быть преобразован в закодированную последовательность байтов. Поддерживается любой из следующих типов обработчиков:  
  
-   Резервный обработчик наилучшего соответствия, который заменяет символы, которые не могут быть закодированы с помощью подходящего символа замены.  
  
-   Резервный обработчик замены, который заменяет символы, которые не могут быть закодированы произвольным символом замены. В состав .NET входит один заменяющий резервный обработчик, <xref:System.Text.EncoderFallback>который по умолчанию заменяет символы, которые не могут быть закодированы символом вопросительного знака ("?").  
  
-   Обработчик отката исключений, который создает исключение, если символы не могут быть закодированы. .NET включает один обработчик <xref:System.Text.EncoderExceptionFallback>резервных исключений, который <xref:System.Text.EncoderFallbackException> создает исключение, когда символы не могут быть декодированы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">В операции задания значением является <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Невозможно задать значение, поскольку текущий объект <see cref="T:System.Text.Encoding" /> предназначен только для чтения.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает описание текущей кодировки, которое может быть прочитано пользователем.</summary>
        <value>Описание текущего объекта <see cref="T:System.Text.Encoding" />, которое может быть прочитано пользователем.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.EncodingName%2A> Свойство предназначено для вывода. Чтобы найти имя, которое можно передать в <xref:System.Text.Encoding.GetEncoding%2A> метод, <xref:System.Text.Encoding.WebName%2A> используйте свойство.  
  
   
  
## Examples  
 В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки с одним или несколькими именами, отличающимися <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>от. Он отображается <xref:System.Text.Encoding.EncodingName%2A> , но не сравнивается с ним.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> для сравнения с текущим экземпляром.</param>
        <summary>Определяет, равен ли указанный объект <see cref="T:System.Object" /> текущему экземпляру.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="value" /> является экземпляром <see cref="T:System.Text.Encoding" />, равным текущему экземпляру; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Два экземпляра <xref:System.Text.Encoding> считаются равными, если они соответствуют одной и той же кодовой странице, `DecoderFallback` а их `EncoderFallback` объекты равны. В частности, на производных страницах кода есть кодовая страница 0, а их резервные варианты `null` обычно`Nothing` находятся в Visual Basic .NET. Поэтому все они считаются равными друг другу. Один из них состоит в <xref:System.Text.Encoding.Equals%2A> том, что когда используется для заполнения хэш-таблицы, все производные кодировки сравниваются равными и попадают в один и тот же слот хэш-таблицы.  
  
   
  
## Examples  
 В следующем примере выполняется получение двух экземпляров одной и той же кодировки (по одной кодовой странице, другой по имени) и проверка их равенства.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе вычисляет количество байтов, полученных при кодировании набора символов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий символы, которые требуется закодировать.</param>
        <summary>При переопределении в производном классе вычисляет количество байтов, полученных при кодировании всех символов из заданного массива символов.</summary>
        <returns>Количество байтов, полученных при кодировании всех символов из указанного массива символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, <xref:System.Text.Encoding.GetBytes%2A> необходимый для хранения результирующих байтов, <xref:System.Text.Encoding.GetByteCount%2A> вызовите метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. Метод обычно позволяет выделить меньше памяти, в <xref:System.Text.Encoding.GetMaxByteCount%2A> то время как метод обычно выполняется быстрее. <xref:System.Text.Encoding.GetByteCount%2A>  
  
 Метод определяет, сколько байт приводит к кодированию набора символов Юникода, <xref:System.Text.Encoding.GetBytes%2A> и метод выполняет фактическую кодировку. <xref:System.Text.Encoding.GetByteCount%2A> Метод принимает дискретные преобразования, в отличие <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> от метода, который обрабатывает несколько преобразований в одном входном потоке. <xref:System.Text.Encoding.GetBytes%2A>  
  
 Поддерживаются несколько <xref:System.Text.Encoding.GetByteCount%2A> версий <xref:System.Text.Encoding.GetBytes%2A> и. Ниже приведены некоторые рекомендации по программированию для использования этих методов.  
  
-   Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов. В этом случае, возможно, потребуется поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> используемым объектом.  
  
-   Если приложение обрабатывает входные данные строки, следует использовать строковые версии <xref:System.Text.Encoding.GetBytes%2A> метода.  
  
-   Версия <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> буфера символов Юникода позволяет <xref:System.Text.Encoder> использовать некоторые быстрые методы, в частности с несколькими вызовами, которые используют объект или вставляются в существующие буферы. Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.  
  
-   Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> наилучшим выбором является версия, которая поддерживает массивы байтов.  
  
-   Рассмотрите возможность <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> использования метода <xref:System.Text.Encoding.GetByteCount%2A>вместо. Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал. Для непрерывной кодировки потока этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования массива символов, символы кодируются и выводятся полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая набор символов для кодирования.</param>
        <summary>При переопределении в производном классе вычисляет число байтов, полученных при кодировании символов в заданной строке.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, <xref:System.Text.Encoding.GetBytes%2A> необходимый для хранения результирующих байтов, <xref:System.Text.Encoding.GetByteCount%2A> вызовите метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. Метод обычно позволяет выделить меньше памяти, в <xref:System.Text.Encoding.GetMaxByteCount%2A> то время как метод обычно выполняется быстрее. <xref:System.Text.Encoding.GetByteCount%2A>  
  
 Метод определяет, сколько байт приводит к кодированию набора символов Юникода, <xref:System.Text.Encoding.GetBytes%2A> и метод выполняет фактическую кодировку. <xref:System.Text.Encoding.GetByteCount%2A> Метод принимает дискретные преобразования, в отличие <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> от метода, который обрабатывает несколько преобразований в одном входном потоке. <xref:System.Text.Encoding.GetBytes%2A>  
  
 Поддерживаются несколько <xref:System.Text.Encoding.GetByteCount%2A> версий <xref:System.Text.Encoding.GetBytes%2A> и. Ниже приведены некоторые рекомендации по программированию для использования этих методов.  
  
-   Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов. В этом случае, возможно, потребуется поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> используемым объектом.  
  
-   Если приложение обрабатывает входные строки, рекомендуется использовать строковую <xref:System.Text.Encoding.GetBytes%2A> версию.  
  
-   Версия <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> буфера символов Юникода позволяет <xref:System.Text.Encoder> использовать некоторые быстрые методы, в частности с несколькими вызовами, которые используют объект или вставляются в существующие буферы. Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.  
  
-   Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> наилучшим выбором является версия, которая поддерживает массивы байтов.  
  
-   Рассмотрите возможность <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> использования метода <xref:System.Text.Encoding.GetByteCount%2A>вместо. Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал. Для непрерывной кодировки потока этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования строки или диапазона в строке, символы кодируются и выводятся полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">Указатель на первый кодируемый символ.</param>
        <param name="count">Число кодируемых символов.</param>
        <summary>При переопределении в производном классе вычисляет количество байтов, полученных при кодировании набора символов, начиная с заданного указателя символа.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива <xref:System.Text.Encoding.GetBytes%2A> , который требуется для хранения результирующих байтов, следует <xref:System.Text.Encoding.GetByteCount%2A> вызвать метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. Метод обычно позволяет выделить меньше памяти, в <xref:System.Text.Encoding.GetMaxByteCount%2A> то время как метод обычно выполняется быстрее. <xref:System.Text.Encoding.GetByteCount%2A>  
  
 Метод определяет, сколько байт приводит к кодированию набора символов Юникода, <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> и метод выполняет фактическую кодировку. <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> Метод принимает дискретные преобразования, в отличие <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> от метода, который обрабатывает несколько преобразований в одном входном потоке. <xref:System.Text.Encoding.GetBytes%2A>  
  
 Поддерживаются несколько <xref:System.Text.Encoding.GetByteCount%2A> версий <xref:System.Text.Encoding.GetBytes%2A> и. Ниже приведены некоторые рекомендации по использованию этих методов.  
  
-   Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов. В этом случае, возможно, потребуется поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> используемым объектом.  
  
-   Если приложение обрабатывает входные данные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A> метода.  
  
-   Версия <xref:System.Text.Encoding.GetBytes%2A> буфера символов Юникода позволяет <xref:System.Text.Encoder> использовать некоторые быстрые методы, в частности с несколькими вызовами, которые используют объект или вставляются в существующие буферы. Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.  
  
-   Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> наилучшим выбором является версия, которая поддерживает массивы байтов.  
  
-   Рассмотрите возможность <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> использования метода <xref:System.Text.Encoding.GetByteCount%2A>вместо. Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал. Для непрерывной кодировки потока этот метод часто является лучшим выбором.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий набор кодируемых символов.</param>
        <param name="index">Индекс первого кодируемого символа.</param>
        <param name="count">Число кодируемых символов.</param>
        <summary>При переопределении в производном классе вычисляет количество байтов, полученных при кодировании набора символов из указанного массива символов.</summary>
        <returns>Число байтов, полученных при кодировании заданных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, <xref:System.Text.Encoding.GetBytes%2A> необходимый для хранения результирующих байтов, <xref:System.Text.Encoding.GetByteCount%2A> вызовите метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. Метод обычно позволяет выделить меньше памяти, в <xref:System.Text.Encoding.GetMaxByteCount%2A> то время как метод обычно выполняется быстрее. <xref:System.Text.Encoding.GetByteCount%2A>  
  
 Метод определяет, сколько байт приводит к кодированию набора символов Юникода, <xref:System.Text.Encoding.GetBytes%2A> и метод выполняет фактическую кодировку. <xref:System.Text.Encoding.GetByteCount%2A> Метод принимает дискретные преобразования, в отличие <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> от метода, который обрабатывает несколько преобразований в одном входном потоке. <xref:System.Text.Encoding.GetBytes%2A>  
  
 Поддерживаются несколько <xref:System.Text.Encoding.GetByteCount%2A> версий <xref:System.Text.Encoding.GetBytes%2A> и. Ниже приведены некоторые рекомендации по программированию для использования этих методов.  
  
-   Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов. В этом случае, возможно, потребуется поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> используемым объектом.  
  
-   Если приложение обрабатывает входные строки, рекомендуется использовать строковую <xref:System.Text.Encoding.GetBytes%2A> версию.  
  
-   Версия <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> буфера символов Юникода позволяет <xref:System.Text.Encoder> использовать некоторые быстрые методы, в частности с несколькими вызовами, которые используют объект или вставляются в существующие буферы. Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.  
  
-   Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> наилучшим выбором является версия, которая поддерживает массивы байтов.  
  
-   Рассмотрите возможность <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> использования метода <xref:System.Text.Encoding.GetByteCount%2A>вместо. Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал. Для непрерывной кодировки потока этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования трех символов из массива символов, символы кодируются и выводятся полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
-или- 
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе кодирует набор символов в последовательность байтов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий символы, которые требуется закодировать.</param>
        <summary>При переопределении в производном классе кодирует все символы из указанного массива символов в последовательность байтов.</summary>
        <returns>Массив байтов, содержащий результаты кодирования указанного набора символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или, <xref:System.Text.Encoder> предоставленный <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метод, соответственно, производного класса.  
  
 Метод определяет, сколько байт приводит к кодированию набора символов Юникода, <xref:System.Text.Encoding.GetBytes%2A> и метод выполняет фактическую кодировку. <xref:System.Text.Encoding.GetByteCount%2A> Метод принимает дискретные преобразования, в отличие <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> от метода, который обрабатывает несколько преобразований в одном входном потоке. <xref:System.Text.Encoding.GetBytes%2A>  
  
 Поддерживаются несколько <xref:System.Text.Encoding.GetByteCount%2A> версий <xref:System.Text.Encoding.GetBytes%2A> и. Ниже приведены некоторые рекомендации по программированию для использования этих методов.  
  
-   Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов. В этом случае, возможно, потребуется поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> используемым объектом. (Например, последовательность символов, включающая суррогатные пары, может заканчиваться старшим суррогатом. <xref:System.Text.Encoder> Запомните, что старший суррогат можно объединить с младшим суррогатом в начале следующего вызова. <xref:System.Text.Encoding>не сможет поддерживать состояние, поэтому символ будет отправлен <xref:System.Text.EncoderFallback>в.)  
  
-   Если приложение обрабатывает входные данные строки, следует вызвать строковую версию <xref:System.Text.Encoding.GetBytes%2A> метода.  
  
-   Версия <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> буфера символов Юникода позволяет <xref:System.Text.Encoder> использовать некоторые быстрые методы, в частности с несколькими вызовами, которые используют объект или вставляются в существующие буферы. Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.  
  
-   Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> наилучшим выбором является версия, которая поддерживает массивы байтов.  
  
-   Рассмотрите возможность <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> использования метода <xref:System.Text.Encoding.GetByteCount%2A>вместо. Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал. Для непрерывной кодировки потока этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования массива символов, символы кодируются и выводятся полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая символы, которые требуется закодировать.</param>
        <summary>При переопределении в производном классе кодирует все символы заданной строки в последовательность байтов.</summary>
        <returns>Массив байтов, содержащий результаты кодирования указанного набора символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или, <xref:System.Text.Encoder> предоставленный <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метод, соответственно, производного класса.  
  
 Метод определяет, сколько байт приводит к кодированию набора символов Юникода, <xref:System.Text.Encoding.GetBytes%2A> и метод выполняет фактическую кодировку. <xref:System.Text.Encoding.GetByteCount%2A> Метод принимает дискретные преобразования, в отличие <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> от метода, который обрабатывает несколько преобразований в одном входном потоке. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>  
  
 Поддерживаются несколько <xref:System.Text.Encoding.GetByteCount%2A> версий <xref:System.Text.Encoding.GetBytes%2A> и. Ниже приведены некоторые рекомендации по программированию для использования этих методов.  
  
-   Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов. В этом случае, возможно, потребуется поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> используемым объектом. (Например, последовательность символов, включающая суррогатные пары, может заканчиваться старшим суррогатом. <xref:System.Text.Encoder> Запомните, что старший суррогат можно объединить с младшим суррогатом в начале следующего вызова. <xref:System.Text.Encoding>не сможет поддерживать состояние, поэтому символ будет отправлен <xref:System.Text.EncoderFallback>в.)  
  
-   Если приложение обрабатывает входные данные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Версия <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> буфера символов Юникода позволяет <xref:System.Text.Encoder> использовать некоторые быстрые методы, в частности с несколькими вызовами, которые используют объект или вставляются в существующие буферы. Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.  
  
-   Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> наилучшим выбором является версия, которая поддерживает массивы байтов.  
  
-   Рассмотрите возможность <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> использования метода <xref:System.Text.Encoding.GetByteCount%2A>вместо. Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал. Для непрерывной кодировки потока этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования строки или диапазона в строке, символы кодируются и выводятся полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий набор кодируемых символов.</param>
        <param name="index">Индекс первого кодируемого символа.</param>
        <param name="count">Число кодируемых символов.</param>
        <summary>При переопределении в производном классе кодирует набор символов из указанного массива символов в последовательность байтов.</summary>
        <returns>Массив байтов, содержащий результаты кодирования указанного набора символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или, <xref:System.Text.Encoder> предоставленный <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метод, соответственно, производного класса.  
  
 Метод определяет, сколько байт приводит к кодированию набора символов Юникода, <xref:System.Text.Encoding.GetBytes%2A> и метод выполняет фактическую кодировку. <xref:System.Text.Encoding.GetByteCount%2A> Метод принимает дискретные преобразования, в отличие <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> от метода, который обрабатывает несколько преобразований в одном входном потоке. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>  
  
 Поддерживаются несколько <xref:System.Text.Encoding.GetByteCount%2A> версий <xref:System.Text.Encoding.GetBytes%2A> и. Ниже приведены некоторые рекомендации по программированию для использования этих методов.  
  
-   Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов. В этом случае, возможно, потребуется поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> используемым объектом. (Например, последовательность символов, включающая суррогатные пары, может заканчиваться старшим суррогатом. <xref:System.Text.Encoder> Запомните, что старший суррогат можно объединить с младшим суррогатом в начале следующего вызова. <xref:System.Text.Encoding>не сможет поддерживать состояние, поэтому символ будет отправлен <xref:System.Text.EncoderFallback>в.)  
  
-   Если приложение обрабатывает входные данные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Версия <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> буфера символов Юникода позволяет <xref:System.Text.Encoder> использовать некоторые быстрые методы, в частности с несколькими вызовами, которые используют объект или вставляются в существующие буферы. Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.  
  
-   Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> наилучшим выбором является версия, которая поддерживает массивы байтов.  
  
-   Рассмотрите возможность <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> использования метода <xref:System.Text.Encoding.GetByteCount%2A>вместо. Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал. Для непрерывной кодировки потока этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования трех символов из массива символов, символы кодируются и выводятся полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
- или - 
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">Указатель на первый кодируемый символ.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Указатель на положение, с которого начинается запись результирующей последовательности байтов.</param>
        <param name="byteCount">Максимальное число байтов для записи.</param>
        <summary>При переопределении в производном классе кодирует набор символов, начало которого задается указателем символа, в последовательность байтов, которые сохраняются, начиная с заданного указателя байта.</summary>
        <returns>Фактическое число байтов, записанных в местоположение, которое задано параметром <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива <xref:System.Text.Encoding.GetBytes%2A> , который требуется для хранения результирующих байтов, <xref:System.Text.Encoding.GetByteCount%2A> вызовите метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. Метод обычно позволяет выделить меньше памяти, в <xref:System.Text.Encoding.GetMaxByteCount%2A> то время как метод обычно выполняется быстрее. <xref:System.Text.Encoding.GetByteCount%2A>  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> объект, предоставляемый <xref:System.Text.Encoding.GetDecoder%2A>настроек или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 Метод определяет, сколько байт приводит к кодированию набора символов Юникода, <xref:System.Text.Encoding.GetBytes%2A> и метод выполняет фактическую кодировку. <xref:System.Text.Encoding.GetByteCount%2A> Метод принимает дискретные преобразования, в отличие <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> от метода, который обрабатывает несколько преобразований в одном входном потоке. <xref:System.Text.Encoding.GetBytes%2A>  
  
 Поддерживаются несколько <xref:System.Text.Encoding.GetByteCount%2A> версий <xref:System.Text.Encoding.GetBytes%2A> и. Ниже приведены некоторые рекомендации по программированию для использования этих методов.  
  
-   Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов. В этом случае, возможно, потребуется поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> используемым объектом. (Например, последовательность символов, включающая суррогатные пары, может заканчиваться старшим суррогатом. <xref:System.Text.Encoder> Запомните, что старший суррогат можно объединить с младшим суррогатом в начале следующего вызова. <xref:System.Text.Encoding>не сможет поддерживать состояние, поэтому символ будет отправлен <xref:System.Text.EncoderFallback>в.)  
  
-   Если приложение обрабатывает входные данные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Версия <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> буфера символов Юникода позволяет <xref:System.Text.Encoder> использовать некоторые быстрые методы, в частности с несколькими вызовами, которые используют объект или вставляются в существующие буферы. Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.  
  
-   Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> наилучшим выбором является версия, которая поддерживает массивы байтов.  
  
-   Рассмотрите возможность <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> использования метода <xref:System.Text.Encoding.GetByteCount%2A>вместо. Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал. Для непрерывной кодировки потока этот метод часто является лучшим выбором.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="chars" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="charCount" /> или <paramref name="byteCount" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="byteCount" /> меньше результирующего числа байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Массив символов, содержащий набор кодируемых символов.</param>
        <param name="charIndex">Индекс первого кодируемого символа.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Массив байтов, в который будет помещена результирующая последовательность байтов.</param>
        <param name="byteIndex">Индекс, с которого начинается запись результирующей последовательности байтов.</param>
        <summary>При переопределении в производном классе кодирует набор символов из указанного массива символов в указанный массив байтов.</summary>
        <returns>Фактическое число байтов, записанных в <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, <xref:System.Text.Encoding.GetBytes%2A> необходимый для хранения результирующих байтов, следует <xref:System.Text.Encoding.GetByteCount%2A> вызвать метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. Метод обычно позволяет выделить меньше памяти, в <xref:System.Text.Encoding.GetMaxByteCount%2A> то время как метод обычно выполняется быстрее. <xref:System.Text.Encoding.GetByteCount%2A>  
  
 Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или, <xref:System.Text.Encoder> предоставленный <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метод, соответственно, производного класса.  
  
 Метод определяет, сколько байт приводит к кодированию набора символов Юникода, <xref:System.Text.Encoding.GetBytes%2A> и метод выполняет фактическую кодировку. <xref:System.Text.Encoding.GetByteCount%2A> Метод принимает дискретные преобразования, в отличие <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> от метода, который обрабатывает несколько преобразований в одном входном потоке. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>  
  
 Поддерживаются несколько <xref:System.Text.Encoding.GetByteCount%2A> версий <xref:System.Text.Encoding.GetBytes%2A> и. Ниже приведены некоторые рекомендации по программированию для использования этих методов.  
  
-   Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов. В этом случае, возможно, потребуется поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> используемым объектом. (Например, последовательность символов, включающая суррогатные пары, может заканчиваться старшим суррогатом. <xref:System.Text.Encoder> Запомните, что старший суррогат можно объединить с младшим суррогатом в начале следующего вызова. <xref:System.Text.Encoding>не сможет поддерживать состояние, поэтому символ будет отправлен <xref:System.Text.EncoderFallback>в.)  
  
-   Если приложение обрабатывает входные данные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Версия <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> буфера символов Юникода позволяет <xref:System.Text.Encoder> использовать некоторые быстрые методы, в частности с несколькими вызовами, которые используют объект или вставляются в существующие буферы. Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.  
  
-   Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> наилучшим выбором является версия, которая поддерживает массивы байтов.  
  
-   Рассмотрите возможность <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> использования метода <xref:System.Text.Encoding.GetByteCount%2A>вместо. Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал. Для непрерывной кодировки потока этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования трех символов из массива символов, символы кодируются и выводятся полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> — <see langword="null" />.  
  
-или- 
 <paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="charIndex" />, <paramref name="charCount" /> или <paramref name="byteIndex" /> меньше нуля.  
  
- или - 
 Параметры<paramref name="charIndex" /> и <paramref name="charCount" /> не указывают допустимый диапазон в <paramref name="chars" />.  
  
-или- 
 Значение параметра <paramref name="byteIndex" /> не является допустимым индексом в <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Недостаточно емкости <paramref name="bytes" /> от <paramref name="byteIndex" /> до конца массива для размещения полученных байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая набор символов для кодирования.</param>
        <param name="charIndex">Индекс первого кодируемого символа.</param>
        <param name="charCount">Число кодируемых символов.</param>
        <param name="bytes">Массив байтов, в который будет помещена результирующая последовательность байтов.</param>
        <param name="byteIndex">Индекс, с которого начинается запись результирующей последовательности байтов.</param>
        <summary>При переопределении в производном классе кодирует набор символов из заданной строки в заданный массив байтов.</summary>
        <returns>Фактическое число байтов, записанных в <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, <xref:System.Text.Encoding.GetBytes%2A> необходимый для хранения результирующих байтов, следует <xref:System.Text.Encoding.GetByteCount%2A> вызвать метод. Чтобы вычислить максимальный размер массива, вызовите <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. Метод обычно позволяет выделить меньше памяти, в <xref:System.Text.Encoding.GetMaxByteCount%2A> то время как метод обычно выполняется быстрее. <xref:System.Text.Encoding.GetByteCount%2A>  
  
 Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или, <xref:System.Text.Encoder> предоставленный <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метод, соответственно, производного класса.  
  
 Метод определяет, сколько байт приводит к кодированию набора символов Юникода, <xref:System.Text.Encoding.GetBytes%2A> и метод выполняет фактическую кодировку. <xref:System.Text.Encoding.GetByteCount%2A> Метод принимает дискретные преобразования, в отличие <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> от метода, который обрабатывает несколько преобразований в одном входном потоке. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>  
  
 Поддерживаются несколько <xref:System.Text.Encoding.GetByteCount%2A> версий <xref:System.Text.Encoding.GetBytes%2A> и. Ниже приведены некоторые рекомендации по программированию для использования этих методов.  
  
-   Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов. В этом случае, возможно, потребуется поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется <xref:System.Text.Encoder> используемым объектом. (Например, последовательность символов, включающая суррогатные пары, может заканчиваться старшим суррогатом. <xref:System.Text.Encoder> Запомните, что старший суррогат можно объединить с младшим суррогатом в начале следующего вызова. <xref:System.Text.Encoding>не сможет поддерживать состояние, поэтому символ будет отправлен <xref:System.Text.EncoderFallback>в.)  
  
-   Если приложение обрабатывает входные данные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Версия <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> буфера символов Юникода позволяет <xref:System.Text.Encoder> использовать некоторые быстрые методы, в частности с несколькими вызовами, которые используют объект или вставляются в существующие буферы. Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.  
  
-   Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер. В этом случае <xref:System.Text.Encoding.GetBytes%2A> наилучшим выбором является версия, которая поддерживает массивы байтов.  
  
-   Рассмотрите возможность <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> использования метода <xref:System.Text.Encoding.GetByteCount%2A>вместо. Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал. Для непрерывной кодировки потока этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования строки или диапазона в строке, символы кодируются и выводятся полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="charIndex" />, <paramref name="charCount" /> или <paramref name="byteIndex" /> меньше нуля.  
  
- или - 
 Параметры<paramref name="charIndex" /> и <paramref name="charCount" /> не указывают допустимый диапазон в <paramref name="chars" />.  
  
-или- 
 Значение параметра <paramref name="byteIndex" /> не является допустимым индексом в <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Недостаточно емкости <paramref name="bytes" /> от <paramref name="byteIndex" /> до конца массива для размещения полученных байтов.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе вычисляет количество символов, полученных при декодировании последовательности байтов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <summary>При переопределении в производном классе вычисляет количество символов, полученных при декодировании всех байтов из заданного массива байтов.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> необходимый для хранения результирующих символов, следует <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> использовать метод. Чтобы вычислить максимальный размер массива, следует использовать <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> метод. Метод обычно позволяет выделить меньше памяти, в <xref:System.Text.Encoding.GetMaxCharCount%2A> то время как метод обычно выполняется быстрее. <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>  
  
 Метод определяет, сколько символов приводит к декодированию последовательности байтов, <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> и метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> Метод принимает дискретные преобразования, в отличие <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> от метода, который обрабатывает несколько проходов по одному входному потоку. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>  
  
 Поддерживаются несколько <xref:System.Text.Encoding.GetCharCount%2A> версий <xref:System.Text.Encoding.GetChars%2A> и. Ниже приведены некоторые рекомендации по программированию для использования этих методов.  
  
-   Приложению может потребоваться декодировать несколько входных байт из кодовой страницы и обработать байты, используя несколько вызовов. В этом случае, возможно, потребуется поддерживать состояние между вызовами.  
  
-   Если приложение обрабатывает выходные данные строки, следует использовать <xref:System.Text.Encoding.GetString%2A> метод. Поскольку этот метод должен проверять длину строки и выделить буфер, он немного медленнее, но результирующий <xref:System.String> тип является предпочтительным.  
  
-   Версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> Byte позволяет выполнять некоторые быстрые приемы, особенно с несколькими вызовами больших буферов. Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.  
  
-   Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер. В этом случае [\], Int32, Int32, char XREF: System. Text. Encoding. GetChars\<% 28System. Byte% 5b% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5b% 5D% 2CSystem. Int32% 29 > версии, поддерживающей выходной символ лучше выбрать буферы.  
  
-   Рассмотрите возможность <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> использования метода <xref:System.Text.Encoding.GetCharCount%2A>вместо. Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 Следующий пример кодирует строку в массив байтов, а затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Указатель на первый декодируемый байт.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе вычисляет количество символов, полученных при декодировании последовательности байтов, начало которой задается указателем байтов.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива <xref:System.Text.Encoding.GetChars%2A> , для которого требуется сохранить полученные символы, следует <xref:System.Text.Encoding.GetCharCount%2A> использовать метод. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxCharCount%2A> метод. Метод обычно позволяет выделить меньше памяти, в <xref:System.Text.Encoding.GetMaxCharCount%2A> то время как метод обычно выполняется быстрее. <xref:System.Text.Encoding.GetCharCount%2A>  
  
 Метод определяет, сколько символов приводит к декодированию последовательности байтов, <xref:System.Text.Encoding.GetChars%2A> и метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetCharCount%2A> Метод принимает дискретные преобразования, в отличие <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> от метода, который обрабатывает несколько проходов по одному входному потоку. <xref:System.Text.Encoding.GetChars%2A>  
  
 Поддерживаются несколько <xref:System.Text.Encoding.GetCharCount%2A> версий <xref:System.Text.Encoding.GetChars%2A> и. Ниже приведены некоторые рекомендации по программированию для использования этих методов.  
  
-   Приложению может потребоваться декодировать несколько входных байт из кодовой страницы и обработать байты, используя несколько вызовов. В этом случае, возможно, потребуется поддерживать состояние между вызовами.  
  
-   Если приложение обрабатывает выходные данные строки, рекомендуется использовать <xref:System.Text.Encoding.GetString%2A> метод. Поскольку этот метод должен проверять длину строки и выделить буфер, он немного медленнее, но результирующий <xref:System.String> тип является предпочтительным.  
  
-   Версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> Byte позволяет выполнять некоторые быстрые приемы, особенно с несколькими вызовами больших буферов. Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.  
  
-   Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер. В этом случае [\], Int32, Int32, char XREF: System. Text. Encoding. GetChars\<% 28System. Byte% 5b% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5b% 5D% 2CSystem. Int32% 29 > версии, поддерживающей выходной символ лучше выбрать буферы.  
  
-   Рассмотрите возможность <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> использования метода <xref:System.Text.Encoding.GetCharCount%2A>вместо. Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока этот метод часто является лучшим выбором.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="index">Индекс первого декодируемого байта.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе вычисляет количество символов, полученных при декодировании последовательности байтов из заданного массива байтов.</summary>
        <returns>Число символов, полученных при декодировании заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, <xref:System.Text.Encoding.GetChars%2A> необходимый для хранения результирующих символов, следует <xref:System.Text.Encoding.GetCharCount%2A> использовать метод. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxCharCount%2A> метод. Метод обычно позволяет выделить меньше памяти, в <xref:System.Text.Encoding.GetMaxCharCount%2A> то время как метод обычно выполняется быстрее. <xref:System.Text.Encoding.GetCharCount%2A>  
  
 Метод определяет, сколько символов приводит к декодированию последовательности байтов, <xref:System.Text.Encoding.GetChars%2A> и метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetCharCount%2A> Метод принимает дискретные преобразования, в отличие <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> от метода, который обрабатывает несколько проходов по одному входному потоку. <xref:System.Text.Encoding.GetChars%2A>  
  
 Поддерживаются несколько <xref:System.Text.Encoding.GetCharCount%2A> версий <xref:System.Text.Encoding.GetChars%2A> и. Ниже приведены некоторые рекомендации по программированию для использования этих методов.  
  
-   Приложению может потребоваться декодировать несколько входных байт из кодовой страницы и обработать байты, используя несколько вызовов. В этом случае, возможно, потребуется поддерживать состояние между вызовами.  
  
-   Если приложение обрабатывает выходные данные строки, рекомендуется использовать <xref:System.Text.Encoding.GetString%2A> метод. Поскольку этот метод должен проверять длину строки и выделить буфер, он немного медленнее, но результирующий <xref:System.String> тип является предпочтительным.  
  
-   Версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> Byte позволяет выполнять некоторые быстрые приемы, особенно с несколькими вызовами больших буферов. Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.  
  
-   Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер. В этом случае [\], Int32, Int32, char XREF: System. Text. Encoding. GetChars\<% 28System. Byte% 5b% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5b% 5D% 2CSystem. Int32% 29 > версии, поддерживающей выходной символ лучше выбрать буферы.  
  
-   Рассмотрите возможность <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> использования метода <xref:System.Text.Encoding.GetCharCount%2A>вместо. Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 В следующем примере строка из одной кодировки преобразуется в другую.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 В следующем примере строка кодируется в массив байтов, а затем декодирует диапазон байтов в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
-или- 
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе декодирует последовательность байтов в набор символов.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <summary>При переопределении в производном классе декодирует все байты из указанного массива байтов в набор символов.</summary>
        <returns>Массив символов, содержащий результаты декодирования указанной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>Получает символы из входной последовательности байтов. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> , так <xref:System.Text.Encoding> как ожидает дискретные преобразования, <xref:System.Text.Decoder> в то время как предназначено для нескольких проходов по одному входному потоку.  
  
 Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или, <xref:System.Text.Encoder> предоставленный <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метод, соответственно, производного класса.  
  
 **Примечание** . Этот метод предназначен для обработки символов Юникода, а не для произвольных двоичных данных, таких как байтовые массивы. Если необходимо закодировать произвольные двоичные данные в текст, следует использовать протокол, такой как uuencode, который реализуется такими методами, <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>как.  
  
 Метод определяет, сколько символов приводит к декодированию последовательности байтов, <xref:System.Text.Encoding.GetChars%2A> и метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetCharCount%2A> Метод принимает дискретные преобразования, в отличие <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> от метода, который обрабатывает несколько проходов по одному входному потоку. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>  
  
 Поддерживаются несколько <xref:System.Text.Encoding.GetCharCount%2A> версий <xref:System.Text.Encoding.GetChars%2A> и. Ниже приведены некоторые рекомендации по программированию для использования этих методов.  
  
-   Приложению может потребоваться декодировать несколько входных байт из кодовой страницы и обработать байты, используя несколько вызовов. В этом случае, возможно, потребуется поддерживать состояние между вызовами, так как последовательности байтов могут быть прерваны при обработке в пакетах. (Например, часть последовательности сдвигов ISO-2022 может завершить один <xref:System.Text.Encoding.GetChars%2A> вызов и продолжить в начале следующего <xref:System.Text.Encoding.GetChars%2A> вызова. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>будет вызывать откат для этих неполных последовательностей, но <xref:System.Text.Decoder> запоминает эти последовательности для следующего вызова.)  
  
-   Если приложение обрабатывает выходные данные строки, рекомендуется использовать <xref:System.Text.Encoding.GetString%2A> метод. Поскольку этот метод должен проверять длину строки и выделить буфер, он немного медленнее, но результирующий <xref:System.String> тип является предпочтительным.  
  
-   Версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> Byte позволяет выполнять некоторые быстрые приемы, особенно с несколькими вызовами больших буферов. Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.  
  
-   Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер. В этом случае [\], Int32, Int32, char XREF: System. Text. Encoding. GetChars\<% 28System. Byte% 5b% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5b% 5D% 2CSystem. Int32% 29 > версии, поддерживающей выходной символ лучше выбрать буферы.  
  
-   Рассмотрите возможность <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> использования метода <xref:System.Text.Encoding.GetCharCount%2A>вместо. Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 Следующий пример кодирует строку в массив байтов, а затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="index">Индекс первого декодируемого байта.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе декодирует последовательность байтов из указанного массива байтов в набор символов.</summary>
        <returns>Массив символов, содержащий результаты декодирования указанной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>Получает символы из входной последовательности байтов. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> , так <xref:System.Text.Encoding> как ожидает дискретные преобразования, <xref:System.Text.Decoder> в то время как предназначено для нескольких проходов по одному входному потоку.  
  
 Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или, <xref:System.Text.Encoder> предоставленный <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метод, соответственно, производного класса.  
  
 **Примечание** . Этот метод предназначен для обработки символов Юникода, а не для произвольных двоичных данных, таких как байтовые массивы. Если необходимо закодировать произвольные двоичные данные в текст, следует использовать протокол, такой как uuencode, который реализуется такими методами, <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>как.  
  
 Метод определяет, сколько символов приводит к декодированию последовательности байтов, <xref:System.Text.Encoding.GetChars%2A> и метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetCharCount%2A> Метод принимает дискретные преобразования, в отличие <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> от метода, который обрабатывает несколько проходов по одному входному потоку. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>  
  
 Поддерживаются несколько <xref:System.Text.Encoding.GetCharCount%2A> версий <xref:System.Text.Encoding.GetChars%2A> и. Ниже приведены некоторые рекомендации по программированию для использования этих методов.  
  
-   Приложению может потребоваться декодировать несколько входных байт из кодовой страницы и обработать байты, используя несколько вызовов. В этом случае, возможно, потребуется поддерживать состояние между вызовами, так как последовательности байтов могут быть прерваны при обработке в пакетах. (Например, часть последовательности сдвигов ISO-2022 может завершить один <xref:System.Text.Encoding.GetChars%2A> вызов и продолжить в начале следующего <xref:System.Text.Encoding.GetChars%2A> вызова. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>будет вызывать откат для этих неполных последовательностей, но <xref:System.Text.Decoder> запоминает эти последовательности для следующего вызова.)  
  
-   Если приложение обрабатывает выходные данные строки, рекомендуется использовать <xref:System.Text.Encoding.GetString%2A> метод. Поскольку этот метод должен проверять длину строки и выделить буфер, он немного медленнее, но результирующий <xref:System.String> тип является предпочтительным.  
  
-   Версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> Byte позволяет выполнять некоторые быстрые приемы, особенно с несколькими вызовами больших буферов. Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.  
  
-   Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер. В этом случае [\], Int32, Int32, char XREF: System. Text. Encoding. GetChars\<% 28System. Byte% 5b% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5b% 5D% 2CSystem. Int32% 29 > версии, поддерживающей выходной символ лучше выбрать буферы.  
  
-   Рассмотрите возможность <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> использования метода <xref:System.Text.Encoding.GetCharCount%2A>вместо. Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 В следующем примере строка кодируется в массив байтов, а затем декодирует диапазон байтов в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
- или - 
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Указатель на первый декодируемый байт.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <param name="chars">Указатель на положение, с которого начинается запись результирующего набора символов.</param>
        <param name="charCount">Наибольшее количество символов для записи.</param>
        <summary>При переопределении в производном классе декодирует последовательность байтов, которая начинается с заданного указателя байта, в набор символов, которые сохраняются, начиная с заданного указателя символа.</summary>
        <returns>Фактическое число символов, записанных в местоположение, которое задано параметром <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива <xref:System.Text.Encoding.GetChars%2A> , для которого требуется сохранить полученные символы, следует <xref:System.Text.Encoding.GetCharCount%2A> использовать метод. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxCharCount%2A> метод. Метод обычно позволяет выделить меньше памяти, в <xref:System.Text.Encoding.GetMaxCharCount%2A> то время как метод обычно выполняется быстрее. <xref:System.Text.Encoding.GetCharCount%2A>  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>Получает символы из входной последовательности байтов. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> , так <xref:System.Text.Encoding> как ожидает дискретные преобразования, <xref:System.Text.Decoder> в то время как предназначено для нескольких проходов по одному входному потоку.  
  
 Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> объект, предоставляемый <xref:System.Text.Encoding.GetDecoder%2A>настроек или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.  
  
 **Примечание** . Этот метод предназначен для обработки символов Юникода, а не для произвольных двоичных данных, таких как байтовые массивы. Если необходимо закодировать произвольные двоичные данные в текст, следует использовать протокол, такой как uuencode, который реализуется такими методами, <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>как.  
  
 Метод определяет, сколько символов приводит к декодированию последовательности байтов, <xref:System.Text.Encoding.GetChars%2A> и метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetCharCount%2A> Метод принимает дискретные преобразования, в отличие <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> от метода, который обрабатывает несколько проходов по одному входному потоку. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>  
  
 Поддерживаются несколько <xref:System.Text.Encoding.GetCharCount%2A> версий <xref:System.Text.Encoding.GetChars%2A> и. Ниже приведены некоторые рекомендации по программированию для использования этих методов.  
  
-   Приложению может потребоваться декодировать несколько входных байт из кодовой страницы и обработать байты, используя несколько вызовов. В этом случае, возможно, потребуется поддерживать состояние между вызовами, так как последовательности байтов могут быть прерваны при обработке в пакетах. (Например, часть последовательности сдвигов ISO-2022 может завершить один <xref:System.Text.Encoding.GetChars%2A> вызов и продолжить в начале следующего <xref:System.Text.Encoding.GetChars%2A> вызова. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>будет вызывать откат для этих неполных последовательностей, но <xref:System.Text.Decoder> запоминает эти последовательности для следующего вызова.)  
  
-   Если приложение обрабатывает выходные данные строки, <xref:System.Text.Encoding.GetString%2A> рекомендуется использовать метод. Поскольку этот метод должен проверять длину строки и выделить буфер, он немного медленнее, но результирующий <xref:System.String> тип является предпочтительным.  
  
-   Версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> Byte позволяет выполнять некоторые быстрые приемы, особенно с несколькими вызовами больших буферов. Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.  
  
-   Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер. В этом случае [\], Int32, Int32, char XREF: System. Text. Encoding. GetChars\<% 28System. Byte% 5b% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5b% 5D% 2CSystem. Int32% 29 > версии, поддерживающей выходной символ лучше выбрать буферы.  
  
-   Рассмотрите возможность <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> использования метода <xref:System.Text.Encoding.GetCharCount%2A>вместо. Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока этот метод часто является лучшим выбором.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.  
  
- или - 
 <paramref name="chars" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="byteCount" /> или <paramref name="charCount" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="charCount" /> меньше результирующего числа символов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="byteIndex">Индекс первого декодируемого байта.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <param name="chars">Массив символов, в который будет помещен результирующий набор символов.</param>
        <param name="charIndex">Индекс, с которого начинается запись результирующего набора символов.</param>
        <summary>При переопределении в производном классе декодирует последовательность байтов из указанного массива байтов в указанный массив символов.</summary>
        <returns>Фактическое число символов, записанных в <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, <xref:System.Text.Encoding.GetChars%2A> необходимый для хранения результирующих символов, следует <xref:System.Text.Encoding.GetCharCount%2A> использовать метод. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxCharCount%2A> метод. Метод обычно позволяет выделить меньше памяти, в <xref:System.Text.Encoding.GetMaxCharCount%2A> то время как метод обычно выполняется быстрее. <xref:System.Text.Encoding.GetCharCount%2A>  
  
 [\], Int32, Int32, char\<XREF: System. Text. Encoding. GetChars% 2A? displayProperty = nameWithType > получает символы из входной последовательности байтов. [\], Int32, Int32, char\<XREF: System. Text. Encoding. GetChars% 2A? displayProperty = nameWithType > отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> , так как <xref:System.Text.Encoding> ожидает дискретные преобразования, в то <xref:System.Text.Decoder> время как предназначено для несколько проходов по одному входному потоку.  
  
 Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или, <xref:System.Text.Encoder> предоставленный <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метод, соответственно, производного класса.  
  
 **Примечание** . Этот метод предназначен для обработки символов Юникода, а не для произвольных двоичных данных, таких как байтовые массивы. Если необходимо закодировать произвольные двоичные данные в текст, следует использовать протокол, такой как uuencode, который реализуется такими методами, <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>как.  
  
 Метод определяет, сколько символов приводит к декодированию последовательности байтов, <xref:System.Text.Encoding.GetChars%2A> и метод выполняет фактическое декодирование. <xref:System.Text.Encoding.GetCharCount%2A> Метод принимает дискретные преобразования, в отличие <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> от метода, который обрабатывает несколько проходов по одному входному потоку. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>  
  
 Поддерживаются несколько <xref:System.Text.Encoding.GetCharCount%2A> версий <xref:System.Text.Encoding.GetChars%2A> и. Ниже приведены некоторые рекомендации по программированию для использования этих методов.  
  
-   Приложению может потребоваться декодировать несколько входных байт из кодовой страницы и обработать байты, используя несколько вызовов. В этом случае, возможно, потребуется поддерживать состояние между вызовами, так как последовательности байтов могут быть прерваны при обработке в пакетах. (Например, часть последовательности сдвига ISO-2022 может заканчиваться на одну [\], Int32, Int32, char\<XREF: System. Text. Encoding. GetChars% 2A > вызвать и продолжить в начале следующего [\], Int32, Int32, char\<XREF : System. Text. Encoding. GetChars% 2A > вызов. [\], Int32, Int32, char\<XREF: System. Text. Encoding. GetChars% 2A? displayProperty = nameWithType > будет вызывать откат для этих неполных последовательностей, <xref:System.Text.Decoder> но запоминает эти последовательности для следующего вызова.)  
  
-   Если приложение обрабатывает выходные данные строки, <xref:System.Text.Encoding.GetString%2A> рекомендуется использовать метод. Поскольку этот метод должен проверять длину строки и выделить буфер, он немного медленнее, но результирующий <xref:System.String> тип является предпочтительным.  
  
-   Версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> Byte позволяет выполнять некоторые быстрые приемы, особенно с несколькими вызовами больших буферов. Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.  
  
-   Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер. В этом случае [\], Int32, Int32, char XREF: System. Text. Encoding. GetChars\<% 28System. Byte% 5b% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5b% 5D% 2CSystem. Int32% 29 > версии, поддерживающей выходной символ лучше выбрать буферы.  
  
-   Рассмотрите возможность <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> использования метода <xref:System.Text.Encoding.GetCharCount%2A>вместо. Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал. Для непрерывного декодирования потока этот метод часто является лучшим выбором.  
  
   
  
## Examples  
 В следующем примере строка из одной кодировки преобразуется в другую.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 В следующем примере строка кодируется в массив байтов, а затем декодирует диапазон байтов в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="chars" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="byteIndex" />, <paramref name="byteCount" /> или <paramref name="charIndex" /> меньше нуля.  
  
- или - 
 Параметры<paramref name="byteindex" /> и <paramref name="byteCount" /> не указывают допустимый диапазон в <paramref name="bytes" />.  
  
-или- 
 Значение параметра <paramref name="charIndex" /> не является допустимым индексом в <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Недостаточно емкости <paramref name="chars" /> от <paramref name="charIndex" /> до конца массива для размещения полученных символов.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе получает декодер, который преобразует последовательность байтов в последовательность символов.</summary>
        <returns>Объект <see cref="T:System.Text.Decoder" />, преобразующий закодированную последовательность байтов в последовательность символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод преобразует последовательные блоки байтов в последовательные блоки символов таким же образом, как <xref:System.Text.Encoding.GetChars%2A> и метод этого класса. <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Тем не менее <xref:System.Text.Decoder> , сохраняет сведения о состоянии между вызовами, чтобы правильно декодировать последовательности байтов, охватывающие блоки. <xref:System.Text.Decoder> Также сохраняет конечные байты в конце блоков данных и использует конечные байты в следующей операции декодирования. Поэтому они <xref:System.Text.Encoding.GetEncoder%2A> и полезны для передачи по сети и операций с файлами, так как эти операции часто работают с блоками данных, а не с полным потоком данных. <xref:System.Text.Encoding.GetDecoder%2A>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Реализация по умолчанию возвращает <see cref="T:System.Text.Decoder" /> объект, который <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> вызывает <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> методы и текущего <see cref="T:System.Text.Encoding" />объекта. Необходимо переопределить этот метод, чтобы он возвращал <see cref="T:System.Text.Decoder" /> объект, сохраняющий его состояние между вызовами.</para></block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе получает кодировщик, который преобразует последовательность символов Юникода в закодированную последовательность байтов.</summary>
        <returns>Объект <see cref="T:System.Text.Encoder" />, преобразующий последовательность символов Юникода в закодированную последовательность байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод преобразует последовательные блоки символов в последовательные блоки байтов способом, аналогичным <xref:System.Text.Encoding.GetBytes%2A> методу этого класса. <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> Тем не менее <xref:System.Text.Encoder> , сохраняет сведения о состоянии между вызовами, чтобы правильно кодировать последовательности символов, охватывающие блоки. <xref:System.Text.Encoder> Также сохраняет замыкающие символы в конце блоков данных и использует замыкающие символы в следующей операции кодирования. Например, блок данных может заканчиваться непарным старшим символом-заместителем, а соответствующий младший символ-заместитель может находиться в следующем блоке данных. Поэтому они <xref:System.Text.Encoding.GetEncoder%2A> и полезны для передачи по сети и операций с файлами, так как эти операции часто работают с блоками данных, а не с полным потоком данных. <xref:System.Text.Encoding.GetDecoder%2A>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Реализация по умолчанию возвращает <see cref="T:System.Text.Encoder" /> объект, который <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> вызывает <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> методы и текущего <see cref="T:System.Text.Encoding" />объекта. Необходимо переопределить этот метод, чтобы он возвращал <see cref="T:System.Text.Encoder" /> объект, сохраняющий его состояние между вызовами.</para></block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает кодировку для указанной кодовой страницы.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage">Идентификатор кодовой страницы предпочтительной кодировки. Возможные значения перечислены в столбце кодовой страницы таблицы, которая отображается в теме класса <see cref="T:System.Text.Encoding" />.  
  
- или - 
0 (ноль), если требуется использовать кодировку по умолчанию.</param>
        <summary>Возвращает кодировку, связанную с указанным идентификатором кодовой страницы.</summary>
        <returns>Кодирование, связанное с заданной страницей кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Резервный обработчик зависит от типа `codepage`кодировки. Если `codepage` является кодовой страницей или двухбайтовой кодировкой (DBCS), используется резервный обработчик наилучшего соответствия. В противном случае используется резервный обработчик замены. Эти резервные обработчики могут не подойти для вашего приложения. Чтобы указать резервный обработчик, используемый кодировкой, заданной параметром `codepage`, можно <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> вызвать перегрузку.  
  
 В .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> метод использует базовую платформу для поддержки большинства кодовых страниц. Однако .NET Framework изначально поддерживает некоторые кодировки. Список кодовых страниц см. в <xref:System.Text.Encoding> разделе о классе. В .NET Core <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает кодировки, которые изначально поддерживаются в .NET Core. В обеих реализациях .NET можно вызвать <xref:System.Text.Encoding.GetEncodings%2A> метод, чтобы получить <xref:System.Text.EncodingInfo> массив объектов, содержащий сведения обо всех доступных кодировках. 

 В дополнение к кодировкам, которые изначально доступны в .NET Core или поддерживаются в конкретной версии платформы .NET Framework, <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает все дополнительные кодировки, которые становятся доступными путем регистрации <xref:System.Text.EncodingProvider> объект. Если одна и та же кодировка зарегистрирована <xref:System.Text.EncodingProvider> несколькими объектами, этот метод возвращает последний зарегистрированный.  

Для `codepage` аргумента можно также указать значение 0. Точное поведение зависит от того, были ли доступны кодировки путем регистрации <xref:System.Text.EncodingProvider> объекта.

- Если один или несколько поставщиков кодировок зарегистрированы, возвращается кодировка последнего зарегистрированного поставщика, который выбрал для возврата кодировки, когда <xref:System.Text.Encoding.GetEncoding%2A> методу `codepage` передается аргумент, равный 0.     

- В .NET Framework, если поставщик кодирования не зарегистрирован, если <xref:System.Text.CodePagesEncodingProvider> является зарегистрированным поставщиком кодирования или если ни один зарегистрированный поставщик кодировок не `codepage` обрабатывает значение 0, возвращается активная кодовая страница операционной системы. Чтобы определить активную кодовую страницу в системах Windows, вызовите функцию Windows [жетакп](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) из .NET Framework на рабочем столе Windows.

- В .NET Core, если поставщик кодирования не зарегистрирован или если ни один зарегистрированный поставщик кодировок не обрабатывает `codepage` значение 0, <xref:System.Text.UTF8Encoding>возвращается.
  
> [!NOTE]
>  Некоторые неподдерживаемые кодовые страницы вызывают <xref:System.ArgumentException> исключение, а другие <xref:System.NotSupportedException>вызывают. Поэтому код должен перехватывать все исключения, указанные в разделе исключения.  
  
> [!NOTE]
>  Кодовые страницы ANSI могут различаться на разных компьютерах и могут изменяться на одном компьютере, что приводит к повреждению данных. По этой причине, если активная кодовая страница является кодовой страницей ANSI, кодирование и декодирование данных с помощью кодовой страницы по `Encoding.GetEncoding(0)` умолчанию, возвращенной, не рекомендуется. Для наиболее последовательных результатов следует использовать кодировку Юникода, такую как UTF-8 (кодовая страница 65001) или UTF-16, а не конкретную кодовую страницу.  
  
 <xref:System.Text.Encoding.GetEncoding%2A>Возвращает кэшированный экземпляр с параметрами по умолчанию. Для получения экземпляра с разными параметрами следует использовать конструкторы производных классов. Например, <xref:System.Text.UTF32Encoding> класс предоставляет конструктор, позволяющий включить обнаружение ошибок.  

   
  
## Examples  
 В следующем примере выполняется получение двух экземпляров одной кодировки (по одной кодовой странице и другой по имени) и проверка их равенства.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="codepage" /> меньше нуля или больше 65 535.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="codepage" /> не поддерживается используемой платформой.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="codepage" /> не поддерживается используемой платформой.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя кодовой страницы предпочтительной кодировки. Любое значение, возвращаемое свойством <see cref="P:System.Text.Encoding.WebName" />, является допустимым. Возможные значения перечислены в столбце "Имя" таблицы, отображаемой в разделе класса <see cref="T:System.Text.Encoding" />.</param>
        <summary>Возвращает кодировку, связанную с указанным именем кодовой страницы.</summary>
        <returns>Кодировка, связанная с указанной кодовой страницей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Резервный обработчик зависит от типа `name`кодировки. Если `name` является кодовой страницей или двухбайтовой кодировкой (DBCS), используется резервный обработчик наилучшего соответствия. В противном случае используется резервный обработчик замены. Эти резервные обработчики могут не подойти для вашего приложения. Чтобы указать резервный обработчик, используемый кодировкой, заданной параметром `name`, можно <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> вызвать перегрузку.  

В .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> метод использует базовую платформу для поддержки большинства кодовых страниц. Однако .NET Framework изначально поддерживает некоторые кодировки. Список кодовых страниц см. в <xref:System.Text.Encoding> разделе о классе. В .NET Core <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает кодировки, которые изначально поддерживаются в .NET Core. В обеих реализациях .NET можно вызвать <xref:System.Text.Encoding.GetEncodings%2A> метод, чтобы получить <xref:System.Text.EncodingInfo> массив объектов, содержащий сведения обо всех доступных кодировках. 

 В дополнение к кодировкам, которые изначально доступны в .NET Core или поддерживаются в конкретной версии платформы .NET Framework, <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает все дополнительные кодировки, которые становятся доступными путем регистрации <xref:System.Text.EncodingProvider> объект. Если одна и та же кодировка зарегистрирована <xref:System.Text.EncodingProvider> несколькими объектами, этот метод возвращает последний зарегистрированный.  
   
> [!NOTE]
>  Кодовые страницы ANSI могут отличаться на разных компьютерах, или их можно изменить для одного компьютера, что приведет к повреждению данных. Для наиболее последовательных результатов следует использовать Юникод, например UTF-8 (кодовая страница 65001) или UTF-16, а не конкретную кодовую страницу.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A>Возвращает кэшированный экземпляр с параметрами по умолчанию. Для получения экземпляра с разными параметрами следует использовать конструкторы производных классов. Например, <xref:System.Text.UTF32Encoding> класс предоставляет конструктор, позволяющий включить обнаружение ошибок.  
  
## Examples  
 В следующем примере выполняется получение двух экземпляров одной кодировки (по одной кодовой странице и другой по имени) и проверка их равенства.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> не является допустимым именем кодовой страницы.  
  
- или - 
Кодовая страница, указанная с помощью параметра <paramref name="name" />, не поддерживается используемой платформой.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage">Идентификатор кодовой страницы предпочтительной кодировки. Возможные значения перечислены в столбце кодовой страницы таблицы, которая отображается в теме класса <see cref="T:System.Text.Encoding" />.  
  
- или - 
0 (ноль), если требуется использовать кодировку по умолчанию.</param>
        <param name="encoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда символ не может быть закодирован с использованием текущей кодировки.</param>
        <param name="decoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда последовательность байтов не может быть декодирована с использованием текущей кодировки.</param>
        <summary>Возвращает кодировку, связанную с указанным идентификатором кодовой страницы. С помощью параметров задается обработчик ошибок для символов, которые не удается закодировать, и последовательностей байтов, которые не удается декодировать.</summary>
        <returns>Кодирование, связанное с заданной страницей кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Некоторые неподдерживаемые кодовые страницы приводят к <xref:System.ArgumentException> возникновению исключения, а другие вызывают <xref:System.NotSupportedException>. Поэтому код должен перехватывать все исключения, указанные в разделе исключения.  

В .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> метод использует базовую платформу для поддержки большинства кодовых страниц. Однако .NET Framework изначально поддерживает некоторые кодировки. Список кодовых страниц см. в <xref:System.Text.Encoding> разделе о классе. В .NET Core <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает кодировки, которые изначально поддерживаются в .NET Core. В обеих реализациях .NET можно вызвать <xref:System.Text.Encoding.GetEncodings%2A> метод, чтобы получить <xref:System.Text.EncodingInfo> массив объектов, содержащий сведения обо всех доступных кодировках. 

 В дополнение к кодировкам, которые изначально доступны в .NET Core или поддерживаются в конкретной версии платформы .NET Framework, <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает все дополнительные кодировки, которые становятся доступными путем регистрации <xref:System.Text.EncodingProvider> объект. Если одна и та же кодировка зарегистрирована <xref:System.Text.EncodingProvider> несколькими объектами, этот метод возвращает последний зарегистрированный.  

Для `codepage` аргумента можно также указать значение 0. Точное поведение зависит от того, были ли доступны кодировки путем регистрации <xref:System.Text.EncodingProvider> объекта.

- Если один или несколько поставщиков кодировок зарегистрированы, возвращается кодировка последнего зарегистрированного поставщика, который выбрал для возврата кодировки, когда <xref:System.Text.Encoding.GetEncoding%2A> методу `codepage` передается аргумент, равный 0.     

- В .NET Framework, если поставщик кодирования не зарегистрирован, если <xref:System.Text.CodePagesEncodingProvider> является зарегистрированным поставщиком кодирования или если ни один зарегистрированный поставщик кодировок не `codepage` обрабатывает значение 0, возвращается активная кодовая страница.

- В .NET Core, если поставщик кодирования не зарегистрирован или если ни один зарегистрированный поставщик кодировок не обрабатывает `codepage` значение 0, <xref:System.Text.UTF8Encoding> возвращается кодировка.

> [!NOTE]
>  Кодовые страницы ANSI могут различаться на разных компьютерах и могут изменяться на одном компьютере, что приводит к повреждению данных. По этой причине, если активная кодовая страница является кодовой страницей ANSI, кодирование и декодирование данных с помощью кодовой страницы по `Encoding.GetEncoding(0)` умолчанию, возвращенной, не рекомендуется. Для наиболее последовательных результатов следует использовать Юникод, например UTF-8 (кодовая страница 65001) или UTF-16, а не конкретную кодовую страницу. 
  
 Чтобы получить кодировку, связанную с активной кодовой страницей, можно либо указать значение 0 для `codepage` аргумента, либо, если код выполняется в .NET Framework на рабочем столе Windows, получить значение <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> свойства. Чтобы определить текущую активную кодовую страницу, вызовите функцию Windows [жетакп](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) из .NET Framework на рабочем столе Windows.  
  
 <xref:System.Text.Encoding.GetEncoding%2A>Возвращает кэшированный экземпляр с параметрами по умолчанию. Для получения экземпляра с разными параметрами следует использовать конструкторы производных классов. Например, <xref:System.Text.UTF32Encoding> класс предоставляет конструктор, позволяющий включить обнаружение ошибок.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> метод.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="codepage" /> меньше нуля или больше 65 535.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="codepage" /> не поддерживается используемой платформой.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="codepage" /> не поддерживается используемой платформой.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Имя кодовой страницы предпочтительной кодировки. Любое значение, возвращаемое свойством <see cref="P:System.Text.Encoding.WebName" />, является допустимым. Возможные значения перечислены в столбце "Имя" таблицы, отображаемой в разделе класса <see cref="T:System.Text.Encoding" />.</param>
        <param name="encoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда символ не может быть закодирован с использованием текущей кодировки.</param>
        <param name="decoderFallback">Объект, предоставляющий процедуру обработки ошибок, когда последовательность байтов не может быть декодирована с использованием текущей кодировки.</param>
        <summary>Возвращает кодировку, связанную с указанным именем кодовой страницы. С помощью параметров задается обработчик ошибок для символов, которые не удается закодировать, и последовательностей байтов, которые не удается декодировать.</summary>
        <returns>Кодирование, связанное с заданной страницей кода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

В .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> метод использует базовую платформу для поддержки большинства кодовых страниц. Однако .NET Framework изначально поддерживает некоторые кодировки. Список кодовых страниц см. в <xref:System.Text.Encoding> разделе о классе. В .NET Core <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает кодировки, которые изначально поддерживаются в .NET Core. В обеих реализациях .NET можно вызвать <xref:System.Text.Encoding.GetEncodings%2A> метод, чтобы получить <xref:System.Text.EncodingInfo> массив объектов, содержащий сведения обо всех доступных кодировках. 

 В дополнение к кодировкам, которые изначально доступны в .NET Core или поддерживаются в конкретной версии платформы .NET Framework, <xref:System.Text.Encoding.GetEncoding%2A> метод возвращает все дополнительные кодировки, которые становятся доступными путем регистрации <xref:System.Text.EncodingProvider> объект. Если одна и та же кодировка зарегистрирована <xref:System.Text.EncodingProvider> несколькими объектами, этот метод возвращает последний зарегистрированный.  
  
> [!NOTE]
>  Кодовые страницы ANSI могут различаться на разных компьютерах и могут изменяться на одном компьютере, что приводит к повреждению данных. Для наиболее последовательных результатов следует использовать кодировку Юникода, такую как UTF-8 (кодовая страница 65001) или UTF-16, а не конкретную кодовую страницу.  
  
 <xref:System.Text.Encoding.GetEncoding%2A>Возвращает кэшированный экземпляр с параметрами по умолчанию. Для получения экземпляра с разными параметрами следует использовать конструкторы производных классов. Например, <xref:System.Text.UTF32Encoding> класс предоставляет конструктор, позволяющий включить обнаружение ошибок.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> метод.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> не является допустимым именем кодовой страницы.  
  
-или- 
Кодовая страница, указанная с помощью параметра <paramref name="name" />, не поддерживается используемой платформой.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив, содержащий все кодировки.</summary>
        <returns>Массив, содержащий все кодировки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает список поддерживаемых кодировок, которые уникально различаются кодовой страницей. Таблицу, в которой перечислены поддерживаемые кодировки, см. в <xref:System.Text.Encoding> разделе о классе.  
  
> [!NOTE]
>  Список поддерживаемых кодировок, <xref:System.Text.Encoding.GetEncodings%2A> возвращаемых методом, не включает дополнительных кодировок, доступных для любых <xref:System.Text.EncodingProvider> реализаций, <xref:System.Text.Encoding.RegisterProvider%2A> зарегистрированных с помощью вызовов метода.  
  
 В .NET Framework кодировки 50220 и 50222 сопоставлены с именем "ISO-2022-JP", но они не идентичны. Кодировка 50220 преобразует символы катакана половинной ширины в символы катакана полной ширины, в то время как кодировка 50222 использует последовательность сдвига и сдвига, чтобы кодировать символы катакана половинной ширины. Отображаемое имя для кодировки 50222 — "Японский (JIS-разрешить 1 байт Кана-SO/SI)", чтобы отличать его от кодировки 50220 с отображаемым именем "Японская (JIS)".  
  
 Если вы запрашиваете имя кодировки "ISO-2022-JP", .NET Framework возвращает кодировку 50220. Однако кодировка, соответствующая Вашему приложению, зависит от предпочтительного способа обработки символов катакана половинной ширины.  
  
 Чтобы получить определенную кодировку, следует использовать <xref:System.Text.Encoding.GetEncoding%2A> метод.  
  
 <xref:System.Text.Encoding.GetEncodings%2A>иногда используется для предоставления пользователю списка кодировок в диалоговом окне **Сохранить как** файл. Однако многие кодировки, отличные от Юникода, являются неполными и преобразовывают много символов в "?" или имеют немного другое поведение на разных платформах. В качестве значения по умолчанию можно использовать UTF-8 или UTF-16.  
  
   
  
## Examples  
 В следующем примере проверяются значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код текущего экземпляра.</summary>
        <returns>Хэш-код для текущего экземпляра.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Число кодируемых символов.</param>
        <summary>При переопределении в производном классе вычисляет максимальное количество байтов, полученных при кодировании заданного количества символов.</summary>
        <returns>Максимальное количество байтов, полученных при кодировании заданного количества символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр фактически определяет <xref:System.Char> количество объектов, представляющих символы Юникода для кодирования, так как .NET внутренне использует UTF-16 для представления символов Юникода. `charCount` Следовательно, большинство символов Юникода могут быть представлены одним <xref:System.Char> объектом, но символ Юникода, представленный суррогатной парой, например, требует наличия двух <xref:System.Char> объектов.  
  
 Чтобы вычислить точный размер массива, <xref:System.Text.Encoding.GetBytes%2A> необходимый для хранения результирующих байтов, следует <xref:System.Text.Encoding.GetByteCount%2A> использовать метод. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxByteCount%2A> метод. Метод обычно позволяет выделить меньше памяти, в <xref:System.Text.Encoding.GetMaxByteCount%2A> то время как метод обычно выполняется быстрее. <xref:System.Text.Encoding.GetByteCount%2A>  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A>Извлекает значение наихудшего регистра, включая наихудший случай для выбранного <xref:System.Text.EncoderFallback>в данный момент. Если резервный вариант выбирается с потенциально большой строкой <xref:System.Text.Encoding.GetMaxByteCount%2A> , получает большие значения, особенно в случаях, когда в худшем случае для кодирования требуется переключение режимов для каждого символа. Например, это может произойти для ISO-2022-JP. Дополнительные сведения см. в записи блога "[что такое Encoding. жетмаксбитекаунт () и Encoding. жетмаксчаркаунт ()?](https://blogs.msdn.microsoft.com/shawnste/2005/03/02/whats-with-encoding-getmaxbytecount-and-encoding-getmaxcharcount/)".  
  
 В большинстве случаев этот метод извлекает разумные значения для небольших строк. Для больших строк может потребоваться выбрать один из самых больших буферов и перехват ошибок в редких случаях, когда более разумный буфер слишком мал. Также можно рассмотреть другой подход с помощью <xref:System.Text.Encoding.GetByteCount%2A> или. <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>  
  
 При использовании <xref:System.Text.Encoding.GetMaxByteCount%2A>следует выделить выходной буфер на основе максимального размера входного буфера. Если размер выходного буфера ограничен, можно использовать <xref:System.Text.Encoding.Convert%2A> метод.  
  
 Обратите <xref:System.Text.Encoding.GetMaxByteCount%2A> внимание, что считает потенциальные оставшиеся суррогаты из предыдущей операции декодера. Из-за декодера передача значения 1 в метод получает 2 для однобайтовой кодировки, например ASCII. Если эти сведения необходимы <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> , следует использовать свойство.  
  
> [!NOTE]
>  `GetMaxByteCount(N)`не обязательно то же значение, что `N* GetMaxByteCount(1)`и.  
  
   
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования массива символов, символы кодируются и выводятся полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="charCount" /> меньше нуля.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides"><para>Все <see cref="T:System.Text.Encoding" /> реализации должны гарантировать, что исключения переполнения буфера не возникают, если размер буферов зависит от результатов вычислений этого метода.</para></block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе вычисляет максимальное количество символов, полученных при декодировании заданного количества байтов.</summary>
        <returns>Максимальное количество символов, полученных при декодировании заданного количества байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы вычислить точный размер массива, <xref:System.Text.Encoding.GetChars%2A> необходимый для хранения результирующих символов, следует <xref:System.Text.Encoding.GetCharCount%2A> использовать метод. Чтобы вычислить максимальный размер массива, используйте <xref:System.Text.Encoding.GetMaxCharCount%2A> метод. Метод обычно позволяет выделить меньше памяти, в <xref:System.Text.Encoding.GetMaxCharCount%2A> то время как метод обычно выполняется быстрее. <xref:System.Text.Encoding.GetCharCount%2A>  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A>Извлекает значение наихудшего регистра, включая наихудший случай для выбранного <xref:System.Text.DecoderFallback>в данный момент. Если резервный вариант выбирается с потенциально большой строкой <xref:System.Text.Encoding.GetMaxCharCount%2A> , получает большие значения.  
  
 В большинстве случаев этот метод извлекает разумные числа для небольших строк. Для больших строк может потребоваться выбрать один из самых больших буферов и перехват ошибок в редких случаях, когда более разумный буфер слишком мал. Также можно рассмотреть другой подход с помощью <xref:System.Text.Encoding.GetCharCount%2A> или. <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A>не имеет отношения к <xref:System.Text.Encoding.GetBytes%2A>. Если требуется аналогичная функция для использования с <xref:System.Text.Encoding.GetBytes%2A>, следует использовать. <xref:System.Text.Encoding.GetMaxByteCount%2A>  
  
 При использовании <xref:System.Text.Encoding.GetMaxCharCount%2A>следует выделить выходной буфер на основе максимального размера входного буфера. Если размер выходного буфера ограничен, можно использовать <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> метод.  
  
 Обратите <xref:System.Text.Encoding.GetMaxCharCount%2A> внимание, что считает наихудший случай для оставшихся байтов из предыдущей операции кодировщика. Для большинства кодовых страниц передача значения 0 в этот метод извлекает значения, которые больше или равны 1.  
  
> [!NOTE]
>  `GetMaxCharCount(N)`не обязательно то же значение, что `N* GetMaxCharCount(1)`и.  
  
   
  
## Examples  
 Следующий пример кодирует строку в массив байтов, а затем декодирует байты в массив символов.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="byteCount" /> меньше нуля.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides"><para>Все <see cref="T:System.Text.Encoding" /> реализации должны гарантировать, что исключения переполнения буфера не возникают, если размер буферов зависит от результатов вычислений этого метода.</para></block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе возвращает последовательность байтов, задающую используемую кодировку.</summary>
        <returns>Массив байтов, в котором содержится последовательность байтов, задающая используемую кодировку.  
  
 - или -  
  
 Массив байтов нулевой длины, если преамбула не требуется.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При необходимости <xref:System.Text.Encoding> объект предоставляет преамбулу, которая представляет собой массив байтов, которые можно предварять на последовательность байтов, полученную в результате процесса кодирования. Если преамбула содержит метку порядка байтов (в Юникоде, кодовую точку U + FEFF), она помогает декодеру определить порядок байтов и формат преобразования или кодировку UTF.  
  
 Метка порядка байтов Юникода (BOM) сериализуется следующим образом (в шестнадцатеричном формате):  
  
-   UTF-8: EF BB BF  
  
-   Порядковый номер UTF-16 с обратным порядком байтов: FE FF  
  
-   UTF-16 с прямым порядком байтов: FF FE  
  
-   UTF-32. обратный порядок байтов: 00 00 FE FF  
  
-   UTF-32 с прямым порядком байтов: FF FE 00 00  
  
 Следует использовать спецификацию, поскольку она обеспечивает почти определенную идентификацию кодировки для файлов, которые в противном случае теряют <xref:System.Text.Encoding> ссылку на объект, например, непомеченные или неправильно помеченные веб-данные или случайные текстовые файлы, хранящиеся, если бизнес не наличие международных проблем или других данных. Часто проблемы пользователей могут быть устранены, если данные постоянно и правильно помечены тегами, желательно в UTF-8 или UTF-16.  
  
 Для стандартов, предоставляющих тип кодировки, BOM является несколько избыточным. Однако его можно использовать, чтобы помочь серверу отправить правильный заголовок кодировки. Кроме того, его можно использовать в качестве резервного, если кодировка в противном случае будет потеряна.  
  
 Существует ряд недостатков использования спецификации. Например, знание того, как ограничить поля базы данных, использующие СПЕЦИФИКАЦИю, может оказаться затруднительным. Объединение файлов может быть проблемой, например, при слиянии файлов таким образом, что ненужный символ может оказаться в середине данных. Несмотря на множество недостатков, настоятельно рекомендуется использовать СПЕЦИФИКАЦИю.  
  
 Дополнительные сведения о порядке байтов и метке порядка байтов см. в стандарте Юникода на [домашней странице Юникода](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Чтобы обеспечить правильную декодирование закодированных байтов, следует добавить в байты префикс в формате преамбулы. Однако большинство кодировок не предоставляют преамбулы. Чтобы обеспечить правильную декодирование закодированных байтов, следует использовать кодировку Юникода, то есть <xref:System.Text.UTF8Encoding> <xref:System.Text.UnicodeEncoding>,, или <xref:System.Text.UTF32Encoding>, с преамбулой.  
  
   
  
## Examples  
 В следующем примере определяется порядок байтов кодировки на основе преамбулы.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>При переопределении в производном классе декодирует последовательность байтов в строку.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <summary>При переопределении в производном классе декодирует все байты из указанного массива байтов в строку.</summary>
        <returns>Строка, содержащая результаты декодирования заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> объект, возвращаемый <xref:System.Text.Encoding.GetDecoder%2A> методом & производные класс ВЭД.  
  
 Обсуждение приемов и рекомендаций по <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> декодированию см. в разделе "Примечания" справочного раздела.  
  
 Обратите внимание, что точное поведение <xref:System.Text.Encoding.GetString%2A> метода для конкретной <xref:System.Text.Encoding> реализации зависит от резервной стратегии, определенной для этого <xref:System.Text.Encoding> объекта. Дополнительные сведения см. в разделе "Выбор стратегии резервного использования" статьи [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md) .  
  
   
  
## Examples  
 В следующем примере считывается строка в кодировке UTF-8 из двоичного файла, представленного <xref:System.IO.FileStream> объектом. Для файлов размером менее 2 048 байт он считывает содержимое всего файла в массив байтов и вызывает <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> метод для выполнения декодирования. Для больших файлов он считывает 2 048 байт за раз в массив байтов, вызывает <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> метод, чтобы определить, сколько символов содержится в массиве, а затем <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> вызывает метод для выполнения декодирования.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 В примере используется следующий текст, который должен быть сохранен в файл в кодировке UTF-8 с именем Utf8Example. txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Массив байтов содержит недопустимые точки кода Юникод.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Указатель на массив байтов.</param>
        <param name="byteCount">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе декодирует указанное количество байтов начиная с указанного адреса в строку.</summary>
        <returns>Строка, содержащая результаты декодирования заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetString%2A> Метод предназначен для оптимизации производительности при наличии собственного указателя на массив байтов. Вместо создания управляемого массива байтов, а затем его декодирования, можно вызвать этот метод без создания каких-либо промежуточных объектов.  
  
 Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> объект, возвращаемый <xref:System.Text.Encoding.GetDecoder%2A> методом & производные класс ВЭД.  
  
 Обсуждение приемов и рекомендаций по <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> декодированию см. в разделе "Примечания" справочного раздела.  
  
 Обратите внимание, что точное поведение <xref:System.Text.Encoding.GetString%2A> метода для конкретной <xref:System.Text.Encoding> реализации зависит от резервной стратегии, определенной для этого <xref:System.Text.Encoding> объекта. Дополнительные сведения см. в разделе "Выбор стратегии резервного использования" статьи [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md) .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> является пустым указателем</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="byteCount" /> меньше нуля.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</param>
        <param name="index">Индекс первого декодируемого байта.</param>
        <param name="count">Число байтов для декодирования.</param>
        <summary>При переопределении в производном классе декодирует последовательность байтов из указанного массива байтов в строку.</summary>
        <returns>Строка, содержащая результаты декодирования заданной последовательности байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или, <xref:System.Text.Encoder> предоставленный <xref:System.Text.Encoding.GetDecoder%2A> метод или <xref:System.Text.Encoding.GetEncoder%2A> метод, соответственно, производного класса.  
  
 Обсуждение приемов и рекомендаций по <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> декодированию см. в разделе "Примечания" справочного раздела.  
  
   
  
## Examples  
 В следующем примере считывается строка в кодировке UTF-8 из двоичного файла, представленного <xref:System.IO.FileStream> объектом. Для файлов размером менее 2 048 байт он считывает содержимое всего файла в массив байтов и вызывает <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> метод для выполнения декодирования. Для больших файлов он считывает 2 048 байт за раз в массив байтов, вызывает <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> метод, чтобы определить, сколько символов содержится в массиве, а затем <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> вызывает метод для выполнения декодирования.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 В примере используется следующий текст, который должен быть сохранен в файл в кодировке UTF-8 с именем Utf8Example. txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Массив байтов содержит недопустимые точки кода Юникод.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.  
  
- или - 
 Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md)) 
- и - 
 Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает имя текущей кодировки, которое может использоваться с тегами заголовка сообщения почтового агента.</summary>
        <value>Имя текущего объекта <see cref="T:System.Text.Encoding" />, которое может использоваться с тегами заголовка сообщения почтового агента.  
  
-или- 
Пустая строка (""), если текущий объект <see cref="T:System.Text.Encoding" /> не может использоваться.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если требуется кодировка для имени заголовка, следует вызвать <xref:System.Text.Encoding.GetEncoding%2A> метод <xref:System.Text.Encoding.HeaderName%2A> со свойством. Часто метод извлекает другую кодировку из тестовой кодировки, предоставляемой в вызове. Как правило, для получения такой кодировки требуются только приложения электронной почты.  
  
 В некоторых случаях значение <xref:System.Text.Encoding.BodyName%2A> свойства соответствует международным стандарту, который определяет эту кодировку. Это не означает, что реализация полностью соответствует этому стандарту.  
  
 Обратите <xref:System.Text.Encoding.WebName%2A> внимание, что возвращает имя, используемое для описания кодировки. <xref:System.Text.Encoding.HeaderName%2A> Свойство определяет другую кодировку, которая может работать лучше для приложения электронной почты, например. Однако использовать свойство для определения кодировки не рекомендуется.  
  
   
  
## Examples  
 В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки с одним или несколькими именами, отличающимися <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>от. Он отображается <xref:System.Text.Encoding.EncodingName%2A> , но не сравнивается с ним.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает значение, которое указывает, является ли текущая кодировка всегда нормированной.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает значение, которое указывает, является ли текущая кодировка всегда нормализованной с использованием формы нормализации по умолчанию.</summary>
        <returns><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> всегда нормирован; в противоположном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию используется форма <xref:System.Text.NormalizationForm.FormC>нормализации, которая использует полную каноническую декомпозицию, а затем заменяет последовательности на их основные составные части, если это возможно.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="form">Одно из значений перечисления <see cref="T:System.Text.NormalizationForm" />.</param>
        <summary>При переопределении в производном классе получает значение, которое указывает, является ли текущая кодировка всегда нормализованной с использованием заданной по умолчанию формы нормализации.</summary>
        <returns><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> всегда нормализуется с использованием заданного значения <see cref="T:System.Text.NormalizationForm" />; в противоположном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию используется форма <xref:System.Text.NormalizationForm.FormC>нормализации, которая использует полную каноническую декомпозицию, а затем заменяет последовательности на их основные составные части, если это возможно.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, может ли текущая кодировка использоваться клиентами браузера для отображения содержимого.</summary>
        <value><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> может использоваться клиентами браузера для отображения содержимого; в противоположном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяются значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, может ли текущая кодировка использоваться клиентами браузера для сохранения содержимого.</summary>
        <value><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> может использоваться клиентами браузера для сохранения содержимого; в противоположном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяются значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, может ли текущая кодировка использоваться клиентами электронной почты и новостей для отображения содержимого.</summary>
        <value><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> может использоваться клиентами электронной почты и новостей для отображения содержимого; в противоположном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяются значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, может ли текущая кодировка использоваться клиентами электронной почты и новостей для сохранения содержимого.</summary>
        <value><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> может использоваться клиентами почты и новостей для сохранения содержимого; в противоположном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяются значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, является ли текущая кодировка доступной только для чтения.</summary>
        <value>Значение <see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> доступен только для чтения, в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, используются ли в текущей кодировке однобайтовые кодовые точки.</summary>
        <value><see langword="true" />, если в текущем объекте <see cref="T:System.Text.Encoding" /> используются однобайтовые кодовые точки; в противоположном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Например, для однобайтовой кодировки <xref:System.Text.ASCIIEncoding>это свойство извлекает. `true`  
  
> [!CAUTION]
>  Следует соблюдать осторожность в том, что делает приложение со значением <xref:System.Text.Encoding.IsSingleByte%2A>. Предположение о том, как будет продолжаться кодирование, может быть неправильным. Например, Windows-1252 имеет значение `true` для <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, а Encoding. жетмаксбитекаунт (1) возвращает 2. Это обусловлено тем, что метод рассматривает потенциальные оставшиеся суррогаты из предыдущей операции декодера.  
  
   
  
## Examples  
 В следующем примере проверяются значения логических свойств каждой кодировки.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Подкласс класса <see cref="T:System.Text.EncodingProvider" />, который предоставляет доступ к дополнительным кодировкам символов.</param>
        <summary>Регистрирует поставщик кодировки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод позволяет зарегистрировать класс, производный от <xref:System.Text.EncodingProvider> , который делает кодировки символов доступными на платформе, которая не поддерживает их в других случаях. <xref:System.Text.Encoding.RegisterProvider%2A> После регистрации поставщика кодировок можно извлечь поддерживаемые им кодировки, вызвав любую <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> перегрузку. При наличии нескольких поставщиков кодировок <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> метод пытается получить указанную кодировку от каждого поставщика, начиная с последней зарегистрированной.

Регистрация поставщика кодирования с помощью <xref:System.Text.Encoding.RegisterProvider%2A> метода также изменяет поведение методов [Encoding. Encoding (Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) и [EncodingProvider. Encoding (Int32, EncoderFallback, DecoderFallback)](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) при передаче `0`аргумент:

- Если зарегистрированный поставщик — <xref:System.Text.CodePagesEncodingProvider>, метод возвращает кодировку, соответствующую системной активной кодовой странице при работе в операционной системе Windows.

- Пользовательский поставщик кодировок может выбрать, какую кодировку следует возвращать, когда <xref:System.Text.Encoding.GetEncoding%2A> любой из этих перегрузок метода передается `0`аргументом. Поставщик может также выбрать не возвращать кодировку, выполнив <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> возврат `null`метода. 
  
Начиная с .NET Framework 4,6 .NET Framework включает один поставщик <xref:System.Text.CodePagesEncodingProvider>кодировок, который делает кодировки, присутствующие в полной .NET Framework, но недоступные в универсальная платформа Windows. По умолчанию универсальная платформа Windows поддерживает только кодировки Юникода, ASCII и кодовую страницу 28591.  
  
 Если один и тот же поставщик кодирования используется в нескольких вызовах <xref:System.Text.Encoding.RegisterProvider%2A> метода, поставщик регистрируется только в первом вызове метода. Последующие вызовы игнорируются.  
  
 <xref:System.Text.Encoding.RegisterProvider%2A> Если метод вызывается для регистрации нескольких поставщиков, обрабатывающих одну и ту же кодировку, последний зарегистрированный поставщик используется для всех операций кодирования и декодирования. Все ранее зарегистрированные поставщики игнорируются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="provider" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для формата UTF-16 с прямым порядком байтов.</summary>
        <value>Кодировка для формата UTF-16 с прямым порядком байтов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сведения о кодировках, поддерживаемых .NET, и о том, какую кодировку Юникод использовать, см. [в разделе кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UnicodeEncoding> Объект, возвращаемый этим свойством, может не иметь соответствующего поведения для приложения. Он использует резервный вариант замены, чтобы заменить каждую строку, которую не удается закодировать, и каждый байт, который не может быть декодирован символом вопросительного знака ("?"). Вместо <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> этого можно вызвать конструктор для создания экземпляра с прямым порядком байтов <xref:System.Text.UnicodeEncoding> , резерв <xref:System.Text.EncoderFallbackException> которого <xref:System.Text.DecoderFallbackException>является либо или, как показано в следующем примере.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования массива символов, символы кодируются и выводятся полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для формата UTF-32 с прямым порядком байтов.</summary>
        <value>Объект кодировки для формата UTF-32 с прямым порядком байтов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding> Объект, возвращаемый этим свойством, может не иметь соответствующего поведения для приложения. Он использует резервный вариант замены, чтобы заменить каждую строку, которую не удается закодировать, и каждый байт, который не может быть декодирован СИМВОЛом замены Юникода (U + ФФФЕ). Вместо этого можно <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> вызвать конструктор для создания экземпляра <xref:System.Text.UTF32Encoding> объекта <xref:System.Text.DecoderFallbackException>, резерв <xref:System.Text.EncoderFallbackException> которого является либо или, как показано в следующем примере.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Обсуждение с прямым порядком байтов см. в <xref:System.Text.Encoding> разделе, посвященном классу.  
  
 Сведения о кодировках, поддерживаемых .NET, и о том, какую кодировку Юникод использовать, см. [в разделе кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования массива символов, символы кодируются и выводятся полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для формата UTF-7.</summary>
        <value>Кодировка для формата UTF-7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодировка UTF-7 используется главным образом в средах, где исторически были ограничены 7 битами, например NNTP и некоторые приложения электронной почты. Из-за проблем с надежностью и безопасностью не следует использовать кодирование UTF7 в 8-разрядных средах, где вместо этого можно использовать кодировку UTF-8.  
  
   
  
## Examples  
 В следующем примере определяется число байтов, необходимое для кодирования массива символов, символы кодируются и выводятся полученные байты.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку для формата UTF-8.</summary>
        <value>Кодировка для формата UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает <xref:System.Text.UTF8Encoding> объект, который кодирует символы в кодировке Юникод (UTF-16) в последовательность от одного до четырех байтов на символ и декодирует массив байтов в кодировке UTF-8 в символы Юникода (UTF-16-Encoded). Сведения о кодировках символов, поддерживаемых .NET, и обсуждении используемой кодировки Юникод см. в разделе [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UTF8Encoding> Объект, возвращаемый этим свойством, может не иметь соответствующего поведения для приложения.  
  
-   Он возвращает <xref:System.Text.UTF8Encoding> объект, который предоставляет метку порядка байтов Юникода (BOM). Чтобы создать экземпляр кодировки UTF8, которая не предоставляет спецификацию, вызовите любую перегрузку <xref:System.Text.UTF8Encoding.%23ctor%2A> конструктора.  
  
-   Он возвращает <xref:System.Text.UTF8Encoding> объект, который использует резервную замену, чтобы заменить каждую строку, которая не может быть закодирована, и каждый байт, который не может быть декодирован символом вопросительного знака ("?"). Вместо этого можно <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> вызвать конструктор для создания экземпляра <xref:System.Text.UTF8Encoding> объекта <xref:System.Text.DecoderFallbackException>, резерв <xref:System.Text.EncoderFallbackException> которого является либо или, как показано в следующем примере.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 В следующем примере определяется массив, состоящий из следующих символов:  
  
-   ЛАТИНСКАЯ СТРОЧНАЯ БУКВА Z (U + 007A)  
  
-   ЛАТИНСКАЯ СТРОЧНАЯ БУКВА A (U + 0061)  
  
-   ОБЪЕДИНЕНИЕ БРЕВЕ; (U + 0306)  
  
-   ЛАТИНСКАЯ МАЛЕНЬКАЯ БУКВА AE С АКУТОМ (U + 01FD)  
  
-   ГРЕЧЕСКАЯ СТРОЧНАЯ БУКВА BETA (U + 03B2)  
  
-   Суррогатная пара (U + D800 U + DD54), которая Forms ГРЕЧЕСКая АКРОФОНИК ЧЕРДАКЕ 1000 STATs (U + 10154).  
  
 Он отображает единицы кода в кодировке UTF-16 каждого символа и определяет число байтов, необходимое кодировщику UTF-8 для кодирования массива символов. Затем он кодирует символы и отображает результирующие байты в кодировке UTF-8.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Общие сведения о кодировках</related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает для текущей кодировки имя, зарегистрированное в IANA (Internet Assigned Numbers Authority).</summary>
        <value>Имя IANA для текущего объекта <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.WebName%2A> Свойство<xref:System.Text.EncodingInfo.Name%2A> совпадает со свойством.  
  
 Обратите <xref:System.Text.Encoding.WebName%2A> внимание, что Возвращает зарегистрированное IANA имя для кодировки. Если его значение является именем стандартного, реализация кодировки может не соответствовать этому стандарту. <xref:System.Text.Encoding.HeaderName%2A> Свойство определяет другую кодировку, которая может лучше работать для заголовков электронной почты. Однако вместо этого следует использовать <xref:System.Text.Encoding.WebName%2A> большинство приложений.  
  
 Дополнительные сведения о IANA см. по адресу [www.IANA.org](https://www.iana.org/).  
  
 Совпадает с методом, возвращаемым методом <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>. <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> Некоторые веб-имена являются повторяющимися; Дополнительные сведения см. <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> в примечаниях.  
  
   
  
## Examples  
 Следующий пример включает <xref:System.Text.Encoding.WebName%2A> в себя заголовок HTML.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки с одним или несколькими именами, отличающимися <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>от. Он отображается <xref:System.Text.Encoding.EncodingName%2A> , но не сравнивается с ним.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает кодовую страницу операционной системы Windows, наиболее точно соответствующую текущей кодировке.</summary>
        <value>Кодовая страница операционной системы Windows, наиболее точно соответствующая текущему объекту <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предназначено для совместимости с API-интерфейсами Windows для различных языков (MLang), например при определении семейств шрифтов. Для глобализации вместо этого рекомендуется использовать одну из кодировок Юникода. Также рекомендуется использовать <xref:System.Text.Encoding.WebName%2A> <xref:System.Text.Encoding.WindowsCodePage%2A> вместо для распознавания кодовой страницы.  
  
   
  
## Examples  
 В следующем примере определяется кодовая страница Windows, наиболее близко соответствующая каждой кодировке.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>
