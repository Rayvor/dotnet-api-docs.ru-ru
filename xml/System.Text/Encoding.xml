<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2483338405b9410628ee67ae0439634a8f3ff1b5" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73381057" /></Metadata><TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="5e6a0-101">Представляет кодировку символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-101">Represents a character encoding.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-102">Кодирование - это процесс преобразования набора символов Юникода в последовательность байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-102">Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</span></span> <span data-ttu-id="5e6a0-103">В отличие от декодирования — это процесс преобразования последовательности закодированных байтов в набор символов Юникода.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-103">In contrast, decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</span></span> <span data-ttu-id="5e6a0-104">Сведения о форматах преобразования Юникода (Утфс) и других кодировках, поддерживаемых <xref:System.Text.Encoding>, см. [в разделе кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-104">For information about the Unicode Transformation Formats (UTFs) and other encodings supported by <xref:System.Text.Encoding>, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
 <span data-ttu-id="5e6a0-105">Обратите внимание, что <xref:System.Text.Encoding> предназначен для работы с символами Юникода вместо произвольных двоичных данных, таких как байтовые массивы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-105">Note that <xref:System.Text.Encoding> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="5e6a0-106">Если необходимо закодировать произвольные двоичные данные в текст, следует использовать протокол, такой как uuencode, который реализуется такими методами, как <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-106">If you must encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5e6a0-107">.NET предоставляет следующие реализации класса <xref:System.Text.Encoding> для поддержки текущих кодировок Юникода и других кодировок:</span><span class="sxs-lookup"><span data-stu-id="5e6a0-107">.NET provides the following implementations of the <xref:System.Text.Encoding> class to support current Unicode encodings and other encodings:</span></span>  
  
-   <span data-ttu-id="5e6a0-108"><xref:System.Text.ASCIIEncoding> кодирует символы Юникода как однострочные 7-разрядные символы ASCII.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-108"><xref:System.Text.ASCIIEncoding> encodes Unicode characters as single 7-bit ASCII characters.</span></span> <span data-ttu-id="5e6a0-109">Эта кодировка поддерживает только символьные значения в диапазоне от U + 0000 до U + 007F.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-109">This encoding only supports character values between U+0000 and U+007F.</span></span> <span data-ttu-id="5e6a0-110">Кодовая страница 20127.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-110">Code page 20127.</span></span> <span data-ttu-id="5e6a0-111">Также доступно через свойство <xref:System.Text.Encoding.ASCII%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-111">Also available through the <xref:System.Text.Encoding.ASCII%2A> property.</span></span>  
  
-   <span data-ttu-id="5e6a0-112"><xref:System.Text.UTF7Encoding> кодирует символы Юникода в кодировке UTF-7.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-112"><xref:System.Text.UTF7Encoding> encodes Unicode characters using the UTF-7 encoding.</span></span> <span data-ttu-id="5e6a0-113">Эта кодировка поддерживает все значения символов Юникода.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-113">This encoding supports all Unicode character values.</span></span> <span data-ttu-id="5e6a0-114">Кодовая страница 65000.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-114">Code page 65000.</span></span> <span data-ttu-id="5e6a0-115">Также доступно через свойство <xref:System.Text.Encoding.UTF7%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-115">Also available through the <xref:System.Text.Encoding.UTF7%2A> property.</span></span>  
  
-   <span data-ttu-id="5e6a0-116"><xref:System.Text.UTF8Encoding> кодирует символы Юникода в кодировке UTF-8.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-116"><xref:System.Text.UTF8Encoding> encodes Unicode characters using the UTF-8 encoding.</span></span> <span data-ttu-id="5e6a0-117">Эта кодировка поддерживает все значения символов Юникода.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-117">This encoding supports all Unicode character values.</span></span> <span data-ttu-id="5e6a0-118">Кодовая страница 65001.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-118">Code page 65001.</span></span> <span data-ttu-id="5e6a0-119">Также доступно через свойство <xref:System.Text.Encoding.UTF8%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-119">Also available through the <xref:System.Text.Encoding.UTF8%2A> property.</span></span>  
  
-   <span data-ttu-id="5e6a0-120"><xref:System.Text.UnicodeEncoding> кодирует символы Юникода в кодировке UTF-16.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-120"><xref:System.Text.UnicodeEncoding> encodes Unicode characters using the UTF-16 encoding.</span></span> <span data-ttu-id="5e6a0-121">Поддерживаются как прямой, так и обратный порядок байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-121">Both little endian and big endian byte orders are supported.</span></span> <span data-ttu-id="5e6a0-122">Также доступно через свойство <xref:System.Text.Encoding.Unicode%2A> и свойство <xref:System.Text.Encoding.BigEndianUnicode%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-122">Also available through the <xref:System.Text.Encoding.Unicode%2A> property and the <xref:System.Text.Encoding.BigEndianUnicode%2A> property.</span></span>  
  
-   <span data-ttu-id="5e6a0-123"><xref:System.Text.UTF32Encoding> кодирует символы Юникода в кодировке UTF-32.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-123"><xref:System.Text.UTF32Encoding> encodes Unicode characters using the UTF-32 encoding.</span></span> <span data-ttu-id="5e6a0-124">Поддерживаются как с прямым порядком байтов (кодовая страница 12000), так и с обратным порядком байтов (кодовая страница 12001).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-124">Both little endian (code page 12000) and big endian (code page 12001) byte orders are supported.</span></span> <span data-ttu-id="5e6a0-125">Также доступно через свойство <xref:System.Text.Encoding.UTF32%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-125">Also available through the <xref:System.Text.Encoding.UTF32%2A> property.</span></span>  
  
 <span data-ttu-id="5e6a0-126">Класс <xref:System.Text.Encoding> в основном предназначен для преобразования между различными кодировками и Юникодом.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-126">The <xref:System.Text.Encoding> class is primarily intended to convert between different encodings and Unicode.</span></span> <span data-ttu-id="5e6a0-127">Часто один из производных классов Юникода является правильным выбором для вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-127">Often one of the derived Unicode classes is the correct choice for your app.</span></span>  
  
 <span data-ttu-id="5e6a0-128">Используйте метод <xref:System.Text.Encoding.GetEncoding%2A> для получения других кодировок и вызовите метод <xref:System.Text.Encoding.GetEncodings%2A>, чтобы получить список всех кодировок.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-128">Use the <xref:System.Text.Encoding.GetEncoding%2A> method to obtain other encodings, and call the <xref:System.Text.Encoding.GetEncodings%2A> method to get a list of all encodings.</span></span>  
  
 <span data-ttu-id="5e6a0-129">В следующей таблице перечислены кодировки, поддерживаемые .NET Framework и .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-129">The following table lists the encodings supported by .NET Framework and .NET Core.</span></span> <span data-ttu-id="5e6a0-130">В нем перечислены номера кодовой страницы каждой кодировки и значения свойств кодировки <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> и <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-130">It lists each encoding's code page number and the values of the encoding's <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> and <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="5e6a0-131">Флажок в столбцах поддержка **.NET Framework** и **.NET Core** указывает на то, что кодовая страница изначально поддерживается этой реализацией .NET, независимо от базовой платформы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-131">A check mark in the **.NET Framework support** and **.NET Core support** columns indicates that the code page is natively supported by that .NET implementation, regardless of the underlying platform.</span></span> <span data-ttu-id="5e6a0-132">Для .NET Framework доступность других кодировок, перечисленных в таблице, зависит от операционной системы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-132">For .NET Framework, the availability of other encodings listed in the table depends on the operating system.</span></span> <span data-ttu-id="5e6a0-133">Для .NET Core другие кодировки доступны с помощью класса <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> или производного от класса <xref:System.Text.EncodingProvider?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-133">For .NET Core, other encodings are available by using the <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> class or by deriving from the <xref:System.Text.EncodingProvider?displayProperty=nameWithType> class.</span></span>  

> [!NOTE]
> <span data-ttu-id="5e6a0-134">Кодовые страницы, свойства <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> которых соответствуют международным стандартам, не обязательно полностью соответствуют этому стандарту.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-134">Code pages whose <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> property corresponds to an international standard do not necessarily comply in full with that standard.</span></span> 

|<span data-ttu-id="5e6a0-135">Кодовая страница</span><span class="sxs-lookup"><span data-stu-id="5e6a0-135">Code page</span></span>|<span data-ttu-id="5e6a0-136">name</span><span class="sxs-lookup"><span data-stu-id="5e6a0-136">Name</span></span>|<span data-ttu-id="5e6a0-137">Отображаемое имя</span><span class="sxs-lookup"><span data-stu-id="5e6a0-137">Display name</span></span>|<span data-ttu-id="5e6a0-138">Поддержка .NET Framework</span><span class="sxs-lookup"><span data-stu-id="5e6a0-138">.NET Framework support</span></span>| <span data-ttu-id="5e6a0-139">Поддержка .NET Core</span><span class="sxs-lookup"><span data-stu-id="5e6a0-139">.NET Core support</span></span> | 
|---------|----|------------|----------------------|-------------------|    
|<span data-ttu-id="5e6a0-140">37</span><span class="sxs-lookup"><span data-stu-id="5e6a0-140">37</span></span>|<span data-ttu-id="5e6a0-141">IBM037</span><span class="sxs-lookup"><span data-stu-id="5e6a0-141">IBM037</span></span>|<span data-ttu-id="5e6a0-142">IBM EBCDIC (США-Канада)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-142">IBM EBCDIC (US-Canada)</span></span>|||  
|<span data-ttu-id="5e6a0-143">437</span><span class="sxs-lookup"><span data-stu-id="5e6a0-143">437</span></span>|<span data-ttu-id="5e6a0-144">IBM437</span><span class="sxs-lookup"><span data-stu-id="5e6a0-144">IBM437</span></span>|<span data-ttu-id="5e6a0-145">OEM США</span><span class="sxs-lookup"><span data-stu-id="5e6a0-145">OEM United States</span></span>|||  
|<span data-ttu-id="5e6a0-146">500</span><span class="sxs-lookup"><span data-stu-id="5e6a0-146">500</span></span>|<span data-ttu-id="5e6a0-147">IBM500</span><span class="sxs-lookup"><span data-stu-id="5e6a0-147">IBM500</span></span>|<span data-ttu-id="5e6a0-148">IBM EBCDIC (Международная)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-148">IBM EBCDIC (International)</span></span>|||  
|<span data-ttu-id="5e6a0-149">708</span><span class="sxs-lookup"><span data-stu-id="5e6a0-149">708</span></span>|<span data-ttu-id="5e6a0-150">ASMO-708</span><span class="sxs-lookup"><span data-stu-id="5e6a0-150">ASMO-708</span></span>|<span data-ttu-id="5e6a0-151">Арабский (ASMO 708)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-151">Arabic (ASMO 708)</span></span>|||  
|<span data-ttu-id="5e6a0-152">720</span><span class="sxs-lookup"><span data-stu-id="5e6a0-152">720</span></span>|<span data-ttu-id="5e6a0-153">DOS-720</span><span class="sxs-lookup"><span data-stu-id="5e6a0-153">DOS-720</span></span>|<span data-ttu-id="5e6a0-154">Арабский (DOS)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-154">Arabic (DOS)</span></span>|||  
|<span data-ttu-id="5e6a0-155">737</span><span class="sxs-lookup"><span data-stu-id="5e6a0-155">737</span></span>|<span data-ttu-id="5e6a0-156">ibm737</span><span class="sxs-lookup"><span data-stu-id="5e6a0-156">ibm737</span></span>|<span data-ttu-id="5e6a0-157">Греческий (DOS)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-157">Greek (DOS)</span></span>|||  
|<span data-ttu-id="5e6a0-158">775</span><span class="sxs-lookup"><span data-stu-id="5e6a0-158">775</span></span>|<span data-ttu-id="5e6a0-159">ibm775</span><span class="sxs-lookup"><span data-stu-id="5e6a0-159">ibm775</span></span>|<span data-ttu-id="5e6a0-160">Балтийская (DOS)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-160">Baltic (DOS)</span></span>|||  
|<span data-ttu-id="5e6a0-161">850</span><span class="sxs-lookup"><span data-stu-id="5e6a0-161">850</span></span>|<span data-ttu-id="5e6a0-162">ibm850</span><span class="sxs-lookup"><span data-stu-id="5e6a0-162">ibm850</span></span>|<span data-ttu-id="5e6a0-163">Западная Европа (DOS)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-163">Western European (DOS)</span></span>|||  
|<span data-ttu-id="5e6a0-164">852</span><span class="sxs-lookup"><span data-stu-id="5e6a0-164">852</span></span>|<span data-ttu-id="5e6a0-165">ibm852</span><span class="sxs-lookup"><span data-stu-id="5e6a0-165">ibm852</span></span>|<span data-ttu-id="5e6a0-166">Центральноевропейская (DOS)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-166">Central European (DOS)</span></span>|||  
|<span data-ttu-id="5e6a0-167">855</span><span class="sxs-lookup"><span data-stu-id="5e6a0-167">855</span></span>|<span data-ttu-id="5e6a0-168">IBM855</span><span class="sxs-lookup"><span data-stu-id="5e6a0-168">IBM855</span></span>|<span data-ttu-id="5e6a0-169">OEM кириллица</span><span class="sxs-lookup"><span data-stu-id="5e6a0-169">OEM Cyrillic</span></span>|||  
|<span data-ttu-id="5e6a0-170">857</span><span class="sxs-lookup"><span data-stu-id="5e6a0-170">857</span></span>|<span data-ttu-id="5e6a0-171">ibm857</span><span class="sxs-lookup"><span data-stu-id="5e6a0-171">ibm857</span></span>|<span data-ttu-id="5e6a0-172">Турецкий (DOS)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-172">Turkish (DOS)</span></span>|||  
|<span data-ttu-id="5e6a0-173">858</span><span class="sxs-lookup"><span data-stu-id="5e6a0-173">858</span></span>|<span data-ttu-id="5e6a0-174">IBM00858</span><span class="sxs-lookup"><span data-stu-id="5e6a0-174">IBM00858</span></span>|<span data-ttu-id="5e6a0-175">OEM многоязычная латиница I</span><span class="sxs-lookup"><span data-stu-id="5e6a0-175">OEM Multilingual Latin I</span></span>|||  
|<span data-ttu-id="5e6a0-176">860</span><span class="sxs-lookup"><span data-stu-id="5e6a0-176">860</span></span>|<span data-ttu-id="5e6a0-177">IBM860</span><span class="sxs-lookup"><span data-stu-id="5e6a0-177">IBM860</span></span>|<span data-ttu-id="5e6a0-178">Португальский (DOS)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-178">Portuguese (DOS)</span></span>|||  
|<span data-ttu-id="5e6a0-179">861</span><span class="sxs-lookup"><span data-stu-id="5e6a0-179">861</span></span>|<span data-ttu-id="5e6a0-180">ibm861</span><span class="sxs-lookup"><span data-stu-id="5e6a0-180">ibm861</span></span>|<span data-ttu-id="5e6a0-181">Исландский (DOS)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-181">Icelandic (DOS)</span></span>|||  
|<span data-ttu-id="5e6a0-182">862</span><span class="sxs-lookup"><span data-stu-id="5e6a0-182">862</span></span>|<span data-ttu-id="5e6a0-183">DOS-862</span><span class="sxs-lookup"><span data-stu-id="5e6a0-183">DOS-862</span></span>|<span data-ttu-id="5e6a0-184">Иврит (DOS)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-184">Hebrew (DOS)</span></span>|||  
|<span data-ttu-id="5e6a0-185">863</span><span class="sxs-lookup"><span data-stu-id="5e6a0-185">863</span></span>|<span data-ttu-id="5e6a0-186">IBM863</span><span class="sxs-lookup"><span data-stu-id="5e6a0-186">IBM863</span></span>|<span data-ttu-id="5e6a0-187">Французская Канада (DOS)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-187">French Canadian (DOS)</span></span>|||  
|<span data-ttu-id="5e6a0-188">864</span><span class="sxs-lookup"><span data-stu-id="5e6a0-188">864</span></span>|<span data-ttu-id="5e6a0-189">IBM864</span><span class="sxs-lookup"><span data-stu-id="5e6a0-189">IBM864</span></span>|<span data-ttu-id="5e6a0-190">Арабский (864)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-190">Arabic (864)</span></span>|||  
|<span data-ttu-id="5e6a0-191">865</span><span class="sxs-lookup"><span data-stu-id="5e6a0-191">865</span></span>|<span data-ttu-id="5e6a0-192">IBM865</span><span class="sxs-lookup"><span data-stu-id="5e6a0-192">IBM865</span></span>|<span data-ttu-id="5e6a0-193">Скандинавский (DOS)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-193">Nordic (DOS)</span></span>|||  
|<span data-ttu-id="5e6a0-194">866</span><span class="sxs-lookup"><span data-stu-id="5e6a0-194">866</span></span>|<span data-ttu-id="5e6a0-195">cp866</span><span class="sxs-lookup"><span data-stu-id="5e6a0-195">cp866</span></span>|<span data-ttu-id="5e6a0-196">Кириллица (DOS)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-196">Cyrillic (DOS)</span></span>|||  
|<span data-ttu-id="5e6a0-197">869</span><span class="sxs-lookup"><span data-stu-id="5e6a0-197">869</span></span>|<span data-ttu-id="5e6a0-198">ibm869</span><span class="sxs-lookup"><span data-stu-id="5e6a0-198">ibm869</span></span>|<span data-ttu-id="5e6a0-199">Греческий, современный (DOS)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-199">Greek, Modern (DOS)</span></span>|||  
|<span data-ttu-id="5e6a0-200">870</span><span class="sxs-lookup"><span data-stu-id="5e6a0-200">870</span></span>|<span data-ttu-id="5e6a0-201">IBM870</span><span class="sxs-lookup"><span data-stu-id="5e6a0-201">IBM870</span></span>|<span data-ttu-id="5e6a0-202">IBM EBCDIC (многоязычная латиница-2)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-202">IBM EBCDIC (Multilingual Latin-2)</span></span>|||  
|<span data-ttu-id="5e6a0-203">874</span><span class="sxs-lookup"><span data-stu-id="5e6a0-203">874</span></span>|<span data-ttu-id="5e6a0-204">Windows — 874</span><span class="sxs-lookup"><span data-stu-id="5e6a0-204">windows-874</span></span>|<span data-ttu-id="5e6a0-205">Тайский (Windows)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-205">Thai (Windows)</span></span>|||  
|<span data-ttu-id="5e6a0-206">875</span><span class="sxs-lookup"><span data-stu-id="5e6a0-206">875</span></span>|<span data-ttu-id="5e6a0-207">cp875</span><span class="sxs-lookup"><span data-stu-id="5e6a0-207">cp875</span></span>|<span data-ttu-id="5e6a0-208">IBM EBCDIC (греческая современная)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-208">IBM EBCDIC (Greek Modern)</span></span>|||  
|<span data-ttu-id="5e6a0-209">932</span><span class="sxs-lookup"><span data-stu-id="5e6a0-209">932</span></span>|<span data-ttu-id="5e6a0-210">shift_jis</span><span class="sxs-lookup"><span data-stu-id="5e6a0-210">shift_jis</span></span>|<span data-ttu-id="5e6a0-211">Японская (Shift-JIS)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-211">Japanese (Shift-JIS)</span></span>|||  
|<span data-ttu-id="5e6a0-212">936</span><span class="sxs-lookup"><span data-stu-id="5e6a0-212">936</span></span>|<span data-ttu-id="5e6a0-213">GB2312</span><span class="sxs-lookup"><span data-stu-id="5e6a0-213">gb2312</span></span>|<span data-ttu-id="5e6a0-214">Китайская упрощенная (GB2312)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-214">Chinese Simplified (GB2312)</span></span>|<span data-ttu-id="5e6a0-215">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-215">✓</span></span>||  
|<span data-ttu-id="5e6a0-216">949</span><span class="sxs-lookup"><span data-stu-id="5e6a0-216">949</span></span>|<span data-ttu-id="5e6a0-217">ks_c_5601 — 1987</span><span class="sxs-lookup"><span data-stu-id="5e6a0-217">ks_c_5601-1987</span></span>|<span data-ttu-id="5e6a0-218">Корейский</span><span class="sxs-lookup"><span data-stu-id="5e6a0-218">Korean</span></span>|||  
|<span data-ttu-id="5e6a0-219">950</span><span class="sxs-lookup"><span data-stu-id="5e6a0-219">950</span></span>|<span data-ttu-id="5e6a0-220">традиционн</span><span class="sxs-lookup"><span data-stu-id="5e6a0-220">big5</span></span>|<span data-ttu-id="5e6a0-221">Китайская традиционная (Big5)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-221">Chinese Traditional (Big5)</span></span>|||  
|<span data-ttu-id="5e6a0-222">1026</span><span class="sxs-lookup"><span data-stu-id="5e6a0-222">1026</span></span>|<span data-ttu-id="5e6a0-223">IBM1026</span><span class="sxs-lookup"><span data-stu-id="5e6a0-223">IBM1026</span></span>|<span data-ttu-id="5e6a0-224">IBM EBCDIC (турецкая латиница-5)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-224">IBM EBCDIC (Turkish Latin-5)</span></span>|||  
|<span data-ttu-id="5e6a0-225">1047</span><span class="sxs-lookup"><span data-stu-id="5e6a0-225">1047</span></span>|<span data-ttu-id="5e6a0-226">IBM01047</span><span class="sxs-lookup"><span data-stu-id="5e6a0-226">IBM01047</span></span>|<span data-ttu-id="5e6a0-227">IBM Latin-1</span><span class="sxs-lookup"><span data-stu-id="5e6a0-227">IBM Latin-1</span></span>|||  
|<span data-ttu-id="5e6a0-228">1140</span><span class="sxs-lookup"><span data-stu-id="5e6a0-228">1140</span></span>|<span data-ttu-id="5e6a0-229">IBM01140</span><span class="sxs-lookup"><span data-stu-id="5e6a0-229">IBM01140</span></span>|<span data-ttu-id="5e6a0-230">IBM EBCDIC (США-Канада-евро)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-230">IBM EBCDIC (US-Canada-Euro)</span></span>|||  
|<span data-ttu-id="5e6a0-231">1141</span><span class="sxs-lookup"><span data-stu-id="5e6a0-231">1141</span></span>|<span data-ttu-id="5e6a0-232">IBM01141</span><span class="sxs-lookup"><span data-stu-id="5e6a0-232">IBM01141</span></span>|<span data-ttu-id="5e6a0-233">IBM EBCDIC (Германия-евро)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-233">IBM EBCDIC (Germany-Euro)</span></span>|||  
|<span data-ttu-id="5e6a0-234">1142</span><span class="sxs-lookup"><span data-stu-id="5e6a0-234">1142</span></span>|<span data-ttu-id="5e6a0-235">IBM01142</span><span class="sxs-lookup"><span data-stu-id="5e6a0-235">IBM01142</span></span>|<span data-ttu-id="5e6a0-236">IBM EBCDIC (Дания-Норвегия-евро)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-236">IBM EBCDIC (Denmark-Norway-Euro)</span></span>|||  
|<span data-ttu-id="5e6a0-237">1143</span><span class="sxs-lookup"><span data-stu-id="5e6a0-237">1143</span></span>|<span data-ttu-id="5e6a0-238">IBM01143</span><span class="sxs-lookup"><span data-stu-id="5e6a0-238">IBM01143</span></span>|<span data-ttu-id="5e6a0-239">IBM EBCDIC (Финляндия-Швеция-евро)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-239">IBM EBCDIC (Finland-Sweden-Euro)</span></span>|||  
|<span data-ttu-id="5e6a0-240">1144</span><span class="sxs-lookup"><span data-stu-id="5e6a0-240">1144</span></span>|<span data-ttu-id="5e6a0-241">IBM01144</span><span class="sxs-lookup"><span data-stu-id="5e6a0-241">IBM01144</span></span>|<span data-ttu-id="5e6a0-242">IBM EBCDIC (Италия-Европа)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-242">IBM EBCDIC (Italy-Euro)</span></span>|||  
|<span data-ttu-id="5e6a0-243">1145</span><span class="sxs-lookup"><span data-stu-id="5e6a0-243">1145</span></span>|<span data-ttu-id="5e6a0-244">IBM01145</span><span class="sxs-lookup"><span data-stu-id="5e6a0-244">IBM01145</span></span>|<span data-ttu-id="5e6a0-245">IBM EBCDIC (Испания-евро)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-245">IBM EBCDIC (Spain-Euro)</span></span>|||  
|<span data-ttu-id="5e6a0-246">1146</span><span class="sxs-lookup"><span data-stu-id="5e6a0-246">1146</span></span>|<span data-ttu-id="5e6a0-247">IBM01146</span><span class="sxs-lookup"><span data-stu-id="5e6a0-247">IBM01146</span></span>|<span data-ttu-id="5e6a0-248">IBM EBCDIC (Великобритания-Европа)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-248">IBM EBCDIC (UK-Euro)</span></span>|||  
|<span data-ttu-id="5e6a0-249">1147</span><span class="sxs-lookup"><span data-stu-id="5e6a0-249">1147</span></span>|<span data-ttu-id="5e6a0-250">IBM01147</span><span class="sxs-lookup"><span data-stu-id="5e6a0-250">IBM01147</span></span>|<span data-ttu-id="5e6a0-251">IBM EBCDIC (Франция-евро)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-251">IBM EBCDIC (France-Euro)</span></span>|||  
|<span data-ttu-id="5e6a0-252">1148</span><span class="sxs-lookup"><span data-stu-id="5e6a0-252">1148</span></span>|<span data-ttu-id="5e6a0-253">IBM01148</span><span class="sxs-lookup"><span data-stu-id="5e6a0-253">IBM01148</span></span>|<span data-ttu-id="5e6a0-254">IBM EBCDIC (Международная Европа)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-254">IBM EBCDIC (International-Euro)</span></span>|||  
|<span data-ttu-id="5e6a0-255">1149</span><span class="sxs-lookup"><span data-stu-id="5e6a0-255">1149</span></span>|<span data-ttu-id="5e6a0-256">IBM01149</span><span class="sxs-lookup"><span data-stu-id="5e6a0-256">IBM01149</span></span>|<span data-ttu-id="5e6a0-257">IBM EBCDIC (Исландский-евро)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-257">IBM EBCDIC (Icelandic-Euro)</span></span>|||  
|<span data-ttu-id="5e6a0-258">1200</span><span class="sxs-lookup"><span data-stu-id="5e6a0-258">1200</span></span>|<span data-ttu-id="5e6a0-259">UTF-16</span><span class="sxs-lookup"><span data-stu-id="5e6a0-259">utf-16</span></span>|<span data-ttu-id="5e6a0-260">Юникод</span><span class="sxs-lookup"><span data-stu-id="5e6a0-260">Unicode</span></span>|<span data-ttu-id="5e6a0-261">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-261">✓</span></span>|<span data-ttu-id="5e6a0-262">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-262">✓</span></span>|  
|<span data-ttu-id="5e6a0-263">1201</span><span class="sxs-lookup"><span data-stu-id="5e6a0-263">1201</span></span>|<span data-ttu-id="5e6a0-264">уникодефффе</span><span class="sxs-lookup"><span data-stu-id="5e6a0-264">unicodeFFFE</span></span>|<span data-ttu-id="5e6a0-265">Юникод (с обратным порядком байтов)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-265">Unicode (Big endian)</span></span>|<span data-ttu-id="5e6a0-266">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-266">✓</span></span>|<span data-ttu-id="5e6a0-267">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-267">✓</span></span>|  
|<span data-ttu-id="5e6a0-268">1250</span><span class="sxs-lookup"><span data-stu-id="5e6a0-268">1250</span></span>|<span data-ttu-id="5e6a0-269">Windows — 1250</span><span class="sxs-lookup"><span data-stu-id="5e6a0-269">windows-1250</span></span>|<span data-ttu-id="5e6a0-270">Центральная Европа (Windows)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-270">Central European (Windows)</span></span>|||  
|<span data-ttu-id="5e6a0-271">1251</span><span class="sxs-lookup"><span data-stu-id="5e6a0-271">1251</span></span>|<span data-ttu-id="5e6a0-272">Windows — 1251</span><span class="sxs-lookup"><span data-stu-id="5e6a0-272">windows-1251</span></span>|<span data-ttu-id="5e6a0-273">Кириллица (Windows)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-273">Cyrillic (Windows)</span></span>|||  
|<span data-ttu-id="5e6a0-274">1252</span><span class="sxs-lookup"><span data-stu-id="5e6a0-274">1252</span></span>|<span data-ttu-id="5e6a0-275">Windows — 1252</span><span class="sxs-lookup"><span data-stu-id="5e6a0-275">Windows-1252</span></span>|<span data-ttu-id="5e6a0-276">Западная Европа (Windows)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-276">Western European (Windows)</span></span>|<span data-ttu-id="5e6a0-277">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-277">✓</span></span>||  
|<span data-ttu-id="5e6a0-278">1253</span><span class="sxs-lookup"><span data-stu-id="5e6a0-278">1253</span></span>|<span data-ttu-id="5e6a0-279">Windows — 1253</span><span class="sxs-lookup"><span data-stu-id="5e6a0-279">windows-1253</span></span>|<span data-ttu-id="5e6a0-280">Греческий (Windows)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-280">Greek (Windows)</span></span>|||  
|<span data-ttu-id="5e6a0-281">1254</span><span class="sxs-lookup"><span data-stu-id="5e6a0-281">1254</span></span>|<span data-ttu-id="5e6a0-282">Windows — 1254</span><span class="sxs-lookup"><span data-stu-id="5e6a0-282">windows-1254</span></span>|<span data-ttu-id="5e6a0-283">Турецкий (Windows)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-283">Turkish (Windows)</span></span>|||  
|<span data-ttu-id="5e6a0-284">1255</span><span class="sxs-lookup"><span data-stu-id="5e6a0-284">1255</span></span>|<span data-ttu-id="5e6a0-285">Windows — 1255</span><span class="sxs-lookup"><span data-stu-id="5e6a0-285">windows-1255</span></span>|<span data-ttu-id="5e6a0-286">Иврит (Windows)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-286">Hebrew (Windows)</span></span>|||  
|<span data-ttu-id="5e6a0-287">1256</span><span class="sxs-lookup"><span data-stu-id="5e6a0-287">1256</span></span>|<span data-ttu-id="5e6a0-288">Windows — 1256</span><span class="sxs-lookup"><span data-stu-id="5e6a0-288">windows-1256</span></span>|<span data-ttu-id="5e6a0-289">Арабский (Windows)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-289">Arabic (Windows)</span></span>|||  
|<span data-ttu-id="5e6a0-290">1257</span><span class="sxs-lookup"><span data-stu-id="5e6a0-290">1257</span></span>|<span data-ttu-id="5e6a0-291">Windows — 1257</span><span class="sxs-lookup"><span data-stu-id="5e6a0-291">windows-1257</span></span>|<span data-ttu-id="5e6a0-292">Балтийская (Windows)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-292">Baltic (Windows)</span></span>|||  
|<span data-ttu-id="5e6a0-293">1258</span><span class="sxs-lookup"><span data-stu-id="5e6a0-293">1258</span></span>|<span data-ttu-id="5e6a0-294">Windows — 1258</span><span class="sxs-lookup"><span data-stu-id="5e6a0-294">windows-1258</span></span>|<span data-ttu-id="5e6a0-295">Вьетнамский (Windows)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-295">Vietnamese (Windows)</span></span>|||  
|<span data-ttu-id="5e6a0-296">1361</span><span class="sxs-lookup"><span data-stu-id="5e6a0-296">1361</span></span>|<span data-ttu-id="5e6a0-297">Johab</span><span class="sxs-lookup"><span data-stu-id="5e6a0-297">Johab</span></span>|<span data-ttu-id="5e6a0-298">Корейский (Johab)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-298">Korean (Johab)</span></span>|||  
|<span data-ttu-id="5e6a0-299">10000</span><span class="sxs-lookup"><span data-stu-id="5e6a0-299">10000</span></span>|<span data-ttu-id="5e6a0-300">«</span><span class="sxs-lookup"><span data-stu-id="5e6a0-300">macintosh</span></span>|<span data-ttu-id="5e6a0-301">Западная Европа (Mac)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-301">Western European (Mac)</span></span>|||  
|<span data-ttu-id="5e6a0-302">10001</span><span class="sxs-lookup"><span data-stu-id="5e6a0-302">10001</span></span>|<span data-ttu-id="5e6a0-303">x-Mac-японская</span><span class="sxs-lookup"><span data-stu-id="5e6a0-303">x-mac-japanese</span></span>|<span data-ttu-id="5e6a0-304">Японская (Mac)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-304">Japanese (Mac)</span></span>|||  
|<span data-ttu-id="5e6a0-305">10002</span><span class="sxs-lookup"><span data-stu-id="5e6a0-305">10002</span></span>|<span data-ttu-id="5e6a0-306">x-Mac-чинесетрад</span><span class="sxs-lookup"><span data-stu-id="5e6a0-306">x-mac-chinesetrad</span></span>|<span data-ttu-id="5e6a0-307">Китайская традиционная (Mac)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-307">Chinese Traditional (Mac)</span></span>|||  
|<span data-ttu-id="5e6a0-308">10003</span><span class="sxs-lookup"><span data-stu-id="5e6a0-308">10003</span></span>|<span data-ttu-id="5e6a0-309">x-Mac-Корейский</span><span class="sxs-lookup"><span data-stu-id="5e6a0-309">x-mac-korean</span></span>|<span data-ttu-id="5e6a0-310">Корейский (Mac)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-310">Korean (Mac)</span></span>|<span data-ttu-id="5e6a0-311">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-311">✓</span></span>||  
|<span data-ttu-id="5e6a0-312">10004</span><span class="sxs-lookup"><span data-stu-id="5e6a0-312">10004</span></span>|<span data-ttu-id="5e6a0-313">x-Mac-Арабская</span><span class="sxs-lookup"><span data-stu-id="5e6a0-313">x-mac-arabic</span></span>|<span data-ttu-id="5e6a0-314">Арабский (Mac)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-314">Arabic (Mac)</span></span>|||  
|<span data-ttu-id="5e6a0-315">10005</span><span class="sxs-lookup"><span data-stu-id="5e6a0-315">10005</span></span>|<span data-ttu-id="5e6a0-316">x-Mac-иврит</span><span class="sxs-lookup"><span data-stu-id="5e6a0-316">x-mac-hebrew</span></span>|<span data-ttu-id="5e6a0-317">Иврит (Mac)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-317">Hebrew (Mac)</span></span>|||  
|<span data-ttu-id="5e6a0-318">10006</span><span class="sxs-lookup"><span data-stu-id="5e6a0-318">10006</span></span>|<span data-ttu-id="5e6a0-319">x-Mac-греческая</span><span class="sxs-lookup"><span data-stu-id="5e6a0-319">x-mac-greek</span></span>|<span data-ttu-id="5e6a0-320">Греческий (Mac)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-320">Greek (Mac)</span></span>|||  
|<span data-ttu-id="5e6a0-321">10007</span><span class="sxs-lookup"><span data-stu-id="5e6a0-321">10007</span></span>|<span data-ttu-id="5e6a0-322">x-Mac-кириллица</span><span class="sxs-lookup"><span data-stu-id="5e6a0-322">x-mac-cyrillic</span></span>|<span data-ttu-id="5e6a0-323">Кириллица (Mac)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-323">Cyrillic (Mac)</span></span>|||  
|<span data-ttu-id="5e6a0-324">10008</span><span class="sxs-lookup"><span data-stu-id="5e6a0-324">10008</span></span>|<span data-ttu-id="5e6a0-325">x-Mac-чинесесимп</span><span class="sxs-lookup"><span data-stu-id="5e6a0-325">x-mac-chinesesimp</span></span>|<span data-ttu-id="5e6a0-326">Китайская, упрощенное письмо (Mac)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-326">Chinese Simplified (Mac)</span></span>|<span data-ttu-id="5e6a0-327">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-327">✓</span></span>||  
|<span data-ttu-id="5e6a0-328">10010</span><span class="sxs-lookup"><span data-stu-id="5e6a0-328">10010</span></span>|<span data-ttu-id="5e6a0-329">x-Mac-румынская</span><span class="sxs-lookup"><span data-stu-id="5e6a0-329">x-mac-romanian</span></span>|<span data-ttu-id="5e6a0-330">Румынский (Mac)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-330">Romanian (Mac)</span></span>|||  
|<span data-ttu-id="5e6a0-331">10017</span><span class="sxs-lookup"><span data-stu-id="5e6a0-331">10017</span></span>|<span data-ttu-id="5e6a0-332">x-Mac-украинский</span><span class="sxs-lookup"><span data-stu-id="5e6a0-332">x-mac-ukrainian</span></span>|<span data-ttu-id="5e6a0-333">Украинский (Mac)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-333">Ukrainian (Mac)</span></span>|||  
|<span data-ttu-id="5e6a0-334">10021</span><span class="sxs-lookup"><span data-stu-id="5e6a0-334">10021</span></span>|<span data-ttu-id="5e6a0-335">x-Mac-тайский</span><span class="sxs-lookup"><span data-stu-id="5e6a0-335">x-mac-thai</span></span>|<span data-ttu-id="5e6a0-336">Тайский (Mac)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-336">Thai (Mac)</span></span>|||  
|<span data-ttu-id="5e6a0-337">10029</span><span class="sxs-lookup"><span data-stu-id="5e6a0-337">10029</span></span>|<span data-ttu-id="5e6a0-338">x-Mac-CE</span><span class="sxs-lookup"><span data-stu-id="5e6a0-338">x-mac-ce</span></span>|<span data-ttu-id="5e6a0-339">Центральноевропейская (Mac)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-339">Central European (Mac)</span></span>|||  
|<span data-ttu-id="5e6a0-340">10079</span><span class="sxs-lookup"><span data-stu-id="5e6a0-340">10079</span></span>|<span data-ttu-id="5e6a0-341">x-Mac-Исландский</span><span class="sxs-lookup"><span data-stu-id="5e6a0-341">x-mac-icelandic</span></span>|<span data-ttu-id="5e6a0-342">Исландский (Mac)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-342">Icelandic (Mac)</span></span>|||  
|<span data-ttu-id="5e6a0-343">10081</span><span class="sxs-lookup"><span data-stu-id="5e6a0-343">10081</span></span>|<span data-ttu-id="5e6a0-344">x-Mac-Турецкая</span><span class="sxs-lookup"><span data-stu-id="5e6a0-344">x-mac-turkish</span></span>|<span data-ttu-id="5e6a0-345">Турецкий (Mac)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-345">Turkish (Mac)</span></span>|||  
|<span data-ttu-id="5e6a0-346">10082</span><span class="sxs-lookup"><span data-stu-id="5e6a0-346">10082</span></span>|<span data-ttu-id="5e6a0-347">x-Mac-Хорватский</span><span class="sxs-lookup"><span data-stu-id="5e6a0-347">x-mac-croatian</span></span>|<span data-ttu-id="5e6a0-348">Хорватский (Mac)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-348">Croatian (Mac)</span></span>|||  
|<span data-ttu-id="5e6a0-349">12000</span><span class="sxs-lookup"><span data-stu-id="5e6a0-349">12000</span></span>|<span data-ttu-id="5e6a0-350">UTF-32</span><span class="sxs-lookup"><span data-stu-id="5e6a0-350">utf-32</span></span>|<span data-ttu-id="5e6a0-351">Юникод (UTF-32)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-351">Unicode (UTF-32)</span></span>|<span data-ttu-id="5e6a0-352">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-352">✓</span></span>|<span data-ttu-id="5e6a0-353">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-353">✓</span></span>|  
|<span data-ttu-id="5e6a0-354">12001</span><span class="sxs-lookup"><span data-stu-id="5e6a0-354">12001</span></span>|<span data-ttu-id="5e6a0-355">UTF-32BE</span><span class="sxs-lookup"><span data-stu-id="5e6a0-355">utf-32BE</span></span>|<span data-ttu-id="5e6a0-356">Юникод (UTF-32 с обратным порядком байтов)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-356">Unicode (UTF-32 Big endian)</span></span>|<span data-ttu-id="5e6a0-357">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-357">✓</span></span>|<span data-ttu-id="5e6a0-358">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-358">✓</span></span>|  
|<span data-ttu-id="5e6a0-359">20000</span><span class="sxs-lookup"><span data-stu-id="5e6a0-359">20000</span></span>|<span data-ttu-id="5e6a0-360">x-китайский — CNS</span><span class="sxs-lookup"><span data-stu-id="5e6a0-360">x-Chinese-CNS</span></span>|<span data-ttu-id="5e6a0-361">Китайская традиционная (CNS)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-361">Chinese Traditional (CNS)</span></span>|||  
|<span data-ttu-id="5e6a0-362">20001</span><span class="sxs-lookup"><span data-stu-id="5e6a0-362">20001</span></span>|<span data-ttu-id="5e6a0-363">x — cp20001</span><span class="sxs-lookup"><span data-stu-id="5e6a0-363">x-cp20001</span></span>|<span data-ttu-id="5e6a0-364">TCA Тайваньская</span><span class="sxs-lookup"><span data-stu-id="5e6a0-364">TCA Taiwan</span></span>|||  
|<span data-ttu-id="5e6a0-365">20002</span><span class="sxs-lookup"><span data-stu-id="5e6a0-365">20002</span></span>|<span data-ttu-id="5e6a0-366">x-китайский — Eten</span><span class="sxs-lookup"><span data-stu-id="5e6a0-366">x-Chinese-Eten</span></span>|<span data-ttu-id="5e6a0-367">Китайская традиционная (Eten)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-367">Chinese Traditional (Eten)</span></span>|||  
|<span data-ttu-id="5e6a0-368">20003</span><span class="sxs-lookup"><span data-stu-id="5e6a0-368">20003</span></span>|<span data-ttu-id="5e6a0-369">x — cp20003</span><span class="sxs-lookup"><span data-stu-id="5e6a0-369">x-cp20003</span></span>|<span data-ttu-id="5e6a0-370">IBM5550 Тайвань</span><span class="sxs-lookup"><span data-stu-id="5e6a0-370">IBM5550 Taiwan</span></span>|||  
|<span data-ttu-id="5e6a0-371">20004</span><span class="sxs-lookup"><span data-stu-id="5e6a0-371">20004</span></span>|<span data-ttu-id="5e6a0-372">x — cp20004</span><span class="sxs-lookup"><span data-stu-id="5e6a0-372">x-cp20004</span></span>|<span data-ttu-id="5e6a0-373">Телетекст, Тайвань</span><span class="sxs-lookup"><span data-stu-id="5e6a0-373">TeleText Taiwan</span></span>|||  
|<span data-ttu-id="5e6a0-374">20005</span><span class="sxs-lookup"><span data-stu-id="5e6a0-374">20005</span></span>|<span data-ttu-id="5e6a0-375">x — cp20005</span><span class="sxs-lookup"><span data-stu-id="5e6a0-375">x-cp20005</span></span>|<span data-ttu-id="5e6a0-376">Wang Тайвань</span><span class="sxs-lookup"><span data-stu-id="5e6a0-376">Wang Taiwan</span></span>|||  
|<span data-ttu-id="5e6a0-377">20105</span><span class="sxs-lookup"><span data-stu-id="5e6a0-377">20105</span></span>|<span data-ttu-id="5e6a0-378">x-IA5</span><span class="sxs-lookup"><span data-stu-id="5e6a0-378">x-IA5</span></span>|<span data-ttu-id="5e6a0-379">Западная Европа (IA5)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-379">Western European (IA5)</span></span>|||  
|<span data-ttu-id="5e6a0-380">20106</span><span class="sxs-lookup"><span data-stu-id="5e6a0-380">20106</span></span>|<span data-ttu-id="5e6a0-381">x-IA5-немецкий</span><span class="sxs-lookup"><span data-stu-id="5e6a0-381">x-IA5-German</span></span>|<span data-ttu-id="5e6a0-382">Немецкий (IA5)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-382">German (IA5)</span></span>|||  
|<span data-ttu-id="5e6a0-383">20107</span><span class="sxs-lookup"><span data-stu-id="5e6a0-383">20107</span></span>|<span data-ttu-id="5e6a0-384">x-IA5-шведский</span><span class="sxs-lookup"><span data-stu-id="5e6a0-384">x-IA5-Swedish</span></span>|<span data-ttu-id="5e6a0-385">Шведский (IA5)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-385">Swedish (IA5)</span></span>|||  
|<span data-ttu-id="5e6a0-386">20108</span><span class="sxs-lookup"><span data-stu-id="5e6a0-386">20108</span></span>|<span data-ttu-id="5e6a0-387">x-IA5-Норвежский</span><span class="sxs-lookup"><span data-stu-id="5e6a0-387">x-IA5-Norwegian</span></span>|<span data-ttu-id="5e6a0-388">Норвежский (IA5)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-388">Norwegian (IA5)</span></span>|||  
|<span data-ttu-id="5e6a0-389">20127</span><span class="sxs-lookup"><span data-stu-id="5e6a0-389">20127</span></span>|<span data-ttu-id="5e6a0-390">US-ASCII</span><span class="sxs-lookup"><span data-stu-id="5e6a0-390">us-ascii</span></span>|<span data-ttu-id="5e6a0-391">US-ASCII</span><span class="sxs-lookup"><span data-stu-id="5e6a0-391">US-ASCII</span></span>|<span data-ttu-id="5e6a0-392">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-392">✓</span></span>|<span data-ttu-id="5e6a0-393">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-393">✓</span></span>|  
|<span data-ttu-id="5e6a0-394">20261</span><span class="sxs-lookup"><span data-stu-id="5e6a0-394">20261</span></span>|<span data-ttu-id="5e6a0-395">x — cp20261</span><span class="sxs-lookup"><span data-stu-id="5e6a0-395">x-cp20261</span></span>|<span data-ttu-id="5e6a0-396">Т. 61</span><span class="sxs-lookup"><span data-stu-id="5e6a0-396">T.61</span></span>|||  
|<span data-ttu-id="5e6a0-397">20269</span><span class="sxs-lookup"><span data-stu-id="5e6a0-397">20269</span></span>|<span data-ttu-id="5e6a0-398">x — cp20269</span><span class="sxs-lookup"><span data-stu-id="5e6a0-398">x-cp20269</span></span>|<span data-ttu-id="5e6a0-399">ISO-6937</span><span class="sxs-lookup"><span data-stu-id="5e6a0-399">ISO-6937</span></span>|||  
|<span data-ttu-id="5e6a0-400">20273</span><span class="sxs-lookup"><span data-stu-id="5e6a0-400">20273</span></span>|<span data-ttu-id="5e6a0-401">IBM273</span><span class="sxs-lookup"><span data-stu-id="5e6a0-401">IBM273</span></span>|<span data-ttu-id="5e6a0-402">IBM EBCDIC (Германия)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-402">IBM EBCDIC (Germany)</span></span>|||  
|<span data-ttu-id="5e6a0-403">20277</span><span class="sxs-lookup"><span data-stu-id="5e6a0-403">20277</span></span>|<span data-ttu-id="5e6a0-404">IBM277</span><span class="sxs-lookup"><span data-stu-id="5e6a0-404">IBM277</span></span>|<span data-ttu-id="5e6a0-405">IBM EBCDIC (Дания-Норвегия)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-405">IBM EBCDIC (Denmark-Norway)</span></span>|||  
|<span data-ttu-id="5e6a0-406">20278</span><span class="sxs-lookup"><span data-stu-id="5e6a0-406">20278</span></span>|<span data-ttu-id="5e6a0-407">IBM278</span><span class="sxs-lookup"><span data-stu-id="5e6a0-407">IBM278</span></span>|<span data-ttu-id="5e6a0-408">IBM EBCDIC (Финляндия-Швеция)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-408">IBM EBCDIC (Finland-Sweden)</span></span>|||  
|<span data-ttu-id="5e6a0-409">20280</span><span class="sxs-lookup"><span data-stu-id="5e6a0-409">20280</span></span>|<span data-ttu-id="5e6a0-410">IBM280</span><span class="sxs-lookup"><span data-stu-id="5e6a0-410">IBM280</span></span>|<span data-ttu-id="5e6a0-411">IBM EBCDIC (Италия)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-411">IBM EBCDIC (Italy)</span></span>|||  
|<span data-ttu-id="5e6a0-412">20284</span><span class="sxs-lookup"><span data-stu-id="5e6a0-412">20284</span></span>|<span data-ttu-id="5e6a0-413">IBM284</span><span class="sxs-lookup"><span data-stu-id="5e6a0-413">IBM284</span></span>|<span data-ttu-id="5e6a0-414">IBM EBCDIC (Испания)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-414">IBM EBCDIC (Spain)</span></span>|||  
|<span data-ttu-id="5e6a0-415">20285</span><span class="sxs-lookup"><span data-stu-id="5e6a0-415">20285</span></span>|<span data-ttu-id="5e6a0-416">IBM285</span><span class="sxs-lookup"><span data-stu-id="5e6a0-416">IBM285</span></span>|<span data-ttu-id="5e6a0-417">IBM EBCDIC (ВЕЛИКОБРИТАНИЯ)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-417">IBM EBCDIC (UK)</span></span>|||  
|<span data-ttu-id="5e6a0-418">20290</span><span class="sxs-lookup"><span data-stu-id="5e6a0-418">20290</span></span>|<span data-ttu-id="5e6a0-419">IBM290</span><span class="sxs-lookup"><span data-stu-id="5e6a0-419">IBM290</span></span>|<span data-ttu-id="5e6a0-420">IBM EBCDIC (японская катакана)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-420">IBM EBCDIC (Japanese katakana)</span></span>|||  
|<span data-ttu-id="5e6a0-421">20297</span><span class="sxs-lookup"><span data-stu-id="5e6a0-421">20297</span></span>|<span data-ttu-id="5e6a0-422">IBM297</span><span class="sxs-lookup"><span data-stu-id="5e6a0-422">IBM297</span></span>|<span data-ttu-id="5e6a0-423">IBM EBCDIC (Франция)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-423">IBM EBCDIC (France)</span></span>|||  
|<span data-ttu-id="5e6a0-424">20420</span><span class="sxs-lookup"><span data-stu-id="5e6a0-424">20420</span></span>|<span data-ttu-id="5e6a0-425">IBM420</span><span class="sxs-lookup"><span data-stu-id="5e6a0-425">IBM420</span></span>|<span data-ttu-id="5e6a0-426">IBM EBCDIC (Арабская)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-426">IBM EBCDIC (Arabic)</span></span>|||  
|<span data-ttu-id="5e6a0-427">20423</span><span class="sxs-lookup"><span data-stu-id="5e6a0-427">20423</span></span>|<span data-ttu-id="5e6a0-428">IBM423</span><span class="sxs-lookup"><span data-stu-id="5e6a0-428">IBM423</span></span>|<span data-ttu-id="5e6a0-429">IBM EBCDIC (греческая)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-429">IBM EBCDIC (Greek)</span></span>|||  
|<span data-ttu-id="5e6a0-430">20424</span><span class="sxs-lookup"><span data-stu-id="5e6a0-430">20424</span></span>|<span data-ttu-id="5e6a0-431">IBM424</span><span class="sxs-lookup"><span data-stu-id="5e6a0-431">IBM424</span></span>|<span data-ttu-id="5e6a0-432">IBM EBCDIC (иврит)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-432">IBM EBCDIC (Hebrew)</span></span>|||  
|<span data-ttu-id="5e6a0-433">20833</span><span class="sxs-lookup"><span data-stu-id="5e6a0-433">20833</span></span>|<span data-ttu-id="5e6a0-434">x-EBCDIC-Кореанекстендед</span><span class="sxs-lookup"><span data-stu-id="5e6a0-434">x-EBCDIC-KoreanExtended</span></span>|<span data-ttu-id="5e6a0-435">IBM EBCDIC (Корейская расширенная)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-435">IBM EBCDIC (Korean Extended)</span></span>|||  
|<span data-ttu-id="5e6a0-436">20838</span><span class="sxs-lookup"><span data-stu-id="5e6a0-436">20838</span></span>|<span data-ttu-id="5e6a0-437">IBM — тайский</span><span class="sxs-lookup"><span data-stu-id="5e6a0-437">IBM-Thai</span></span>|<span data-ttu-id="5e6a0-438">IBM EBCDIC (тайский)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-438">IBM EBCDIC (Thai)</span></span>|||  
|<span data-ttu-id="5e6a0-439">20866</span><span class="sxs-lookup"><span data-stu-id="5e6a0-439">20866</span></span>|<span data-ttu-id="5e6a0-440">koi8-r</span><span class="sxs-lookup"><span data-stu-id="5e6a0-440">koi8-r</span></span>|<span data-ttu-id="5e6a0-441">Кириллица (KOI8-R)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-441">Cyrillic (KOI8-R)</span></span>|||  
|<span data-ttu-id="5e6a0-442">20871</span><span class="sxs-lookup"><span data-stu-id="5e6a0-442">20871</span></span>|<span data-ttu-id="5e6a0-443">IBM871</span><span class="sxs-lookup"><span data-stu-id="5e6a0-443">IBM871</span></span>|<span data-ttu-id="5e6a0-444">IBM EBCDIC (исландский)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-444">IBM EBCDIC (Icelandic)</span></span>|||  
|<span data-ttu-id="5e6a0-445">20880</span><span class="sxs-lookup"><span data-stu-id="5e6a0-445">20880</span></span>|<span data-ttu-id="5e6a0-446">IBM880</span><span class="sxs-lookup"><span data-stu-id="5e6a0-446">IBM880</span></span>|<span data-ttu-id="5e6a0-447">IBM EBCDIC (кириллица русская)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-447">IBM EBCDIC (Cyrillic Russian)</span></span>|||  
|<span data-ttu-id="5e6a0-448">20905</span><span class="sxs-lookup"><span data-stu-id="5e6a0-448">20905</span></span>|<span data-ttu-id="5e6a0-449">IBM905</span><span class="sxs-lookup"><span data-stu-id="5e6a0-449">IBM905</span></span>|<span data-ttu-id="5e6a0-450">IBM EBCDIC (Турецкая)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-450">IBM EBCDIC (Turkish)</span></span>|||  
|<span data-ttu-id="5e6a0-451">20924</span><span class="sxs-lookup"><span data-stu-id="5e6a0-451">20924</span></span>|<span data-ttu-id="5e6a0-452">IBM00924</span><span class="sxs-lookup"><span data-stu-id="5e6a0-452">IBM00924</span></span>|<span data-ttu-id="5e6a0-453">IBM Latin-1</span><span class="sxs-lookup"><span data-stu-id="5e6a0-453">IBM Latin-1</span></span>|||  
|<span data-ttu-id="5e6a0-454">20932</span><span class="sxs-lookup"><span data-stu-id="5e6a0-454">20932</span></span>|<span data-ttu-id="5e6a0-455">EUC-JP</span><span class="sxs-lookup"><span data-stu-id="5e6a0-455">EUC-JP</span></span>|<span data-ttu-id="5e6a0-456">Японская (JIS 0208-1990 и 0212-1990)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-456">Japanese (JIS 0208-1990 and 0212-1990)</span></span>|||  
|<span data-ttu-id="5e6a0-457">20936</span><span class="sxs-lookup"><span data-stu-id="5e6a0-457">20936</span></span>|<span data-ttu-id="5e6a0-458">x — cp20936</span><span class="sxs-lookup"><span data-stu-id="5e6a0-458">x-cp20936</span></span>|<span data-ttu-id="5e6a0-459">Китайская упрощенная (GB2312-80)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-459">Chinese Simplified (GB2312-80)</span></span>|<span data-ttu-id="5e6a0-460">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-460">✓</span></span>||  
|<span data-ttu-id="5e6a0-461">20949</span><span class="sxs-lookup"><span data-stu-id="5e6a0-461">20949</span></span>|<span data-ttu-id="5e6a0-462">x — cp20949</span><span class="sxs-lookup"><span data-stu-id="5e6a0-462">x-cp20949</span></span>|<span data-ttu-id="5e6a0-463">Корейский Wansung</span><span class="sxs-lookup"><span data-stu-id="5e6a0-463">Korean Wansung</span></span>|<span data-ttu-id="5e6a0-464">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-464">✓</span></span>||  
|<span data-ttu-id="5e6a0-465">21025</span><span class="sxs-lookup"><span data-stu-id="5e6a0-465">21025</span></span>|<span data-ttu-id="5e6a0-466">cp1025</span><span class="sxs-lookup"><span data-stu-id="5e6a0-466">cp1025</span></span>|<span data-ttu-id="5e6a0-467">IBM EBCDIC (кириллица, Сербский — Болгарский)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-467">IBM EBCDIC (Cyrillic Serbian-Bulgarian)</span></span>|||  
|<span data-ttu-id="5e6a0-468">21866</span><span class="sxs-lookup"><span data-stu-id="5e6a0-468">21866</span></span>|<span data-ttu-id="5e6a0-469">koi8-u</span><span class="sxs-lookup"><span data-stu-id="5e6a0-469">koi8-u</span></span>|<span data-ttu-id="5e6a0-470">Кириллица (KOI8-U)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-470">Cyrillic (KOI8-U)</span></span>|||  
|<span data-ttu-id="5e6a0-471">28591</span><span class="sxs-lookup"><span data-stu-id="5e6a0-471">28591</span></span>|<span data-ttu-id="5e6a0-472">ISO-8859-1</span><span class="sxs-lookup"><span data-stu-id="5e6a0-472">iso-8859-1</span></span>|<span data-ttu-id="5e6a0-473">Западная Европа (ISO)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-473">Western European (ISO)</span></span>|<span data-ttu-id="5e6a0-474">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-474">✓</span></span>|<span data-ttu-id="5e6a0-475">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-475">✓</span></span>|  
|<span data-ttu-id="5e6a0-476">28592</span><span class="sxs-lookup"><span data-stu-id="5e6a0-476">28592</span></span>|<span data-ttu-id="5e6a0-477">ISO-8859-2</span><span class="sxs-lookup"><span data-stu-id="5e6a0-477">iso-8859-2</span></span>|<span data-ttu-id="5e6a0-478">Центральноевропейская (ISO)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-478">Central European (ISO)</span></span>|||  
|<span data-ttu-id="5e6a0-479">28593</span><span class="sxs-lookup"><span data-stu-id="5e6a0-479">28593</span></span>|<span data-ttu-id="5e6a0-480">ISO-8859-3</span><span class="sxs-lookup"><span data-stu-id="5e6a0-480">iso-8859-3</span></span>|<span data-ttu-id="5e6a0-481">Латиница 3 (ISO)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-481">Latin 3 (ISO)</span></span>|||  
|<span data-ttu-id="5e6a0-482">28594</span><span class="sxs-lookup"><span data-stu-id="5e6a0-482">28594</span></span>|<span data-ttu-id="5e6a0-483">ISO-8859-4</span><span class="sxs-lookup"><span data-stu-id="5e6a0-483">iso-8859-4</span></span>|<span data-ttu-id="5e6a0-484">Балтийская (ISO)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-484">Baltic (ISO)</span></span>|||  
|<span data-ttu-id="5e6a0-485">28595</span><span class="sxs-lookup"><span data-stu-id="5e6a0-485">28595</span></span>|<span data-ttu-id="5e6a0-486">ISO-8859-5</span><span class="sxs-lookup"><span data-stu-id="5e6a0-486">iso-8859-5</span></span>|<span data-ttu-id="5e6a0-487">Кириллица (ISO)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-487">Cyrillic (ISO)</span></span>|||  
|<span data-ttu-id="5e6a0-488">28596</span><span class="sxs-lookup"><span data-stu-id="5e6a0-488">28596</span></span>|<span data-ttu-id="5e6a0-489">ISO-8859-6</span><span class="sxs-lookup"><span data-stu-id="5e6a0-489">iso-8859-6</span></span>|<span data-ttu-id="5e6a0-490">Арабский (ISO)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-490">Arabic (ISO)</span></span>|||  
|<span data-ttu-id="5e6a0-491">28597</span><span class="sxs-lookup"><span data-stu-id="5e6a0-491">28597</span></span>|<span data-ttu-id="5e6a0-492">ISO-8859-7</span><span class="sxs-lookup"><span data-stu-id="5e6a0-492">iso-8859-7</span></span>|<span data-ttu-id="5e6a0-493">Греческий (ISO)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-493">Greek (ISO)</span></span>|||  
|<span data-ttu-id="5e6a0-494">28598</span><span class="sxs-lookup"><span data-stu-id="5e6a0-494">28598</span></span>|<span data-ttu-id="5e6a0-495">ISO-8859-8</span><span class="sxs-lookup"><span data-stu-id="5e6a0-495">iso-8859-8</span></span>|<span data-ttu-id="5e6a0-496">Иврит (ISO-Visual)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-496">Hebrew (ISO-Visual)</span></span>|<span data-ttu-id="5e6a0-497">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-497">✓</span></span>||  
|<span data-ttu-id="5e6a0-498">28599</span><span class="sxs-lookup"><span data-stu-id="5e6a0-498">28599</span></span>|<span data-ttu-id="5e6a0-499">ISO-8859-9</span><span class="sxs-lookup"><span data-stu-id="5e6a0-499">iso-8859-9</span></span>|<span data-ttu-id="5e6a0-500">Турецкий (ISO)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-500">Turkish (ISO)</span></span>|||  
|<span data-ttu-id="5e6a0-501">28603</span><span class="sxs-lookup"><span data-stu-id="5e6a0-501">28603</span></span>|<span data-ttu-id="5e6a0-502">ISO-8859-13</span><span class="sxs-lookup"><span data-stu-id="5e6a0-502">iso-8859-13</span></span>|<span data-ttu-id="5e6a0-503">Эстонский (ISO)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-503">Estonian (ISO)</span></span>|||  
|<span data-ttu-id="5e6a0-504">28605</span><span class="sxs-lookup"><span data-stu-id="5e6a0-504">28605</span></span>|<span data-ttu-id="5e6a0-505">ISO-8859-15</span><span class="sxs-lookup"><span data-stu-id="5e6a0-505">iso-8859-15</span></span>|<span data-ttu-id="5e6a0-506">Латиница 9 (ISO)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-506">Latin 9 (ISO)</span></span>|||  
|<span data-ttu-id="5e6a0-507">29001</span><span class="sxs-lookup"><span data-stu-id="5e6a0-507">29001</span></span>|<span data-ttu-id="5e6a0-508">x — Европа</span><span class="sxs-lookup"><span data-stu-id="5e6a0-508">x-Europa</span></span>|<span data-ttu-id="5e6a0-509">Европа</span><span class="sxs-lookup"><span data-stu-id="5e6a0-509">Europa</span></span>|||  
|<span data-ttu-id="5e6a0-510">38598</span><span class="sxs-lookup"><span data-stu-id="5e6a0-510">38598</span></span>|<span data-ttu-id="5e6a0-511">ISO-8859-8-i</span><span class="sxs-lookup"><span data-stu-id="5e6a0-511">iso-8859-8-i</span></span>|<span data-ttu-id="5e6a0-512">Иврит (ISO-Logical)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-512">Hebrew (ISO-Logical)</span></span>|<span data-ttu-id="5e6a0-513">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-513">✓</span></span>||  
|<span data-ttu-id="5e6a0-514">50220</span><span class="sxs-lookup"><span data-stu-id="5e6a0-514">50220</span></span>|<span data-ttu-id="5e6a0-515">ISO-2022-JP</span><span class="sxs-lookup"><span data-stu-id="5e6a0-515">iso-2022-jp</span></span>|<span data-ttu-id="5e6a0-516">Японская (JIS)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-516">Japanese (JIS)</span></span>|<span data-ttu-id="5e6a0-517">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-517">✓</span></span>||  
|<span data-ttu-id="5e6a0-518">50221</span><span class="sxs-lookup"><span data-stu-id="5e6a0-518">50221</span></span>|<span data-ttu-id="5e6a0-519">csISO2022JP</span><span class="sxs-lookup"><span data-stu-id="5e6a0-519">csISO2022JP</span></span>|<span data-ttu-id="5e6a0-520">Японская (JIS, разрешить 1 байт Кана)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-520">Japanese (JIS-Allow 1 byte Kana)</span></span>|<span data-ttu-id="5e6a0-521">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-521">✓</span></span>||  
|<span data-ttu-id="5e6a0-522">50222</span><span class="sxs-lookup"><span data-stu-id="5e6a0-522">50222</span></span>|<span data-ttu-id="5e6a0-523">ISO-2022-JP</span><span class="sxs-lookup"><span data-stu-id="5e6a0-523">iso-2022-jp</span></span>|<span data-ttu-id="5e6a0-524">Японская (JIS — разрешить 1 байт Кана-SO/SI)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-524">Japanese (JIS-Allow 1 byte Kana - SO/SI)</span></span>|<span data-ttu-id="5e6a0-525">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-525">✓</span></span>||  
|<span data-ttu-id="5e6a0-526">50225</span><span class="sxs-lookup"><span data-stu-id="5e6a0-526">50225</span></span>|<span data-ttu-id="5e6a0-527">ISO-2022-kr</span><span class="sxs-lookup"><span data-stu-id="5e6a0-527">iso-2022-kr</span></span>|<span data-ttu-id="5e6a0-528">Корейский (ISO)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-528">Korean (ISO)</span></span>|<span data-ttu-id="5e6a0-529">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-529">✓</span></span>||  
|<span data-ttu-id="5e6a0-530">50227</span><span class="sxs-lookup"><span data-stu-id="5e6a0-530">50227</span></span>|<span data-ttu-id="5e6a0-531">x — cp50227</span><span class="sxs-lookup"><span data-stu-id="5e6a0-531">x-cp50227</span></span>|<span data-ttu-id="5e6a0-532">Китайская, упрощенное письмо (ISO-2022)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-532">Chinese Simplified (ISO-2022)</span></span>|<span data-ttu-id="5e6a0-533">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-533">✓</span></span>||  
|<span data-ttu-id="5e6a0-534">51932</span><span class="sxs-lookup"><span data-stu-id="5e6a0-534">51932</span></span>|<span data-ttu-id="5e6a0-535">EUC-JP</span><span class="sxs-lookup"><span data-stu-id="5e6a0-535">euc-jp</span></span>|<span data-ttu-id="5e6a0-536">Японский (EUC)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-536">Japanese (EUC)</span></span>|<span data-ttu-id="5e6a0-537">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-537">✓</span></span>||  
|<span data-ttu-id="5e6a0-538">51936</span><span class="sxs-lookup"><span data-stu-id="5e6a0-538">51936</span></span>|<span data-ttu-id="5e6a0-539">EUC-CN</span><span class="sxs-lookup"><span data-stu-id="5e6a0-539">EUC-CN</span></span>|<span data-ttu-id="5e6a0-540">Китайская упрощенная (EUC)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-540">Chinese Simplified (EUC)</span></span>|<span data-ttu-id="5e6a0-541">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-541">✓</span></span>||  
|<span data-ttu-id="5e6a0-542">51949</span><span class="sxs-lookup"><span data-stu-id="5e6a0-542">51949</span></span>|<span data-ttu-id="5e6a0-543">euc-kr</span><span class="sxs-lookup"><span data-stu-id="5e6a0-543">euc-kr</span></span>|<span data-ttu-id="5e6a0-544">Корейский (EUC)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-544">Korean (EUC)</span></span>|<span data-ttu-id="5e6a0-545">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-545">✓</span></span>||  
|<span data-ttu-id="5e6a0-546">52936</span><span class="sxs-lookup"><span data-stu-id="5e6a0-546">52936</span></span>|<span data-ttu-id="5e6a0-547">Гц-GB-2312</span><span class="sxs-lookup"><span data-stu-id="5e6a0-547">hz-gb-2312</span></span>|<span data-ttu-id="5e6a0-548">Китайская, упрощенное письмо (Гц)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-548">Chinese Simplified (HZ)</span></span>|<span data-ttu-id="5e6a0-549">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-549">✓</span></span>||  
|<span data-ttu-id="5e6a0-550">54936</span><span class="sxs-lookup"><span data-stu-id="5e6a0-550">54936</span></span>|<span data-ttu-id="5e6a0-551">GB18030</span><span class="sxs-lookup"><span data-stu-id="5e6a0-551">GB18030</span></span>|<span data-ttu-id="5e6a0-552">Китайская, упрощенное письмо (GB18030)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-552">Chinese Simplified (GB18030)</span></span>|<span data-ttu-id="5e6a0-553">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-553">✓</span></span>||  
|<span data-ttu-id="5e6a0-554">57002</span><span class="sxs-lookup"><span data-stu-id="5e6a0-554">57002</span></span>|<span data-ttu-id="5e6a0-555">x-ISCII-de</span><span class="sxs-lookup"><span data-stu-id="5e6a0-555">x-iscii-de</span></span>|<span data-ttu-id="5e6a0-556">ISCII — деванагари</span><span class="sxs-lookup"><span data-stu-id="5e6a0-556">ISCII Devanagari</span></span>|<span data-ttu-id="5e6a0-557">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-557">✓</span></span>||  
|<span data-ttu-id="5e6a0-558">57003</span><span class="sxs-lookup"><span data-stu-id="5e6a0-558">57003</span></span>|<span data-ttu-id="5e6a0-559">x-ISCII-составлять</span><span class="sxs-lookup"><span data-stu-id="5e6a0-559">x-iscii-be</span></span>|<span data-ttu-id="5e6a0-560">ISCII Бенгальская</span><span class="sxs-lookup"><span data-stu-id="5e6a0-560">ISCII Bengali</span></span>|<span data-ttu-id="5e6a0-561">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-561">✓</span></span>||  
|<span data-ttu-id="5e6a0-562">57004</span><span class="sxs-lookup"><span data-stu-id="5e6a0-562">57004</span></span>|<span data-ttu-id="5e6a0-563">x-ISCII-TA</span><span class="sxs-lookup"><span data-stu-id="5e6a0-563">x-iscii-ta</span></span>|<span data-ttu-id="5e6a0-564">ISCII — тамильский</span><span class="sxs-lookup"><span data-stu-id="5e6a0-564">ISCII Tamil</span></span>|<span data-ttu-id="5e6a0-565">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-565">✓</span></span>||  
|<span data-ttu-id="5e6a0-566">57005</span><span class="sxs-lookup"><span data-stu-id="5e6a0-566">57005</span></span>|<span data-ttu-id="5e6a0-567">x-ISCII-TE</span><span class="sxs-lookup"><span data-stu-id="5e6a0-567">x-iscii-te</span></span>|<span data-ttu-id="5e6a0-568">ISCII — телугу</span><span class="sxs-lookup"><span data-stu-id="5e6a0-568">ISCII Telugu</span></span>|<span data-ttu-id="5e6a0-569">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-569">✓</span></span>||  
|<span data-ttu-id="5e6a0-570">57006</span><span class="sxs-lookup"><span data-stu-id="5e6a0-570">57006</span></span>|<span data-ttu-id="5e6a0-571">x-ISCII-AS</span><span class="sxs-lookup"><span data-stu-id="5e6a0-571">x-iscii-as</span></span>|<span data-ttu-id="5e6a0-572">ISCII — Ассамская</span><span class="sxs-lookup"><span data-stu-id="5e6a0-572">ISCII Assamese</span></span>|<span data-ttu-id="5e6a0-573">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-573">✓</span></span>||  
|<span data-ttu-id="5e6a0-574">57007</span><span class="sxs-lookup"><span data-stu-id="5e6a0-574">57007</span></span>|<span data-ttu-id="5e6a0-575">x-ISCII-или</span><span class="sxs-lookup"><span data-stu-id="5e6a0-575">x-iscii-or</span></span>|<span data-ttu-id="5e6a0-576">ISCII — Ория</span><span class="sxs-lookup"><span data-stu-id="5e6a0-576">ISCII Oriya</span></span>|<span data-ttu-id="5e6a0-577">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-577">✓</span></span>||  
|<span data-ttu-id="5e6a0-578">57008</span><span class="sxs-lookup"><span data-stu-id="5e6a0-578">57008</span></span>|<span data-ttu-id="5e6a0-579">x-ISCII-ка</span><span class="sxs-lookup"><span data-stu-id="5e6a0-579">x-iscii-ka</span></span>|<span data-ttu-id="5e6a0-580">ISCII — каннада</span><span class="sxs-lookup"><span data-stu-id="5e6a0-580">ISCII Kannada</span></span>|<span data-ttu-id="5e6a0-581">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-581">✓</span></span>||  
|<span data-ttu-id="5e6a0-582">57009</span><span class="sxs-lookup"><span data-stu-id="5e6a0-582">57009</span></span>|<span data-ttu-id="5e6a0-583">x-ISCII-MA</span><span class="sxs-lookup"><span data-stu-id="5e6a0-583">x-iscii-ma</span></span>|<span data-ttu-id="5e6a0-584">ISCII — малаялам</span><span class="sxs-lookup"><span data-stu-id="5e6a0-584">ISCII Malayalam</span></span>|<span data-ttu-id="5e6a0-585">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-585">✓</span></span>||  
|<span data-ttu-id="5e6a0-586">57010</span><span class="sxs-lookup"><span data-stu-id="5e6a0-586">57010</span></span>|<span data-ttu-id="5e6a0-587">x-ISCII-gu</span><span class="sxs-lookup"><span data-stu-id="5e6a0-587">x-iscii-gu</span></span>|<span data-ttu-id="5e6a0-588">ISCII — гуджарати</span><span class="sxs-lookup"><span data-stu-id="5e6a0-588">ISCII Gujarati</span></span>|<span data-ttu-id="5e6a0-589">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-589">✓</span></span>||  
|<span data-ttu-id="5e6a0-590">57011</span><span class="sxs-lookup"><span data-stu-id="5e6a0-590">57011</span></span>|<span data-ttu-id="5e6a0-591">x-ISCII-PA</span><span class="sxs-lookup"><span data-stu-id="5e6a0-591">x-iscii-pa</span></span>|<span data-ttu-id="5e6a0-592">Панджаби ISCII</span><span class="sxs-lookup"><span data-stu-id="5e6a0-592">ISCII Punjabi</span></span>|<span data-ttu-id="5e6a0-593">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-593">✓</span></span>||  
|<span data-ttu-id="5e6a0-594">65000</span><span class="sxs-lookup"><span data-stu-id="5e6a0-594">65000</span></span>|<span data-ttu-id="5e6a0-595">UTF-7</span><span class="sxs-lookup"><span data-stu-id="5e6a0-595">utf-7</span></span>|<span data-ttu-id="5e6a0-596">Юникод (UTF-7)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-596">Unicode (UTF-7)</span></span>|<span data-ttu-id="5e6a0-597">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-597">✓</span></span>|<span data-ttu-id="5e6a0-598">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-598">✓</span></span>|  
|<span data-ttu-id="5e6a0-599">65001</span><span class="sxs-lookup"><span data-stu-id="5e6a0-599">65001</span></span>|<span data-ttu-id="5e6a0-600">UTF-8</span><span class="sxs-lookup"><span data-stu-id="5e6a0-600">utf-8</span></span>|<span data-ttu-id="5e6a0-601">Юникод (UTF-8)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-601">Unicode (UTF-8)</span></span>|<span data-ttu-id="5e6a0-602">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-602">✓</span></span>|<span data-ttu-id="5e6a0-603">✓</span><span class="sxs-lookup"><span data-stu-id="5e6a0-603">✓</span></span>|  
  
 <span data-ttu-id="5e6a0-604">В следующем примере вызываются методы <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> и <xref:System.Text.Encoding.GetEncoding%28System.String%29> для получения кодировки кодовой страницы греческого языка (Windows).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-604">The following example calls the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> and <xref:System.Text.Encoding.GetEncoding%28System.String%29> methods to get the Greek (Windows) code page encoding.</span></span> <span data-ttu-id="5e6a0-605">Он сравнивает <xref:System.Text.Encoding> объекты, возвращаемые вызовами методов, чтобы показать, что они равны, а затем Maps отображает кодовую точку Юникода и соответствующее значение кодовой страницы для каждого символа в греческом алфавите.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-605">It compares the <xref:System.Text.Encoding> objects returned by the method calls to show that they are equal, and then maps displays the Unicode code point and the corresponding code page value for each character in the Greek alphabet.</span></span>  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 <span data-ttu-id="5e6a0-606">Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или метод <xref:System.Text.Encoding.GetEncoder%2A>, соответственно, производного класса.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-606">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="5e6a0-607">Кодировщики UTF-16 и UTF-32 могут использовать обратный порядок байтов (самый значащий байт) или обратный порядок байтов (минимальный значащий байт).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-607">The UTF-16 and the UTF-32 encoders can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first).</span></span> <span data-ttu-id="5e6a0-608">Например, Латинская прописная буква A (U + 0041) сериализуется следующим образом (в шестнадцатеричном формате):</span><span class="sxs-lookup"><span data-stu-id="5e6a0-608">For example, the Latin Capital Letter A (U+0041) is serialized as follows (in hexadecimal):</span></span>  
  
-   <span data-ttu-id="5e6a0-609">Порядковый номер UTF-16 с обратным порядком байтов: 00 41</span><span class="sxs-lookup"><span data-stu-id="5e6a0-609">UTF-16 big endian byte order: 00 41</span></span>  
  
-   <span data-ttu-id="5e6a0-610">UTF-16 с прямым порядком байтов: 41 00</span><span class="sxs-lookup"><span data-stu-id="5e6a0-610">UTF-16 little endian byte order: 41 00</span></span>  
  
-   <span data-ttu-id="5e6a0-611">UTF-32. обратный порядок байтов: 00 00 00 41</span><span class="sxs-lookup"><span data-stu-id="5e6a0-611">UTF-32 big endian byte order: 00 00 00 41</span></span>  
  
-   <span data-ttu-id="5e6a0-612">UTF-32, прямой порядок байтов: 41 00 00 00</span><span class="sxs-lookup"><span data-stu-id="5e6a0-612">UTF-32 little endian byte order: 41 00 00 00</span></span>  
  
 <span data-ttu-id="5e6a0-613">Обычно более эффективно хранить символы Юникода с помощью собственного порядка байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-613">It is generally more efficient to store Unicode characters using the native byte order.</span></span> <span data-ttu-id="5e6a0-614">Например, лучше использовать прямой порядок байтов на платформах с прямым порядком байтов, таких как компьютеры Intel.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-614">For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.</span></span>  
  
 <span data-ttu-id="5e6a0-615">Метод <xref:System.Text.Encoding.GetPreamble%2A> извлекает массив байтов, включающий метку порядка байтов (BOM).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-615">The <xref:System.Text.Encoding.GetPreamble%2A> method retrieves an array of bytes that includes the byte order mark (BOM).</span></span> <span data-ttu-id="5e6a0-616">Если этот массив байтов имеет префикс в закодированном потоке, он позволяет декодеру указывать используемый формат кодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-616">If this byte array is prefixed to an encoded stream, it helps the decoder to identify the encoding format used.</span></span>  
  
 <span data-ttu-id="5e6a0-617">Дополнительные сведения о порядке байтов и метке порядка байтов см. в стандарте Юникода на [домашней странице Юникода](https://go.microsoft.com/fwlink/?LinkId=37123).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-617">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](https://go.microsoft.com/fwlink/?LinkId=37123).</span></span>  
  
 <span data-ttu-id="5e6a0-618">Обратите внимание, что классы кодирования позволяют ошибкам:</span><span class="sxs-lookup"><span data-stu-id="5e6a0-618">Note that the encoding classes allow errors to:</span></span>  
  
-   <span data-ttu-id="5e6a0-619">Автоматическое изменение символа на символ "?".</span><span class="sxs-lookup"><span data-stu-id="5e6a0-619">Silently change to a "?" character.</span></span>  
  
-   <span data-ttu-id="5e6a0-620">Используйте символ "лучше подходит".</span><span class="sxs-lookup"><span data-stu-id="5e6a0-620">Use a "best fit" character.</span></span>  
  
-   <span data-ttu-id="5e6a0-621">Измените поведение приложения с помощью классов <xref:System.Text.EncoderFallback> и <xref:System.Text.DecoderFallback> с помощью символа замены Юникода U + FFFD.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-621">Change to an application-specific behavior through use of the <xref:System.Text.EncoderFallback> and <xref:System.Text.DecoderFallback> classes with the U+FFFD Unicode replacement character.</span></span>  
  
 <span data-ttu-id="5e6a0-622">При любой ошибке потока данных следует вызывать исключение.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-622">You should throw an exception on any data stream error.</span></span> <span data-ttu-id="5e6a0-623">Приложение либо использует флаг "throwOnError", если применимо, либо использует классы <xref:System.Text.EncoderExceptionFallback> и <xref:System.Text.DecoderExceptionFallback>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-623">An app either uses a "throwonerror" flag when applicable or uses the <xref:System.Text.EncoderExceptionFallback> and <xref:System.Text.DecoderExceptionFallback> classes.</span></span> <span data-ttu-id="5e6a0-624">Резервные стратегии наилучшего соответствия часто не рекомендуются, так как это может привести к потере или путанице данных и медленнее, чем простые замены символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-624">Best fit fallback is often not recommended because it can cause data loss or confusion and is slower than simple character replacements.</span></span> <span data-ttu-id="5e6a0-625">Для кодировок ANSI наилучшее поведение используется по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-625">For ANSI encodings, the best fit behavior is the default.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-626">В следующем примере строка из одной кодировки преобразуется в другую.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-626">The following example converts a string from one encoding to another.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5e6a0-627">Массив Byte [] является единственным типом в этом примере, который содержит закодированные данные.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-627">The byte[] array is the only type in this example that contains the encoded data.</span></span> <span data-ttu-id="5e6a0-628">Типы .NET Char и String представляют собой Юникод, поэтому <xref:System.Text.Encoding.GetChars%2A>ный вызов декодирует данные обратно в Юникод.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-628">The .NET Char and String types are themselves Unicode, so the <xref:System.Text.Encoding.GetChars%2A> call decodes the data back to Unicode.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="5e6a0-629">Общие сведения о кодировках</span><span class="sxs-lookup"><span data-stu-id="5e6a0-629">Understanding Encodings</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5e6a0-630">Инициализирует новый экземпляр класса <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-630">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5e6a0-631">Инициализирует новый экземпляр класса <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-631">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-632">Этот конструктор переопределяется производными классами.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-632">Derived classes override this constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage"><span data-ttu-id="5e6a0-633">Идентификатор кодовой страницы предпочтительной кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-633">The code page identifier of the preferred encoding.</span></span>  
  
 <span data-ttu-id="5e6a0-634">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-634">-or-</span></span>  
  
 <span data-ttu-id="5e6a0-635">0, если требуется использовать кодировку по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-635">0, to use the default encoding.</span></span></param>
        <summary><span data-ttu-id="5e6a0-636">Инициализирует новый экземпляр класса <see cref="T:System.Text.Encoding" />, соответствующий заданной кодовой странице.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-636">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-637">Этот конструктор переопределяется производными классами.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-637">Derived classes override this constructor.</span></span>  
  
 <span data-ttu-id="5e6a0-638">Вызовы этого конструктора из производного класса создают объект <xref:System.Text.Encoding>, который использует стратегию наилучшего соответствия для операций кодирования и декодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-638">Calls to this constructor from a derived class create an <xref:System.Text.Encoding> object that uses best-fit fallback for both encoding and decoding operations.</span></span> <span data-ttu-id="5e6a0-639">Свойства <xref:System.Text.Encoding.DecoderFallback%2A> и <xref:System.Text.Encoding.EncoderFallback%2A> доступны только для чтения и не могут быть изменены.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-639">Both the <xref:System.Text.Encoding.DecoderFallback%2A> and <xref:System.Text.Encoding.EncoderFallback%2A> properties are read-only and cannot be modified.</span></span> <span data-ttu-id="5e6a0-640">Чтобы управлять резервной стратегией для класса, производного от <xref:System.Text.Encoding>, вызовите конструктор <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-640">To control the fallback strategy for a class derived from <xref:System.Text.Encoding>, call the <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-641">Значение параметра <paramref name="codePage" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-641"><paramref name="codePage" /> is less than zero.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage"><span data-ttu-id="5e6a0-642">Идентификатор кодовой страницы кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-642">The encoding code page identifier.</span></span></param>
        <param name="encoderFallback"><span data-ttu-id="5e6a0-643">Объект, предоставляющий процедуру обработки ошибок, когда символ не может быть закодирован с использованием текущей кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-643">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span></span></param>
        <param name="decoderFallback"><span data-ttu-id="5e6a0-644">Объект, предоставляющий процедуру обработки ошибок, когда последовательность байтов не может быть декодирована с использованием текущей кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-644">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span></span></param>
        <summary><span data-ttu-id="5e6a0-645">Инициализирует новый экземпляр класса <see cref="T:System.Text.Encoding" />, соответствующий заданной кодовой странице, с использованием указанных стратегий резервирования кодировщика и декодера.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-645">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page with the specified encoder and decoder fallback strategies.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-646">Этот конструктор `protected`; производные классы переопределяют его.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-646">This constructor is `protected`; derived classes override it.</span></span>  
  
 <span data-ttu-id="5e6a0-647">Этот конструктор вызывается из производного класса для управления стратегиями резервного кодирования и декодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-647">You call this constructor from a derived class to control the fallback encoding and decoding strategies.</span></span> <span data-ttu-id="5e6a0-648">Конструкторы классов <xref:System.Text.Encoding> создают объекты кодирования, предназначенные только для чтения, которые не допускают установку кодировщика или дерезерва декодера после создания объекта.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-648">The <xref:System.Text.Encoding> class constructors create read-only encoding objects that don't allow encoder or decoder fallback to be set after the object is created.</span></span>  
  
 <span data-ttu-id="5e6a0-649">Если `encoderFallback` или `decoderFallback` имеет значение null, в качестве соответствующей резервной стратегии используется стратегия наилучшего соответствия.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-649">If either `encoderFallback` or `decoderFallback` is null, best-fit fallback is used as the corresponding fallback strategy.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-650">Значение параметра <paramref name="codePage" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-650"><paramref name="codePage" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-651">Получает кодировку для набора символов ASCII (7-разрядных).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-651">Gets an encoding for the ASCII (7-bit) character set.</span></span></summary>
        <value><span data-ttu-id="5e6a0-652">Кодировка набора символов ASCII (7-разрядных).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-652">An  encoding for the ASCII (7-bit) character set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-653">Символы ASCII ограничены самыми низкими 128 символами Юникода от U + 0000 до U + 007F.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-653">ASCII characters are limited to the lowest 128 Unicode characters, from U+0000 to U+007F.</span></span>  
  
 <span data-ttu-id="5e6a0-654">При выборе кодировки ASCII для приложения учитывайте следующее.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-654">When selecting the ASCII encoding for your app, consider the following:</span></span>  
  
-   <span data-ttu-id="5e6a0-655">Кодировка ASCII обычно подходит для протоколов, требующих ASCII.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-655">The ASCII encoding is usually appropriate for protocols that require ASCII.</span></span>  
  
-   <span data-ttu-id="5e6a0-656">Если требуется 8-разрядная кодировка (которая иногда ошибочно называется ASCII), рекомендуется использовать кодировку UTF-8 в кодировке ASCII.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-656">If you requires 8-bit encoding (which is sometimes incorrectly referred to as "ASCII"), the UTF-8 encoding is recommended over the ASCII encoding.</span></span> <span data-ttu-id="5e6a0-657">Для символов 0-7F результаты идентичны, но использование UTF-8 позволяет избежать потери данных, разрешая представление всех символов Юникода, которые можно представить.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-657">For the characters 0-7F, the results are identical, but use of UTF-8 avoids data loss by allowing representation of all Unicode characters that are representable.</span></span> <span data-ttu-id="5e6a0-658">Обратите внимание, что кодировка ASCII имеет 8-разрядную неоднозначность, которая может допускать вредоносное использование, но кодировка UTF-8 устраняет неоднозначность в восьмом бите.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-658">Note that the ASCII encoding has an 8th bit ambiguity that can allow malicious use, but the UTF-8 encoding removes ambiguity about the 8th bit.</span></span>  
  
-   <span data-ttu-id="5e6a0-659">До версии .NET Framework 2,0 .NET Framework допускало подмену, игнорируя восьмой бит.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-659">Prior to the .NET Framework version 2.0, the .NET Framework allowed spoofing by ignoring the 8th bit.</span></span> <span data-ttu-id="5e6a0-660">Начиная с .NET Framework 2,0, в процессе декодирования кодовые точки, не входящие в набор ASCII, переходят назад.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-660">Beginning with the .NET Framework 2.0, non-ASCII code points fall back during decoding.</span></span>  
  
 <span data-ttu-id="5e6a0-661">Объект <xref:System.Text.ASCIIEncoding>, возвращаемый этим свойством, может не иметь соответствующего поведения для приложения.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-661">The <xref:System.Text.ASCIIEncoding> object that is returned by this property might not have the appropriate behavior for your app.</span></span> <span data-ttu-id="5e6a0-662">Он использует резервный вариант замены, чтобы заменить каждую строку, которую не удается закодировать, и каждый байт, который не может быть декодирован символом вопросительного знака ("?").</span><span class="sxs-lookup"><span data-stu-id="5e6a0-662">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="5e6a0-663">Вместо этого можно вызвать метод <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>, чтобы создать экземпляр <xref:System.Text.ASCIIEncoding>, резервный объект которого является либо <xref:System.Text.EncoderFallbackException>, либо <xref:System.Text.DecoderFallbackException>, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-663">Instead, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> method to instantiate an <xref:System.Text.ASCIIEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-664">В следующем примере демонстрируется воздействие кодировки ASCII на символы, находящиеся за пределами диапазона ASCII.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-664">The following example demonstrates the effect of the ASCII encoding on characters that are outside the ASCII range.</span></span>  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="5e6a0-665">Общие сведения о кодировках</span><span class="sxs-lookup"><span data-stu-id="5e6a0-665">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-666">Получает кодировку для формата UTF-16 с обратным порядком байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-666">Gets an encoding for the UTF-16 format that uses the big endian byte order.</span></span></summary>
        <value><span data-ttu-id="5e6a0-667">Объект кодировки для формата UTF-16 с обратным порядком байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-667">An encoding object for the UTF-16 format that uses the big endian byte order.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-668">Объект <xref:System.Text.UnicodeEncoding>, возвращаемый этим свойством, может не иметь соответствующего поведения для приложения.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-668">The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="5e6a0-669">Он использует резервный вариант замены, чтобы заменить каждую строку, которую не удается закодировать, и каждый байт, который не может быть декодирован символом вопросительного знака ("?").</span><span class="sxs-lookup"><span data-stu-id="5e6a0-669">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="5e6a0-670">Вместо этого можно вызвать конструктор <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>, чтобы создать объект <xref:System.Text.UnicodeEncoding> с обратным порядком байтов, резервом которого является <xref:System.Text.EncoderFallbackException> или <xref:System.Text.DecoderFallbackException>, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-670">Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a big endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 <span data-ttu-id="5e6a0-671">Возвращаемый объект <xref:System.Text.UnicodeEncoding> содержит свойства <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>и <xref:System.Text.Encoding.WebName%2A>, которые дают имя "Уникодефффе".</span><span class="sxs-lookup"><span data-stu-id="5e6a0-671">The returned <xref:System.Text.UnicodeEncoding> object has <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, and <xref:System.Text.Encoding.WebName%2A> properties, which yield the name "unicodeFFFE".</span></span> <span data-ttu-id="5e6a0-672">Несмотря на то, что метка порядка байтов в кодировке UTF-16 имеет шестнадцатеричное значение FEFF, было выбрано имя «Уникодефффе», поскольку метка порядка байтов отображается как шестнадцатеричная ФФФЕ на компьютерах Windows с прямым порядком байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-672">Although the UTF-16 big endian byte order mark is hexadecimal FEFF, the name "unicodeFFFE" was chosen because the byte order mark appears as hexadecimal FFFE on little endian Windows computers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-673">В следующем примере выполняется чтение текстового файла с кодировкой UTF-16 с обратным порядком байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-673">The following example reads a text file with a UTF-16 encoding using the big endian byte order.</span></span>  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 <span data-ttu-id="5e6a0-674">В следующем примере определяется число байтов, необходимое для кодирования массива символов, символы кодируются и выводятся полученные байты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-674">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="5e6a0-675">Общие сведения о кодировках</span><span class="sxs-lookup"><span data-stu-id="5e6a0-675">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-676">При переопределении в производном классе получает имя текущей кодировки, которое может использоваться с тегами текста сообщения почтового агента.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-676">When overridden in a derived class, gets a name for the current encoding that can be used with mail agent body tags.</span></span></summary>
        <value><span data-ttu-id="5e6a0-677">Имя текущего объекта <see cref="T:System.Text.Encoding" />, которое может использоваться с тегами текста сообщения почтового агента.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-677">A name for the current <see cref="T:System.Text.Encoding" /> that can be used with mail agent body tags.</span></span>  
  
<span data-ttu-id="5e6a0-678">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-678">-or-</span></span> 
<span data-ttu-id="5e6a0-679">Пустая строка (""), если текущий объект <see cref="T:System.Text.Encoding" /> не может использоваться.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-679">An empty string (""), if the current <see cref="T:System.Text.Encoding" /> cannot be used.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-680">Если требуется кодировка для имени тела, следует вызвать метод <xref:System.Text.Encoding.GetEncoding%2A> со свойством <xref:System.Text.Encoding.BodyName%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-680">If you need an encoding for a body name, you should call <xref:System.Text.Encoding.GetEncoding%2A> with the <xref:System.Text.Encoding.BodyName%2A> property.</span></span> <span data-ttu-id="5e6a0-681">Часто метод извлекает другую кодировку из тестовой кодировки, предоставляемой в вызове.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-681">Often the method retrieves a different encoding from the test encoding furnished in the call.</span></span> <span data-ttu-id="5e6a0-682">Обычно для получения такой кодировки требуются только приложения электронной почты. Большинство других приложений, которым необходимо описать кодировку, должны использовать его <xref:System.Text.Encoding.WebName%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-682">Generally only email applications need to retrieve such an encoding; most other applications that need to describe an encoding should use its <xref:System.Text.Encoding.WebName%2A>.</span></span>  
  
 <span data-ttu-id="5e6a0-683">В некоторых случаях значение свойства <xref:System.Text.Encoding.BodyName%2A> соответствует международным стандарту, который определяет эту кодировку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-683">In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding.</span></span> <span data-ttu-id="5e6a0-684">Это не означает, что реализация полностью соответствует этому стандарту.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-684">This doesn't mean that the implementation complies in full with that standard.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-685">В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки с одним или несколькими именами, отличными от <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-685">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5e6a0-686">Он отображает <xref:System.Text.Encoding.EncodingName%2A> но не выполняет сравнение с ним.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-686">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5e6a0-687">При переопределении в производном классе создается неполная копия текущего объекта <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-687">When overridden in a derived class, creates a shallow copy of the current <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-688">Копия текущего объекта <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-688">A copy of the current <see cref="T:System.Text.Encoding" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-689">Копия доступна для записи, даже если исходный объект <xref:System.Text.Encoding> доступен только для чтения.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-689">The clone is writable even if the original <xref:System.Text.Encoding> object is read-only.</span></span> <span data-ttu-id="5e6a0-690">Таким образом, свойства клона можно изменить.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-690">Therefore, the properties of the clone can be modified.</span></span>  
  
 <span data-ttu-id="5e6a0-691">Неполная копия объекта — это копия только объекта.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-691">A shallow copy of an object is a copy of the object only.</span></span> <span data-ttu-id="5e6a0-692">Если объект содержит ссылки на другие объекты, то неполная копия не создает копии объектов, на которые они ссылаются.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-692">If the object contains references to other objects, the shallow copy does not create copies of the referred objects.</span></span> <span data-ttu-id="5e6a0-693">Вместо этого он ссылается на исходные объекты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-693">It refers to the original objects instead.</span></span> <span data-ttu-id="5e6a0-694">В отличие от этого, глубокая копия объекта создает копию объекта и копию всех объектов, на которые прямо или косвенно ссылается этот объект.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-694">In contrast, a deep copy of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-695">При переопределении в производном классе получает идентификатор кодовой страницы текущего объекта <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-695">When overridden in a derived class, gets the code page identifier of the current <see cref="T:System.Text.Encoding" />.</span></span></summary>
        <value><span data-ttu-id="5e6a0-696">Идентификатор кодовой страницы текущего объекта <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-696">The code page identifier of the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="5e6a0-697">В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки с одним или несколькими именами, отличными от <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-697">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5e6a0-698">Он отображает <xref:System.Text.Encoding.EncodingName%2A> но не выполняет сравнение с ним.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-698">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5e6a0-699">Преобразует массив байтов из одной кодировки в другую.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-699">Converts a byte array from one encoding to another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding"><span data-ttu-id="5e6a0-700">Формат кодировки параметра <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-700">The encoding format of <paramref name="bytes" />.</span></span></param>
        <param name="dstEncoding"><span data-ttu-id="5e6a0-701">Целевой формат кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-701">The target encoding format.</span></span></param>
        <param name="bytes"><span data-ttu-id="5e6a0-702">Преобразуемые байты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-702">The bytes to convert.</span></span></param>
        <summary><span data-ttu-id="5e6a0-703">Преобразует весь массив байтов из одной кодировки в другую.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-703">Converts an entire byte array from one encoding to another.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-704">Массив типа <see cref="T:System.Byte" />, содержащий результаты преобразования <paramref name="bytes" /> из <paramref name="srcEncoding" /> в <paramref name="dstEncoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-704">An array of type <see cref="T:System.Byte" /> containing the results of converting <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="5e6a0-705">В следующем примере строка в кодировке Юникод преобразуется в строку в кодировке ASCII.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-705">The following example converts a Unicode-encoded string to an ASCII-encoded string.</span></span> <span data-ttu-id="5e6a0-706">Поскольку объект кодировки ASCII, возвращаемый свойством <xref:System.Text.Encoding.ASCII%2A>, использует замену замены, а символ PI не является частью кодировки ASCII, символ PI заменяется вопросительным знаком, как показано в выходных данных примера.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-706">Because the ASCII encoding object returned by the <xref:System.Text.Encoding.ASCII%2A> property uses replacement fallback and the Pi character is not part of the ASCII character set, the Pi character is replaced with a question mark, as the output from the example shows.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-707">Свойство <paramref name="srcEncoding" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-707"><paramref name="srcEncoding" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5e6a0-708">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-708">-or-</span></span> 
 <span data-ttu-id="5e6a0-709">Свойство <paramref name="dstEncoding" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-709"><paramref name="dstEncoding" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5e6a0-710">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-710">-or-</span></span> 
 <span data-ttu-id="5e6a0-711"><paramref name="bytes" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-711"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="5e6a0-712">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-712">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-713">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-713">-and-</span></span> 
 <span data-ttu-id="5e6a0-714">**srcEncoding.**</span><span class="sxs-lookup"><span data-stu-id="5e6a0-714">**srcEncoding.**</span></span> <span data-ttu-id="5e6a0-715">Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-715"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="5e6a0-716">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-716">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-717">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-717">-and-</span></span> 
 <span data-ttu-id="5e6a0-718">**dstEncoding.**</span><span class="sxs-lookup"><span data-stu-id="5e6a0-718">**dstEncoding.**</span></span> <span data-ttu-id="5e6a0-719">Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-719"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding"><span data-ttu-id="5e6a0-720">Кодировка исходного массива, <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-720">The encoding of the source array, <paramref name="bytes" />.</span></span></param>
        <param name="dstEncoding"><span data-ttu-id="5e6a0-721">Кодировка выходного массива.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-721">The encoding of the output array.</span></span></param>
        <param name="bytes"><span data-ttu-id="5e6a0-722">Преобразуемый массив байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-722">The array of bytes to convert.</span></span></param>
        <param name="index"><span data-ttu-id="5e6a0-723">Индекс первого элемента преобразуемого массива байтов <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-723">The index of the first element of <paramref name="bytes" /> to convert.</span></span></param>
        <param name="count"><span data-ttu-id="5e6a0-724">Число байтов, которые требуется преобразовать.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-724">The number of bytes to convert.</span></span></param>
        <summary><span data-ttu-id="5e6a0-725">Преобразует диапазон байтов в массиве байтов из одной кодировки в другую.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-725">Converts a range of bytes in a byte array from one encoding to another.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-726">Массив типа <see cref="T:System.Byte" />, содержащий результат преобразования диапазона байтов из массива <paramref name="bytes" /> из <paramref name="srcEncoding" /> в <paramref name="dstEncoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-726">An array of type <see cref="T:System.Byte" /> containing the result of converting a range of bytes in <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-727">Свойство <paramref name="srcEncoding" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-727"><paramref name="srcEncoding" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5e6a0-728">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-728">-or-</span></span> 
 <span data-ttu-id="5e6a0-729">Свойство <paramref name="dstEncoding" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-729"><paramref name="dstEncoding" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5e6a0-730">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-730">-or-</span></span> 
 <span data-ttu-id="5e6a0-731">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-731"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-732"><paramref name="index" /> и <paramref name="count" /> не определяют допустимый диапазон в массиве байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-732"><paramref name="index" /> and <paramref name="count" /> do not specify a valid range in the byte array.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="5e6a0-733">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-733">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-734">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-734">-and-</span></span> 
 <span data-ttu-id="5e6a0-735">**srcEncoding.**</span><span class="sxs-lookup"><span data-stu-id="5e6a0-735">**srcEncoding.**</span></span> <span data-ttu-id="5e6a0-736">Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-736"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="5e6a0-737">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-737">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-738">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-738">-and-</span></span> 
 <span data-ttu-id="5e6a0-739">**dstEncoding.**</span><span class="sxs-lookup"><span data-stu-id="5e6a0-739">**dstEncoding.**</span></span> <span data-ttu-id="5e6a0-740">Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-740"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DecoderFallback As DecoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback" Usage="System.Text.Encoding.DecoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-741">Возвращает или задает объект <see cref="T:System.Text.DecoderFallback" /> для текущего объекта <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-741">Gets or sets the <see cref="T:System.Text.DecoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <value><span data-ttu-id="5e6a0-742">Резервный объект декодера для текущего объекта <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-742">The decoder fallback object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-743">Объект <xref:System.Text.DecoderFallback> представляет обработчик ошибок, который вызывается, когда закодированная последовательность байтов не может быть декодирована в символ.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-743">The <xref:System.Text.DecoderFallback> object represents an error handler that is invoked when an encoded byte sequence cannot be decoded into a character.</span></span> <span data-ttu-id="5e6a0-744">Поддерживается любой из следующих типов обработчиков:</span><span class="sxs-lookup"><span data-stu-id="5e6a0-744">Any one of the following handler types is supported:</span></span>  
  
-   <span data-ttu-id="5e6a0-745">Резервный обработчик наилучшего соответствия, который заменяет байты, которые не могут быть декодированы с помощью подходящего символа замены.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-745">A best-fit fallback handler, which replaces bytes that cannot be decoded with some suitable replacement character.</span></span>  
  
-   <span data-ttu-id="5e6a0-746">Резервный обработчик замены, который заменяет байты, которые не могут быть декодированы с помощью произвольного символа замены.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-746">A replacement fallback handler, which replaces bytes that cannot be decoded with some arbitrary replacement character.</span></span> <span data-ttu-id="5e6a0-747">В состав .NET входит один заменяющий резервный обработчик, <xref:System.Text.DecoderFallback>, который по умолчанию заменяет байты, которые не могут быть декодированы символом вопросительного знака ("?").</span><span class="sxs-lookup"><span data-stu-id="5e6a0-747">.NET includes one replacement fallback handler, <xref:System.Text.DecoderFallback>, which by default replaces bytes that cannot be decoded with a question mark ("?") character.</span></span>  
  
-   <span data-ttu-id="5e6a0-748">Обработчик отката исключений, который создает исключение, если не удается декодировать байты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-748">An exception fallback handler, which throws an exception when bytes cannot be decoded.</span></span> <span data-ttu-id="5e6a0-749">.NET включает один обработчик отката исключений, <xref:System.Text.DecoderExceptionFallback>, который вызывает <xref:System.Text.DecoderFallbackException>, если не удается декодировать байты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-749">.NET includes one exception fallback handler, <xref:System.Text.DecoderExceptionFallback>, which throws a <xref:System.Text.DecoderFallbackException> when bytes cannot be decoded.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-750">В операции задания значением является <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-750">The value in a set operation is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5e6a0-751">Невозможно задать значение, поскольку текущий объект <see cref="T:System.Text.Encoding" /> предназначен только для чтения.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-751">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</span></span></exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="5e6a0-752">Общие сведения о кодировках</span><span class="sxs-lookup"><span data-stu-id="5e6a0-752">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-753">Возвращает кодировку по умолчанию для данной реализации .NET.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-753">Gets the default encoding for this .NET implementation.</span></span></summary>
        <value><span data-ttu-id="5e6a0-754">Кодировка по умолчанию для этой реализации .NET.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-754">The default encoding for this .NET implementation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  <span data-ttu-id="5e6a0-755">Разные компьютеры могут использовать разные кодировки по умолчанию, а кодировка по умолчанию может измениться на одном компьютере.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-755">Different computers can use different encodings as the default, and the default encoding can change on a single computer.</span></span> <span data-ttu-id="5e6a0-756">При использовании кодировки <xref:System.Text.Encoding.Default%2A> для кодирования и декодирования данных, потоков между компьютерами или извлеченных в разное время на том же компьютере, они могут неправильно преобразовать эти данные.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-756">If you use the <xref:System.Text.Encoding.Default%2A> encoding to encode and decode data streamed between computers or retrieved at different times on the same computer, it may translate that data incorrectly.</span></span> <span data-ttu-id="5e6a0-757">Кроме того, кодировка, возвращаемая свойством <xref:System.Text.Encoding.Default%2A>, использует стратегию наилучшего соответствия, чтобы сопоставлять неподдерживаемые символы с символами, поддерживаемыми кодовой страницей.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-757">In addition, the encoding returned by the <xref:System.Text.Encoding.Default%2A> property uses best-fit fallback to map unsupported characters to characters supported by the code page.</span></span> <span data-ttu-id="5e6a0-758">По этим причинам использовать кодировку по умолчанию не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-758">For these reasons, using the default encoding is not recommended.</span></span> <span data-ttu-id="5e6a0-759">Чтобы обеспечить правильную декодирование закодированных байтов, следует использовать Юникод-кодировку, например <xref:System.Text.UTF8Encoding> или <xref:System.Text.UnicodeEncoding>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-759">To ensure that encoded bytes are decoded properly, you should use a Unicode encoding, such as <xref:System.Text.UTF8Encoding> or <xref:System.Text.UnicodeEncoding>.</span></span> <span data-ttu-id="5e6a0-760">Можно также использовать протокол более высокого уровня, чтобы убедиться в том, что для кодирования и декодирования используется один и тот же формат.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-760">You could also use a higher-level protocol to ensure that the same format is used for encoding and decoding.</span></span>  

### <a name="the-default-property-in-the-net-framework"></a><span data-ttu-id="5e6a0-761">Свойство по умолчанию в .NET Framework</span><span class="sxs-lookup"><span data-stu-id="5e6a0-761">The Default property in the .NET Framework</span></span>

<span data-ttu-id="5e6a0-762">В .NET Framework на рабочем столе Windows свойство <xref:System.Text.Encoding.Default%2A> всегда получает активную кодовую страницу системы и создает объект <xref:System.Text.Encoding>, соответствующий ему.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-762">In the .NET Framework on the Windows desktop, the <xref:System.Text.Encoding.Default%2A> property always gets the system's active code page and creates a <xref:System.Text.Encoding> object that corresponds to it.</span></span> <span data-ttu-id="5e6a0-763">Активной кодовой страницей может быть кодовая страница ANSI, содержащая набор символов ASCII вместе с дополнительными символами, которые зависят от кодовой страницы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-763">The active code page may be an ANSI code page, which includes the ASCII character set along with additional characters that vary by code page.</span></span> <span data-ttu-id="5e6a0-764">Поскольку все кодировки <xref:System.Text.Encoding.Default%2A>, основанные на кодовых страницах ANSI, теряют данные, рассмотрите возможность использования кодировки <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-764">Because all <xref:System.Text.Encoding.Default%2A> encodings based on ANSI code pages lose data, consider using the <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> encoding instead.</span></span> <span data-ttu-id="5e6a0-765">UTF-8 часто совпадает с диапазоном U + 00 до U + 7F, но может кодировать символы за пределами диапазона ASCII без потерь.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-765">UTF-8 is often identical in the U+00 to U+7F range, but can encode characters outside the ASCII range without loss.</span></span>

## <a name="the-default-property-on-net-core"></a><span data-ttu-id="5e6a0-766">Свойство по умолчанию в .NET Core</span><span class="sxs-lookup"><span data-stu-id="5e6a0-766">The Default property on .NET Core</span></span>

<span data-ttu-id="5e6a0-767">В .NET Core свойство <xref:System.Text.Encoding.Default%2A> всегда возвращает <xref:System.Text.UTF8Encoding>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-767">On .NET Core, the <xref:System.Text.Encoding.Default%2A> property always returns the <xref:System.Text.UTF8Encoding>.</span></span> <span data-ttu-id="5e6a0-768">UTF-8 поддерживается во всех операционных системах (Windows, Linux и Max OS X), на которых работают приложения .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-768">UTF-8 is supported on all the operating systems (Windows, Linux, and Max OS X) on which .NET Core applications run.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EncoderFallback As EncoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback" Usage="System.Text.Encoding.EncoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-769">Возвращает или задает объект <see cref="T:System.Text.EncoderFallback" /> для текущего объекта <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-769">Gets or sets the <see cref="T:System.Text.EncoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <value><span data-ttu-id="5e6a0-770">Резервный объект кодировщика для текущего объекта <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-770">The encoder fallback object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-771">Объект <xref:System.Text.EncoderFallback> представляет обработчик ошибок, который вызывается, когда символ не может быть преобразован в закодированную последовательность байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-771">The <xref:System.Text.EncoderFallback> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence.</span></span> <span data-ttu-id="5e6a0-772">Поддерживается любой из следующих типов обработчиков:</span><span class="sxs-lookup"><span data-stu-id="5e6a0-772">Any one of the following handler types is supported:</span></span>  
  
-   <span data-ttu-id="5e6a0-773">Резервный обработчик наилучшего соответствия, который заменяет символы, которые не могут быть закодированы с помощью подходящего символа замены.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-773">A best-fit fallback handler, which replaces characters that cannot be encoded with some suitable replacement character.</span></span>  
  
-   <span data-ttu-id="5e6a0-774">Резервный обработчик замены, который заменяет символы, которые не могут быть закодированы произвольным символом замены.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-774">A replacement fallback handler, which replaces characters that cannot be encoded with some arbitrary replacement character.</span></span> <span data-ttu-id="5e6a0-775">В состав .NET входит один заменяющий резервный обработчик, <xref:System.Text.EncoderFallback>, который по умолчанию заменяет символы, которые не могут быть закодированы символом вопросительного знака ("?").</span><span class="sxs-lookup"><span data-stu-id="5e6a0-775">.NET includes one replacement fallback handler, <xref:System.Text.EncoderFallback>, which by default replaces characters that cannot be encoded with a question mark ("?") character.</span></span>  
  
-   <span data-ttu-id="5e6a0-776">Обработчик отката исключений, который создает исключение, если символы не могут быть закодированы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-776">An exception fallback handler, which throws an exception when characters cannot be encoded.</span></span> <span data-ttu-id="5e6a0-777">.NET включает один обработчик отката исключений, <xref:System.Text.EncoderExceptionFallback>, который вызывает <xref:System.Text.EncoderFallbackException>, когда символы не могут быть декодированы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-777">.NET includes one exception fallback handler, <xref:System.Text.EncoderExceptionFallback>, which throws an <xref:System.Text.EncoderFallbackException> when characters cannot be decoded.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-778">В операции задания значением является <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-778">The value in a set operation is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5e6a0-779">Невозможно задать значение, поскольку текущий объект <see cref="T:System.Text.Encoding" /> предназначен только для чтения.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-779">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</span></span></exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="5e6a0-780">Общие сведения о кодировках</span><span class="sxs-lookup"><span data-stu-id="5e6a0-780">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-781">При переопределении в производном классе получает описание текущей кодировки, которое может быть прочитано пользователем.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-781">When overridden in a derived class, gets the human-readable description of the current encoding.</span></span></summary>
        <value><span data-ttu-id="5e6a0-782">Описание текущего объекта <see cref="T:System.Text.Encoding" />, которое может быть прочитано пользователем.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-782">The human-readable description of the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-783">Свойство <xref:System.Text.Encoding.EncodingName%2A> предназначено для вывода.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-783">The <xref:System.Text.Encoding.EncodingName%2A> property is intended for display.</span></span> <span data-ttu-id="5e6a0-784">Чтобы найти имя, которое можно передать в метод <xref:System.Text.Encoding.GetEncoding%2A>, используйте свойство <xref:System.Text.Encoding.WebName%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-784">To find a name that can be passed to the <xref:System.Text.Encoding.GetEncoding%2A> method, use the <xref:System.Text.Encoding.WebName%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-785">В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки с одним или несколькими именами, отличными от <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-785">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5e6a0-786">Он отображает <xref:System.Text.Encoding.EncodingName%2A> но не выполняет сравнение с ним.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-786">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="5e6a0-787"><see cref="T:System.Object" /> для сравнения с текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-787">The <see cref="T:System.Object" /> to compare with the current instance.</span></span></param>
        <summary><span data-ttu-id="5e6a0-788">Определяет, равен ли указанный объект <see cref="T:System.Object" /> текущему экземпляру.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-788">Determines whether the specified <see cref="T:System.Object" /> is equal to the current instance.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-789">Значение <see langword="true" />, если <paramref name="value" /> является экземпляром <see cref="T:System.Text.Encoding" />, равным текущему экземпляру; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-789"><see langword="true" /> if <paramref name="value" /> is an instance of <see cref="T:System.Text.Encoding" /> and is equal to the current instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-790">Два экземпляра <xref:System.Text.Encoding> считаются равными, если они соответствуют одной и той же кодовой странице, а их `EncoderFallback` и `DecoderFallback` объекты равны.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-790">Two instances of <xref:System.Text.Encoding> are considered equal if they correspond to the same code page and their `EncoderFallback` and `DecoderFallback` objects are equal.</span></span> <span data-ttu-id="5e6a0-791">В частности, на производных страницах кода есть кодовая страница 0, а их резервные варианты обычно `null` (`Nothing` в Visual Basic .NET).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-791">In particular, derived code pages all have a code page of 0 and their fallbacks are normally `null` (`Nothing` in Visual Basic .NET).</span></span> <span data-ttu-id="5e6a0-792">Поэтому все они считаются равными друг другу.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-792">Thus they are all considered equal to one another.</span></span> <span data-ttu-id="5e6a0-793">Один из них состоит в том, что когда <xref:System.Text.Encoding.Equals%2A> используется для заполнения хэш-таблицы, все производные кодировки сравниваются равными и попадают в один и тот же слот хэш-таблицы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-793">One consequence is that when <xref:System.Text.Encoding.Equals%2A> is used to populate a hash table, all derived encodings compare equal and fall into the same hash table slot.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-794">В следующем примере выполняется получение двух экземпляров одной и той же кодировки (по одной кодовой странице, другой по имени) и проверка их равенства.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-794">The following example gets two instances of the same encoding (one by codepage and another by name), and checks their equality.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5e6a0-795">При переопределении в производном классе вычисляет количество байтов, полученных при кодировании набора символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-795">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="5e6a0-796">Массив символов, содержащий символы, которые требуется закодировать.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-796">The character array containing the characters to encode.</span></span></param>
        <summary><span data-ttu-id="5e6a0-797">При переопределении в производном классе вычисляет количество байтов, полученных при кодировании всех символов из заданного массива символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-797">When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-798">Количество байтов, полученных при кодировании всех символов из указанного массива символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-798">The number of bytes produced by encoding all the characters in the specified character array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-799">Чтобы вычислить точный размер массива, необходимый <xref:System.Text.Encoding.GetBytes%2A> для хранения результирующих байтов, вызовите метод <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-799">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="5e6a0-800">Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.Encoding.GetMaxByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-800">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="5e6a0-801">Метод <xref:System.Text.Encoding.GetByteCount%2A> обычно позволяет выделить меньше памяти, а метод <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-801">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="5e6a0-802">Метод <xref:System.Text.Encoding.GetByteCount%2A> определяет, сколько байт приводит к кодированию набора символов Юникода, а метод <xref:System.Text.Encoding.GetBytes%2A> выполняет фактическую кодировку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-802">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="5e6a0-803">Метод <xref:System.Text.Encoding.GetBytes%2A> ждет дискретные преобразования, в отличие от метода <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>, который обрабатывает несколько преобразований в одном входном потоке.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-803">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-804">Поддерживаются несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-804">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="5e6a0-805">Ниже приведены некоторые рекомендации по программированию для использования этих методов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-805">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="5e6a0-806">Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-806">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="5e6a0-807">В этом случае, вероятно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется в используемом объекте <xref:System.Text.Encoder>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-807">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>  
  
-   <span data-ttu-id="5e6a0-808">Если приложение обрабатывает входные данные строки, следует использовать строковые версии метода <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-808">If your app handles string inputs, you should use the string versions of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>  
  
-   <span data-ttu-id="5e6a0-809">Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые методы, особенно с несколькими вызовами с помощью объекта <xref:System.Text.Encoder> или вставкой в существующие буферы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-809">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="5e6a0-810">Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-810">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="5e6a0-811">Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-811">If your app must convert a large amount of data, you should reuse the output buffer.</span></span> <span data-ttu-id="5e6a0-812">В этом случае лучшим выбором является версия <xref:System.Text.Encoding.GetBytes%2A>, которая поддерживает массивы байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-812">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="5e6a0-813">Вместо <xref:System.Text.Encoding.GetByteCount%2A>рекомендуется использовать метод <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-813">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="5e6a0-814">Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-814">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="5e6a0-815">Для непрерывной кодировки потока этот метод часто является лучшим выбором.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-815">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-816">В следующем примере определяется число байтов, необходимое для кодирования массива символов, символы кодируются и выводятся полученные байты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-816">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-817">Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-817"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="5e6a0-818">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-818">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-819">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-819">-and-</span></span> 
 <span data-ttu-id="5e6a0-820">Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-820"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="5e6a0-821">Строка, содержащая набор символов для кодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-821">The string containing the set of characters to encode.</span></span></param>
        <summary><span data-ttu-id="5e6a0-822">При переопределении в производном классе вычисляет число байтов, полученных при кодировании символов в заданной строке.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-822">When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-823">Число байтов, полученных при кодировании заданных символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-823">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-824">Чтобы вычислить точный размер массива, необходимый <xref:System.Text.Encoding.GetBytes%2A> для хранения результирующих байтов, вызовите метод <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-824">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="5e6a0-825">Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.Encoding.GetMaxByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-825">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="5e6a0-826">Метод <xref:System.Text.Encoding.GetByteCount%2A> обычно позволяет выделить меньше памяти, а метод <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-826">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="5e6a0-827">Метод <xref:System.Text.Encoding.GetByteCount%2A> определяет, сколько байт приводит к кодированию набора символов Юникода, а метод <xref:System.Text.Encoding.GetBytes%2A> выполняет фактическую кодировку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-827">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="5e6a0-828">Метод <xref:System.Text.Encoding.GetBytes%2A> ждет дискретные преобразования, в отличие от метода <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>, который обрабатывает несколько преобразований в одном входном потоке.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-828">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-829">Поддерживаются несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-829">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="5e6a0-830">Ниже приведены некоторые рекомендации по программированию для использования этих методов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-830">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="5e6a0-831">Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-831">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="5e6a0-832">В этом случае, вероятно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется в используемом объекте <xref:System.Text.Encoder>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-832">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>  
  
-   <span data-ttu-id="5e6a0-833">Если приложение обрабатывает входные строки, рекомендуется использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-833">If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>  
  
-   <span data-ttu-id="5e6a0-834">Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые методы, особенно с несколькими вызовами с помощью объекта <xref:System.Text.Encoder> или вставкой в существующие буферы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-834">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="5e6a0-835">Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-835">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="5e6a0-836">Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-836">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="5e6a0-837">В этом случае лучшим выбором является версия <xref:System.Text.Encoding.GetBytes%2A>, которая поддерживает массивы байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-837">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="5e6a0-838">Вместо <xref:System.Text.Encoding.GetByteCount%2A>рекомендуется использовать метод <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-838">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="5e6a0-839">Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-839">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="5e6a0-840">Для непрерывной кодировки потока этот метод часто является лучшим выбором.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-840">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-841">В следующем примере определяется число байтов, необходимое для кодирования строки или диапазона в строке, символы кодируются и выводятся полученные байты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-841">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-842">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-842"><paramref name="s" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="5e6a0-843">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-843">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-844">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-844">-and-</span></span> 
 <span data-ttu-id="5e6a0-845">Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-845"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="5e6a0-846">Указатель на первый кодируемый символ.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-846">A pointer to the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="5e6a0-847">Число кодируемых символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-847">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="5e6a0-848">При переопределении в производном классе вычисляет количество байтов, полученных при кодировании набора символов, начиная с заданного указателя символа.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-848">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-849">Число байтов, полученных при кодировании заданных символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-849">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-850">Чтобы вычислить точный размер массива, который <xref:System.Text.Encoding.GetBytes%2A> требуется для хранения результирующих байтов, следует вызвать метод <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-850">To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="5e6a0-851">Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.Encoding.GetMaxByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-851">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="5e6a0-852">Метод <xref:System.Text.Encoding.GetByteCount%2A> обычно позволяет выделить меньше памяти, а метод <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-852">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="5e6a0-853">Метод <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> определяет, сколько байт приводит к кодированию набора символов Юникода, а метод <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> выполняет фактическую кодировку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-853">The <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> method performs the actual encoding.</span></span> <span data-ttu-id="5e6a0-854">Метод <xref:System.Text.Encoding.GetBytes%2A> ждет дискретные преобразования, в отличие от метода <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>, который обрабатывает несколько преобразований в одном входном потоке.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-854">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-855">Поддерживаются несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-855">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="5e6a0-856">Ниже приведены некоторые рекомендации по использованию этих методов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-856">The following are some considerations for using these methods:</span></span>  
  
-   <span data-ttu-id="5e6a0-857">Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-857">Your app may need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="5e6a0-858">В этом случае, вероятно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется в используемом объекте <xref:System.Text.Encoder>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-858">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>  
  
-   <span data-ttu-id="5e6a0-859">Если приложение обрабатывает входные строки, следует использовать строковую версию метода <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-859">If your app handles string inputs, you should use the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>  
  
-   <span data-ttu-id="5e6a0-860">Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%2A> позволяет использовать некоторые быстрые методы, особенно с несколькими вызовами с помощью объекта <xref:System.Text.Encoder> или вставкой в существующие буферы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-860">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%2A> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="5e6a0-861">Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-861">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="5e6a0-862">Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-862">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="5e6a0-863">В этом случае лучшим выбором является версия <xref:System.Text.Encoding.GetBytes%2A>, которая поддерживает массивы байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-863">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="5e6a0-864">Вместо <xref:System.Text.Encoding.GetByteCount%2A>рекомендуется использовать метод <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-864">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="5e6a0-865">Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-865">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="5e6a0-866">Для непрерывной кодировки потока этот метод часто является лучшим выбором.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-866">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-867"><paramref name="chars" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-867"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-868">Значение параметра <paramref name="count" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-868"><paramref name="count" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="5e6a0-869">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-869">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-870">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-870">-and-</span></span> 
 <span data-ttu-id="5e6a0-871">Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-871"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5e6a0-872">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-872">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="5e6a0-873">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-873">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="5e6a0-874">Массив символов, содержащий набор кодируемых символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-874">The character array containing the set of characters to encode.</span></span></param>
        <param name="index"><span data-ttu-id="5e6a0-875">Индекс первого кодируемого символа.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-875">The index of the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="5e6a0-876">Число кодируемых символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-876">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="5e6a0-877">При переопределении в производном классе вычисляет количество байтов, полученных при кодировании набора символов из указанного массива символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-877">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-878">Число байтов, полученных при кодировании заданных символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-878">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-879">Чтобы вычислить точный размер массива, необходимый <xref:System.Text.Encoding.GetBytes%2A> для хранения результирующих байтов, вызовите метод <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-879">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="5e6a0-880">Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.Encoding.GetMaxByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-880">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="5e6a0-881">Метод <xref:System.Text.Encoding.GetByteCount%2A> обычно позволяет выделить меньше памяти, а метод <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-881">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="5e6a0-882">Метод <xref:System.Text.Encoding.GetByteCount%2A> определяет, сколько байт приводит к кодированию набора символов Юникода, а метод <xref:System.Text.Encoding.GetBytes%2A> выполняет фактическую кодировку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-882">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="5e6a0-883">Метод <xref:System.Text.Encoding.GetBytes%2A> ждет дискретные преобразования, в отличие от метода <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>, который обрабатывает несколько преобразований в одном входном потоке.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-883">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-884">Поддерживаются несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-884">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="5e6a0-885">Ниже приведены некоторые рекомендации по программированию для использования этих методов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-885">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="5e6a0-886">Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-886">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="5e6a0-887">В этом случае, вероятно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется в используемом объекте <xref:System.Text.Encoder>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-887">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>  
  
-   <span data-ttu-id="5e6a0-888">Если приложение обрабатывает входные строки, рекомендуется использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-888">If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>  
  
-   <span data-ttu-id="5e6a0-889">Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые методы, особенно с несколькими вызовами с помощью объекта <xref:System.Text.Encoder> или вставкой в существующие буферы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-889">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="5e6a0-890">Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-890">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="5e6a0-891">Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-891">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="5e6a0-892">В этом случае лучшим выбором является версия <xref:System.Text.Encoding.GetBytes%2A>, которая поддерживает массивы байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-892">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="5e6a0-893">Вместо <xref:System.Text.Encoding.GetByteCount%2A>рекомендуется использовать метод <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-893">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="5e6a0-894">Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-894">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="5e6a0-895">Для непрерывной кодировки потока этот метод часто является лучшим выбором.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-895">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-896">В следующем примере определяется число байтов, необходимое для кодирования трех символов из массива символов, символы кодируются и выводятся полученные байты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-896">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-897">Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-897"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-898">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-898"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="5e6a0-899">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-899">-or-</span></span> 
 <span data-ttu-id="5e6a0-900">Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="chars" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-900"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="5e6a0-901">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-901">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-902">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-902">-and-</span></span> 
 <span data-ttu-id="5e6a0-903">Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-903"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5e6a0-904">При переопределении в производном классе кодирует набор символов в последовательность байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-904">When overridden in a derived class, encodes a set of characters into a sequence of bytes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="5e6a0-905">Массив символов, содержащий символы, которые требуется закодировать.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-905">The character array containing the characters to encode.</span></span></param>
        <summary><span data-ttu-id="5e6a0-906">При переопределении в производном классе кодирует все символы из указанного массива символов в последовательность байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-906">When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-907">Массив байтов, содержащий результаты кодирования указанного набора символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-907">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-908">Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или метод <xref:System.Text.Encoding.GetEncoder%2A>, соответственно, производного класса.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-908">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="5e6a0-909">Метод <xref:System.Text.Encoding.GetByteCount%2A> определяет, сколько байт приводит к кодированию набора символов Юникода, а метод <xref:System.Text.Encoding.GetBytes%2A> выполняет фактическую кодировку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-909">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="5e6a0-910">Метод <xref:System.Text.Encoding.GetBytes%2A> ждет дискретные преобразования, в отличие от метода <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>, который обрабатывает несколько преобразований в одном входном потоке.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-910">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-911">Поддерживаются несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-911">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="5e6a0-912">Ниже приведены некоторые рекомендации по программированию для использования этих методов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-912">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="5e6a0-913">Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-913">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="5e6a0-914">В этом случае, вероятно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется в используемом объекте <xref:System.Text.Encoder>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-914">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="5e6a0-915">(Например, последовательность символов, включающая суррогатные пары, может заканчиваться старшим суррогатом.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-915">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="5e6a0-916"><xref:System.Text.Encoder> будет помнить, что старший суррогат можно объединить с младшим суррогатом в начале следующего вызова.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-916">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="5e6a0-917"><xref:System.Text.Encoding> не сможет поддерживать состояние, поэтому символ будет отправлен на <xref:System.Text.EncoderFallback>.)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-917"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="5e6a0-918">Если приложение обрабатывает входные данные строки, следует вызвать строковую версию метода <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-918">If your app handles string inputs, you should call the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>  
  
-   <span data-ttu-id="5e6a0-919">Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые методы, особенно с несколькими вызовами с помощью объекта <xref:System.Text.Encoder> или вставкой в существующие буферы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-919">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="5e6a0-920">Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-920">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="5e6a0-921">Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-921">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="5e6a0-922">В этом случае лучшим выбором является версия <xref:System.Text.Encoding.GetBytes%2A>, которая поддерживает массивы байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-922">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="5e6a0-923">Вместо <xref:System.Text.Encoding.GetByteCount%2A>рекомендуется использовать метод <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-923">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="5e6a0-924">Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-924">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="5e6a0-925">Для непрерывной кодировки потока этот метод часто является лучшим выбором.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-925">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-926">В следующем примере определяется число байтов, необходимое для кодирования массива символов, символы кодируются и выводятся полученные байты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-926">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-927">Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-927"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="5e6a0-928">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-928">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-929">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-929">-and-</span></span> 
 <span data-ttu-id="5e6a0-930">Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-930"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="5e6a0-931">Строка, содержащая символы, которые требуется закодировать.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-931">The string containing the characters to encode.</span></span></param>
        <summary><span data-ttu-id="5e6a0-932">При переопределении в производном классе кодирует все символы заданной строки в последовательность байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-932">When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-933">Массив байтов, содержащий результаты кодирования указанного набора символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-933">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-934">Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или метод <xref:System.Text.Encoding.GetEncoder%2A>, соответственно, производного класса.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-934">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="5e6a0-935">Метод <xref:System.Text.Encoding.GetByteCount%2A> определяет, сколько байт приводит к кодированию набора символов Юникода, а метод <xref:System.Text.Encoding.GetBytes%2A> выполняет фактическую кодировку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-935">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="5e6a0-936">Метод <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> ждет дискретные преобразования, в отличие от метода <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>, который обрабатывает несколько преобразований в одном входном потоке.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-936">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-937">Поддерживаются несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-937">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="5e6a0-938">Ниже приведены некоторые рекомендации по программированию для использования этих методов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-938">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="5e6a0-939">Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-939">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="5e6a0-940">В этом случае, вероятно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется в используемом объекте <xref:System.Text.Encoder>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-940">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="5e6a0-941">(Например, последовательность символов, включающая суррогатные пары, может заканчиваться старшим суррогатом.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-941">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="5e6a0-942"><xref:System.Text.Encoder> будет помнить, что старший суррогат можно объединить с младшим суррогатом в начале следующего вызова.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-942">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="5e6a0-943"><xref:System.Text.Encoding> не сможет поддерживать состояние, поэтому символ будет отправлен на <xref:System.Text.EncoderFallback>.)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-943"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="5e6a0-944">Если приложение обрабатывает входные данные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-944">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>  
  
-   <span data-ttu-id="5e6a0-945">Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые методы, особенно с несколькими вызовами с помощью объекта <xref:System.Text.Encoder> или вставкой в существующие буферы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-945">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="5e6a0-946">Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-946">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="5e6a0-947">Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-947">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="5e6a0-948">В этом случае лучшим выбором является версия <xref:System.Text.Encoding.GetBytes%2A>, которая поддерживает массивы байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-948">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="5e6a0-949">Вместо <xref:System.Text.Encoding.GetByteCount%2A>рекомендуется использовать метод <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-949">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="5e6a0-950">Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-950">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="5e6a0-951">Для непрерывной кодировки потока этот метод часто является лучшим выбором.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-951">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-952">В следующем примере определяется число байтов, необходимое для кодирования строки или диапазона в строке, символы кодируются и выводятся полученные байты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-952">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-953">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-953"><paramref name="s" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="5e6a0-954">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-954">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-955">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-955">-and-</span></span> 
 <span data-ttu-id="5e6a0-956">Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-956"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="5e6a0-957">Массив символов, содержащий набор кодируемых символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-957">The character array containing the set of characters to encode.</span></span></param>
        <param name="index"><span data-ttu-id="5e6a0-958">Индекс первого кодируемого символа.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-958">The index of the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="5e6a0-959">Число кодируемых символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-959">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="5e6a0-960">При переопределении в производном классе кодирует набор символов из указанного массива символов в последовательность байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-960">When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-961">Массив байтов, содержащий результаты кодирования указанного набора символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-961">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-962">Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или метод <xref:System.Text.Encoding.GetEncoder%2A>, соответственно, производного класса.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-962">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="5e6a0-963">Метод <xref:System.Text.Encoding.GetByteCount%2A> определяет, сколько байт приводит к кодированию набора символов Юникода, а метод <xref:System.Text.Encoding.GetBytes%2A> выполняет фактическую кодировку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-963">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="5e6a0-964">Метод <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> ждет дискретные преобразования, в отличие от метода <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>, который обрабатывает несколько преобразований в одном входном потоке.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-964">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-965">Поддерживаются несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-965">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="5e6a0-966">Ниже приведены некоторые рекомендации по программированию для использования этих методов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-966">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="5e6a0-967">Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-967">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="5e6a0-968">В этом случае, вероятно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется в используемом объекте <xref:System.Text.Encoder>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-968">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="5e6a0-969">(Например, последовательность символов, включающая суррогатные пары, может заканчиваться старшим суррогатом.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-969">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="5e6a0-970"><xref:System.Text.Encoder> будет помнить, что старший суррогат можно объединить с младшим суррогатом в начале следующего вызова.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-970">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="5e6a0-971"><xref:System.Text.Encoding> не сможет поддерживать состояние, поэтому символ будет отправлен на <xref:System.Text.EncoderFallback>.)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-971"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="5e6a0-972">Если приложение обрабатывает входные данные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-972">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>  
  
-   <span data-ttu-id="5e6a0-973">Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые методы, особенно с несколькими вызовами с помощью объекта <xref:System.Text.Encoder> или вставкой в существующие буферы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-973">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="5e6a0-974">Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-974">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="5e6a0-975">Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-975">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="5e6a0-976">В этом случае лучшим выбором является версия <xref:System.Text.Encoding.GetBytes%2A>, которая поддерживает массивы байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-976">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="5e6a0-977">Вместо <xref:System.Text.Encoding.GetByteCount%2A>рекомендуется использовать метод <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-977">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="5e6a0-978">Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-978">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="5e6a0-979">Для непрерывной кодировки потока этот метод часто является лучшим выбором.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-979">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-980">В следующем примере определяется число байтов, необходимое для кодирования трех символов из массива символов, символы кодируются и выводятся полученные байты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-980">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-981"><paramref name="chars" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-981"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-982">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-982"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="5e6a0-983">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-983">-or-</span></span> 
 <span data-ttu-id="5e6a0-984">Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="chars" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-984"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="5e6a0-985">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-985">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-986">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-986">-and-</span></span> 
 <span data-ttu-id="5e6a0-987">Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-987"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="5e6a0-988">Указатель на первый кодируемый символ.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-988">A pointer to the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="5e6a0-989">Число кодируемых символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-989">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="5e6a0-990">Указатель на положение, с которого начинается запись результирующей последовательности байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-990">A pointer to the location at which to start writing the resulting sequence of bytes.</span></span></param>
        <param name="byteCount"><span data-ttu-id="5e6a0-991">Максимальное число байтов для записи.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-991">The maximum number of bytes to write.</span></span></param>
        <summary><span data-ttu-id="5e6a0-992">При переопределении в производном классе кодирует набор символов, начало которого задается указателем символа, в последовательность байтов, которые сохраняются, начиная с заданного указателя байта.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-992">When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-993">Фактическое число байтов, записанных в местоположение, которое задано параметром <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-993">The actual number of bytes written at the location indicated by the <paramref name="bytes" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-994">Чтобы вычислить точный размер массива, который <xref:System.Text.Encoding.GetBytes%2A> требуется для хранения результирующих байтов, вызовите метод <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-994">To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="5e6a0-995">Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.Encoding.GetMaxByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-995">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="5e6a0-996">Метод <xref:System.Text.Encoding.GetByteCount%2A> обычно позволяет выделить меньше памяти, а метод <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-996">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="5e6a0-997">Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> объект, предоставляемый <xref:System.Text.Encoding.GetDecoder%2A>настроек или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-997">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="5e6a0-998">Метод <xref:System.Text.Encoding.GetByteCount%2A> определяет, сколько байт приводит к кодированию набора символов Юникода, а метод <xref:System.Text.Encoding.GetBytes%2A> выполняет фактическую кодировку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-998">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="5e6a0-999">Метод <xref:System.Text.Encoding.GetBytes%2A> ждет дискретные преобразования, в отличие от метода <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>, который обрабатывает несколько преобразований в одном входном потоке.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-999">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-1000">Поддерживаются несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1000">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="5e6a0-1001">Ниже приведены некоторые рекомендации по программированию для использования этих методов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1001">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="5e6a0-1002">Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1002">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="5e6a0-1003">В этом случае, вероятно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется в используемом объекте <xref:System.Text.Encoder>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1003">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="5e6a0-1004">(Например, последовательность символов, включающая суррогатные пары, может заканчиваться старшим суррогатом.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1004">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="5e6a0-1005"><xref:System.Text.Encoder> будет помнить, что старший суррогат можно объединить с младшим суррогатом в начале следующего вызова.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1005">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="5e6a0-1006"><xref:System.Text.Encoding> не сможет поддерживать состояние, поэтому символ будет отправлен на <xref:System.Text.EncoderFallback>.)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1006"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="5e6a0-1007">Если приложение обрабатывает входные данные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1007">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>  
  
-   <span data-ttu-id="5e6a0-1008">Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые методы, особенно с несколькими вызовами с помощью объекта <xref:System.Text.Encoder> или вставкой в существующие буферы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1008">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="5e6a0-1009">Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1009">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="5e6a0-1010">Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1010">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="5e6a0-1011">В этом случае лучшим выбором является версия <xref:System.Text.Encoding.GetBytes%2A>, которая поддерживает массивы байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1011">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="5e6a0-1012">Вместо <xref:System.Text.Encoding.GetByteCount%2A>рекомендуется использовать метод <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1012">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="5e6a0-1013">Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1013">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="5e6a0-1014">Для непрерывной кодировки потока этот метод часто является лучшим выбором.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1014">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-1015">Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1015"><paramref name="chars" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5e6a0-1016">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1016">-or-</span></span> 
 <span data-ttu-id="5e6a0-1017">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1017"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-1018">Значение параметра <paramref name="charCount" /> или <paramref name="byteCount" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1018"><paramref name="charCount" /> or <paramref name="byteCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5e6a0-1019"><paramref name="byteCount" /> меньше результирующего числа байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1019"><paramref name="byteCount" /> is less than the resulting number of bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="5e6a0-1020">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1020">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-1021">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1021">-and-</span></span> 
 <span data-ttu-id="5e6a0-1022">Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1022"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5e6a0-1023">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1023">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="5e6a0-1024">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1024">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="5e6a0-1025">Массив символов, содержащий набор кодируемых символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1025">The character array containing the set of characters to encode.</span></span></param>
        <param name="charIndex"><span data-ttu-id="5e6a0-1026">Индекс первого кодируемого символа.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1026">The index of the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="5e6a0-1027">Число кодируемых символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1027">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="5e6a0-1028">Массив байтов, в который будет помещена результирующая последовательность байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1028">The byte array to contain the resulting sequence of bytes.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="5e6a0-1029">Индекс, с которого начинается запись результирующей последовательности байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1029">The index at which to start writing the resulting sequence of bytes.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1030">При переопределении в производном классе кодирует набор символов из указанного массива символов в указанный массив байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1030">When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1031">Фактическое число байтов, записанных в <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1031">The actual number of bytes written into <paramref name="bytes" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1032">Чтобы вычислить точный размер массива, необходимый <xref:System.Text.Encoding.GetBytes%2A> для хранения результирующих байтов, следует вызвать метод <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1032">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="5e6a0-1033">Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.Encoding.GetMaxByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1033">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="5e6a0-1034">Метод <xref:System.Text.Encoding.GetByteCount%2A> обычно позволяет выделить меньше памяти, а метод <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1034">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="5e6a0-1035">Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или метод <xref:System.Text.Encoding.GetEncoder%2A>, соответственно, производного класса.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1035">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="5e6a0-1036">Метод <xref:System.Text.Encoding.GetByteCount%2A> определяет, сколько байт приводит к кодированию набора символов Юникода, а метод <xref:System.Text.Encoding.GetBytes%2A> выполняет фактическую кодировку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1036">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="5e6a0-1037">Метод <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> ждет дискретные преобразования, в отличие от метода <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>, который обрабатывает несколько преобразований в одном входном потоке.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1037">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-1038">Поддерживаются несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1038">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="5e6a0-1039">Ниже приведены некоторые рекомендации по программированию для использования этих методов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1039">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="5e6a0-1040">Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1040">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="5e6a0-1041">В этом случае, вероятно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется в используемом объекте <xref:System.Text.Encoder>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1041">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="5e6a0-1042">(Например, последовательность символов, включающая суррогатные пары, может заканчиваться старшим суррогатом.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1042">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="5e6a0-1043"><xref:System.Text.Encoder> будет помнить, что старший суррогат можно объединить с младшим суррогатом в начале следующего вызова.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1043">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="5e6a0-1044"><xref:System.Text.Encoding> не сможет поддерживать состояние, поэтому символ будет отправлен на <xref:System.Text.EncoderFallback>.)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1044"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="5e6a0-1045">Если приложение обрабатывает входные данные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1045">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>  
  
-   <span data-ttu-id="5e6a0-1046">Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые методы, особенно с несколькими вызовами с помощью объекта <xref:System.Text.Encoder> или вставкой в существующие буферы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1046">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="5e6a0-1047">Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1047">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="5e6a0-1048">Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1048">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="5e6a0-1049">В этом случае лучшим выбором является версия <xref:System.Text.Encoding.GetBytes%2A>, которая поддерживает массивы байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1049">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="5e6a0-1050">Вместо <xref:System.Text.Encoding.GetByteCount%2A>рекомендуется использовать метод <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1050">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="5e6a0-1051">Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1051">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="5e6a0-1052">Для непрерывной кодировки потока этот метод часто является лучшим выбором.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1052">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1053">В следующем примере определяется число байтов, необходимое для кодирования трех символов из массива символов, символы кодируются и выводятся полученные байты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1053">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-1054">Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1054"><paramref name="chars" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5e6a0-1055">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1055">-or-</span></span> 
 <span data-ttu-id="5e6a0-1056">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1056"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-1057">Значение параметра <paramref name="charIndex" />, <paramref name="charCount" /> или <paramref name="byteIndex" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1057"><paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span></span>  
  
<span data-ttu-id="5e6a0-1058">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1058">-or-</span></span> 
 <span data-ttu-id="5e6a0-1059">Параметры<paramref name="charIndex" /> и <paramref name="charCount" /> не указывают допустимый диапазон в <paramref name="chars" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1059"><paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span></span>  
  
<span data-ttu-id="5e6a0-1060">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1060">-or-</span></span> 
 <span data-ttu-id="5e6a0-1061">Значение параметра <paramref name="byteIndex" /> не является допустимым индексом в <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1061"><paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5e6a0-1062">Недостаточно емкости <paramref name="bytes" /> от <paramref name="byteIndex" /> до конца массива для размещения полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1062"><paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="5e6a0-1063">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1063">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-1064">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1064">-and-</span></span> 
 <span data-ttu-id="5e6a0-1065">Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1065"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="5e6a0-1066">Строка, содержащая набор символов для кодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1066">The string containing the set of characters to encode.</span></span></param>
        <param name="charIndex"><span data-ttu-id="5e6a0-1067">Индекс первого кодируемого символа.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1067">The index of the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="5e6a0-1068">Число кодируемых символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1068">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="5e6a0-1069">Массив байтов, в который будет помещена результирующая последовательность байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1069">The byte array to contain the resulting sequence of bytes.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="5e6a0-1070">Индекс, с которого начинается запись результирующей последовательности байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1070">The index at which to start writing the resulting sequence of bytes.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1071">При переопределении в производном классе кодирует набор символов из заданной строки в заданный массив байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1071">When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1072">Фактическое число байтов, записанных в <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1072">The actual number of bytes written into <paramref name="bytes" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1073">Чтобы вычислить точный размер массива, необходимый <xref:System.Text.Encoding.GetBytes%2A> для хранения результирующих байтов, следует вызвать метод <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1073">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="5e6a0-1074">Чтобы вычислить максимальный размер массива, вызовите метод <xref:System.Text.Encoding.GetMaxByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1074">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="5e6a0-1075">Метод <xref:System.Text.Encoding.GetByteCount%2A> обычно позволяет выделить меньше памяти, а метод <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1075">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="5e6a0-1076">Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или метод <xref:System.Text.Encoding.GetEncoder%2A>, соответственно, производного класса.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1076">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="5e6a0-1077">Метод <xref:System.Text.Encoding.GetByteCount%2A> определяет, сколько байт приводит к кодированию набора символов Юникода, а метод <xref:System.Text.Encoding.GetBytes%2A> выполняет фактическую кодировку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1077">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="5e6a0-1078">Метод <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> ждет дискретные преобразования, в отличие от метода <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>, который обрабатывает несколько преобразований в одном входном потоке.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1078">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-1079">Поддерживаются несколько версий <xref:System.Text.Encoding.GetByteCount%2A> и <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1079">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="5e6a0-1080">Ниже приведены некоторые рекомендации по программированию для использования этих методов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1080">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="5e6a0-1081">Приложению может потребоваться закодировать множество входных символов в кодовую страницу и обработать символы с помощью нескольких вызовов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1081">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="5e6a0-1082">В этом случае, вероятно, необходимо поддерживать состояние между вызовами, принимая во внимание состояние, которое сохраняется в используемом объекте <xref:System.Text.Encoder>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1082">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="5e6a0-1083">(Например, последовательность символов, включающая суррогатные пары, может заканчиваться старшим суррогатом.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1083">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="5e6a0-1084"><xref:System.Text.Encoder> будет помнить, что старший суррогат можно объединить с младшим суррогатом в начале следующего вызова.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1084">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="5e6a0-1085"><xref:System.Text.Encoding> не сможет поддерживать состояние, поэтому символ будет отправлен на <xref:System.Text.EncoderFallback>.)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1085"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="5e6a0-1086">Если приложение обрабатывает входные данные строки, следует использовать строковую версию <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1086">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>  
  
-   <span data-ttu-id="5e6a0-1087">Версия буфера символов Юникода <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> позволяет использовать некоторые быстрые методы, особенно с несколькими вызовами с помощью объекта <xref:System.Text.Encoder> или вставкой в существующие буферы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1087">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="5e6a0-1088">Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1088">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="5e6a0-1089">Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1089">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="5e6a0-1090">В этом случае лучшим выбором является версия <xref:System.Text.Encoding.GetBytes%2A>, которая поддерживает массивы байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1090">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="5e6a0-1091">Вместо <xref:System.Text.Encoding.GetByteCount%2A>рекомендуется использовать метод <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1091">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="5e6a0-1092">Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1092">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="5e6a0-1093">Для непрерывной кодировки потока этот метод часто является лучшим выбором.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1093">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1094">В следующем примере определяется число байтов, необходимое для кодирования строки или диапазона в строке, символы кодируются и выводятся полученные байты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1094">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-1095"><paramref name="s" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1095"><paramref name="s" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5e6a0-1096">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1096">-or-</span></span> 
 <span data-ttu-id="5e6a0-1097">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1097"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-1098">Значение параметра <paramref name="charIndex" />, <paramref name="charCount" /> или <paramref name="byteIndex" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1098"><paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span></span>  
  
<span data-ttu-id="5e6a0-1099">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1099">-or-</span></span> 
 <span data-ttu-id="5e6a0-1100">Параметры<paramref name="charIndex" /> и <paramref name="charCount" /> не указывают допустимый диапазон в <paramref name="chars" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1100"><paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span></span>  
  
<span data-ttu-id="5e6a0-1101">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1101">-or-</span></span> 
 <span data-ttu-id="5e6a0-1102">Значение параметра <paramref name="byteIndex" /> не является допустимым индексом в <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1102"><paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5e6a0-1103">Недостаточно емкости <paramref name="bytes" /> от <paramref name="byteIndex" /> до конца массива для размещения полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1103"><paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="5e6a0-1104">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1104">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-1105">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1105">-and-</span></span> 
 <span data-ttu-id="5e6a0-1106">Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1106"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1107">При переопределении в производном классе вычисляет количество символов, полученных при декодировании последовательности байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1107">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="5e6a0-1108">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1108">The byte array containing the sequence of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1109">При переопределении в производном классе вычисляет количество символов, полученных при декодировании всех байтов из заданного массива байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1109">When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1110">Число символов, полученных при декодировании заданной последовательности байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1110">The number of characters produced by decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1111">Чтобы вычислить точный размер массива, необходимый <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> для хранения полученных символов, следует использовать метод <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1111">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method.</span></span> <span data-ttu-id="5e6a0-1112">Чтобы вычислить максимальный размер массива, следует использовать метод <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1112">To calculate the maximum array size, you should use the <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> method.</span></span> <span data-ttu-id="5e6a0-1113">Метод <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> обычно позволяет выделить меньше памяти, а метод <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1113">The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="5e6a0-1114">Метод <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> определяет, сколько символов приводит к декодированию последовательности байтов, а метод <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> выполняет фактическое декодирование.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1114">The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method determines how many characters result in decoding a sequence of bytes, and the  <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> method performs the actual decoding.</span></span> <span data-ttu-id="5e6a0-1115">Метод <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> ждет дискретные преобразования, в отличие от метода <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, который обрабатывает несколько проходов по одному входному потоку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1115">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-1116">Поддерживаются несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1116">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="5e6a0-1117">Ниже приведены некоторые рекомендации по программированию для использования этих методов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1117">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="5e6a0-1118">Приложению может потребоваться декодировать несколько входных байт из кодовой страницы и обработать байты, используя несколько вызовов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1118">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="5e6a0-1119">В этом случае, возможно, потребуется поддерживать состояние между вызовами.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1119">In this case, you probably need to maintain state between calls.</span></span>  
  
-   <span data-ttu-id="5e6a0-1120">Если приложение обрабатывает выходные данные строки, следует использовать метод <xref:System.Text.Encoding.GetString%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1120">If your app handles string outputs, you should use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="5e6a0-1121">Поскольку этот метод должен проверять длину строки и выделить буфер, он немного медленнее, но полученный <xref:System.String> тип является предпочтительным.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1121">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="5e6a0-1122">Байтовая версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> допускает некоторые быстрые методы, особенно с несколькими вызовами больших буферов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1122">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="5e6a0-1123">Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1123">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="5e6a0-1124">Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1124">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="5e6a0-1125">В этом случае типы [\], Int32, Int32, char\<XREF: System. Text. Encoding. GetChars% 28System. Byte% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5B% 5D% 2CSystem. Int32% 29 > версии, поддерживающей буферы выходных символов, являются наилучший вариант.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1125">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="5e6a0-1126">Вместо <xref:System.Text.Encoding.GetCharCount%2A>рекомендуется использовать метод <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1126">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="5e6a0-1127">Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1127">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="5e6a0-1128">Для непрерывного декодирования потока этот метод часто является лучшим выбором.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1128">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1129">Следующий пример кодирует строку в массив байтов, а затем декодирует байты в массив символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1129">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-1130"><paramref name="bytes" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1130"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="5e6a0-1131">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1131">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-1132">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1132">-and-</span></span> 
 <span data-ttu-id="5e6a0-1133">Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1133"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="5e6a0-1134">Указатель на первый декодируемый байт.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1134">A pointer to the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="5e6a0-1135">Число байтов для декодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1135">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1136">При переопределении в производном классе вычисляет количество символов, полученных при декодировании последовательности байтов, начало которой задается указателем байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1136">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1137">Число символов, полученных при декодировании заданной последовательности байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1137">The number of characters produced by decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1138">Чтобы вычислить точный размер массива, который <xref:System.Text.Encoding.GetChars%2A> требуется для хранения результирующих символов, следует использовать метод <xref:System.Text.Encoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1138">To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="5e6a0-1139">Чтобы вычислить максимальный размер массива, используйте метод <xref:System.Text.Encoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1139">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="5e6a0-1140">Метод <xref:System.Text.Encoding.GetCharCount%2A> обычно позволяет выделить меньше памяти, а метод <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1140">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="5e6a0-1141">Метод <xref:System.Text.Encoding.GetCharCount%2A> определяет, сколько символов приводит к декодированию последовательности байтов, а метод <xref:System.Text.Encoding.GetChars%2A> выполняет фактическое декодирование.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1141">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="5e6a0-1142">Метод <xref:System.Text.Encoding.GetChars%2A> ждет дискретные преобразования, в отличие от метода <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, который обрабатывает несколько проходов по одному входному потоку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1142">The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-1143">Поддерживаются несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1143">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="5e6a0-1144">Ниже приведены некоторые рекомендации по программированию для использования этих методов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1144">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="5e6a0-1145">Приложению может потребоваться декодировать несколько входных байт из кодовой страницы и обработать байты, используя несколько вызовов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1145">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="5e6a0-1146">В этом случае, возможно, потребуется поддерживать состояние между вызовами.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1146">In this case, you probably need to maintain state between calls.</span></span>  
  
-   <span data-ttu-id="5e6a0-1147">Если приложение обрабатывает выходные данные строки, рекомендуется использовать метод <xref:System.Text.Encoding.GetString%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1147">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="5e6a0-1148">Поскольку этот метод должен проверять длину строки и выделить буфер, он немного медленнее, но полученный <xref:System.String> тип является предпочтительным.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1148">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="5e6a0-1149">Байтовая версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> допускает некоторые быстрые методы, особенно с несколькими вызовами больших буферов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1149">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="5e6a0-1150">Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1150">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="5e6a0-1151">Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1151">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="5e6a0-1152">В этом случае типы [\], Int32, Int32, char\<XREF: System. Text. Encoding. GetChars% 28System. Byte% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5B% 5D% 2CSystem. Int32% 29 > версии, поддерживающей буферы выходных символов, являются наилучший вариант.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1152">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="5e6a0-1153">Вместо <xref:System.Text.Encoding.GetCharCount%2A>рекомендуется использовать метод <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1153">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="5e6a0-1154">Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1154">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="5e6a0-1155">Для непрерывного декодирования потока этот метод часто является лучшим выбором.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1155">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-1156">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1156"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-1157">Значение параметра <paramref name="count" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1157"><paramref name="count" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="5e6a0-1158">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1158">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-1159">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1159">-and-</span></span> 
 <span data-ttu-id="5e6a0-1160">Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1160"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5e6a0-1161">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1161">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="5e6a0-1162">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1162">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="5e6a0-1163">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1163">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="index"><span data-ttu-id="5e6a0-1164">Индекс первого декодируемого байта.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1164">The index of the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="5e6a0-1165">Число байтов для декодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1165">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1166">При переопределении в производном классе вычисляет количество символов, полученных при декодировании последовательности байтов из заданного массива байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1166">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1167">Число символов, полученных при декодировании заданной последовательности байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1167">The number of characters produced by decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1168">Чтобы вычислить точный размер массива, необходимый <xref:System.Text.Encoding.GetChars%2A> для хранения полученных символов, следует использовать метод <xref:System.Text.Encoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1168">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="5e6a0-1169">Чтобы вычислить максимальный размер массива, используйте метод <xref:System.Text.Encoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1169">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="5e6a0-1170">Метод <xref:System.Text.Encoding.GetCharCount%2A> обычно позволяет выделить меньше памяти, а метод <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1170">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="5e6a0-1171">Метод <xref:System.Text.Encoding.GetCharCount%2A> определяет, сколько символов приводит к декодированию последовательности байтов, а метод <xref:System.Text.Encoding.GetChars%2A> выполняет фактическое декодирование.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1171">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="5e6a0-1172">Метод <xref:System.Text.Encoding.GetChars%2A> ждет дискретные преобразования, в отличие от метода <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, который обрабатывает несколько проходов по одному входному потоку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1172">The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-1173">Поддерживаются несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1173">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="5e6a0-1174">Ниже приведены некоторые рекомендации по программированию для использования этих методов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1174">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="5e6a0-1175">Приложению может потребоваться декодировать несколько входных байт из кодовой страницы и обработать байты, используя несколько вызовов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1175">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="5e6a0-1176">В этом случае, возможно, потребуется поддерживать состояние между вызовами.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1176">In this case, you probably need to maintain state between calls.</span></span>  
  
-   <span data-ttu-id="5e6a0-1177">Если приложение обрабатывает выходные данные строки, рекомендуется использовать метод <xref:System.Text.Encoding.GetString%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1177">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="5e6a0-1178">Поскольку этот метод должен проверять длину строки и выделить буфер, он немного медленнее, но полученный <xref:System.String> тип является предпочтительным.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1178">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="5e6a0-1179">Байтовая версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> допускает некоторые быстрые методы, особенно с несколькими вызовами больших буферов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1179">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="5e6a0-1180">Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1180">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="5e6a0-1181">Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1181">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="5e6a0-1182">В этом случае типы [\], Int32, Int32, char\<XREF: System. Text. Encoding. GetChars% 28System. Byte% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5B% 5D% 2CSystem. Int32% 29 > версии, поддерживающей буферы выходных символов, являются наилучший вариант.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1182">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="5e6a0-1183">Вместо <xref:System.Text.Encoding.GetCharCount%2A>рекомендуется использовать метод <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1183">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="5e6a0-1184">Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1184">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="5e6a0-1185">Для непрерывного декодирования потока этот метод часто является лучшим выбором.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1185">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1186">В следующем примере строка из одной кодировки преобразуется в другую.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1186">The following example converts a string from one encoding to another.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 <span data-ttu-id="5e6a0-1187">В следующем примере строка кодируется в массив байтов, а затем декодирует диапазон байтов в массив символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1187">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-1188">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1188"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-1189">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1189"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="5e6a0-1190">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1190">-or-</span></span> 
 <span data-ttu-id="5e6a0-1191">Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1191"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="5e6a0-1192">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1192">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-1193">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1193">-and-</span></span> 
 <span data-ttu-id="5e6a0-1194">Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1194"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1195">При переопределении в производном классе декодирует последовательность байтов в набор символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1195">When overridden in a derived class, decodes a sequence of bytes into a set of characters.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="5e6a0-1196">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1196">The byte array containing the sequence of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1197">При переопределении в производном классе декодирует все байты из указанного массива байтов в набор символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1197">When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1198">Массив символов, содержащий результаты декодирования указанной последовательности байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1198">A character array containing the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1199"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> получает символы из входной последовательности байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1199"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="5e6a0-1200"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, так как <xref:System.Text.Encoding> ожидает дискретные преобразования, а <xref:System.Text.Decoder> предназначен для нескольких проходов по одному входному потоку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1200"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-1201">Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или метод <xref:System.Text.Encoding.GetEncoder%2A>, соответственно, производного класса.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1201">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="5e6a0-1202">**Примечание** . Этот метод предназначен для обработки символов Юникода, а не для произвольных двоичных данных, таких как байтовые массивы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1202">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="5e6a0-1203">Если необходимо закодировать произвольные двоичные данные в текст, следует использовать протокол, такой как uuencode, который реализуется такими методами, как <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1203">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5e6a0-1204">Метод <xref:System.Text.Encoding.GetCharCount%2A> определяет, сколько символов приводит к декодированию последовательности байтов, а метод <xref:System.Text.Encoding.GetChars%2A> выполняет фактическое декодирование.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1204">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="5e6a0-1205">Метод <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> ждет дискретные преобразования, в отличие от метода <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, который обрабатывает несколько проходов по одному входному потоку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1205">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-1206">Поддерживаются несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1206">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="5e6a0-1207">Ниже приведены некоторые рекомендации по программированию для использования этих методов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1207">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="5e6a0-1208">Приложению может потребоваться декодировать несколько входных байт из кодовой страницы и обработать байты, используя несколько вызовов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1208">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="5e6a0-1209">В этом случае, возможно, потребуется поддерживать состояние между вызовами, так как последовательности байтов могут быть прерваны при обработке в пакетах.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1209">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="5e6a0-1210">(Например, часть последовательности сдвига ISO-2022 может заканчиваться первой <xref:System.Text.Encoding.GetChars%2A> вызове и Continue в начале следующего <xref:System.Text.Encoding.GetChars%2A> вызова.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1210">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="5e6a0-1211"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> будет вызывать откат для этих неполных последовательностей, но <xref:System.Text.Decoder> запоминает эти последовательности для следующего вызова.)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1211"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>  
  
-   <span data-ttu-id="5e6a0-1212">Если приложение обрабатывает выходные данные строки, рекомендуется использовать метод <xref:System.Text.Encoding.GetString%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1212">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="5e6a0-1213">Поскольку этот метод должен проверять длину строки и выделить буфер, он немного медленнее, но полученный <xref:System.String> тип является предпочтительным.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1213">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="5e6a0-1214">Байтовая версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> допускает некоторые быстрые методы, особенно с несколькими вызовами больших буферов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1214">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="5e6a0-1215">Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1215">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="5e6a0-1216">Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1216">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="5e6a0-1217">В этом случае типы [\], Int32, Int32, char\<XREF: System. Text. Encoding. GetChars% 28System. Byte% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5B% 5D% 2CSystem. Int32% 29 > версии, поддерживающей буферы выходных символов, являются наилучший вариант.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1217">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="5e6a0-1218">Вместо <xref:System.Text.Encoding.GetCharCount%2A>рекомендуется использовать метод <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1218">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="5e6a0-1219">Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1219">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="5e6a0-1220">Для непрерывного декодирования потока этот метод часто является лучшим выбором.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1220">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1221">Следующий пример кодирует строку в массив байтов, а затем декодирует байты в массив символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1221">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-1222">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1222"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="5e6a0-1223">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1223">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-1224">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1224">-and-</span></span> 
 <span data-ttu-id="5e6a0-1225">Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1225"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="5e6a0-1226">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1226">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="index"><span data-ttu-id="5e6a0-1227">Индекс первого декодируемого байта.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1227">The index of the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="5e6a0-1228">Число байтов для декодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1228">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1229">При переопределении в производном классе декодирует последовательность байтов из указанного массива байтов в набор символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1229">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1230">Массив символов, содержащий результаты декодирования указанной последовательности байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1230">A character array containing the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1231"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> получает символы из входной последовательности байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1231"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="5e6a0-1232"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, так как <xref:System.Text.Encoding> ожидает дискретные преобразования, а <xref:System.Text.Decoder> предназначен для нескольких проходов по одному входному потоку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1232"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-1233">Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или метод <xref:System.Text.Encoding.GetEncoder%2A>, соответственно, производного класса.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1233">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="5e6a0-1234">**Примечание** . Этот метод предназначен для обработки символов Юникода, а не для произвольных двоичных данных, таких как байтовые массивы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1234">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="5e6a0-1235">Если необходимо закодировать произвольные двоичные данные в текст, следует использовать протокол, такой как uuencode, который реализуется такими методами, как <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1235">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5e6a0-1236">Метод <xref:System.Text.Encoding.GetCharCount%2A> определяет, сколько символов приводит к декодированию последовательности байтов, а метод <xref:System.Text.Encoding.GetChars%2A> выполняет фактическое декодирование.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1236">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="5e6a0-1237">Метод <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> ждет дискретные преобразования, в отличие от метода <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, который обрабатывает несколько проходов по одному входному потоку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1237">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-1238">Поддерживаются несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1238">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="5e6a0-1239">Ниже приведены некоторые рекомендации по программированию для использования этих методов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1239">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="5e6a0-1240">Приложению может потребоваться декодировать несколько входных байт из кодовой страницы и обработать байты, используя несколько вызовов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1240">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="5e6a0-1241">В этом случае, возможно, потребуется поддерживать состояние между вызовами, так как последовательности байтов могут быть прерваны при обработке в пакетах.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1241">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="5e6a0-1242">(Например, часть последовательности сдвига ISO-2022 может заканчиваться первой <xref:System.Text.Encoding.GetChars%2A> вызове и Continue в начале следующего <xref:System.Text.Encoding.GetChars%2A> вызова.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1242">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="5e6a0-1243"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> будет вызывать откат для этих неполных последовательностей, но <xref:System.Text.Decoder> запоминает эти последовательности для следующего вызова.)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1243"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>  
  
-   <span data-ttu-id="5e6a0-1244">Если приложение обрабатывает выходные данные строки, рекомендуется использовать метод <xref:System.Text.Encoding.GetString%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1244">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="5e6a0-1245">Поскольку этот метод должен проверять длину строки и выделить буфер, он немного медленнее, но полученный <xref:System.String> тип является предпочтительным.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1245">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="5e6a0-1246">Байтовая версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> допускает некоторые быстрые методы, особенно с несколькими вызовами больших буферов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1246">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="5e6a0-1247">Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1247">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="5e6a0-1248">Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1248">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="5e6a0-1249">В этом случае типы [\], Int32, Int32, char\<XREF: System. Text. Encoding. GetChars% 28System. Byte% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5B% 5D% 2CSystem. Int32% 29 > версии, поддерживающей буферы выходных символов, являются наилучший вариант.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1249">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="5e6a0-1250">Вместо <xref:System.Text.Encoding.GetCharCount%2A>рекомендуется использовать метод <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1250">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="5e6a0-1251">Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1251">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="5e6a0-1252">Для непрерывного декодирования потока этот метод часто является лучшим выбором.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1252">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1253">В следующем примере строка кодируется в массив байтов, а затем декодирует диапазон байтов в массив символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1253">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-1254"><paramref name="bytes" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1254"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-1255">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1255"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="5e6a0-1256">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1256">-or-</span></span> 
 <span data-ttu-id="5e6a0-1257">Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1257"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="5e6a0-1258">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1258">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-1259">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1259">-and-</span></span> 
 <span data-ttu-id="5e6a0-1260">Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1260"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="5e6a0-1261">Указатель на первый декодируемый байт.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1261">A pointer to the first byte to decode.</span></span></param>
        <param name="byteCount"><span data-ttu-id="5e6a0-1262">Число байтов для декодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1262">The number of bytes to decode.</span></span></param>
        <param name="chars"><span data-ttu-id="5e6a0-1263">Указатель на положение, с которого начинается запись результирующего набора символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1263">A pointer to the location at which to start writing the resulting set of characters.</span></span></param>
        <param name="charCount"><span data-ttu-id="5e6a0-1264">Наибольшее количество символов для записи.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1264">The maximum number of characters to write.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1265">При переопределении в производном классе декодирует последовательность байтов, которая начинается с заданного указателя байта, в набор символов, которые сохраняются, начиная с заданного указателя символа.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1265">When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1266">Фактическое число символов, записанных в местоположение, которое задано параметром <paramref name="chars" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1266">The actual number of characters written at the location indicated by the <paramref name="chars" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1267">Чтобы вычислить точный размер массива, который <xref:System.Text.Encoding.GetChars%2A> требуется для хранения результирующих символов, следует использовать метод <xref:System.Text.Encoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1267">To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="5e6a0-1268">Чтобы вычислить максимальный размер массива, используйте метод <xref:System.Text.Encoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1268">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="5e6a0-1269">Метод <xref:System.Text.Encoding.GetCharCount%2A> обычно позволяет выделить меньше памяти, а метод <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1269">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="5e6a0-1270"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> получает символы из входной последовательности байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1270"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="5e6a0-1271"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, так как <xref:System.Text.Encoding> ожидает дискретные преобразования, а <xref:System.Text.Decoder> предназначен для нескольких проходов по одному входному потоку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1271"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-1272">Если преобразование данных доступен только в последовательных блоках (например, данные, считанные из потока) или если объем данных настолько велик, что ему следует разделить на более мелкие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder> объект, предоставляемый <xref:System.Text.Encoding.GetDecoder%2A>настроек или <xref:System.Text.Encoding.GetEncoder%2A> метода, соответственно, производного класса.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1272">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="5e6a0-1273">**Примечание** . Этот метод предназначен для обработки символов Юникода, а не для произвольных двоичных данных, таких как байтовые массивы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1273">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="5e6a0-1274">Если необходимо закодировать произвольные двоичные данные в текст, следует использовать протокол, такой как uuencode, который реализуется такими методами, как <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1274">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5e6a0-1275">Метод <xref:System.Text.Encoding.GetCharCount%2A> определяет, сколько символов приводит к декодированию последовательности байтов, а метод <xref:System.Text.Encoding.GetChars%2A> выполняет фактическое декодирование.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1275">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="5e6a0-1276">Метод <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> ждет дискретные преобразования, в отличие от метода <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, который обрабатывает несколько проходов по одному входному потоку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1276">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-1277">Поддерживаются несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1277">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="5e6a0-1278">Ниже приведены некоторые рекомендации по программированию для использования этих методов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1278">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="5e6a0-1279">Приложению может потребоваться декодировать несколько входных байт из кодовой страницы и обработать байты, используя несколько вызовов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1279">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="5e6a0-1280">В этом случае, возможно, потребуется поддерживать состояние между вызовами, так как последовательности байтов могут быть прерваны при обработке в пакетах.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1280">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="5e6a0-1281">(Например, часть последовательности сдвига ISO-2022 может заканчиваться первой <xref:System.Text.Encoding.GetChars%2A> вызове и Continue в начале следующего <xref:System.Text.Encoding.GetChars%2A> вызова.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1281">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="5e6a0-1282"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> будет вызывать откат для этих неполных последовательностей, но <xref:System.Text.Decoder> запоминает эти последовательности для следующего вызова.)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1282"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>  
  
-   <span data-ttu-id="5e6a0-1283">Если приложение обрабатывает выходные данные строки, рекомендуется использовать метод <xref:System.Text.Encoding.GetString%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1283">If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended.</span></span> <span data-ttu-id="5e6a0-1284">Поскольку этот метод должен проверять длину строки и выделить буфер, он немного медленнее, но полученный <xref:System.String> тип является предпочтительным.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1284">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="5e6a0-1285">Байтовая версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> допускает некоторые быстрые методы, особенно с несколькими вызовами больших буферов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1285">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="5e6a0-1286">Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1286">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="5e6a0-1287">Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1287">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="5e6a0-1288">В этом случае типы [\], Int32, Int32, char\<XREF: System. Text. Encoding. GetChars% 28System. Byte% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5B% 5D% 2CSystem. Int32% 29 > версии, поддерживающей буферы выходных символов, являются наилучший вариант.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1288">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="5e6a0-1289">Вместо <xref:System.Text.Encoding.GetCharCount%2A>рекомендуется использовать метод <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1289">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="5e6a0-1290">Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1290">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="5e6a0-1291">Для непрерывного декодирования потока этот метод часто является лучшим выбором.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1291">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-1292">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1292"><paramref name="bytes" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5e6a0-1293">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1293">-or-</span></span> 
 <span data-ttu-id="5e6a0-1294"><paramref name="chars" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1294"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-1295">Значение параметра <paramref name="byteCount" /> или <paramref name="charCount" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1295"><paramref name="byteCount" /> or <paramref name="charCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5e6a0-1296"><paramref name="charCount" /> меньше результирующего числа символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1296"><paramref name="charCount" /> is less than the resulting number of characters.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="5e6a0-1297">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1297">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-1298">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1298">-and-</span></span> 
 <span data-ttu-id="5e6a0-1299">Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1299"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5e6a0-1300">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1300">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="5e6a0-1301">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1301">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="5e6a0-1302">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1302">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="5e6a0-1303">Индекс первого декодируемого байта.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1303">The index of the first byte to decode.</span></span></param>
        <param name="byteCount"><span data-ttu-id="5e6a0-1304">Число байтов для декодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1304">The number of bytes to decode.</span></span></param>
        <param name="chars"><span data-ttu-id="5e6a0-1305">Массив символов, в который будет помещен результирующий набор символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1305">The character array to contain the resulting set of characters.</span></span></param>
        <param name="charIndex"><span data-ttu-id="5e6a0-1306">Индекс, с которого начинается запись результирующего набора символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1306">The index at which to start writing the resulting set of characters.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1307">При переопределении в производном классе декодирует последовательность байтов из указанного массива байтов в указанный массив символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1307">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1308">Фактическое число символов, записанных в <paramref name="chars" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1308">The actual number of characters written into <paramref name="chars" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1309">Чтобы вычислить точный размер массива, необходимый <xref:System.Text.Encoding.GetChars%2A> для хранения полученных символов, следует использовать метод <xref:System.Text.Encoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1309">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="5e6a0-1310">Чтобы вычислить максимальный размер массива, используйте метод <xref:System.Text.Encoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1310">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="5e6a0-1311">Метод <xref:System.Text.Encoding.GetCharCount%2A> обычно позволяет выделить меньше памяти, а метод <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1311">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="5e6a0-1312">[\], Int32, Int32, char\<XREF: System. Text. Encoding. GetChars% 2A? displayProperty = nameWithType > получает символы из входной последовательности байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1312">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="5e6a0-1313">[\], Int32, Int32, char\<XREF: System. Text. Encoding. GetChars% 2A? displayProperty = nameWithType > отличается от <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, поскольку <xref:System.Text.Encoding> ожидает дискретные преобразования, а <xref:System.Text.Decoder> предназначен для нескольких проходов в одном входной поток.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1313">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-1314">Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или метод <xref:System.Text.Encoding.GetEncoder%2A>, соответственно, производного класса.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1314">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="5e6a0-1315">**Примечание** . Этот метод предназначен для обработки символов Юникода, а не для произвольных двоичных данных, таких как байтовые массивы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1315">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="5e6a0-1316">Если необходимо закодировать произвольные двоичные данные в текст, следует использовать протокол, такой как uuencode, который реализуется такими методами, как <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1316">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5e6a0-1317">Метод <xref:System.Text.Encoding.GetCharCount%2A> определяет, сколько символов приводит к декодированию последовательности байтов, а метод <xref:System.Text.Encoding.GetChars%2A> выполняет фактическое декодирование.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1317">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="5e6a0-1318">Метод <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> ждет дискретные преобразования, в отличие от метода <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>, который обрабатывает несколько проходов по одному входному потоку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1318">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="5e6a0-1319">Поддерживаются несколько версий <xref:System.Text.Encoding.GetCharCount%2A> и <xref:System.Text.Encoding.GetChars%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1319">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="5e6a0-1320">Ниже приведены некоторые рекомендации по программированию для использования этих методов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1320">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="5e6a0-1321">Приложению может потребоваться декодировать несколько входных байт из кодовой страницы и обработать байты, используя несколько вызовов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1321">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="5e6a0-1322">В этом случае, возможно, потребуется поддерживать состояние между вызовами, так как последовательности байтов могут быть прерваны при обработке в пакетах.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1322">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="5e6a0-1323">(Например, часть последовательности сдвига ISO-2022 может заканчиваться на одну [\], Int32, Int32, char\<XREF: System. Text. Encoding. GetChars% 2A > вызов и Continue в начале следующего [\], Int32, Int32, char\<XREF: Вызов System. Text. Encoding. GetChars% 2A > вызова.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1323">(For example, part of an ISO-2022 shift sequence may end one [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="5e6a0-1324">[\], Int32, Int32, char\<XREF: System. Text. Encoding. GetChars% 2A? displayProperty = nameWithType > будет вызывать откат для этих неполных последовательностей, но <xref:System.Text.Decoder> Запомните эти последовательности для следующего вызова.)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1324">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>  
  
-   <span data-ttu-id="5e6a0-1325">Если приложение обрабатывает выходные данные строки, рекомендуется использовать метод <xref:System.Text.Encoding.GetString%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1325">If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended.</span></span> <span data-ttu-id="5e6a0-1326">Поскольку этот метод должен проверять длину строки и выделить буфер, он немного медленнее, но полученный <xref:System.String> тип является предпочтительным.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1326">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="5e6a0-1327">Байтовая версия <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> допускает некоторые быстрые методы, особенно с несколькими вызовами больших буферов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1327">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="5e6a0-1328">Однако следует помнить, что эта версия метода иногда является ненадежной, так как указатели являются обязательными.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1328">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="5e6a0-1329">Если приложение должно преобразовать большой объем данных, следует повторно использовать выходной буфер.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1329">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="5e6a0-1330">В этом случае типы [\], Int32, Int32, char\<XREF: System. Text. Encoding. GetChars% 28System. Byte% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5B% 5D% 2CSystem. Int32% 29 > версии, поддерживающей буферы выходных символов, являются наилучший вариант.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1330">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="5e6a0-1331">Вместо <xref:System.Text.Encoding.GetCharCount%2A>рекомендуется использовать метод <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1331">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="5e6a0-1332">Метод преобразования преобразует как можно больше данных и создает исключение, если выходной буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1332">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="5e6a0-1333">Для непрерывного декодирования потока этот метод часто является лучшим выбором.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1333">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1334">В следующем примере строка из одной кодировки преобразуется в другую.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1334">The following example converts a string from one encoding to another.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 <span data-ttu-id="5e6a0-1335">В следующем примере строка кодируется в массив байтов, а затем декодирует диапазон байтов в массив символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1335">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-1336">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1336"><paramref name="bytes" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="5e6a0-1337">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1337">-or-</span></span> 
 <span data-ttu-id="5e6a0-1338">Свойство <paramref name="chars" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1338"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-1339">Значение параметра <paramref name="byteIndex" />, <paramref name="byteCount" /> или <paramref name="charIndex" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1339"><paramref name="byteIndex" /> or <paramref name="byteCount" /> or <paramref name="charIndex" /> is less than zero.</span></span>  
  
<span data-ttu-id="5e6a0-1340">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1340">-or-</span></span> 
 <span data-ttu-id="5e6a0-1341">Параметры<paramref name="byteindex" /> и <paramref name="byteCount" /> не указывают допустимый диапазон в <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1341"><paramref name="byteindex" /> and <paramref name="byteCount" /> do not denote a valid range in <paramref name="bytes" />.</span></span>  
  
<span data-ttu-id="5e6a0-1342">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1342">-or-</span></span> 
 <span data-ttu-id="5e6a0-1343">Значение параметра <paramref name="charIndex" /> не является допустимым индексом в <paramref name="chars" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1343"><paramref name="charIndex" /> is not a valid index in <paramref name="chars" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5e6a0-1344">Недостаточно емкости <paramref name="chars" /> от <paramref name="charIndex" /> до конца массива для размещения полученных символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1344"><paramref name="chars" /> does not have enough capacity from <paramref name="charIndex" /> to the end of the array to accommodate the resulting characters.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="5e6a0-1345">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1345">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-1346">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1346">-and-</span></span> 
 <span data-ttu-id="5e6a0-1347">Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1347"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5e6a0-1348">При переопределении в производном классе получает декодер, который преобразует последовательность байтов в последовательность символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1348">When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1349">Объект <see cref="T:System.Text.Decoder" />, преобразующий закодированную последовательность байтов в последовательность символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1349">A <see cref="T:System.Text.Decoder" /> that converts an encoded sequence of bytes into a sequence of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1350">Метод <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> преобразует последовательные блоки байтов в последовательные блоки символов так же, как метод <xref:System.Text.Encoding.GetChars%2A> этого класса.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1350">The <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.Encoding.GetChars%2A> method of this class.</span></span> <span data-ttu-id="5e6a0-1351">Однако <xref:System.Text.Decoder> сохраняет сведения о состоянии между вызовами, чтобы правильно декодировать последовательности байтов, охватывающие блоки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1351">However, a <xref:System.Text.Decoder> maintains state information between calls so it correctly decodes byte sequences that span blocks.</span></span> <span data-ttu-id="5e6a0-1352"><xref:System.Text.Decoder> также сохраняет конечные байты в конце блоков данных и использует конечные байты в следующей операции декодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1352">The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</span></span> <span data-ttu-id="5e6a0-1353">Таким образом, <xref:System.Text.Encoding.GetDecoder%2A> и <xref:System.Text.Encoding.GetEncoder%2A> полезны для передачи по сети и операций с файлами, так как эти операции часто работают с блоками данных, а не с полным потоком данных.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1353">Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="5e6a0-1354">Реализация по умолчанию возвращает <see cref="T:System.Text.Decoder" />, которая вызывает методы <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> и <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> текущего <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1354">The default implementation returns a <see cref="T:System.Text.Decoder" /> that calls the <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> and <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> methods of the current <see cref="T:System.Text.Encoding" />.</span></span> <span data-ttu-id="5e6a0-1355">Необходимо переопределить этот метод, чтобы возвращался <see cref="T:System.Text.Decoder" />, сохраняющая его состояние между вызовами.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1355">You must override this method to return a <see cref="T:System.Text.Decoder" /> that maintains its state between calls.</span></span></para></block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="5e6a0-1356">Общие сведения о кодировках</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1356">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5e6a0-1357">При переопределении в производном классе получает кодировщик, который преобразует последовательность символов Юникода в закодированную последовательность байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1357">When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1358">Объект <see cref="T:System.Text.Encoder" />, преобразующий последовательность символов Юникода в закодированную последовательность байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1358">A <see cref="T:System.Text.Encoder" /> that converts a sequence of Unicode characters into an encoded sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1359">Метод <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> преобразует последовательные блоки символов в последовательные блоки байтов так же, как метод <xref:System.Text.Encoding.GetBytes%2A> этого класса.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1359">The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref:System.Text.Encoding.GetBytes%2A> method of this class.</span></span> <span data-ttu-id="5e6a0-1360">Однако <xref:System.Text.Encoder> сохраняет сведения о состоянии между вызовами, чтобы правильно кодировать последовательности символов, охватывающие блоки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1360">However, a <xref:System.Text.Encoder> maintains state information between calls so it correctly encodes character sequences that span blocks.</span></span> <span data-ttu-id="5e6a0-1361"><xref:System.Text.Encoder> также сохраняет замыкающие символы в конце блоков данных и использует замыкающие символы в следующей операции кодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1361">The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</span></span> <span data-ttu-id="5e6a0-1362">Например, блок данных может заканчиваться непарным старшим символом-заместителем, а соответствующий младший символ-заместитель может находиться в следующем блоке данных.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1362">For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</span></span> <span data-ttu-id="5e6a0-1363">Таким образом, <xref:System.Text.Encoding.GetDecoder%2A> и <xref:System.Text.Encoding.GetEncoder%2A> полезны для передачи по сети и операций с файлами, так как эти операции часто работают с блоками данных, а не с полным потоком данных.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1363">Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="5e6a0-1364">Реализация по умолчанию возвращает <see cref="T:System.Text.Encoder" />, которая вызывает методы <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> и <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> текущего <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1364">The default implementation returns a <see cref="T:System.Text.Encoder" /> that calls the <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> and <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> methods of the current <see cref="T:System.Text.Encoding" />.</span></span> <span data-ttu-id="5e6a0-1365">Необходимо переопределить этот метод, чтобы возвращался <see cref="T:System.Text.Encoder" />, сохраняющая его состояние между вызовами.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1365">You must override this method to return a <see cref="T:System.Text.Encoder" /> that maintains its state between calls.</span></span></para></block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="5e6a0-1366">Общие сведения о кодировках</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1366">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1367">Возвращает кодировку для указанной кодовой страницы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1367">Returns an encoding for the specified code page.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage"><span data-ttu-id="5e6a0-1368">Идентификатор кодовой страницы предпочтительной кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1368">The code page identifier of the preferred encoding.</span></span> <span data-ttu-id="5e6a0-1369">Возможные значения перечислены в столбце кодовой страницы таблицы, которая отображается в теме класса <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1369">Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span>  
  
<span data-ttu-id="5e6a0-1370">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1370">-or-</span></span> 
<span data-ttu-id="5e6a0-1371">0 (ноль), если требуется использовать кодировку по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1371">0 (zero), to use the default encoding.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1372">Возвращает кодировку, связанную с указанным идентификатором кодовой страницы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1372">Returns the encoding associated with the specified code page identifier.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1373">Кодирование, связанное с заданной страницей кода.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1373">The encoding that is associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1374">Резервный обработчик зависит от типа кодировки `codepage`.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1374">The fallback handler depends on the encoding type of `codepage`.</span></span> <span data-ttu-id="5e6a0-1375">Если `codepage` является кодовой страницей или двухбайтовой кодировкой (DBCS), используется резервный обработчик наилучшего соответствия.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1375">If `codepage` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</span></span> <span data-ttu-id="5e6a0-1376">В противном случае используется резервный обработчик замены.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1376">Otherwise, a replacement fallback handler is used.</span></span> <span data-ttu-id="5e6a0-1377">Эти резервные обработчики могут не подойти для вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1377">These fallback handlers may not be appropriate for your app.</span></span> <span data-ttu-id="5e6a0-1378">Чтобы указать резервный обработчик, используемый кодировкой, заданной `codepage`, можно вызвать перегрузку <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1378">To specify the fallback handler used by the encoding specified by `codepage`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.</span></span>  
  
 <span data-ttu-id="5e6a0-1379">В .NET Framework метод <xref:System.Text.Encoding.GetEncoding%2A> использует базовую платформу для поддержки большинства кодовых страниц.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1379">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="5e6a0-1380">Однако .NET Framework изначально поддерживает некоторые кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1380">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="5e6a0-1381">Список кодовых страниц см. в разделе <xref:System.Text.Encoding> Class.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1381">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="5e6a0-1382">В .NET Core метод <xref:System.Text.Encoding.GetEncoding%2A> возвращает кодировки, которые изначально поддерживаются в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1382">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="5e6a0-1383">В обеих реализациях .NET можно вызвать метод <xref:System.Text.Encoding.GetEncodings%2A>, чтобы получить массив объектов <xref:System.Text.EncodingInfo>, содержащий сведения обо всех доступных кодировках.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1383">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span> 

 <span data-ttu-id="5e6a0-1384">В дополнение к кодировкам, которые изначально доступны в .NET Core или поддерживаются в конкретной версии платформы .NET Framework, метод <xref:System.Text.Encoding.GetEncoding%2A> возвращает все дополнительные кодировки, которые становятся доступными путем регистрации <xref:System.Text.EncodingProvider> объектами.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1384">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="5e6a0-1385">Если одна и та же кодировка зарегистрирована несколькими объектами <xref:System.Text.EncodingProvider>, этот метод возвращает последний зарегистрированный.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1385">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>  

<span data-ttu-id="5e6a0-1386">Можно также указать значение 0 для аргумента `codepage`.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1386">You can also supply a value of 0 for the `codepage` argument.</span></span> <span data-ttu-id="5e6a0-1387">Точное поведение зависит от того, были ли доступны кодировки путем регистрации объекта <xref:System.Text.EncodingProvider>:</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1387">Its precise behavior depends on whether any encodings have been made available by registering an <xref:System.Text.EncodingProvider> object:</span></span>

- <span data-ttu-id="5e6a0-1388">Если один или несколько поставщиков кодировок зарегистрированы, возвращается кодировка последнего зарегистрированного поставщика, который выбрал для возврата кодировки, когда методу <xref:System.Text.Encoding.GetEncoding%2A> передается `codepage` аргумент, равный 0.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1388">If one or more encoding providers have been registered, it returns the encoding of the last registered provider that has chosen to return a encoding when the <xref:System.Text.Encoding.GetEncoding%2A> method is passed a `codepage` argument of 0.</span></span>     

- <span data-ttu-id="5e6a0-1389">Если в .NET Framework не зарегистрирован поставщик кодирования, если <xref:System.Text.CodePagesEncodingProvider> является зарегистрированным поставщиком кодирования или если ни один зарегистрированный поставщик кодировок не обрабатывает `codepage` значение 0, возвращается активная кодовая страница операционной системы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1389">On the .NET Framework, if no encoding provider has been registered, if the <xref:System.Text.CodePagesEncodingProvider> is the registered encoding provider, or if no registered encoding provider handles a `codepage` value of 0, it returns the operating system's active code page.</span></span> <span data-ttu-id="5e6a0-1390">Чтобы определить активную кодовую страницу в системах Windows, вызовите функцию Windows [жетакп](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) из .NET Framework на рабочем столе Windows.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1390">To determine the active code page on Windows systems, call the Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the .NET Framework on the Windows desktop.</span></span>

- <span data-ttu-id="5e6a0-1391">В .NET Core, если поставщик кодирования не зарегистрирован или если ни один зарегистрированный поставщик кодировок не обрабатывает `codepage` значение 0, возвращается <xref:System.Text.UTF8Encoding>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1391">On .NET Core, if no encoding provider has been registered or if no registered encoding provider handles a `codepage` value of 0, it returns the <xref:System.Text.UTF8Encoding>.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="5e6a0-1392">Некоторые неподдерживаемые кодовые страницы приводят к возникновению <xref:System.ArgumentException>, в то время как другие вызывают <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1392">Some unsupported code pages cause an <xref:System.ArgumentException> to be thrown, whereas others cause a <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="5e6a0-1393">Поэтому код должен перехватывать все исключения, указанные в разделе исключения.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1393">Therefore, your code must catch all exceptions indicated in the Exceptions section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5e6a0-1394">Кодовые страницы ANSI могут различаться на разных компьютерах и могут изменяться на одном компьютере, что приводит к повреждению данных.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1394">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="5e6a0-1395">По этой причине, если активная кодовая страница является кодовой страницей ANSI, не рекомендуется кодировать и декодировать данные, используя кодовую страницу по умолчанию, возвращенную `Encoding.GetEncoding(0)`.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1395">For this reason, if the active code page is an ANSI code page, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended.</span></span> <span data-ttu-id="5e6a0-1396">Для наиболее последовательных результатов следует использовать кодировку Юникода, такую как UTF-8 (кодовая страница 65001) или UTF-16, а не конкретную кодовую страницу.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1396">For the most consistent results, you should use a Unicode encoding, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>  
  
 <span data-ttu-id="5e6a0-1397"><xref:System.Text.Encoding.GetEncoding%2A> Возвращает кэшированный экземпляр с параметрами по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1397"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="5e6a0-1398">Для получения экземпляра с разными параметрами следует использовать конструкторы производных классов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1398">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="5e6a0-1399">Например, класс <xref:System.Text.UTF32Encoding> предоставляет конструктор, позволяющий включить обнаружение ошибок.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1399">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>  

   
  
## Examples  
 <span data-ttu-id="5e6a0-1400">В следующем примере выполняется получение двух экземпляров одной кодировки (по одной кодовой странице и другой по имени) и проверка их равенства.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1400">The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-1401">Параметр <paramref name="codepage" /> меньше нуля или больше 65 535.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1401"><paramref name="codepage" /> is less than zero or greater than 65535.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5e6a0-1402"><paramref name="codepage" /> не поддерживается используемой платформой.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1402"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5e6a0-1403"><paramref name="codepage" /> не поддерживается используемой платформой.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1403"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="5e6a0-1404">Общие сведения о кодировках</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1404">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="5e6a0-1405">Имя кодовой страницы предпочтительной кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1405">The code page name of the preferred encoding.</span></span> <span data-ttu-id="5e6a0-1406">Любое значение, возвращаемое свойством <see cref="P:System.Text.Encoding.WebName" />, является допустимым.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1406">Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid.</span></span> <span data-ttu-id="5e6a0-1407">Возможные значения перечислены в столбце "Имя" таблицы, отображаемой в разделе класса <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1407">Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1408">Возвращает кодировку, связанную с указанным именем кодовой страницы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1408">Returns the encoding associated with the specified code page name.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1409">Кодировка, связанная с указанной кодовой страницей.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1409">The encoding  associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1410">Резервный обработчик зависит от типа кодировки `name`.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1410">The fallback handler depends on the encoding type of `name`.</span></span> <span data-ttu-id="5e6a0-1411">Если `name` является кодовой страницей или двухбайтовой кодировкой (DBCS), используется резервный обработчик наилучшего соответствия.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1411">If `name` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</span></span> <span data-ttu-id="5e6a0-1412">В противном случае используется резервный обработчик замены.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1412">Otherwise, a replacement fallback handler is used.</span></span> <span data-ttu-id="5e6a0-1413">Эти резервные обработчики могут не подойти для вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1413">These fallback handlers may not be appropriate for your app.</span></span> <span data-ttu-id="5e6a0-1414">Чтобы указать резервный обработчик, используемый кодировкой, заданной `name`, можно вызвать перегрузку <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1414">To specify the fallback handler used by the encoding specified by `name`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.</span></span>  

<span data-ttu-id="5e6a0-1415">В .NET Framework метод <xref:System.Text.Encoding.GetEncoding%2A> использует базовую платформу для поддержки большинства кодовых страниц.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1415">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="5e6a0-1416">Однако .NET Framework изначально поддерживает некоторые кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1416">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="5e6a0-1417">Список кодовых страниц см. в разделе <xref:System.Text.Encoding> Class.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1417">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="5e6a0-1418">В .NET Core метод <xref:System.Text.Encoding.GetEncoding%2A> возвращает кодировки, которые изначально поддерживаются в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1418">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="5e6a0-1419">В обеих реализациях .NET можно вызвать метод <xref:System.Text.Encoding.GetEncodings%2A>, чтобы получить массив объектов <xref:System.Text.EncodingInfo>, содержащий сведения обо всех доступных кодировках.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1419">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span> 

 <span data-ttu-id="5e6a0-1420">В дополнение к кодировкам, которые изначально доступны в .NET Core или поддерживаются в конкретной версии платформы .NET Framework, метод <xref:System.Text.Encoding.GetEncoding%2A> возвращает все дополнительные кодировки, которые становятся доступными путем регистрации <xref:System.Text.EncodingProvider> объектами.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1420">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="5e6a0-1421">Если одна и та же кодировка зарегистрирована несколькими объектами <xref:System.Text.EncodingProvider>, этот метод возвращает последний зарегистрированный.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1421">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>  
   
> [!NOTE]
>  <span data-ttu-id="5e6a0-1422">Кодовые страницы ANSI могут отличаться на разных компьютерах, или их можно изменить для одного компьютера, что приведет к повреждению данных.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1422">The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption.</span></span> <span data-ttu-id="5e6a0-1423">Для наиболее последовательных результатов следует использовать Юникод, например UTF-8 (кодовая страница 65001) или UTF-16, а не конкретную кодовую страницу.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1423">For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>  
 
  
 <span data-ttu-id="5e6a0-1424"><xref:System.Text.Encoding.GetEncoding%2A> Возвращает кэшированный экземпляр с параметрами по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1424"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="5e6a0-1425">Для получения экземпляра с разными параметрами следует использовать конструкторы производных классов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1425">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="5e6a0-1426">Например, класс <xref:System.Text.UTF32Encoding> предоставляет конструктор, позволяющий включить обнаружение ошибок.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1426">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>  
  
## Examples  
 <span data-ttu-id="5e6a0-1427">В следующем примере выполняется получение двух экземпляров одной кодировки (по одной кодовой странице и другой по имени) и проверка их равенства.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1427">The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5e6a0-1428"><paramref name="name" /> не является допустимым именем кодовой страницы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1428"><paramref name="name" /> is not a valid code page name.</span></span>  
  
<span data-ttu-id="5e6a0-1429">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1429">-or-</span></span> 
<span data-ttu-id="5e6a0-1430">Кодовая страница, указанная с помощью параметра <paramref name="name" />, не поддерживается используемой платформой.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1430">The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="5e6a0-1431">Общие сведения о кодировках</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1431">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage"><span data-ttu-id="5e6a0-1432">Идентификатор кодовой страницы предпочтительной кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1432">The code page identifier of the preferred encoding.</span></span> <span data-ttu-id="5e6a0-1433">Возможные значения перечислены в столбце кодовой страницы таблицы, которая отображается в теме класса <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1433">Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span>  
  
<span data-ttu-id="5e6a0-1434">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1434">-or-</span></span> 
<span data-ttu-id="5e6a0-1435">0 (ноль), если требуется использовать кодировку по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1435">0 (zero), to use the default encoding.</span></span></param>
        <param name="encoderFallback"><span data-ttu-id="5e6a0-1436">Объект, предоставляющий процедуру обработки ошибок, когда символ не может быть закодирован с использованием текущей кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1436">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span></span></param>
        <param name="decoderFallback"><span data-ttu-id="5e6a0-1437">Объект, предоставляющий процедуру обработки ошибок, когда последовательность байтов не может быть декодирована с использованием текущей кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1437">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1438">Возвращает кодировку, связанную с указанным идентификатором кодовой страницы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1438">Returns the encoding associated with the specified code page identifier.</span></span> <span data-ttu-id="5e6a0-1439">С помощью параметров задается обработчик ошибок для символов, которые не удается закодировать, и последовательностей байтов, которые не удается декодировать.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1439">Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1440">Кодирование, связанное с заданной страницей кода.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1440">The encoding that is associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="5e6a0-1441">Некоторые неподдерживаемые кодовые страницы приводят к возникновению исключения <xref:System.ArgumentException>, в то время как другие вызывают <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1441">Some unsupported code pages cause the exception <xref:System.ArgumentException> to be thrown, whereas others cause <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="5e6a0-1442">Поэтому код должен перехватывать все исключения, указанные в разделе исключения.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1442">Therefore, your code must catch all exceptions indicated in the Exceptions section.</span></span>  

<span data-ttu-id="5e6a0-1443">В .NET Framework метод <xref:System.Text.Encoding.GetEncoding%2A> использует базовую платформу для поддержки большинства кодовых страниц.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1443">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="5e6a0-1444">Однако .NET Framework изначально поддерживает некоторые кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1444">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="5e6a0-1445">Список кодовых страниц см. в разделе <xref:System.Text.Encoding> Class.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1445">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="5e6a0-1446">В .NET Core метод <xref:System.Text.Encoding.GetEncoding%2A> возвращает кодировки, которые изначально поддерживаются в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1446">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="5e6a0-1447">В обеих реализациях .NET можно вызвать метод <xref:System.Text.Encoding.GetEncodings%2A>, чтобы получить массив объектов <xref:System.Text.EncodingInfo>, содержащий сведения обо всех доступных кодировках.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1447">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span> 

 <span data-ttu-id="5e6a0-1448">В дополнение к кодировкам, которые изначально доступны в .NET Core или поддерживаются в конкретной версии платформы .NET Framework, метод <xref:System.Text.Encoding.GetEncoding%2A> возвращает все дополнительные кодировки, которые становятся доступными путем регистрации <xref:System.Text.EncodingProvider> объектами.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1448">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="5e6a0-1449">Если одна и та же кодировка зарегистрирована несколькими объектами <xref:System.Text.EncodingProvider>, этот метод возвращает последний зарегистрированный.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1449">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>  

<span data-ttu-id="5e6a0-1450">Можно также указать значение 0 для аргумента `codepage`.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1450">You can also supply a value of 0 for the `codepage` argument.</span></span> <span data-ttu-id="5e6a0-1451">Точное поведение зависит от того, были ли доступны кодировки путем регистрации объекта <xref:System.Text.EncodingProvider>:</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1451">Its precise behavior depends on whether any encodings have been made available by registering an <xref:System.Text.EncodingProvider> object:</span></span>

- <span data-ttu-id="5e6a0-1452">Если один или несколько поставщиков кодировок зарегистрированы, возвращается кодировка последнего зарегистрированного поставщика, который выбрал для возврата кодировки, когда методу <xref:System.Text.Encoding.GetEncoding%2A> передается `codepage` аргумент, равный 0.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1452">If one or more encoding providers have been registered, it returns the encoding of the last registered provider that has chosen to return a encoding when the <xref:System.Text.Encoding.GetEncoding%2A> method is passed a `codepage` argument of 0.</span></span>     

- <span data-ttu-id="5e6a0-1453">Если в .NET Framework не зарегистрирован поставщик кодирования, если <xref:System.Text.CodePagesEncodingProvider> является зарегистрированным поставщиком кодирования или если ни один зарегистрированный поставщик кодировок не обрабатывает `codepage` значение 0, возвращается активная кодовая страница.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1453">On the .NET Framework, if no encoding provider has been registered, if the <xref:System.Text.CodePagesEncodingProvider> is the registered encoding provider, or if no registered encoding provider handles a `codepage` value of 0, it returns the active code page.</span></span>

- <span data-ttu-id="5e6a0-1454">В .NET Core, если поставщик кодирования не зарегистрирован или если ни один зарегистрированный поставщик кодировок не обрабатывает `codepage` значение 0, возвращается <xref:System.Text.UTF8Encoding> кодировка.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1454">On .NET Core, if no encoding provider has been registered or if no registered encoding provider handles a `codepage` value of 0, it returns the <xref:System.Text.UTF8Encoding> encoding.</span></span>

> [!NOTE]
>  <span data-ttu-id="5e6a0-1455">Кодовые страницы ANSI могут различаться на разных компьютерах и могут изменяться на одном компьютере, что приводит к повреждению данных.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1455">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="5e6a0-1456">По этой причине, если активная кодовая страница является кодовой страницей ANSI, не рекомендуется кодировать и декодировать данные, используя кодовую страницу по умолчанию, возвращенную `Encoding.GetEncoding(0)`.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1456">For this reason, if the active code page is an ANSI code page, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended.</span></span> <span data-ttu-id="5e6a0-1457">Для наиболее последовательных результатов следует использовать Юникод, например UTF-8 (кодовая страница 65001) или UTF-16, а не конкретную кодовую страницу.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1457">For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span> 
  
 <span data-ttu-id="5e6a0-1458">Чтобы получить кодировку, связанную с активной кодовой страницей, можно либо указать значение 0 для аргумента `codepage`, либо, если код выполняется в .NET Framework на рабочем столе Windows, получить значение свойства <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1458">To get the encoding associated with the active code page, you can either supply a value of 0 for the `codepage` argument or, if your code is running on the .NET Framework on the Windows desktop, retrieve the value of the <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="5e6a0-1459">Чтобы определить текущую активную кодовую страницу, вызовите функцию Windows [жетакп](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) из .NET Framework на рабочем столе Windows.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1459">To determine the current active code page, call the Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the .NET Framework on the Windows desktop.</span></span>  
  
 <span data-ttu-id="5e6a0-1460"><xref:System.Text.Encoding.GetEncoding%2A> Возвращает кэшированный экземпляр с параметрами по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1460"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="5e6a0-1461">Для получения экземпляра с разными параметрами следует использовать конструкторы производных классов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1461">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="5e6a0-1462">Например, класс <xref:System.Text.UTF32Encoding> предоставляет конструктор, позволяющий включить обнаружение ошибок.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1462">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1463">В следующем примере демонстрируется использование метода <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1463">The following example demonstrates the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> method.</span></span>  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-1464">Параметр <paramref name="codepage" /> меньше нуля или больше 65 535.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1464"><paramref name="codepage" /> is less than zero or greater than 65535.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5e6a0-1465"><paramref name="codepage" /> не поддерживается используемой платформой.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1465"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5e6a0-1466"><paramref name="codepage" /> не поддерживается используемой платформой.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1466"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="5e6a0-1467">Общие сведения о кодировках</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1467">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="5e6a0-1468">Имя кодовой страницы предпочтительной кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1468">The code page name of the preferred encoding.</span></span> <span data-ttu-id="5e6a0-1469">Любое значение, возвращаемое свойством <see cref="P:System.Text.Encoding.WebName" />, является допустимым.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1469">Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid.</span></span> <span data-ttu-id="5e6a0-1470">Возможные значения перечислены в столбце "Имя" таблицы, отображаемой в разделе класса <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1470">Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span></param>
        <param name="encoderFallback"><span data-ttu-id="5e6a0-1471">Объект, предоставляющий процедуру обработки ошибок, когда символ не может быть закодирован с использованием текущей кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1471">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span></span></param>
        <param name="decoderFallback"><span data-ttu-id="5e6a0-1472">Объект, предоставляющий процедуру обработки ошибок, когда последовательность байтов не может быть декодирована с использованием текущей кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1472">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1473">Возвращает кодировку, связанную с указанным именем кодовой страницы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1473">Returns the encoding associated with the specified code page name.</span></span> <span data-ttu-id="5e6a0-1474">С помощью параметров задается обработчик ошибок для символов, которые не удается закодировать, и последовательностей байтов, которые не удается декодировать.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1474">Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1475">Кодирование, связанное с заданной страницей кода.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1475">The encoding that is associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="5e6a0-1476">В .NET Framework метод <xref:System.Text.Encoding.GetEncoding%2A> использует базовую платформу для поддержки большинства кодовых страниц.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1476">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="5e6a0-1477">Однако .NET Framework изначально поддерживает некоторые кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1477">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="5e6a0-1478">Список кодовых страниц см. в разделе <xref:System.Text.Encoding> Class.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1478">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="5e6a0-1479">В .NET Core метод <xref:System.Text.Encoding.GetEncoding%2A> возвращает кодировки, которые изначально поддерживаются в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1479">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="5e6a0-1480">В обеих реализациях .NET можно вызвать метод <xref:System.Text.Encoding.GetEncodings%2A>, чтобы получить массив объектов <xref:System.Text.EncodingInfo>, содержащий сведения обо всех доступных кодировках.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1480">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span> 

 <span data-ttu-id="5e6a0-1481">В дополнение к кодировкам, которые изначально доступны в .NET Core или поддерживаются в конкретной версии платформы .NET Framework, метод <xref:System.Text.Encoding.GetEncoding%2A> возвращает все дополнительные кодировки, которые становятся доступными путем регистрации <xref:System.Text.EncodingProvider> объектами.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1481">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="5e6a0-1482">Если одна и та же кодировка зарегистрирована несколькими объектами <xref:System.Text.EncodingProvider>, этот метод возвращает последний зарегистрированный.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1482">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5e6a0-1483">Кодовые страницы ANSI могут различаться на разных компьютерах и могут изменяться на одном компьютере, что приводит к повреждению данных.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1483">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="5e6a0-1484">Для наиболее последовательных результатов следует использовать кодировку Юникода, такую как UTF-8 (кодовая страница 65001) или UTF-16, а не конкретную кодовую страницу.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1484">For the most consistent results, you should use a Unicode encoding, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>  
  
 <span data-ttu-id="5e6a0-1485"><xref:System.Text.Encoding.GetEncoding%2A> Возвращает кэшированный экземпляр с параметрами по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1485"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="5e6a0-1486">Для получения экземпляра с разными параметрами следует использовать конструкторы производных классов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1486">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="5e6a0-1487">Например, класс <xref:System.Text.UTF32Encoding> предоставляет конструктор, позволяющий включить обнаружение ошибок.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1487">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1488">В следующем примере демонстрируется использование метода <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1488">The following example demonstrates the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> method.</span></span>  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5e6a0-1489"><paramref name="name" /> не является допустимым именем кодовой страницы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1489"><paramref name="name" /> is not a valid code page name.</span></span>  
  
<span data-ttu-id="5e6a0-1490">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1490">-or-</span></span> 
<span data-ttu-id="5e6a0-1491">Кодовая страница, указанная с помощью параметра <paramref name="name" />, не поддерживается используемой платформой.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1491">The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="5e6a0-1492">Общие сведения о кодировках</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1492">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5e6a0-1493">Возвращает массив, содержащий все кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1493">Returns an array that contains all encodings.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1494">Массив, содержащий все кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1494">An array that contains all encodings.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1495">Этот метод возвращает список поддерживаемых кодировок, которые уникально различаются кодовой страницей.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1495">This method returns a list of supported encodings, uniquely distinguished by code page.</span></span> <span data-ttu-id="5e6a0-1496">Таблицу, в которой перечислены поддерживаемые кодировки, см. в разделе <xref:System.Text.Encoding> Class.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1496">For a table that lists the supported encodings, see the <xref:System.Text.Encoding> class topic.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5e6a0-1497">Список поддерживаемых кодировок, возвращаемых методом <xref:System.Text.Encoding.GetEncodings%2A>, не включает дополнительных кодировок, доступных для любых реализаций <xref:System.Text.EncodingProvider>, которые были зарегистрированы вызовами метода <xref:System.Text.Encoding.RegisterProvider%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1497">The list of supported encodings returned by the <xref:System.Text.Encoding.GetEncodings%2A> method does not include any additional encodings made available by any <xref:System.Text.EncodingProvider> implementations that were registered by calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method.</span></span>  
  
 <span data-ttu-id="5e6a0-1498">В .NET Framework кодировки 50220 и 50222 сопоставлены с именем "ISO-2022-JP", но они не идентичны.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1498">On the .NET Framework, encodings 50220 and 50222 are both associated with the name "iso-2022-jp", but they are not identical.</span></span> <span data-ttu-id="5e6a0-1499">Кодировка 50220 преобразует символы катакана половинной ширины в символы катакана полной ширины, в то время как кодировка 50222 использует последовательность сдвига и сдвига, чтобы кодировать символы катакана половинной ширины.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1499">Encoding 50220 converts half-width Katakana characters to full-width Katakana characters, whereas encoding 50222 uses a shift-in/shift-out sequence to encode half-width Katakana characters.</span></span> <span data-ttu-id="5e6a0-1500">Отображаемое имя для кодировки 50222 — "Японский (JIS-разрешить 1 байт Кана-SO/SI)", чтобы отличать его от кодировки 50220 с отображаемым именем "Японская (JIS)".</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1500">The display name for encoding 50222 is "Japanese (JIS-Allow 1 byte Kana - SO/SI)" to distinguish it from encoding 50220, which has the display name "Japanese (JIS)".</span></span>  
  
 <span data-ttu-id="5e6a0-1501">Если вы запрашиваете имя кодировки "ISO-2022-JP", .NET Framework возвращает кодировку 50220.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1501">If you request the encoding name "iso-2022-jp", the .NET Framework returns encoding 50220.</span></span> <span data-ttu-id="5e6a0-1502">Однако кодировка, соответствующая Вашему приложению, зависит от предпочтительного способа обработки символов катакана половинной ширины.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1502">However, the encoding that is appropriate for your app depends on the preferred treatment of the half-width Katakana characters.</span></span>  
  
 <span data-ttu-id="5e6a0-1503">Чтобы получить определенную кодировку, следует использовать метод <xref:System.Text.Encoding.GetEncoding%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1503">To get a specific encoding, you should use the <xref:System.Text.Encoding.GetEncoding%2A> method.</span></span>  
  
 <span data-ttu-id="5e6a0-1504"><xref:System.Text.Encoding.GetEncodings%2A> иногда используется для предоставления пользователю списка кодировок в диалоговом окне **Сохранить как** файл.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1504"><xref:System.Text.Encoding.GetEncodings%2A> is sometimes used to present the user with a list of encodings in a File **Save as** dialog box.</span></span> <span data-ttu-id="5e6a0-1505">Однако многие кодировки, отличные от Юникода, являются неполными и преобразовывают много символов в "?" или имеют немного другое поведение на разных платформах.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1505">However, many non-Unicode encodings are either incomplete and translate many characters to "?", or have subtly different behavior on different platforms.</span></span> <span data-ttu-id="5e6a0-1506">В качестве значения по умолчанию можно использовать UTF-8 или UTF-16.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1506">Consider using UTF-8 or UTF-16 as the default.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1507">В следующем примере проверяются значения логических свойств каждой кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1507">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="5e6a0-1508">Общие сведения о кодировках</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1508">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5e6a0-1509">Возвращает хэш-код текущего экземпляра.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1509">Returns the hash code for the current instance.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1510">Хэш-код для текущего экземпляра.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1510">The hash code for the current instance.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount"><span data-ttu-id="5e6a0-1511">Число кодируемых символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1511">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1512">При переопределении в производном классе вычисляет максимальное количество байтов, полученных при кодировании заданного количества символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1512">When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1513">Максимальное количество байтов, полученных при кодировании заданного количества символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1513">The maximum number of bytes produced by encoding the specified number of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1514">Параметр `charCount` фактически определяет количество <xref:System.Char> объектов, которые представляют символы Юникода для кодирования, так как .NET внутренне использует UTF-16 для представления символов Юникода.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1514">The `charCount` parameter actually specifies the number of <xref:System.Char> objects that represent the Unicode characters to encode, because .NET internally uses UTF-16 to represent Unicode characters.</span></span> <span data-ttu-id="5e6a0-1515">Следовательно, большинство символов Юникода могут быть представлены одним <xref:System.Char> объектом, но символ Юникода, представленный суррогатной парой, например, требует двух <xref:System.Char>ных объектов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1515">Consequently, most Unicode characters can be represented by one <xref:System.Char> object, but a Unicode character represented by a surrogate pair, for example, requires two <xref:System.Char> objects.</span></span>  
  
 <span data-ttu-id="5e6a0-1516">Чтобы вычислить точный размер массива, необходимый <xref:System.Text.Encoding.GetBytes%2A> для хранения результирующих байтов, следует использовать метод <xref:System.Text.Encoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1516">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should use the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="5e6a0-1517">Чтобы вычислить максимальный размер массива, используйте метод <xref:System.Text.Encoding.GetMaxByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1517">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="5e6a0-1518">Метод <xref:System.Text.Encoding.GetByteCount%2A> обычно позволяет выделить меньше памяти, а метод <xref:System.Text.Encoding.GetMaxByteCount%2A> обычно выполняется быстрее.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1518">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="5e6a0-1519"><xref:System.Text.Encoding.GetMaxByteCount%2A> извлекает наихудшее число, включая наихудший случай для выбранного в данный момент <xref:System.Text.EncoderFallback>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1519"><xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>.</span></span> <span data-ttu-id="5e6a0-1520">Если резервный вариант выбирается с потенциально большой строкой, <xref:System.Text.Encoding.GetMaxByteCount%2A> получает большие значения, особенно в случаях, когда в худшем случае для кодирования предполагается переключение режимов для каждого символа.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1520">If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves large values, particularly in cases where the worst case for the encoding involves switching modes for every character.</span></span> <span data-ttu-id="5e6a0-1521">Например, это может произойти для ISO-2022-JP.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1521">For example, this can happen for ISO-2022-JP.</span></span> <span data-ttu-id="5e6a0-1522">Дополнительные сведения см. в записи блога "[что такое Encoding. жетмаксбитекаунт () и Encoding. жетмаксчаркаунт ()?](https://blogs.msdn.microsoft.com/shawnste/2005/03/02/whats-with-encoding-getmaxbytecount-and-encoding-getmaxcharcount/)".</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1522">For more information, see the blog post "[What's with Encoding.GetMaxByteCount() and Encoding.GetMaxCharCount()?](https://blogs.msdn.microsoft.com/shawnste/2005/03/02/whats-with-encoding-getmaxbytecount-and-encoding-getmaxcharcount/).</span></span>  
  
 <span data-ttu-id="5e6a0-1523">В большинстве случаев этот метод извлекает разумные значения для небольших строк.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1523">In most cases, this method retrieves reasonable values for small strings.</span></span> <span data-ttu-id="5e6a0-1524">Для больших строк может потребоваться выбрать один из самых больших буферов и перехват ошибок в редких случаях, когда более разумный буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1524">For large strings, you might have to choose between using very large buffers and catching errors in the rare case when a more reasonable buffer is too small.</span></span> <span data-ttu-id="5e6a0-1525">Также можно рассмотреть другой подход, используя <xref:System.Text.Encoding.GetByteCount%2A> или <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1525">You might also want to consider a different approach using <xref:System.Text.Encoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5e6a0-1526">При использовании <xref:System.Text.Encoding.GetMaxByteCount%2A>следует выделить выходной буфер на основе максимального размера входного буфера.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1526">When using <xref:System.Text.Encoding.GetMaxByteCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer.</span></span> <span data-ttu-id="5e6a0-1527">Если размер выходного буфера ограничен, можно использовать метод <xref:System.Text.Encoding.Convert%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1527">If the output buffer is constrained in size, you might use the <xref:System.Text.Encoding.Convert%2A> method.</span></span>  
  
 <span data-ttu-id="5e6a0-1528">Обратите внимание, что <xref:System.Text.Encoding.GetMaxByteCount%2A> считает потенциальные оставшиеся суррогаты из предыдущей операции декодера.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1528">Note that <xref:System.Text.Encoding.GetMaxByteCount%2A> considers potential leftover surrogates from a previous decoder operation.</span></span> <span data-ttu-id="5e6a0-1529">Из-за декодера передача значения 1 в метод получает 2 для однобайтовой кодировки, например ASCII.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1529">Because of the decoder, passing a value of 1 to the method retrieves 2 for a single-byte encoding, such as ASCII.</span></span> <span data-ttu-id="5e6a0-1530">Если эти сведения необходимы, следует использовать свойство <xref:System.Text.ASCIIEncoding.IsSingleByte%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1530">You should use the <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> property if this information is necessary.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5e6a0-1531">`GetMaxByteCount(N)` не обязательно является тем же значением, что и `N* GetMaxByteCount(1)`.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1531">`GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1532">В следующем примере определяется число байтов, необходимое для кодирования массива символов, символы кодируются и выводятся полученные байты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1532">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-1533">Значение параметра <paramref name="charCount" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1533"><paramref name="charCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="5e6a0-1534">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1534">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-1535">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1535">-and-</span></span> 
 <span data-ttu-id="5e6a0-1536">Параметру <see cref="P:System.Text.Encoding.EncoderFallback" /> задается значение <see cref="T:System.Text.EncoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1536"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="5e6a0-1537">Все реализации <see cref="T:System.Text.Encoding" /> должны гарантировать, что исключения переполнения буфера не возникают, если размер буферов изменяется в соответствии с результатами вычислений этого метода.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1537">All <see cref="T:System.Text.Encoding" /> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</span></span></para></block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount"><span data-ttu-id="5e6a0-1538">Число байтов для декодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1538">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1539">При переопределении в производном классе вычисляет максимальное количество символов, полученных при декодировании заданного количества байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1539">When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1540">Максимальное количество символов, полученных при декодировании заданного количества байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1540">The maximum number of characters produced by decoding the specified number of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1541">Чтобы вычислить точный размер массива, необходимый <xref:System.Text.Encoding.GetChars%2A> для хранения полученных символов, следует использовать метод <xref:System.Text.Encoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1541">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="5e6a0-1542">Чтобы вычислить максимальный размер массива, используйте метод <xref:System.Text.Encoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1542">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="5e6a0-1543">Метод <xref:System.Text.Encoding.GetCharCount%2A> обычно позволяет выделить меньше памяти, а метод <xref:System.Text.Encoding.GetMaxCharCount%2A> обычно выполняется быстрее.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1543">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="5e6a0-1544"><xref:System.Text.Encoding.GetMaxCharCount%2A> извлекает наихудшее число, включая наихудший случай для выбранного в данный момент <xref:System.Text.DecoderFallback>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1544"><xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>.</span></span> <span data-ttu-id="5e6a0-1545">Если резервный вариант выбирается с потенциально большой строкой, <xref:System.Text.Encoding.GetMaxCharCount%2A> получает большие значения.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1545">If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves large values.</span></span>  
  
 <span data-ttu-id="5e6a0-1546">В большинстве случаев этот метод извлекает разумные числа для небольших строк.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1546">In most cases, this method retrieves reasonable numbers for small strings.</span></span> <span data-ttu-id="5e6a0-1547">Для больших строк может потребоваться выбрать один из самых больших буферов и перехват ошибок в редких случаях, когда более разумный буфер слишком мал.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1547">For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is too small.</span></span> <span data-ttu-id="5e6a0-1548">Также можно рассмотреть другой подход, используя <xref:System.Text.Encoding.GetCharCount%2A> или <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1548">You might also want to consider a different approach using <xref:System.Text.Encoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="5e6a0-1549"><xref:System.Text.Encoding.GetMaxCharCount%2A> не имеет связи с <xref:System.Text.Encoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1549"><xref:System.Text.Encoding.GetMaxCharCount%2A> has no relation to <xref:System.Text.Encoding.GetBytes%2A>.</span></span> <span data-ttu-id="5e6a0-1550">Если требуется аналогичная функция для использования с <xref:System.Text.Encoding.GetBytes%2A>, следует использовать <xref:System.Text.Encoding.GetMaxByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1550">If you needs a similar function to use with <xref:System.Text.Encoding.GetBytes%2A>, you should use <xref:System.Text.Encoding.GetMaxByteCount%2A>.</span></span>  
  
 <span data-ttu-id="5e6a0-1551">При использовании <xref:System.Text.Encoding.GetMaxCharCount%2A>следует выделить выходной буфер на основе максимального размера входного буфера.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1551">When using <xref:System.Text.Encoding.GetMaxCharCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer.</span></span> <span data-ttu-id="5e6a0-1552">Если размер выходного буфера ограничен, можно использовать метод <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1552">If the output buffer is constrained in size, you might use the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="5e6a0-1553">Обратите внимание, что <xref:System.Text.Encoding.GetMaxCharCount%2A> считает наихудший случай для оставшихся байтов из предыдущей операции кодировщика.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1553">Note that <xref:System.Text.Encoding.GetMaxCharCount%2A> considers the worst case for leftover bytes from a previous encoder operation.</span></span> <span data-ttu-id="5e6a0-1554">Для большинства кодовых страниц передача значения 0 в этот метод извлекает значения, которые больше или равны 1.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1554">For most code pages, passing a value of 0 to this method retrieves values greater than or equal to 1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5e6a0-1555">`GetMaxCharCount(N)` не обязательно является тем же значением, что и `N* GetMaxCharCount(1)`.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1555">`GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1556">Следующий пример кодирует строку в массив байтов, а затем декодирует байты в массив символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1556">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-1557">Значение параметра <paramref name="byteCount" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1557"><paramref name="byteCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="5e6a0-1558">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1558">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-1559">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1559">-and-</span></span> 
 <span data-ttu-id="5e6a0-1560">Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1560"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="5e6a0-1561">Все реализации <see cref="T:System.Text.Encoding" /> должны гарантировать, что исключения переполнения буфера не возникают, если размер буферов изменяется в соответствии с результатами вычислений этого метода.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1561">All <see cref="T:System.Text.Encoding" /> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</span></span></para></block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5e6a0-1562">При переопределении в производном классе возвращает последовательность байтов, задающую используемую кодировку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1562">When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1563">Массив байтов, в котором содержится последовательность байтов, задающая используемую кодировку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1563">A byte array containing a sequence of bytes that specifies the encoding used.</span></span>  
  
 <span data-ttu-id="5e6a0-1564">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1564">-or-</span></span>  
  
 <span data-ttu-id="5e6a0-1565">Массив байтов нулевой длины, если преамбула не требуется.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1565">A byte array of length zero, if a preamble is not required.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1566">При необходимости объект <xref:System.Text.Encoding> предоставляет преамбулу, которая представляет собой массив байтов, который может быть префиксом последовательности байтов, полученной в результате процесса кодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1566">Optionally, the <xref:System.Text.Encoding> object provides a preamble that is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process.</span></span> <span data-ttu-id="5e6a0-1567">Если преамбула содержит метку порядка байтов (в Юникоде, кодовую точку U + FEFF), она помогает декодеру определить порядок байтов и формат преобразования или кодировку UTF.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1567">If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF.</span></span>  
  
 <span data-ttu-id="5e6a0-1568">Метка порядка байтов Юникода (BOM) сериализуется следующим образом (в шестнадцатеричном формате):</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1568">The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):</span></span>  
  
-   <span data-ttu-id="5e6a0-1569">UTF-8: EF BB BF</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1569">UTF-8: EF BB BF</span></span>  
  
-   <span data-ttu-id="5e6a0-1570">Порядковый номер UTF-16 с обратным порядком байтов: FE FF</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1570">UTF-16 big endian byte order: FE FF</span></span>  
  
-   <span data-ttu-id="5e6a0-1571">UTF-16, прямой порядок байтов: FF FE</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1571">UTF-16 little endian byte order: FF FE</span></span>  
  
-   <span data-ttu-id="5e6a0-1572">UTF-32. обратный порядок байтов: 00 00 FE FF</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1572">UTF-32 big endian byte order: 00 00 FE FF</span></span>  
  
-   <span data-ttu-id="5e6a0-1573">UTF-32, прямой порядок байтов: FF FE 00 00</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1573">UTF-32 little endian byte order: FF FE 00 00</span></span>  
  
 <span data-ttu-id="5e6a0-1574">Следует использовать СПЕЦИФИКАЦИю, так как она обеспечивает почти определенную идентификацию кодировки для файлов, которые в противном случае теряют ссылку на объект <xref:System.Text.Encoding>, например, непомеченные или неправильно помеченные веб-данные или случайные текстовые файлы, хранящиеся, если у бизнеса нет международные проблемы или другие данные.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1574">You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.Encoding> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data.</span></span> <span data-ttu-id="5e6a0-1575">Часто проблемы пользователей могут быть устранены, если данные постоянно и правильно помечены тегами, желательно в UTF-8 или UTF-16.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1575">Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.</span></span>  
  
 <span data-ttu-id="5e6a0-1576">Для стандартов, предоставляющих тип кодировки, BOM является несколько избыточным.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1576">For standards that provide an encoding type, a BOM is somewhat redundant.</span></span> <span data-ttu-id="5e6a0-1577">Однако его можно использовать, чтобы помочь серверу отправить правильный заголовок кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1577">However, it can be used to help a server send the correct encoding header.</span></span> <span data-ttu-id="5e6a0-1578">Кроме того, его можно использовать в качестве резервного, если кодировка в противном случае будет потеряна.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1578">Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</span></span>  
  
 <span data-ttu-id="5e6a0-1579">Существует ряд недостатков использования спецификации.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1579">There are some disadvantages to using a BOM.</span></span> <span data-ttu-id="5e6a0-1580">Например, знание того, как ограничить поля базы данных, использующие СПЕЦИФИКАЦИю, может оказаться затруднительным.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1580">For example, knowing how to limit the database fields that use a BOM can be difficult.</span></span> <span data-ttu-id="5e6a0-1581">Объединение файлов может быть проблемой, например, при слиянии файлов таким образом, что ненужный символ может оказаться в середине данных.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1581">Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</span></span> <span data-ttu-id="5e6a0-1582">Несмотря на множество недостатков, настоятельно рекомендуется использовать СПЕЦИФИКАЦИю.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1582">In spite of the few disadvantages, however, the use of a BOM is highly recommended.</span></span>  
  
 <span data-ttu-id="5e6a0-1583">Дополнительные сведения о порядке байтов и метке порядка байтов см. в стандарте Юникода на [домашней странице Юникода](https://go.microsoft.com/fwlink/?LinkId=37123).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1583">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](https://go.microsoft.com/fwlink/?LinkId=37123).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="5e6a0-1584">Чтобы обеспечить правильную декодирование закодированных байтов, следует добавить в байты префикс в формате преамбулы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1584">To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble.</span></span> <span data-ttu-id="5e6a0-1585">Однако большинство кодировок не предоставляют преамбулы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1585">However, most encodings do not provide a preamble.</span></span> <span data-ttu-id="5e6a0-1586">Чтобы обеспечить правильную декодирование закодированных байтов, следует использовать кодировку Юникода, то есть <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>или <xref:System.Text.UTF32Encoding>с преамбулой.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1586">To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, or <xref:System.Text.UTF32Encoding>, with a preamble.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1587">В следующем примере определяется порядок байтов кодировки на основе преамбулы.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1587">The following example determines the byte order of the encoding based on the preamble.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1588">При переопределении в производном классе декодирует последовательность байтов в строку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1588">When overridden in a derived class, decodes a sequence of bytes into a string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="5e6a0-1589">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1589">The byte array containing the sequence of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1590">При переопределении в производном классе декодирует все байты из указанного массива байтов в строку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1590">When overridden in a derived class, decodes all the bytes in the specified byte array into a string.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1591">Строка, содержащая результаты декодирования заданной последовательности байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1591">A string that contains the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1592">Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать объект <xref:System.Text.Decoder>, возвращаемый методом <xref:System.Text.Encoding.GetDecoder%2A> производного класса см.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1592">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.</span></span>  
  
 <span data-ttu-id="5e6a0-1593">Обсуждение приемов и рекомендаций по декодированию см. в разделе "Примечания" <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> справочной статьи.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1593">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>  
  
 <span data-ttu-id="5e6a0-1594">Обратите внимание, что точное поведение метода <xref:System.Text.Encoding.GetString%2A> для конкретной реализации <xref:System.Text.Encoding> зависит от резервной стратегии, определенной для этого <xref:System.Text.Encoding> объекта.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1594">Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object.</span></span> <span data-ttu-id="5e6a0-1595">Дополнительные сведения см. в разделе "Выбор стратегии резервного использования" статьи [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md) .</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1595">For more information, see the "Choosing a Fallback Strategy" section of the [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) topic.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1596">В следующем примере считывается строка в кодировке UTF-8 из двоичного файла, представленного <xref:System.IO.FileStream> объектом.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1596">The following example reads a UTF-8 encoded string from a binary file represented by a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="5e6a0-1597">Для файлов размером менее 2 048 байт он считывает содержимое всего файла в массив байтов и вызывает метод <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> для выполнения декодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1597">For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> method to perform the decoding.</span></span> <span data-ttu-id="5e6a0-1598">Для больших файлов он считывает 2 048 байт за раз в массив байтов, вызывает метод <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>, чтобы определить, сколько символов содержится в массиве, а затем вызывает метод <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> для выполнения декодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1598">For larger files, it reads 2,048 bytes at a time into a byte array, calls the <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to determine how many characters are contained in the array, and then calls the <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> method to perform the decoding.</span></span>  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 <span data-ttu-id="5e6a0-1599">В примере используется следующий текст, который должен быть сохранен в файл в кодировке UTF-8 с именем Utf8Example. txt.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1599">The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</span></span>  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5e6a0-1600">Массив байтов содержит недопустимые точки кода Юникод.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1600">The byte array contains invalid Unicode code points.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-1601">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1601"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="5e6a0-1602">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1602">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-1603">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1603">-and-</span></span> 
 <span data-ttu-id="5e6a0-1604">Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1604"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="5e6a0-1605">Указатель на массив байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1605">A pointer to a byte array.</span></span></param>
        <param name="byteCount"><span data-ttu-id="5e6a0-1606">Число байтов для декодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1606">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1607">При переопределении в производном классе декодирует указанное количество байтов начиная с указанного адреса в строку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1607">When overridden in a derived class, decodes a specified number of bytes starting at a specified address into a string.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1608">Строка, содержащая результаты декодирования заданной последовательности байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1608">A string that contains the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1609">Метод <xref:System.Text.Encoding.GetString%2A> предназначен для оптимизации производительности при наличии собственного указателя на массив байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1609">The <xref:System.Text.Encoding.GetString%2A> method is designed to optimize performance when you have a native pointer to a byte array.</span></span> <span data-ttu-id="5e6a0-1610">Вместо создания управляемого массива байтов, а затем его декодирования, можно вызвать этот метод без создания каких-либо промежуточных объектов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1610">Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects.</span></span>  
  
 <span data-ttu-id="5e6a0-1611">Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать объект <xref:System.Text.Decoder>, возвращаемый методом <xref:System.Text.Encoding.GetDecoder%2A> производного класса см.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1611">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.</span></span>  
  
 <span data-ttu-id="5e6a0-1612">Обсуждение приемов и рекомендаций по декодированию см. в разделе "Примечания" <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> справочной статьи.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1612">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>  
  
 <span data-ttu-id="5e6a0-1613">Обратите внимание, что точное поведение метода <xref:System.Text.Encoding.GetString%2A> для конкретной реализации <xref:System.Text.Encoding> зависит от резервной стратегии, определенной для этого <xref:System.Text.Encoding> объекта.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1613">Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object.</span></span> <span data-ttu-id="5e6a0-1614">Дополнительные сведения см. в разделе "Выбор стратегии резервного использования" статьи [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md) .</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1614">For more information, see the "Choosing a Fallback Strategy" section of the [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) topic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-1615"><paramref name="bytes" /> является пустым указателем</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1615"><paramref name="bytes" /> is a null pointer.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-1616">Значение параметра <paramref name="byteCount" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1616"><paramref name="byteCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="5e6a0-1617">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1617">A   fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for a complete explanation)</span></span> 
<span data-ttu-id="5e6a0-1618">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1618">-and-</span></span> 
 <span data-ttu-id="5e6a0-1619">Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1619"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="5e6a0-1620">Массив байтов, содержащий последовательность байтов, которую требуется декодировать.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1620">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="index"><span data-ttu-id="5e6a0-1621">Индекс первого декодируемого байта.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1621">The index of the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="5e6a0-1622">Число байтов для декодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1622">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1623">При переопределении в производном классе декодирует последовательность байтов из указанного массива байтов в строку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1623">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1624">Строка, содержащая результаты декодирования заданной последовательности байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1624">A string that contains the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1625">Если данные для преобразования доступны только в последовательных блоках (например, чтение данных из потока) или если объем данных настолько велик, что необходимо разделить на меньшие блоки, следует использовать <xref:System.Text.Decoder> или <xref:System.Text.Encoder>, предоставляемые <xref:System.Text.Encoding.GetDecoder%2A> метод или метод <xref:System.Text.Encoding.GetEncoder%2A>, соответственно, производного класса.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1625">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="5e6a0-1626">Обсуждение приемов и рекомендаций по декодированию см. в разделе "Примечания" <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> справочной статьи.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1626">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1627">В следующем примере считывается строка в кодировке UTF-8 из двоичного файла, представленного <xref:System.IO.FileStream> объектом.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1627">The following example reads a UTF-8 encoded string from a binary file that is represented by a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="5e6a0-1628">Для файлов размером менее 2 048 байт он считывает содержимое всего файла в массив байтов и вызывает метод <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> для выполнения декодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1628">For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method to perform the decoding.</span></span> <span data-ttu-id="5e6a0-1629">Для больших файлов он считывает 2 048 байт за раз в массив байтов, вызывает метод <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>, чтобы определить, сколько символов содержится в массиве, а затем вызывает метод <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> для выполнения декодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1629">For larger files, it reads 2,048 bytes at a time into a byte array, calls the <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to determine how many characters are contained in the array, and then calls the <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> method to perform the decoding.</span></span>  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 <span data-ttu-id="5e6a0-1630">В примере используется следующий текст, который должен быть сохранен в файл в кодировке UTF-8 с именем Utf8Example. txt.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1630">The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</span></span>  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5e6a0-1631">Массив байтов содержит недопустимые точки кода Юникод.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1631">The byte array contains invalid Unicode code points.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-1632">Свойство <paramref name="bytes" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1632"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5e6a0-1633">Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1633"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>  
  
<span data-ttu-id="5e6a0-1634">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1634">-or-</span></span> 
 <span data-ttu-id="5e6a0-1635">Параметры <paramref name="index" /> и <paramref name="count" /> не указывают допустимый диапазон в <paramref name="bytes" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1635"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="5e6a0-1636">Произошел откат (полное объяснение см. в статье [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md))</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1636">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span></span> 
<span data-ttu-id="5e6a0-1637">- и -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1637">-and-</span></span> 
 <span data-ttu-id="5e6a0-1638">Параметру <see cref="P:System.Text.Encoding.DecoderFallback" /> задается значение <see cref="T:System.Text.DecoderExceptionFallback" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1638"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1639">При переопределении в производном классе получает имя текущей кодировки, которое может использоваться с тегами заголовка сообщения почтового агента.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1639">When overridden in a derived class, gets a name for the current encoding that can be used with mail agent header tags.</span></span></summary>
        <value><span data-ttu-id="5e6a0-1640">Имя текущего объекта <see cref="T:System.Text.Encoding" />, которое может использоваться с тегами заголовка сообщения почтового агента.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1640">A name for the current <see cref="T:System.Text.Encoding" /> to use with mail agent header tags.</span></span>  
  
<span data-ttu-id="5e6a0-1641">- или -</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1641">-or-</span></span> 
<span data-ttu-id="5e6a0-1642">Пустая строка (""), если текущий объект <see cref="T:System.Text.Encoding" /> не может использоваться.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1642">An empty string (""), if the current <see cref="T:System.Text.Encoding" /> cannot be used.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1643">Если требуется кодировка для имени заголовка, следует вызвать метод <xref:System.Text.Encoding.GetEncoding%2A> со свойством <xref:System.Text.Encoding.HeaderName%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1643">If you need an encoding for a header name, you should call the <xref:System.Text.Encoding.GetEncoding%2A> method with the <xref:System.Text.Encoding.HeaderName%2A> property.</span></span> <span data-ttu-id="5e6a0-1644">Часто метод извлекает другую кодировку из тестовой кодировки, предоставляемой в вызове.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1644">Often the method retrieves a different encoding from the test encoding furnished in the call.</span></span> <span data-ttu-id="5e6a0-1645">Как правило, для получения такой кодировки требуются только приложения электронной почты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1645">Generally only email applications need to retrieve such an encoding.</span></span>  
  
 <span data-ttu-id="5e6a0-1646">В некоторых случаях значение свойства <xref:System.Text.Encoding.BodyName%2A> соответствует международным стандарту, который определяет эту кодировку.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1646">In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding.</span></span> <span data-ttu-id="5e6a0-1647">Это не означает, что реализация полностью соответствует этому стандарту.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1647">This doesn't mean that the implementation complies in full with that standard.</span></span>  
  
 <span data-ttu-id="5e6a0-1648">Обратите внимание, что <xref:System.Text.Encoding.WebName%2A> возвращает имя, используемое для описания кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1648">Note that <xref:System.Text.Encoding.WebName%2A> returns the name to use to describe an encoding.</span></span> <span data-ttu-id="5e6a0-1649">Свойство <xref:System.Text.Encoding.HeaderName%2A> определяет другую кодировку, которая может работать лучше для приложения электронной почты, например.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1649">The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for an email application, for example.</span></span> <span data-ttu-id="5e6a0-1650">Однако использовать свойство для определения кодировки не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1650">However, use of the property to define the encoding is not recommended.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1651">В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки с одним или несколькими именами, отличными от <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1651">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5e6a0-1652">Он отображает <xref:System.Text.Encoding.EncodingName%2A> но не выполняет сравнение с ним.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1652">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1653">Получает значение, которое указывает, является ли текущая кодировка всегда нормированной.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1653">Gets a value indicating whether the current encoding is always normalized.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5e6a0-1654">Получает значение, которое указывает, является ли текущая кодировка всегда нормализованной с использованием формы нормализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1654">Gets a value indicating whether the current encoding is always normalized, using the default normalization form.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1655"><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> всегда нормирован; в противоположном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1655"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> is always normalized; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="5e6a0-1656">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1656">The default is <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1657">Форма нормализации по умолчанию — <xref:System.Text.NormalizationForm.FormC>, которая использует полную каноническую декомпозицию, а затем заменяет последовательности на их основные составные части, если это возможно.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1657">The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="form"><span data-ttu-id="5e6a0-1658">Одно из значений <see cref="T:System.Text.NormalizationForm" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1658">One of the <see cref="T:System.Text.NormalizationForm" /> values.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1659">При переопределении в производном классе получает значение, которое указывает, является ли текущая кодировка всегда нормализованной с использованием заданной по умолчанию формы нормализации.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1659">When overridden in a derived class, gets a value indicating whether the current encoding is always normalized, using the specified normalization form.</span></span></summary>
        <returns><span data-ttu-id="5e6a0-1660"><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> всегда нормализуется с использованием заданного значения <see cref="T:System.Text.NormalizationForm" />; в противоположном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1660"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> object is always normalized using the specified <see cref="T:System.Text.NormalizationForm" /> value; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="5e6a0-1661">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1661">The default is <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1662">Форма нормализации по умолчанию — <xref:System.Text.NormalizationForm.FormC>, которая использует полную каноническую декомпозицию, а затем заменяет последовательности на их основные составные части, если это возможно.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1662">The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1663">При переопределении в производном классе получает значение, указывающее, может ли текущая кодировка использоваться клиентами браузера для отображения содержимого.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1663">When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for displaying content.</span></span></summary>
        <value><span data-ttu-id="5e6a0-1664"><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> может использоваться клиентами браузера для отображения содержимого; в противоположном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1664"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by browser clients for displaying content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="5e6a0-1665">В следующем примере проверяются значения логических свойств каждой кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1665">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1666">При переопределении в производном классе получает значение, указывающее, может ли текущая кодировка использоваться клиентами браузера для сохранения содержимого.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1666">When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for saving content.</span></span></summary>
        <value><span data-ttu-id="5e6a0-1667"><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> может использоваться клиентами браузера для сохранения содержимого; в противоположном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1667"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by browser clients for saving content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="5e6a0-1668">В следующем примере проверяются значения логических свойств каждой кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1668">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1669">При переопределении в производном классе получает значение, указывающее, может ли текущая кодировка использоваться клиентами электронной почты и новостей для отображения содержимого.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1669">When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for displaying content.</span></span></summary>
        <value><span data-ttu-id="5e6a0-1670"><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> может использоваться клиентами электронной почты и новостей для отображения содержимого; в противоположном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1670"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by mail and news clients for displaying content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="5e6a0-1671">В следующем примере проверяются значения логических свойств каждой кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1671">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1672">При переопределении в производном классе получает значение, указывающее, может ли текущая кодировка использоваться клиентами электронной почты и новостей для сохранения содержимого.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1672">When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for saving content.</span></span></summary>
        <value><span data-ttu-id="5e6a0-1673"><see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> может использоваться клиентами почты и новостей для сохранения содержимого; в противоположном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1673"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by mail and news clients for saving content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="5e6a0-1674">В следующем примере проверяются значения логических свойств каждой кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1674">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1675">При переопределении в производном классе получает значение, указывающее, является ли текущая кодировка доступной только для чтения.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1675">When overridden in a derived class, gets a value indicating whether the current encoding is read-only.</span></span></summary>
        <value><span data-ttu-id="5e6a0-1676">Значение <see langword="true" />, если текущий объект <see cref="T:System.Text.Encoding" /> доступен только для чтения, в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1676"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> is read-only; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="5e6a0-1677">Значение по умолчанию — <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1677">The default is <see langword="true" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1678">При переопределении в производном классе получает значение, указывающее, используются ли в текущей кодировке однобайтовые кодовые точки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1678">When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.</span></span></summary>
        <value><span data-ttu-id="5e6a0-1679"><see langword="true" />, если в текущем объекте <see cref="T:System.Text.Encoding" /> используются однобайтовые кодовые точки; в противоположном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1679"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> uses single-byte code points; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1680">Для однобайтовой кодировки, например <xref:System.Text.ASCIIEncoding>, это свойство извлекает `true`.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1680">For a single-byte encoding, for example, <xref:System.Text.ASCIIEncoding>, this property retrieves `true`.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="5e6a0-1681">Следует соблюдать осторожность при работе приложения со значением <xref:System.Text.Encoding.IsSingleByte%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1681">You should be careful in what your application does with the value for <xref:System.Text.Encoding.IsSingleByte%2A>.</span></span> <span data-ttu-id="5e6a0-1682">Предположение о том, как будет продолжаться кодирование, может быть неправильным.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1682">An assumption of how an Encoding will proceed may still be wrong.</span></span> <span data-ttu-id="5e6a0-1683">Например, в Windows-1252 имеется значение `true` для <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, но Encoding. Жетмаксбитекаунт (1) возвращает 2.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1683">For example, Windows-1252 has a value of `true` for <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, but Encoding.GetMaxByteCount(1) returns 2.</span></span> <span data-ttu-id="5e6a0-1684">Это обусловлено тем, что метод рассматривает потенциальные оставшиеся суррогаты из предыдущей операции декодера.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1684">This is because the method considers potential leftover surrogates from a previous decoder operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1685">В следующем примере проверяются значения логических свойств каждой кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1685">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="5e6a0-1686">Подкласс класса <see cref="T:System.Text.EncodingProvider" />, который предоставляет доступ к дополнительным кодировкам символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1686">A subclass of <see cref="T:System.Text.EncodingProvider" /> that provides access to additional character encodings.</span></span></param>
        <summary><span data-ttu-id="5e6a0-1687">Регистрирует поставщик кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1687">Registers an encoding provider.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1688">Метод <xref:System.Text.Encoding.RegisterProvider%2A> позволяет зарегистрировать класс, производный от <xref:System.Text.EncodingProvider>, который делает кодировку символов доступной на платформе, которая в противном случае не поддерживает их.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1688">The <xref:System.Text.Encoding.RegisterProvider%2A> method allows you to register a class derived from <xref:System.Text.EncodingProvider> that makes character encodings available on a platform that does not otherwise support them.</span></span> <span data-ttu-id="5e6a0-1689">После регистрации поставщика кодировок можно извлечь поддерживаемые им кодировки, вызвав любую перегрузку <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1689">Once the encoding provider is registered, the encodings that it supports can be retrieved by calling any <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> overload.</span></span> <span data-ttu-id="5e6a0-1690">При наличии нескольких поставщиков кодировок метод <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> пытается получить заданную кодировку от каждого поставщика, начиная с последней зарегистрированной.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1690">If there are multiple encoding providers, the <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> method attempts to retrieve a specified encoding from each provider starting with the one most recently registered.</span></span>

<span data-ttu-id="5e6a0-1691">Регистрация поставщика кодирования с помощью метода <xref:System.Text.Encoding.RegisterProvider%2A> также изменяет поведение методов [Encoding. Encoding (Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) и [EncodingProvider. Encoding (Int32, EncoderFallback, DecoderFallback)](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) при передаче аргумента. из `0`:</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1691">Registering an encoding provider by using the <xref:System.Text.Encoding.RegisterProvider%2A> method also modifies the behavior of the [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) and [EncodingProvider.GetEncoding(Int32, EncoderFallback, DecoderFallback)](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) methods when passed an argument of `0`:</span></span>

- <span data-ttu-id="5e6a0-1692">Если зарегистрированный поставщик является <xref:System.Text.CodePagesEncodingProvider>, метод возвращает кодировку, соответствующую системной активной кодовой странице при работе в операционной системе Windows.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1692">If the registered provider is the <xref:System.Text.CodePagesEncodingProvider>, the method returns the encoding that matches the system active code page when running on the Windows operating system.</span></span>

- <span data-ttu-id="5e6a0-1693">Пользовательский поставщик кодирования может выбрать, какую кодировку следует вернуть, когда любой из этих <xref:System.Text.Encoding.GetEncoding%2A> перегрузок метода передается аргументом `0`.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1693">A custom encoding provider can choose which encoding to return when either of these <xref:System.Text.Encoding.GetEncoding%2A> method overloads is passed an argument of `0`.</span></span> <span data-ttu-id="5e6a0-1694">Поставщик также может не возвращать кодировку, если метод <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1694">The provider can also choose to not return an encoding by having the <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> method return `null`.</span></span> 
  
<span data-ttu-id="5e6a0-1695">Начиная с .NET Framework 4,6, .NET Framework включает один поставщик кодирования, <xref:System.Text.CodePagesEncodingProvider>, который делает кодировки в полной .NET Framework, но недоступны в универсальная платформа Windows.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1695">Starting with the .NET Framework 4.6, the .NET Framework includes one encoding provider, <xref:System.Text.CodePagesEncodingProvider>, that makes the encodings available that are present in the full .NET Framework but are not available in the Universal Windows Platform.</span></span> <span data-ttu-id="5e6a0-1696">По умолчанию универсальная платформа Windows поддерживает только кодировки Юникода, ASCII и кодовую страницу 28591.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1696">By default, the Universal Windows Platform only supports the Unicode encodings, ASCII, and code page 28591.</span></span>  
  
 <span data-ttu-id="5e6a0-1697">Если один и тот же поставщик кодирования используется в нескольких вызовах метода <xref:System.Text.Encoding.RegisterProvider%2A>, поставщик регистрируется только в первом вызове метода.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1697">If the same encoding provider is used in multiple calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method, only the first method call registers the provider.</span></span> <span data-ttu-id="5e6a0-1698">Последующие вызовы игнорируются.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1698">Subsequent calls are ignored.</span></span>  
  
 <span data-ttu-id="5e6a0-1699">Если метод <xref:System.Text.Encoding.RegisterProvider%2A> вызывается для регистрации нескольких поставщиков, обрабатывающих одну и ту же кодировку, последний зарегистрированный поставщик используется для всех операций кодирования и декодирования.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1699">If the <xref:System.Text.Encoding.RegisterProvider%2A> method is called to register multiple providers that handle the same encoding, the last registered provider is the used for all encoding and decoding operations.</span></span> <span data-ttu-id="5e6a0-1700">Все ранее зарегистрированные поставщики игнорируются.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1700">Any previously registered providers are ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="5e6a0-1701">Свойство <paramref name="provider" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1701"><paramref name="provider" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1702">Получает кодировку для формата UTF-16 с прямым порядком байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1702">Gets an encoding for the UTF-16 format using the little endian byte order.</span></span></summary>
        <value><span data-ttu-id="5e6a0-1703">Кодировка для формата UTF-16 с прямым порядком байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1703">An encoding for the UTF-16 format using the little endian byte order.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1704">Сведения о кодировках, поддерживаемых .NET, и о том, какую кодировку Юникод использовать, см. [в разделе кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1704">For information about the encodings supported by the .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
 <span data-ttu-id="5e6a0-1705">Объект <xref:System.Text.UnicodeEncoding>, возвращаемый этим свойством, может не иметь соответствующего поведения для приложения.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1705">The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="5e6a0-1706">Он использует резервный вариант замены, чтобы заменить каждую строку, которую не удается закодировать, и каждый байт, который не может быть декодирован символом вопросительного знака ("?").</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1706">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="5e6a0-1707">Вместо этого можно вызвать конструктор <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> для создания экземпляра с прямым порядком байтов <xref:System.Text.UnicodeEncoding>, резервом которого является <xref:System.Text.EncoderFallbackException> или <xref:System.Text.DecoderFallbackException>, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1707">Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a little endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1708">В следующем примере определяется число байтов, необходимое для кодирования массива символов, символы кодируются и выводятся полученные байты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1708">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="5e6a0-1709">Общие сведения о кодировках</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1709">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1710">Получает кодировку для формата UTF-32 с прямым порядком байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1710">Gets an encoding for the UTF-32 format using the little endian byte order.</span></span></summary>
        <value><span data-ttu-id="5e6a0-1711">Объект кодировки для формата UTF-32 с прямым порядком байтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1711">An  encoding object for the UTF-32 format using the little endian byte order.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1712">Объект <xref:System.Text.UTF32Encoding>, возвращаемый этим свойством, может не иметь соответствующего поведения для приложения.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1712">The <xref:System.Text.UTF32Encoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="5e6a0-1713">Он использует резервный вариант замены, чтобы заменить каждую строку, которую не удается закодировать, и каждый байт, который не может быть декодирован СИМВОЛом замены Юникода (U + ФФФЕ).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1713">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with the Unicode REPLACEMENT CHARACTER (U+FFFE).</span></span> <span data-ttu-id="5e6a0-1714">Вместо этого можно вызвать конструктор <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>, чтобы создать экземпляр <xref:System.Text.UTF32Encoding>, резервный объект которого является либо <xref:System.Text.EncoderFallbackException>, либо <xref:System.Text.DecoderFallbackException>, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1714">Instead, you can call the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.UTF32Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 <span data-ttu-id="5e6a0-1715">Обсуждение с прямым порядком байтов см. в разделе <xref:System.Text.Encoding> Class.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1715">For a discussion of little endian byte order, see the <xref:System.Text.Encoding> class topic.</span></span>  
  
 <span data-ttu-id="5e6a0-1716">Сведения о кодировках, поддерживаемых .NET, и о том, какую кодировку Юникод использовать, см. [в разделе кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1716">For information about the encodings supported by .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1717">В следующем примере определяется число байтов, необходимое для кодирования массива символов, символы кодируются и выводятся полученные байты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1717">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="5e6a0-1718">Общие сведения о кодировках</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1718">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1719">Получает кодировку для формата UTF-7.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1719">Gets an encoding for the UTF-7 format.</span></span></summary>
        <value><span data-ttu-id="5e6a0-1720">Кодировка для формата UTF-7.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1720">An encoding for the UTF-7 format.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1721">Кодировка UTF-7 используется главным образом в средах, где исторически были ограничены 7 битами, например NNTP и некоторые приложения электронной почты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1721">UTF-7 encoding is used primarily in environments that historically have been restricted to 7 bits, such as NNTP and some email applications.</span></span> <span data-ttu-id="5e6a0-1722">Из-за проблем с надежностью и безопасностью не следует использовать кодирование UTF7 в 8-разрядных средах, где вместо этого можно использовать кодировку UTF-8.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1722">Because of issues with robustness and security, you should not use UTF7 encoding in 8-bit environments where UTF-8 encoding can be used instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1723">В следующем примере определяется число байтов, необходимое для кодирования массива символов, символы кодируются и выводятся полученные байты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1723">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="5e6a0-1724">Общие сведения о кодировках</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1724">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1725">Получает кодировку для формата UTF-8.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1725">Gets an encoding for the UTF-8 format.</span></span></summary>
        <value><span data-ttu-id="5e6a0-1726">Кодировка для формата UTF-8.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1726">An encoding for the UTF-8 format.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1727">Это свойство возвращает объект <xref:System.Text.UTF8Encoding>, который кодирует символы в Юникоде (UTF-16) в последовательность от одного до четырех байтов на символ и декодирует массив байтов в кодировке UTF-8 в символы Юникода (UTF-16-Encoded).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1727">This property returns a <xref:System.Text.UTF8Encoding> object that encodes Unicode (UTF-16-encoded) characters into a sequence of one to four bytes per character, and that decodes a UTF-8-encoded byte array to Unicode (UTF-16-encoded) characters.</span></span> <span data-ttu-id="5e6a0-1728">Сведения о кодировках символов, поддерживаемых .NET, и обсуждении используемой кодировки Юникод см. в разделе [Кодировка символов в .NET](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1728">For information about the character encodings supported by .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
 <span data-ttu-id="5e6a0-1729">Объект <xref:System.Text.UTF8Encoding>, возвращаемый этим свойством, может не иметь соответствующего поведения для приложения.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1729">The <xref:System.Text.UTF8Encoding> object that is returned by this property might not have the appropriate behavior for your app.</span></span>  
  
-   <span data-ttu-id="5e6a0-1730">Он возвращает объект <xref:System.Text.UTF8Encoding>, предоставляющий метку порядка байтов Юникода (BOM).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1730">It returns a <xref:System.Text.UTF8Encoding> object that provides a Unicode byte order mark (BOM).</span></span> <span data-ttu-id="5e6a0-1731">Чтобы создать экземпляр кодировки UTF8, которая не предоставляет СПЕЦИФИКАЦИю, вызовите любую перегрузку конструктора <xref:System.Text.UTF8Encoding.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1731">To instantiate a UTF8 encoding that doesn't provide a BOM, call any overload of the <xref:System.Text.UTF8Encoding.%23ctor%2A> constructor.</span></span>  
  
-   <span data-ttu-id="5e6a0-1732">Он возвращает объект <xref:System.Text.UTF8Encoding>, который использует замену замены, чтобы заменить каждую строку, которая не может быть закодирована, и каждый байт, который не удается декодировать с вопросительным знаком ("?").</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1732">It returns a <xref:System.Text.UTF8Encoding> object that uses replacement fallback to replace each string that it can't encode and each byte that it can't decode with a question mark ("?") character.</span></span> <span data-ttu-id="5e6a0-1733">Вместо этого можно вызвать конструктор <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>, чтобы создать экземпляр <xref:System.Text.UTF8Encoding>, резервный объект которого является либо <xref:System.Text.EncoderFallbackException>, либо <xref:System.Text.DecoderFallbackException>, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1733">Instead, you can call the <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.UTF8Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1734">В следующем примере определяется массив, состоящий из следующих символов:</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1734">The following example defines an array that consists of the following characters:</span></span>  
  
-   <span data-ttu-id="5e6a0-1735">ЛАТИНСКАЯ СТРОЧНАЯ БУКВА Z (U + 007A)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1735">LATIN SMALL LETTER Z (U+007A)</span></span>  
  
-   <span data-ttu-id="5e6a0-1736">ЛАТИНСКАЯ СТРОЧНАЯ БУКВА A (U + 0061)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1736">LATIN SMALL LETTER A (U+0061)</span></span>  
  
-   <span data-ttu-id="5e6a0-1737">ОБЪЕДИНЕНИЕ БРЕВЕ; (U + 0306)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1737">COMBINING BREVE (U+0306)</span></span>  
  
-   <span data-ttu-id="5e6a0-1738">ЛАТИНСКАЯ МАЛЕНЬКАЯ БУКВА AE С АКУТОМ (U + 01FD)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1738">LATIN SMALL LETTER AE WITH ACUTE (U+01FD)</span></span>  
  
-   <span data-ttu-id="5e6a0-1739">ГРЕЧЕСКАЯ СТРОЧНАЯ БУКВА BETA (U + 03B2)</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1739">GREEK SMALL LETTER BETA (U+03B2)</span></span>  
  
-   <span data-ttu-id="5e6a0-1740">Суррогатная пара (U + D800 U + DD54), которая Forms ГРЕЧЕСКая АКРОФОНИК ЧЕРДАКЕ 1000 STATs (U + 10154).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1740">A surrogate pair (U+D800 U+DD54) that forms GREEK ACROPHONIC ATTIC ONE THOUSAND STATERS (U+10154).</span></span>  
  
 <span data-ttu-id="5e6a0-1741">Он отображает единицы кода в кодировке UTF-16 каждого символа и определяет число байтов, необходимое кодировщику UTF-8 для кодирования массива символов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1741">It displays the UTF-16 code units of each character and determines the number of bytes required by a UTF-8 encoder to encode the character array.</span></span> <span data-ttu-id="5e6a0-1742">Затем он кодирует символы и отображает результирующие байты в кодировке UTF-8.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1742">It then encodes the characters and displays the resulting UTF-8-encoded bytes.</span></span>  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="5e6a0-1743">Общие сведения о кодировках</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1743">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1744">При переопределении в производном классе получает для текущей кодировки имя, зарегистрированное в IANA (Internet Assigned Numbers Authority).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1744">When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.</span></span></summary>
        <value><span data-ttu-id="5e6a0-1745">Имя IANA для текущего объекта <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1745">The IANA name for the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1746">Свойство <xref:System.Text.Encoding.WebName%2A> совпадает со свойством <xref:System.Text.EncodingInfo.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1746">The <xref:System.Text.Encoding.WebName%2A> property is the same as the <xref:System.Text.EncodingInfo.Name%2A> property.</span></span>  
  
 <span data-ttu-id="5e6a0-1747">Обратите внимание, что <xref:System.Text.Encoding.WebName%2A> Возвращает зарегистрированное IANA имя для кодировки.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1747">Note that <xref:System.Text.Encoding.WebName%2A> returns an IANA-registered name for the encoding.</span></span> <span data-ttu-id="5e6a0-1748">Если его значение является именем стандартного, реализация кодировки может не соответствовать этому стандарту.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1748">When its value is the name of a standard, the implementation of the encoding might not conform in full to that standard.</span></span> <span data-ttu-id="5e6a0-1749">Свойство <xref:System.Text.Encoding.HeaderName%2A> определяет другую кодировку, которая может лучше работать для заголовков электронной почты.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1749">The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for email headers.</span></span> <span data-ttu-id="5e6a0-1750">Однако в большинстве приложений вместо них следует использовать <xref:System.Text.Encoding.WebName%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1750">However, most apps should use <xref:System.Text.Encoding.WebName%2A> instead.</span></span>  
  
 <span data-ttu-id="5e6a0-1751">Дополнительные сведения о IANA см. по адресу [www.IANA.org](https://www.iana.org/).</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1751">For more information on the IANA, go to [www.iana.org](https://www.iana.org/).</span></span>  
  
 <span data-ttu-id="5e6a0-1752"><xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> совпадает с <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>, возвращаемым <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1752">The <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> is the same as the <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> returned by <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5e6a0-1753">Некоторые веб-имена являются повторяющимися; Дополнительные сведения см. в примечаниях по <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1753">Some of the web names are duplicates; see the remarks for <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> for more information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1754">Следующий пример включает <xref:System.Text.Encoding.WebName%2A> в заголовок HTML.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1754">The following example includes the <xref:System.Text.Encoding.WebName%2A> in an HTML header.</span></span>  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 <span data-ttu-id="5e6a0-1755">В следующем примере извлекаются разные имена для каждой кодировки и отображаются кодировки с одним или несколькими именами, отличными от <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1755">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5e6a0-1756">Он отображает <xref:System.Text.Encoding.EncodingName%2A> но не выполняет сравнение с ним.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1756">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5e6a0-1757">При переопределении в производном классе получает кодовую страницу операционной системы Windows, наиболее точно соответствующую текущей кодировке.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1757">When overridden in a derived class, gets the Windows operating system code page that most closely corresponds to the current encoding.</span></span></summary>
        <value><span data-ttu-id="5e6a0-1758">Кодовая страница операционной системы Windows, наиболее точно соответствующая текущему объекту <see cref="T:System.Text.Encoding" />.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1758">The Windows operating system code page that most closely corresponds to the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5e6a0-1759">Это свойство предназначено для совместимости с API-интерфейсами Windows для различных языков (MLang), например при определении семейств шрифтов.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1759">This property is provided for compatibility with the Windows MultiLanguage (MLang) APIs, for example, in determining font families.</span></span> <span data-ttu-id="5e6a0-1760">Для глобализации вместо этого рекомендуется использовать одну из кодировок Юникода.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1760">For globalization, using one of the Unicode encodings is recommended instead.</span></span> <span data-ttu-id="5e6a0-1761">Для поиска кодовой страницы рекомендуется использовать <xref:System.Text.Encoding.WebName%2A> вместо <xref:System.Text.Encoding.WindowsCodePage%2A>.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1761">It is also recommended to use <xref:System.Text.Encoding.WebName%2A> instead of <xref:System.Text.Encoding.WindowsCodePage%2A> to identify the code page.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5e6a0-1762">В следующем примере определяется кодовая страница Windows, наиболее близко соответствующая каждой кодировке.</span><span class="sxs-lookup"><span data-stu-id="5e6a0-1762">The following example determines the Windows code page that most closely corresponds to each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>
