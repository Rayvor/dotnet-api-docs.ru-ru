<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="458924ee3c8e8f237831ce53cd05124a98e8ee2d" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73381036" /></Metadata><TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет изменяемую строку символов. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс представляет объект, подобный строке, значение которого является изменяемой последовательностью символов.  
  
 Содержание  
  
-   [Типы String и StringBuilder](#StringAndSB)  
  
-   [Принцип работы StringBuilder](#HowWorks)  
  
-   [Выделение памяти](#Memory)  
  
-   [Создание экземпляра объекта StringBuilder](#Instantiating)  
  
-   [Вызов методов StringBuilder](#Calling)  
  
-   [Выполнение операций StringBuilder](#Operations)  
  
    -   [Итерация символов StringBuilder](#Iterating)  
  
    -   [Добавление текста в объект StringBuilder](#Adding)  
  
    -   [Удаление текста из объекта StringBuilder](#Deleting)  
  
    -   [Изменение текста в объекте StringBuilder](#Modifying)  
  
-   [Поиск текста в объекте StringBuilder](#Searching)  
  
-   [Преобразование объекта StringBuilder в строку](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>Типы String и StringBuilder  
 Хотя <xref:System.Text.StringBuilder> и <xref:System.String> оба представляют последовательности символов, они реализуются по-разному. <xref:System.String> является неизменяемым типом. То есть каждая операция, которая может изменить объект <xref:System.String>, фактически создает новую строку.  
  
 Например, вызов метода <xref:System.String.Concat%2A?displayProperty=nameWithType> в следующем примере приводит C# к изменению значения строковой переменной с именем `value`. Фактически, метод <xref:System.String.Concat%2A> возвращает объект `value` с другим значением и адресом из объекта `value`, который был передан в метод. Обратите внимание, что пример необходимо скомпилировать с помощью параметра компилятора `/unsafe`.  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 Для подпрограмм, выполняющих обширную обработку строк (например, приложения, которые изменяют строку несколько раз в цикле), многократное изменение строки может привести к значительному снижению производительности. Альтернативой является использование <xref:System.Text.StringBuilder>, который является изменяемым строковым классом. Изменяемость означает, что после создания экземпляра класса его можно изменить путем добавления, удаления, замены или вставки символов. Объект <xref:System.Text.StringBuilder> поддерживает буфер для расширения строки. При наличии свободного места новые данные добавляются в буфер. в противном случае выделяется новый буфер большего размера, данные из исходного буфера копируются в новый буфер, а новые данные добавляются в новый буфер.  
  
> [!IMPORTANT]
>  Хотя класс <xref:System.Text.StringBuilder>, как правило, обеспечивает лучшую производительность, чем класс <xref:System.String>, не следует автоматически заменять <xref:System.String> на <xref:System.Text.StringBuilder>, когда требуется управлять строками. Производительность зависит от размера строки, объема памяти, выделяемого для новой строки, системы, в которой выполняется приложение, и типа операции. Необходимо подготовиться к тестированию приложения, чтобы определить, действительно ли <xref:System.Text.StringBuilder> на самом деле обеспечивает значительное повышение производительности.  
  
 Рассмотрите возможность использования класса <xref:System.String> в следующих условиях:  
  
-   Когда число изменений, которое приложение будет вносить в строку, невелико. В таких случаях <xref:System.Text.StringBuilder> может предложить незначительное повышение производительности по сравнению с <xref:System.String>.  
  
-   При выполнении фиксированного числа операций объединения, особенно с строковыми литералами. В этом случае компилятор может объединить операции объединения в одну операцию.  
  
-   Если при построении строки необходимо выполнять широкие операции поиска. Класс <xref:System.Text.StringBuilder> не имеет методов поиска, таких как `IndexOf` или `StartsWith`. Необходимо преобразовать объект <xref:System.Text.StringBuilder> в <xref:System.String> для этих операций. это может отрицательно повлиять на производительность при использовании <xref:System.Text.StringBuilder>. Дополнительные сведения см. в разделе [Поиск текста в объекте StringBuilder](#Searching) .  
  
 Рассмотрите возможность использования класса <xref:System.Text.StringBuilder> в следующих условиях:  
  
-   Если вы ожидаете, что приложение будет вносить неизвестное количество изменений в строку во время разработки (например, при использовании цикла для сцепления случайного числа строк, содержащего введенные пользователем данные).  
  
-   Если предполагается, что приложение вносит значительное количество изменений в строку.  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>Принцип работы StringBuilder  
 Свойство <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> указывает количество символов, которое в данный момент содержит объект <xref:System.Text.StringBuilder>. При добавлении символов в объект <xref:System.Text.StringBuilder> его длина увеличивается до тех пор, пока не будет равен размеру свойства <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType>, определяющего количество символов, которое может содержать объект. Если количество добавленных символов приводит к тому, что длина объекта <xref:System.Text.StringBuilder> превышает текущую емкость, выделяется новая память, значение свойства <xref:System.Text.StringBuilder.Capacity%2A> удваивается, в объект <xref:System.Text.StringBuilder> добавляются новые символы, а свойство <xref:System.Text.StringBuilder.Length%2A> — настройки. Дополнительная память для объекта <xref:System.Text.StringBuilder> выделяется динамически до тех пор, пока не достигнет значения, определенного свойством <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType>. По достижении максимальной емкости не удается выделить память для объекта <xref:System.Text.StringBuilder>, и при попытке добавить символы или расширить его после максимальной емкости выдается исключение <xref:System.ArgumentOutOfRangeException> или <xref:System.OutOfMemoryException>.  
  
 В следующем примере показано, как объект <xref:System.Text.StringBuilder> выделяет новую память и увеличивает ее емкость динамически по мере расширения строки, назначенной объекту. Код создает объект <xref:System.Text.StringBuilder>, вызывая конструктор по умолчанию (без параметров). Емкость этого объекта по умолчанию составляет 16 символов, а ее максимальная емкость превышает 2 000 000 000 символов. Добавление строки «это предложение». приводит к новому выделению памяти, так как длина строки (19 символов) превышает емкость объекта <xref:System.Text.StringBuilder> по умолчанию. Емкость объекта удваивается до 32 символов, добавляется новая строка, а длина объекта теперь равна 19 символам. Затем код добавляет строку «это дополнительное предложение». в значение объекта <xref:System.Text.StringBuilder> 11 раз. Когда операция добавления приводит к превышению емкости объекта <xref:System.Text.StringBuilder>, его существующая емкость удваивается и операция <xref:System.Text.StringBuilder.Append%2A> завершается с ошибкой.  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>Выделение памяти  
 Емкость по умолчанию для объекта <xref:System.Text.StringBuilder> составляет 16 символов, а максимальная емкость по умолчанию — <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Эти значения по умолчанию используются при вызове конструкторов <xref:System.Text.StringBuilder.%23ctor> и <xref:System.Text.StringBuilder.%23ctor%28System.String%29>.  
  
 Можно явно определить начальную емкость объекта <xref:System.Text.StringBuilder> следующими способами.  
  
-   Путем вызова любого конструктора <xref:System.Text.StringBuilder>, который включает параметр `capacity` при создании объекта.  
  
-   Путем явного присвоения свойству <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> нового значения, чтобы расширить существующий объект <xref:System.Text.StringBuilder>. Обратите внимание, что свойство создает исключение, если новая емкость меньше, чем существующая емкость, или больше, чем максимальная емкость объекта <xref:System.Text.StringBuilder>.  
  
-   Путем вызова метода <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> с новой емкостью. Новая емкость не должна превышать максимальную емкость объекта <xref:System.Text.StringBuilder>. Однако, в отличие от присваивания свойству <xref:System.Text.StringBuilder.Capacity%2A>, <xref:System.Text.StringBuilder.EnsureCapacity%2A> не создает исключение, если нужная Новая емкость меньше, чем существующая емкость; в этом случае вызов метода не оказывает никакого влияния.  
  
 Если длина строки, назначенной объекту <xref:System.Text.StringBuilder> в вызове конструктора, превышает емкость по умолчанию или указанную емкость, свойству <xref:System.Text.StringBuilder.Capacity%2A> присваивается длина строки, заданной параметром `value`.  
  
 Можно явно определить максимальную емкость объекта <xref:System.Text.StringBuilder>, вызвав конструктор <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>. Вы не можете изменить максимальную емкость, назначив свойству <xref:System.Text.StringBuilder.MaxCapacity%2A> новое значение, так как оно доступно только для чтения.  
  
 Как показано в предыдущем разделе, когда существующая емкость недостаточна, выделяется дополнительная память, а емкость объекта <xref:System.Text.StringBuilder> удваивается до значения, определенного свойством <xref:System.Text.StringBuilder.MaxCapacity%2A>.  
  
 Как правило, емкость по умолчанию и максимальная емкость подходят для большинства приложений. Эти значения можно установить при следующих условиях.  
  
-   Если в конечном итоге размер объекта <xref:System.Text.StringBuilder>, скорее всего, увеличится слишком большим, обычно он превышает несколько мегабайт. В этом случае может возникнуть некоторый выигрыш в производительности от установки значения свойства Initial <xref:System.Text.StringBuilder.Capacity%2A> в значительном высоком значении, чтобы исключить необходимость в слишком большом количестве перераспределения памяти.  
  
-   Если приложение работает в системе с ограниченным объемом памяти. В этом случае, возможно, стоит рассмотреть возможность установки свойства <xref:System.Text.StringBuilder.MaxCapacity%2A> в значение меньше <xref:System.Int32.MaxValue?displayProperty=nameWithType>, если приложение обрабатывает большие строки, которые могут привести к его выполнению в среде с ограниченным объемом памяти.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>Создание экземпляра объекта StringBuilder  
 Вы создаете объект <xref:System.Text.StringBuilder>, вызывая один из шести перегруженных конструкторов классов, которые перечислены в следующей таблице. Три конструктора создают экземпляр объекта <xref:System.Text.StringBuilder>, значением которого является пустая строка, но устанавливайте значения <xref:System.Text.StringBuilder.Capacity%2A> и <xref:System.Text.StringBuilder.MaxCapacity%2A> по-разному. Остальные три конструктора определяют объект <xref:System.Text.StringBuilder> с определенным строковым значением и емкостью. Два из трех конструкторов используют максимальную емкость <xref:System.Int32.MaxValue?displayProperty=nameWithType>по умолчанию, а третья позволяет задать максимальную емкость.  
  
|Конструктор|Строковое значение|Емкость|Максимальная емкость|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Определяется параметром `capacity`|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Определяется параметром `capacity`|Определяется параметром `maxCapacity`|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|Определяется параметром `value`|16 или `value`. <xref:System.String.Length%2A>, в зависимости от того, какое значение больше|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|Определяется параметром `value`|Определяется параметром `capacity` или `value`. <xref:System.String.Length%2A>, в зависимости от того, какое значение больше.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|Определяется в `value`. <xref:System.String.Substring%2A>(`startIndex`, `length`)|Определяется параметром `capacity` или `value`. <xref:System.String.Length%2A>, в зависимости от того, какое значение больше.|Определяется параметром `maxCapacity`|  
  
 В следующем примере используются три из этих перегрузок конструктора для создания экземпляров объектов <xref:System.Text.StringBuilder>.  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>Вызов методов StringBuilder  
 Большинство методов, которые изменяют строку в экземпляре <xref:System.Text.StringBuilder>, возвращают ссылку на этот же экземпляр. Это позволяет вызывать методы <xref:System.Text.StringBuilder> двумя способами:  
  
-   Можно выполнить отдельные вызовы метода и игнорировать возвращаемое значение, как показано в следующем примере.  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   В одной инструкции можно создать ряд вызовов методов. Это может быть удобно, если вы хотите написать одну инструкцию, которая повязывает последовательные операции. В следующем примере три вызова метода из предыдущего примера консолидируются в одну строку кода.  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>Выполнение операций StringBuilder  
 Методы класса <xref:System.Text.StringBuilder> можно использовать для итерации, добавления, удаления или изменения символов в объекте <xref:System.Text.StringBuilder>.  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>Итерация символов StringBuilder  
 Доступ к символам в <xref:System.Text.StringBuilder>ном объекте можно получить с помощью свойства <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>. В C#<xref:System.Text.StringBuilder.Chars%2A> является индексатором; в Visual Basic это свойство класса <xref:System.Text.StringBuilder> по умолчанию. Это позволяет задавать или извлекать отдельные символы, используя только индекс, без явной ссылки на свойство <xref:System.Text.StringBuilder.Chars%2A>. Символы в <xref:System.Text.StringBuilder>ном объекте начинаются с индекса 0 (ноль) и продолжают индексироваться <xref:System.Text.StringBuilder.Length%2A>-1.  
  
 В следующем примере показано свойство <xref:System.Text.StringBuilder.Chars%2A>. Он добавляет десять случайных чисел к объекту <xref:System.Text.StringBuilder>, а затем выполняет итерацию каждого символа. Если категория символа в Юникоде имеет <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, то число уменьшается на 1 (или, если значение равно 0). В примере отображается содержимое объекта <xref:System.Text.StringBuilder> как до, так и после изменения значений отдельных символов.  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>Добавление текста в объект StringBuilder  
 Класс <xref:System.Text.StringBuilder> включает следующие методы для расширения содержимого объекта <xref:System.Text.StringBuilder>.  
  
-   Метод <xref:System.Text.StringBuilder.Append%2A> добавляет строку, подстроку, массив символов, часть массива символов, один символ повторяется несколько раз или строковое представление примитивного типа данных в объект <xref:System.Text.StringBuilder>.  
  
-   Метод <xref:System.Text.StringBuilder.AppendLine%2A> добавляет признак конца строки или строку вместе с признаком конца строки к объекту <xref:System.Text.StringBuilder>.  
  
-   Метод <xref:System.Text.StringBuilder.AppendFormat%2A> добавляет [строку составного формата](~/docs/standard/base-types/composite-formatting.md) к объекту <xref:System.Text.StringBuilder>. Строковые представления объектов, входящих в результирующую строку, могут отражать соглашения о форматировании текущего языка и региональных параметров системы или указанного языка и региональных параметров.  
  
-   Метод <xref:System.Text.StringBuilder.Insert%2A> вставляет строку, подстроку, несколько повторений строки, массив символов, часть массива символов или строковое представление примитивного типа данных в указанной позиции в объекте <xref:System.Text.StringBuilder>. Позиция определяется индексом, начинающимся с нуля.  
  
 В следующем примере используются методы <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и <xref:System.Text.StringBuilder.Insert%2A> для расширения текста объекта <xref:System.Text.StringBuilder>.  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>Удаление текста из объекта StringBuilder  
 Класс <xref:System.Text.StringBuilder> содержит методы, которые могут уменьшить размер текущего экземпляра <xref:System.Text.StringBuilder>. Метод <xref:System.Text.StringBuilder.Clear%2A> удаляет все символы и устанавливает для свойства <xref:System.Text.StringBuilder.Length%2A> значение 0. Метод <xref:System.Text.StringBuilder.Remove%2A> удаляет указанное число символов, начиная с определенной позиции индекса. Кроме того, можно удалить символы из конца объекта <xref:System.Text.StringBuilder>, задав свойству <xref:System.Text.StringBuilder.Length%2A> значение, которое меньше, чем длина текущего экземпляра.  
  
 В следующем примере удаляется часть текста из объекта <xref:System.Text.StringBuilder>, выводится его результирующая емкость, максимальная емкость и значения свойств длины, а затем вызывается метод <xref:System.Text.StringBuilder.Clear%2A> для удаления всех символов из объекта <xref:System.Text.StringBuilder>.  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>Изменение текста в объекте StringBuilder  
 Метод <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> заменяет все вхождения символа или строки во всем объекте <xref:System.Text.StringBuilder> или в определенном диапазоне символов. В следующем примере используется метод <xref:System.Text.StringBuilder.Replace%2A> для замены всех восклицательных знаков (!) на вопросительные знаки (?) в объекте <xref:System.Text.StringBuilder>.  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>Поиск текста в объекте StringBuilder  
 Класс <xref:System.Text.StringBuilder> не включает методы, аналогичные методам <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>и <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, предоставляемым классом <xref:System.String>, которые позволяют искать в объекте определенный символ или подстроку. Чтобы определить присутствие или начальную точку символа подстроки, необходимо выполнить поиск <xref:System.String> значения с помощью метода поиска строки или метода регулярного выражения. Существует четыре способа реализации таких поисков, как показано в следующей таблице.  
  
|Процедура|ИТ специалистов|Недостатки|  
|---------------|----------|----------|  
|Поиск значений строки перед их добавлением в объект <xref:System.Text.StringBuilder>.|Полезно для определения того, существует ли подстрока.|Не может использоваться, если позиция подстроки индекса важна.|  
|Вызовите <xref:System.Text.StringBuilder.ToString%2A> и найдите возвращаемый объект <xref:System.String>.|Простая в использовании, если вы назначаете весь текст объекту <xref:System.Text.StringBuilder>, а затем приступите к его изменению.|Громоздкий способ повторного вызова <xref:System.Text.StringBuilder.ToString%2A>, если необходимо внести изменения до того, как весь текст будет добавлен в объект <xref:System.Text.StringBuilder>.<br /><br /> При внесении изменений следует приступать к работе с конца текста объекта <xref:System.Text.StringBuilder>.|  
|Используйте свойство <xref:System.Text.StringBuilder.Chars%2A> для последовательного поиска диапазона символов.|Полезно, если вы работаете с отдельными символами или небольшой подстрокой.|Громоздкий, если количество символов для поиска велико или если логика поиска сложна.<br /><br />Приводит к очень низкой производительности для объектов, которые увеличились очень крупнее с помощью повторяющихся вызовов методов.  |  
|Преобразуйте объект <xref:System.Text.StringBuilder> в объект <xref:System.String> и выполните изменения в объекте <xref:System.String>.|Полезно, если число изменений невелико.|Инвертирует преимущество производительности класса <xref:System.Text.StringBuilder>, если число изменений велико.|  
  
 Рассмотрим эти приемы более подробно.  
  
-   Если целью поиска является определение того, существует ли конкретная подстрока (то есть если вы не заинтересованы в положении подстроки), можно искать строки перед их сохранением в объекте <xref:System.Text.StringBuilder>. В следующем примере показана одна возможная реализация. Он определяет класс `StringBuilderFinder`, конструктор которого передает ссылку на <xref:System.Text.StringBuilder> объект и подстроку для поиска в строке. В этом случае в примере предпринимается попытка определить, находится ли записанная температура в градусах Фаренгейта или Цельсия, и добавляет соответствующий вводный текст в начало объекта <xref:System.Text.StringBuilder>. Генератор случайных чисел используется для выбора массива, содержащего данные в градусах Цельсия или градусах Фаренгейта.  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   Вызовите метод <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>, чтобы преобразовать объект <xref:System.Text.StringBuilder> в объект <xref:System.String>. Можно выполнять поиск в строке с помощью таких методов, как <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> или <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, либо использовать регулярные выражения и класс <xref:System.Text.RegularExpressions.Regex> для поиска шаблонов. Поскольку как <xref:System.Text.StringBuilder>, так и <xref:System.String> объекты используют кодировку UTF-16 для хранения символов, позиции индекса, подстроки и совпадения регулярных выражений одинаковы в обоих объектах. Это позволяет использовать <xref:System.Text.StringBuilder> методы для внесения изменений в той же позиции, в которой этот текст находится в объекте <xref:System.String>.  
  
    > [!NOTE]
    >  При применении этого подхода следует работать с конца объекта <xref:System.Text.StringBuilder> до его начала, чтобы не нужно было повторно преобразовывать объект <xref:System.Text.StringBuilder> в строку.  
  
     Этот подход показан в приведенном ниже примере. Он сохраняет четыре вхождения каждой буквы английского алфавита в объект <xref:System.Text.StringBuilder>. Затем он преобразует текст в объект <xref:System.String> и использует регулярное выражение для обнаружения начальной позиции каждой последовательности из четырех символов. Наконец, он добавляет символ подчеркивания перед каждой последовательностью из четырех символов, за исключением первой последовательности, и преобразует первый символ последовательности в верхний регистр.  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   Используйте свойство <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> для последовательного поиска диапазона символов в объекте <xref:System.Text.StringBuilder>. Этот подход может оказаться нецелесообразным, если количество символов для поиска является большим или логика поиска особенно сложна. Сведения о влиянии на производительность при доступе к символьному индексу для очень больших, фрагментированных <xref:System.Text.StringBuilder> объектов см. в документации по свойству <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>. 
  
     Следующий пример аналогичен функции предыдущего примера, но отличается в реализации. Он использует свойство <xref:System.Text.StringBuilder.Chars%2A> для обнаружения изменения значения символа, вставляет символ подчеркивания в эту точку и преобразует первый символ в новой последовательности в верхний регистр.  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   Сохраните весь неизмененный текст в объекте <xref:System.Text.StringBuilder>, вызовите метод <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>, чтобы преобразовать объект <xref:System.Text.StringBuilder> в объект <xref:System.String> и выполнить изменения в объекте <xref:System.String>. Этот подход можно использовать, если имеется всего несколько изменений. в противном случае стоимость работы с неизменяемыми строками может отрицательно отменять производительность при использовании объекта <xref:System.Text.StringBuilder>.  
  
     Следующий пример аналогичен функциям предыдущих двух примеров, но отличается в реализации. Он создает объект <xref:System.Text.StringBuilder>, преобразует его в <xref:System.String> объект, а затем использует регулярное выражение для выполнения всех оставшихся изменений в строке. Метод <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> использует лямбда-выражение для замены каждого соответствия.  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>Преобразование объекта StringBuilder в строку  
 Необходимо преобразовать объект <xref:System.Text.StringBuilder> в <xref:System.String>, прежде чем передавать представленную объектом <xref:System.Text.StringBuilder> строку методу, который содержит параметр <xref:System.String>, или вывести ее в пользовательском интерфейсе. Это преобразование выполняется путем вызова метода <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>. Иллюстрации см. в предыдущем примере, который вызывает метод <xref:System.Text.StringBuilder.ToString%2A> для преобразования объекта <xref:System.Text.StringBuilder> в строку, чтобы ее можно было передать в метод регулярного выражения.  
  
   
  
## Examples  
 В следующем примере показано, как вызвать множество методов, определенных классом <xref:System.Text.StringBuilder>.  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строковое значение этого экземпляра задается равным <xref:System.String.Empty?displayProperty=nameWithType>, а для емкости устанавливается емкость по умолчанию, зависящая от реализации.  
  
   
  
## Examples  
 В следующем примере показано, как вызвать конструктор <xref:System.Text.StringBuilder.%23ctor%2A> без параметров.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Предлагаемый начальный размер этого экземпляра.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />, используя указанную емкость.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `capacity` определяет максимальное число символов, которые могут храниться в памяти, выделенной текущим экземпляром. Его значение присваивается свойству <xref:System.Text.StringBuilder.Capacity%2A>. Если число символов, сохраняемых в текущем экземпляре, превышает это значение `capacity`, объект <xref:System.Text.StringBuilder> выделяет дополнительную память для их хранения.  
  
 Строковое значение этого экземпляра равно <xref:System.String.Empty?displayProperty=nameWithType>. Если `capacity` равен нулю, используется емкость по умолчанию, зависящая от реализации.  
  
   
  
## Examples  
 В следующем примере показано, как вызвать конструктор <xref:System.Text.StringBuilder.%23ctor%2A> с заданной емкостью.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="capacity" /> меньше нуля.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Строка, используемая для инициализации значения экземпляра. Если <paramref name="value" /> равно <see langword="null" />, то новый <see cref="T:System.Text.StringBuilder" /> будет содержать пустую строку (то есть, он содержит <see cref="F:System.String.Empty" />).</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />, используя указанную строку.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `value` равно `null`, то новый <xref:System.Text.StringBuilder> будет содержать пустую строку (то есть, он содержит <xref:System.String.Empty>).  
  
   
  
## Examples  
 В следующем примере показано, как вызвать конструктор <xref:System.Text.StringBuilder.%23ctor%2A> с указанной строкой.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Предлагаемый начальный размер <see cref="T:System.Text.StringBuilder" />.</param>
        <param name="maxCapacity">Наибольшее допустимое количество знаков в текущей строке.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />, который начинается с указанной емкости и может увеличиваться до указанного максимального значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `capacity` определяет максимальное число символов, которые могут храниться в памяти, выделенной текущим экземпляром. Его значение присваивается свойству <xref:System.Text.StringBuilder.Capacity%2A>. Если число символов, сохраняемых в текущем экземпляре, превышает это значение `capacity`, объект <xref:System.Text.StringBuilder> выделяет дополнительную память для их хранения.  
  
 Если `capacity` равен нулю, используется емкость по умолчанию, зависящая от реализации.  
  
 Свойство `maxCapacity` определяет максимальное число символов, которое может храниться в текущем экземпляре. Его значение присваивается свойству <xref:System.Text.StringBuilder.MaxCapacity%2A>. Если число символов, сохраняемых в текущем экземпляре, превышает это значение `maxCapacity`, объект <xref:System.Text.StringBuilder> не выделяет дополнительную память, а вместо этого создает исключение.  
  
   
  
## Examples  
 В следующем примере показано, как вызвать конструктор <xref:System.Text.StringBuilder.%23ctor%2A> с заданной емкостью и максимальной емкостью.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxCapacity" /> меньше единицы, <paramref name="capacity" /> меньше нуля, или <paramref name="capacity" /> больше <paramref name="maxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Строка, используемая для инициализации значения экземпляра. Если <paramref name="value" /> равно <see langword="null" />, то новый <see cref="T:System.Text.StringBuilder" /> будет содержать пустую строку (то есть, он содержит <see cref="F:System.String.Empty" />).</param>
        <param name="capacity">Предлагаемый начальный размер <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" />, используя указанную строку и емкость.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `capacity` определяет максимальное число символов, которые могут храниться в памяти, выделенной текущим экземпляром. Его значение присваивается свойству <xref:System.Text.StringBuilder.Capacity%2A>. Если число символов, сохраняемых в текущем экземпляре, превышает это значение `capacity`, объект <xref:System.Text.StringBuilder> выделяет дополнительную память для их хранения.  
  
 Если `capacity` равен нулю, используется емкость по умолчанию, зависящая от реализации.  
  
   
  
## Examples  
 В следующем примере показано, как вызвать конструктор <xref:System.Text.StringBuilder.%23ctor%2A> с начальной строкой и заданной емкостью.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="capacity" /> меньше нуля.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Строка, содержащая подстроку, применяемую для инициализации значения этого экземпляра. Если <paramref name="value" /> равно <see langword="null" />, то новый <see cref="T:System.Text.StringBuilder" /> будет содержать пустую строку (то есть, он содержит <see cref="F:System.String.Empty" />).</param>
        <param name="startIndex">Позиция в пределах <paramref name="value" />, с которой начинается подстрока.</param>
        <param name="length">Число символов в подстроке.</param>
        <param name="capacity">Предлагаемый начальный размер <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Text.StringBuilder" /> из указанной подстроки и емкости.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `capacity` определяет максимальное число символов, которые могут храниться в памяти, выделенной текущим экземпляром. Его значение присваивается свойству <xref:System.Text.StringBuilder.Capacity%2A>. Если число символов, сохраняемых в текущем экземпляре, превышает это значение `capacity`, объект <xref:System.Text.StringBuilder> выделяет дополнительную память для их хранения.  
  
 Если `capacity` равен нулю, используется емкость по умолчанию, зависящая от реализации.  
  
   
  
## Examples  
 В следующем примере показано, как вызвать конструктор <xref:System.Text.StringBuilder.%23ctor%2A> с указанной строкой.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="capacity" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> плюс <paramref name="length" /> не является позицией в <paramref name="value" />.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет строковое представление указанного объекта к данному экземпляру.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое логическое значение.</param>
        <summary>Добавляет строковое представление указанного логического значения к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.StringBuilder.Append%28System.Boolean%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Метод <xref:System.Text.StringBuilder.Append%28System.Boolean%29> вызывает метод <xref:System.Boolean.ToString?displayProperty=nameWithType>, чтобы получить строковое представление `value`. Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 8-разрядного целого числа без знака к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.StringBuilder.Append%28System.Byte%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 Метод <xref:System.Text.StringBuilder.Append%28System.Byte%29> вызывает метод <xref:System.Byte.ToString%28System.IFormatProvider%29>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Единица кода в кодировке UTF-16 для добавления.</param>
        <summary>Добавляет строковое представление указанного объекта <see cref="T:System.Char" /> в данный экземпляр.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.StringBuilder.Append%28System.Char%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Массив символов для добавления.</param>
        <summary>Добавляет строковое представление символа Юникода в указанном массиве к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет все символы в указанном массиве к текущему экземпляру в том же порядке, в котором они отображаются в `value`. Если `value` `null`, изменения не вносятся.  
  
 Метод <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного десятичного числа к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.StringBuilder.Append%28System.Decimal%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 Метод <xref:System.Text.StringBuilder.Append%28System.Decimal%29> вызывает метод <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного числа с плавающей запятой с удвоенной точностью к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.StringBuilder.Append%28System.Double%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 Метод <xref:System.Text.StringBuilder.Append%28System.Double%29> вызывает метод <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 16-разрядного целого числа со знаком к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.StringBuilder.Append%28System.Int16%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 Метод <xref:System.Text.StringBuilder.Append%28System.Int16%29> вызывает метод <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 32-разрядного целого числа со знаком к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.StringBuilder.Append%28System.Int32%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 Метод <xref:System.Text.StringBuilder.Append%28System.Int32%29> вызывает метод <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 64-разрядного целого числа со знаком к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.StringBuilder.Append%28System.Int64%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 Метод <xref:System.Text.StringBuilder.Append%28System.Int64%29> вызывает <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемый объект.</param>
        <summary>Добавляет строковое представление указанного объекта к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.StringBuilder.Append%28System.Object%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере. Он определяет класс `Dog`, создает объект `Dog` и выполняет три вызова метода <xref:System.Text.StringBuilder.Append%2A>, чтобы создать строку, содержащую имя и породу Dog.  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 Метод <xref:System.Text.StringBuilder.Append%28System.Object%29> вызывает метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>, чтобы получить строковое представление `value`. Если `value` `null`, то в объект <xref:System.Text.StringBuilder> не вносятся изменения.  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlyMemory`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlyMemory(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlyMemory&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlyMemory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемая область памяти символов только для чтения.</param>
        <summary>Добавляет строковое представление указанной области памяти символов только для чтения к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемый диапазон символов только для чтения.</param>
        <summary>Добавляет строковое представление указанного диапазона символов только для чтения к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 8-разрядного целого числа со знаком к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.StringBuilder.Append%28System.SByte%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 Метод <xref:System.Text.StringBuilder.Append%28System.SByte%29> вызывает метод <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного числа с плавающей запятой с обычной точностью к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.StringBuilder.Append%28System.Single%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 Метод <xref:System.Text.StringBuilder.Append%28System.Single%29> вызывает метод <xref:System.Single.ToString%2A?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемая строка.</param>
        <summary>Добавляет копию указанной строки к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.StringBuilder.Append%28System.String%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Если `value` `null`, изменения не вносятся.  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Построитель строки для добавления.</param>
        <summary>Добавляет строковое представление указанного построителя строки к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 16-разрядного целого числа без знака к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.StringBuilder.Append%28System.UInt16%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 Метод <xref:System.Text.StringBuilder.Append%28System.UInt16%29> вызывает метод <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, чтобы получить строковое представление `value`. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 32-разрядного целого числа без знака к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.StringBuilder.Append%28System.UInt32%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> вызывает метод <xref:System.UInt32.ToString%2A?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемое значение.</param>
        <summary>Добавляет строковое представление указанного 64-разрядного целого числа без знака к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.StringBuilder.Append%28System.UInt64%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 Метод <xref:System.Text.StringBuilder.Append%28System.UInt64%29> вызывает метод <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемый символ.</param>
        <param name="repeatCount">Сколько раз следует добавить <paramref name="value" />.</param>
        <summary>Добавляет указанное число копий строкового представления символа Юникода к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="repeatCount" /> меньше нуля.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Указатель на массив символов.</param>
        <param name="valueCount">Количество символов в массиве.</param>
        <summary>Добавляет к данному экземпляру массив символов Юникода начиная с указанного адреса.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет `valueCount` символов, начиная с адреса `value` с текущим экземпляром.  
  
 Метод <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>.  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="valueCount" /> меньше нуля.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> является пустым указателем</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Массив символов.</param>
        <param name="startIndex">Начальная позиция в массиве <paramref name="value" />.</param>
        <param name="charCount">Количество добавляемых знаков.</param>
        <summary>Добавляет строковое представление указанного дочернего массива символов Юникода к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет указанный диапазон символов в `value` к текущему экземпляру. Если `value` имеет значение `null` а `startIndex` и `count` равны нулю, изменения не вносятся.  
  
 Метод <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> имеет значение <see langword="null" />, а <paramref name="startIndex" /> и <paramref name="charCount" /> не равны нулю.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="charCount" /> меньше нуля.  
  
-или- 
 Значение параметра <paramref name="startIndex" /> меньше нуля.  
  
-или- 
 Значение <paramref name="startIndex" /> + <paramref name="charCount" /> превышает длину <paramref name="value" />.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Строка, содержащая добавляемую подстроку.</param>
        <param name="startIndex">Начальная позиция подстроки в пределах <paramref name="value" />.</param>
        <param name="count">Число знаков в подстроке <paramref name="value" /> для добавления.</param>
        <summary>Добавляет копию указанной подстроки к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет указанный диапазон символов в `value` к текущему экземпляру. Если `value` имеет значение `null` а `startIndex` и `count` равны нулю, изменения не вносятся.  
  
 Метод <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> имеет значение <see langword="null" />, а <paramref name="startIndex" /> и <paramref name="count" /> не равны нулю.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> меньше нуля.  
  
-или- 
 Значение <paramref name="startIndex" /> + <paramref name="count" /> превышает длину <paramref name="value" />.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Построитель строки, содержащий добавляемую подстроку.</param>
        <param name="startIndex">Начальная позиция подстроки в пределах <paramref name="value" />.</param>
        <param name="count">Число знаков в подстроке <paramref name="value" /> для добавления.</param>
        <summary>Добавляет копию подстроки в пределах указанного построителя строки к данному экземпляру.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением соответствующего аргумента объекта.</summary>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением одного аргумента.</summary>
        <returns>Ссылка на данный экземпляр с добавленным <paramref name="format" />. Каждый элемент формата в параметре <paramref name="format" /> заменяется строковым представлением параметра <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в текущий объект <xref:System.Text.StringBuilder>.  
  
 Параметр `format` состоит из нуля или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами формата. Индекс элементов формата должен быть равен 0, чтобы соответствовать `arg0`, один объект в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования строковым представлением `arg0`.  
  
 Синтаксис элемента форматирования выглядит следующим образом:  
  
 {*index*[,*length*] [:*FormatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*номер*|Отсчитываемая от нуля координата в списке параметров объекта для форматирования. Если объект, указанный в *индексе* , имеет `null`, элемент форматирования заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если в позиции *индекса* нет параметра, выдается <xref:System.FormatException>.|  
|,*Длина*|Минимальное число символов в строковом представлении параметра. Если положительный, параметр размещается по правому краю; Если отрицательное, то оно по левому краю.|  
|:*FormatString*|Строка стандартного или пользовательского формата, поддерживаемая параметром.|  
  
> [!NOTE]
>  Для строк стандартного и пользовательского формата, используемых со значениями даты и времени, см. раздел [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Сведения о строках стандартных и пользовательских форматов, используемых с числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые с перечислениями, см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` представляет форматируемый объект. Каждый элемент формата в `format` заменяется строковым представлением `arg0`. Если элемент форматирования включает `formatString` и `arg0` реализует интерфейс <xref:System.IFormattable>, то `arg0.ToString(formatString, null)` определяет форматирование. В противном случае `arg0.ToString()` определяет форматирование.  
  
 Если строка, назначенная `format`, равна "Благодарим вас за ваше пожертвование {0: # # # #} за продукты в нашей благотворительной организации". а `arg0` — целое число со значением 10, возвращаемое значение будет "Благодарим вас за участие в 10 десятках продуктов нашей компании".  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.AppendFormat%2A>.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или не меньше 1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="args">Массив объектов для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением соответствующего аргумента в массиве параметров.</summary>
        <returns>Ссылка на данный экземпляр с добавленным <paramref name="format" />. Каждый элемент формата в параметре <paramref name="format" /> заменяется строковым представлением соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в текущий объект <xref:System.Text.StringBuilder>.  
  
 Параметр `format` состоит из нуля или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объектам в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования строковым представлением соответствующего объекта.  
  
 Синтаксис элемента форматирования выглядит следующим образом:  
  
 {*index*[,*length*] [:*FormatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*номер*|Отсчитываемая от нуля координата в списке параметров объекта для форматирования. Если объект, указанный в *индексе* , имеет `null`, элемент форматирования заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если в позиции *индекса* нет параметра, выдается <xref:System.FormatException>.|  
|,*Длина*|Минимальное число символов в строковом представлении параметра. Если положительный, параметр размещается по правому краю; Если отрицательное, то оно по левому краю.|  
|:*FormatString*|Строка стандартного или пользовательского формата, поддерживаемая параметром.|  
  
> [!NOTE]
>  Для строк стандартного и пользовательского формата, используемых со значениями даты и времени, см. раздел [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Сведения о строках стандартных и пользовательских форматов, используемых с числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые с перечислениями, см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `args` представляет объекты для форматирования. Каждый элемент формата в `format` заменяется строковым представлением соответствующего объекта в `args`. Если элемент форматирования включает `formatString` и соответствующий объект в `args` реализует интерфейс <xref:System.IFormattable>, `args[index].ToString(formatString, provider)` определяет форматирование. В противном случае `args[index].ToString()` определяет форматирование.  
  
 Если строка, назначенная `format`, равна "Благодарим вас за ваше пожертвование {0: # # # #} за продукты в нашей благотворительной организации". а `arg0` — целое число со значением 10, возвращаемое значение будет "Благодарим вас за участие в 10 десятках продуктов нашей компании".  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.AppendFormat%2A>.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="format" /> или <paramref name="args" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или больше либо равен длине массива <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением одного аргумента с использованием указанного поставщика формата.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления. После операции добавления этот экземпляр содержит все данные, существовавшие до операции, к которым добавляется копия параметра <paramref name="format" />, где все спецификации форматирования заменяются представлением <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения `arg0` в текстовое представление и внедрения этого представления в текущий объект <xref:System.Text.StringBuilder>.  
  
 Параметр `format` состоит из нуля или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами формата. Индекс каждого элемента формата должен быть равен нулю (0), так как этот метод включает список аргументов с одним аргументом. Процесс форматирования заменяет каждый элемент форматирования строковым представлением `arg0`.  
  
 Синтаксис элемента форматирования выглядит следующим образом:  
  
 {*index*[,*length*] [:*FormatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*номер*|Отсчитываемая от нуля координата в списке параметров объекта для форматирования. Если объект, указанный в *индексе* , имеет `null`, элемент форматирования заменяется <xref:System.String.Empty?displayProperty=nameWithType>. В этом случае, поскольку метод <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> содержит один аргумент в списке аргументов, значение *индекса* всегда должно быть равно 0. Если это не так, выдается <xref:System.FormatException>.|  
|,*Длина*|Минимальное число символов в строковом представлении параметра. Если положительный, параметр размещается по правому краю; Если отрицательное, то оно по левому краю.|  
|:*FormatString*|Строка стандартного или пользовательского формата, поддерживаемая параметром.|  
  
> [!NOTE]
>  Для строк стандартного и пользовательского формата, используемых со значениями даты и времени, см. раздел [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Сведения о строках стандартных и пользовательских форматов, используемых с числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые с перечислениями, см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Параметр `provider` указывает реализацию <xref:System.IFormatProvider>, которая может предоставлять сведения о форматировании для объектов в `args`. `provider` может быть одним из следующих:  
  
-   Объект <xref:System.Globalization.CultureInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами, для `arg0`, если это числовое значение.  
  
-   Объект <xref:System.Globalization.DateTimeFormatInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами, для `arg0`, если это значение даты и времени.  
  
-   Пользовательская реализация <xref:System.IFormatProvider>, которая предоставляет сведения о форматировании для `arg0`. Как правило, такая реализация также реализует интерфейс <xref:System.ICustomFormatter>.  
  
 Если параметр `provider` имеет значение `null`, сведения о форматировании получаются из текущего языка и региональных параметров.  
  
 `arg0` представляет форматируемый объект. Каждый элемент формата в `format` заменяется строковым представлением `arg0`. Если элемент форматирования включает `formatString` и `arg0` реализует интерфейс <xref:System.IFormattable>, то `arg0.ToString(formatString, provider)` определяет форматирование. В противном случае `arg0.ToString()` определяет форматирование.  
  
   
  
## Examples  
 Ниже приведены два вызова метода <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29>. Оба варианта используют соглашения о форматировании для языка и региональных параметров «Английский (EN-GB)». Первый Вставляет строковое представление валюты <xref:System.Decimal> значений в результирующую строку. Вторая вставляет <xref:System.DateTime> значение в двух местах в результирующей строке, первый включает только краткую строку даты и вторую короткую строку времени.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или больше либо равен единице.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Практическое руководство. Определение и использование настраиваемых поставщиков числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">Строка составного формата.</param>
        <param name="args">Массив объектов для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением соответствующего аргумента в массиве параметров с помощью указанного поставщика формата.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления. После операции добавления этот экземпляр содержит все данные, существовавшие до операции, к которым добавляется копия параметра <paramref name="format" />, где все спецификации форматирования заменяются представлением строки соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в текущий объект <xref:System.Text.StringBuilder>.  
  
 Параметр `format` состоит из нуля или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объектам в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования строковым представлением соответствующего объекта.  
  
 Синтаксис элемента форматирования выглядит следующим образом:  
  
 {*index*[,*length*] [:*FormatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*номер*|Отсчитываемая от нуля координата в списке параметров объекта для форматирования. Если объект, указанный в *индексе* , имеет `null`, элемент форматирования заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если в позиции *индекса* нет параметра, выдается <xref:System.FormatException>.|  
|,*Длина*|Минимальное число символов в строковом представлении параметра. Если положительный, параметр размещается по правому краю; Если отрицательное, то оно по левому краю.|  
|:*FormatString*|Строка стандартного или пользовательского формата, поддерживаемая параметром.|  
  
> [!NOTE]
>  Для строк стандартного и пользовательского формата, используемых со значениями даты и времени, см. раздел [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Сведения о строках стандартных и пользовательских форматов, используемых с числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые с перечислениями, см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Параметр `provider` указывает реализацию <xref:System.IFormatProvider>, которая может предоставлять сведения о форматировании для объектов в `args`. `provider` может быть одним из следующих:  
  
-   Объект <xref:System.Globalization.CultureInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo>, предоставляющий сведения об особенностях форматирования для числовых значений в `args`.  
  
-   Объект <xref:System.Globalization.DateTimeFormatInfo>, предоставляющий сведения об особенностях форматирования для значений даты и времени в `args`.  
  
-   Пользовательская реализация <xref:System.IFormatProvider>, которая предоставляет сведения о форматировании для одного или нескольких объектов в `args`. Как правило, такая реализация также реализует интерфейс <xref:System.ICustomFormatter>. Во втором примере в следующем разделе показан вызов метода <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> с реализацией пользовательского <xref:System.IFormatProvider>.  
  
 Если параметр `provider` имеет значение `null`, сведения о поставщике формата получаются из текущего языка и региональных параметров.  
  
 `args` представляет объекты для форматирования. Каждый элемент формата в `format` заменяется строковым представлением соответствующего объекта в `args`. Если элемент форматирования включает `formatString` и соответствующий объект в `args` реализует интерфейс <xref:System.IFormattable>, `args[index].ToString(formatString, provider)` определяет форматирование. В противном случае `args[index].ToString()` определяет форматирование.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.AppendFormat%2A>.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 В следующем примере определяется пользовательская реализация <xref:System.IFormatProvider> с именем `CustomerFormatter`, которая форматирует 10-значный номер клиента дефисами после четвертой и седьмой цифр. Он передается методу <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> для создания строки, содержащей отформатированный номер клиента и имя клиента.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или больше либо равен длине массива <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Практическое руководство. Определение и использование настраиваемых поставщиков числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением любого из двух аргументов.</summary>
        <returns>Ссылка на данный экземпляр с добавленным <paramref name="format" />. Каждый элемент формата в параметре <paramref name="format" /> заменяется строковым представлением соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в текущий объект <xref:System.Text.StringBuilder>.  
  
 Параметр `format` содержит ноль или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют `arg0` и `arg1`, два объекта в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования строковым представлением соответствующего объекта.  
  
 Синтаксис элемента форматирования выглядит следующим образом:  
  
 {*index*[,*length*] [:*FormatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*номер*|Отсчитываемая от нуля координата в списке параметров объекта для форматирования. Если объект, указанный в *индексе* , имеет `null`, элемент форматирования заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если в позиции *индекса* нет параметра, выдается <xref:System.FormatException>.|  
|,*Длина*|Минимальное число символов в строковом представлении параметра. Если положительный, параметр размещается по правому краю; Если отрицательное, то оно по левому краю.|  
|:*FormatString*|Строка стандартного или пользовательского формата, поддерживаемая параметром.|  
  
> [!NOTE]
>  Для строк стандартного и пользовательского формата, используемых со значениями даты и времени, см. раздел [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Сведения о строках стандартных и пользовательских форматов, используемых с числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые с перечислениями, см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` и `arg1` представляют объекты для форматирования. Каждый элемент формата в `format` заменяется строковым представлением `arg0` или `arg1`. Если элемент форматирования включает `formatString` и соответствующий объект реализует интерфейс <xref:System.IFormattable>, то `arg`*x*`.ToString(formatString, provider)` определяет форматирование, где *x* — индекс аргумента. В противном случае форматирование определяется `arg`*x*`.ToString()`.  
  
 Если строка, назначенная `format`, равна "Благодарим вас за ваше пожертвование {0: # # # #} за продукты в нашей благотворительной организации". а `arg0` — целое число со значением 10, возвращаемое значение будет "Благодарим вас за участие в 10 десятках продуктов нашей компании".  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.AppendFormat%2A>.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или больше либо равен двум.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением любого из двух аргументов с помощью указанного поставщика формата.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления. После операции добавления этот экземпляр содержит все данные, существовавшие до операции, к которым добавляется копия параметра <paramref name="format" />, где все спецификации форматирования заменяются представлением строки соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в текущий объект <xref:System.Text.StringBuilder>.  
  
 Параметр `format` состоит из нуля или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объектам в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования строковым представлением соответствующего объекта.  
  
 Синтаксис элемента форматирования выглядит следующим образом:  
  
 {*index*[,*length*] [:*FormatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*номер*|Отсчитываемая от нуля координата в списке параметров объекта для форматирования. Если объект, указанный в *индексе* , имеет `null`, элемент форматирования заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если в позиции *индекса* нет параметра, выдается <xref:System.FormatException>.|  
|,*Длина*|Минимальное число символов в строковом представлении параметра. Если положительный, параметр размещается по правому краю; Если отрицательное, то оно по левому краю.|  
|:*FormatString*|Строка стандартного или пользовательского формата, поддерживаемая параметром.|  
  
> [!NOTE]
>  Для строк стандартного и пользовательского формата, используемых со значениями даты и времени, см. раздел [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Сведения о строках стандартных и пользовательских форматов, используемых с числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые с перечислениями, см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Параметр `provider` указывает реализацию <xref:System.IFormatProvider>, которая может предоставить сведения о форматировании для `arg0` и `arg1`. `provider` может быть одним из следующих:  
  
-   Объект <xref:System.Globalization.CultureInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo>, предоставляющий сведения об особенностях форматирования для языка и региональных параметров для `arg0` или `arg1`, если они являются числовыми значениями.  
  
-   Объект <xref:System.Globalization.DateTimeFormatInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами, для `arg0` или `arg1`, если они являются значениями даты и времени.  
  
-   Пользовательская реализация <xref:System.IFormatProvider>, которая предоставляет сведения о форматировании для `arg0` и `arg1`. Как правило, такая реализация также реализует интерфейс <xref:System.ICustomFormatter>.  
  
 Если параметр `provider` имеет значение `null`, сведения о поставщике формата получаются из текущего языка и региональных параметров.  
  
 `arg0` и `arg1` представляют объекты для форматирования. Каждый элемент формата в `format` заменяется строковым представлением объекта с соответствующим индексом. Если элемент форматирования включает `formatString` и соответствующий аргумент реализует интерфейс <xref:System.IFormattable>, то форматирование определяется методом `ToString(formatString, provider)` аргумента. В противном случае форматирование определяет метод `ToString()` аргумента.  
  
   
  
## Examples  
 В следующем примере используется метод <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> для вывода данных о времени и температуре, хранящихся в универсальном <xref:System.Collections.Generic.Dictionary%602> объекте. Обратите внимание, что строка формата имеет три элемента форматирования, хотя есть только объекты для форматирования. Это происходит потому, что первый объект в списке (значение даты и времени) используется двумя элементами форматирования: в первом элементе форматирования отображается время, а во втором отображается дата.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или больше либо равен двум.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>ИИН .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра <see cref="T:System.Text.StringBuilder" /> с помощью вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Практическое руководство. Определение и использование настраиваемых поставщиков числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <param name="arg2">Третий объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением любого из трех аргументов.</summary>
        <returns>Ссылка на данный экземпляр с добавленным <paramref name="format" />. Каждый элемент формата в параметре <paramref name="format" /> заменяется строковым представлением соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в текущий объект <xref:System.Text.StringBuilder>.  
  
 Параметр `format` состоит из нуля или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют `arg0` с помощью `arg2`, объектов в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования строковым представлением соответствующего объекта.  
  
 Синтаксис элемента форматирования выглядит следующим образом:  
  
 {*index*[,*length*] [:*FormatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*номер*|Отсчитываемая от нуля координата в списке параметров объекта для форматирования. Если объект, указанный в *индексе* , имеет `null`, элемент форматирования заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если в позиции *индекса* нет параметра, выдается <xref:System.FormatException>.|  
|,*Длина*|Минимальное число символов в строковом представлении параметра. Если положительный, параметр размещается по правому краю; Если отрицательное, то оно по левому краю.|  
|:*FormatString*|Строка стандартного или пользовательского формата, поддерживаемая параметром.|  
  
> [!NOTE]
>  Для строк стандартного и пользовательского формата, используемых со значениями даты и времени, см. раздел [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Сведения о строках стандартных и пользовательских форматов, используемых с числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые с перечислениями, см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`, `arg1`и `arg2` представляют объекты для форматирования. Каждый элемент формата в `format` заменяется строковым представлением `arg0`, `arg1`или `arg2`в зависимости от индекса элемента формата. Если элемент форматирования включает `formatString` и соответствующий объект в `args` реализует интерфейс <xref:System.IFormattable>, то `arg`*x*`.ToString(formatString, null)` определяет форматирование, где *x* — индекс аргумента. В противном случае форматирование определяется `arg`*x*`.ToString()`.  
  
 Если строка, назначенная `format`, равна "Благодарим вас за ваше пожертвование {0: # # # #} за продукты в нашей благотворительной организации". а `arg0` — целое число со значением 10, возвращаемое значение будет "Благодарим вас за участие в 10 десятках продуктов нашей компании".  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.AppendFormat%2A>.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля либо больше или равен 3.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для форматирования.</param>
        <param name="arg1">Второй объект для форматирования.</param>
        <param name="arg2">Третий объект для форматирования.</param>
        <summary>Добавляет к данному экземпляру строку, возвращаемую в результате обработки строки составного формата, содержащей ноль или более элементов формата. Каждый элемент формата заменяется строковым представлением любого из трех аргументов с помощью указанного поставщика формата.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления. После операции добавления этот экземпляр содержит все данные, существовавшие до операции, к которым добавляется копия параметра <paramref name="format" />, где все спецификации форматирования заменяются представлением строки соответствующего аргумента объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в текущий объект <xref:System.Text.StringBuilder>.  
  
 Параметр `format` состоит из нуля или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объектам в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования строковым представлением соответствующего объекта.  
  
 Синтаксис элемента форматирования выглядит следующим образом:  
  
 {*index*[,*length*] [:*FormatString*]}  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|*номер*|Отсчитываемая от нуля координата в списке параметров объекта для форматирования. Если объект, указанный в *индексе* , имеет `null`, элемент форматирования заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если в позиции *индекса* нет параметра, выдается <xref:System.FormatException>.|  
|,*Длина*|Минимальное число символов в строковом представлении параметра. Если положительный, параметр размещается по правому краю; Если отрицательное, то оно по левому краю.|  
|:*FormatString*|Строка стандартного или пользовательского формата, поддерживаемая параметром.|  
  
> [!NOTE]
>  Для строк стандартного и пользовательского формата, используемых со значениями даты и времени, см. раздел [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Сведения о строках стандартных и пользовательских форматов, используемых с числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые с перечислениями, см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Параметр `provider` указывает реализацию <xref:System.IFormatProvider>, которая может предоставить сведения о форматировании для `arg0` и `arg1`. `provider` может быть одним из следующих:  
  
-   Объект <xref:System.Globalization.CultureInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo>, предоставляющий сведения об особенностях форматирования для языка и региональных параметров для `arg0` или `arg1`, если они являются числовыми значениями.  
  
-   Объект <xref:System.Globalization.DateTimeFormatInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами для `arg0`, `arg1`или `arg2`, если они являются значениями даты и времени.  
  
-   Пользовательская реализация <xref:System.IFormatProvider>, которая предоставляет сведения о форматировании для `arg0`, `arg1`и `arg2`. Как правило, такая реализация также реализует интерфейс <xref:System.ICustomFormatter>.  
  
 Если параметр `provider` имеет значение `null`, сведения о поставщике формата получаются из текущего языка и региональных параметров.  
  
 `arg0`, `arg1`и `arg2` представляют объекты для форматирования. Каждый элемент формата в `format` заменяется строковым представлением объекта с соответствующим индексом. Если элемент форматирования включает `formatString` и соответствующий аргумент реализует интерфейс <xref:System.IFormattable>, то форматирование определяется методом `ToString(formatString, provider)` аргумента. В противном случае форматирование определяет метод `ToString()` аргумента.  
  
   
  
## Examples  
 В следующем примере используется метод <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> для иллюстрации результата операции логического `And` с целочисленными значениями. Обратите внимание, что строка формата включает шесть элементов форматирования, но метод имеет только три элемента в списке аргументов, поскольку каждый элемент форматируется двумя разными способами.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> недопустим.  
  
-или- 
Индекс элемента формата меньше нуля или не меньше трех.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Длина развернутой строки превысит <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Практическое руководство. Определение и использование настраиваемых поставщиков числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет знак завершения строки по умолчанию или копию указанной строки и знак завершения строки по умолчанию в конце этого экземпляра.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Добавляет знак завершения строки по умолчанию в конец текущего объекта <see cref="T:System.Text.StringBuilder" />.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Признак конца строки по умолчанию — текущее значение свойства <xref:System.Environment.NewLine%2A?displayProperty=nameWithType>.  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.AppendLine%2A>.  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемая строка.</param>
        <summary>Добавляет копию указанной строки и знак завершения строки по умолчанию в конец текущего объекта <see cref="T:System.Text.StringBuilder" />.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции добавления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Признак конца строки по умолчанию — текущее значение свойства <xref:System.Environment.NewLine%2A?displayProperty=nameWithType>.  
  
 Емкость этого экземпляра корректируется по мере необходимости.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное число знаков, которое может содержаться в памяти, назначенной текущим экземпляром.</summary>
        <value>Максимальное число символов, которое может содержаться в памяти, назначенной текущим экземпляром. Это значение может меняться в диапазоне от <see cref="P:System.Text.StringBuilder.Length" /> до <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A> не влияет на строковое значение текущего экземпляра. <xref:System.Text.StringBuilder.Capacity%2A> можно уменьшить, если он не меньше <xref:System.Text.StringBuilder.Length%2A>.  
  
 <xref:System.Text.StringBuilder> динамически выделяет дополнительное пространство при необходимости и повышает <xref:System.Text.StringBuilder.Capacity%2A> соответствующим образом. По соображениям производительности <xref:System.Text.StringBuilder> может выделить больше памяти, чем требуется. Объем выделенной памяти зависит от конкретной реализации.  
  
   
  
## Examples  
 В следующем примере демонстрируется свойство <xref:System.Text.StringBuilder.Capacity%2A>.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, указанное для операции задания, меньше текущей длины данного экземпляра.  
  
 -или-  
  
 Значение, заданное для операции задания, больше максимальной емкости.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Позиция символа.</param>
        <summary>Возвращает или задает символ на указанной позиции в данном экземпляре.</summary>
        <value>Символ Юникода в позиции <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `index` — это расположение символа в <xref:System.Text.StringBuilder>. Первый символ в строке находится по индексу 0. Длина строки — это количество содержащихся в ней символов. Последний доступный символ <xref:System.Text.StringBuilder> экземпляра находится в индексе <xref:System.Text.StringBuilder.Length%2A>-1.  
  
 <xref:System.Text.StringBuilder.Chars%2A> является свойством по умолчанию класса <xref:System.Text.StringBuilder>. В C#это индексатор. Это означает, что отдельные символы можно получить из свойства <xref:System.Text.StringBuilder.Chars%2A>, как показано в следующем примере, который подсчитывает количество алфавитных, пробелов и знаков препинания в строке.  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>Производительность и индексирование на основе символов

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">При задании символа <paramref name="index" /> находится за пределами данного экземпляра.</exception>
        <exception cref="T:System.IndexOutOfRangeException">При получении символа <paramref name="index" /> находится за пределами данного экземпляра.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все символы из текущего экземпляра <see cref="T:System.Text.StringBuilder" />.</summary>
        <returns>Объект, длина <see cref="P:System.Text.StringBuilder.Length" /> которого равна 0 (нулю).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Text.StringBuilder.Clear%2A> — это удобный метод, эквивалентный присвоению свойству <xref:System.Text.StringBuilder.Length%2A> текущего экземпляра значения 0 (ноль).  
  
## Examples

В следующем примере создается экземпляр <xref:System.Text.StringBuilder> объекта со строкой, вызывается метод <xref:System.Text.StringBuilder.Clear%2A>, а затем добавляется новая строка.  
  
[!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
[!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destination" Type="System.Char[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Начальная позиция в этом экземпляре, откуда будут скопированы символы. Индексация начинается с нуля.</param>
        <param name="destination">Массив, в который копируются символы.</param>
        <param name="destinationIndex">Начальная позиция в массиве <paramref name="destination" />, в которую копируются символы. Индексация начинается с нуля.</param>
        <param name="count">Число копируемых знаков.</param>
        <summary>Копирует символы из указанного сегмента этого экземпляра в указанный массив <see cref="T:System.Char" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Text.StringBuilder.CopyTo%2A> предназначен для использования в редких ситуациях, когда необходимо эффективно копировать последовательные разделы <xref:System.Text.StringBuilder> объекта в массив. Массив должен быть фиксированным размером, предварительно выделенным, многократно используемым и, возможно, глобально доступным.  
  
 Например, приложение может заполнить <xref:System.Text.StringBuilder> объект с большим количеством символов, а затем использовать метод <xref:System.Text.StringBuilder.CopyTo%2A> для копирования мелких последовательных фрагментов объекта <xref:System.Text.StringBuilder> в массив, где обрабатываются элементы. Когда все данные в объекте <xref:System.Text.StringBuilder> обрабатываются, размер <xref:System.Text.StringBuilder> объекта устанавливается равным нулю и цикл повторяется.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.CopyTo%2A>.  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="destination" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="sourceIndex" />, <paramref name="destinationIndex" /> или <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="sourceIndex" /> больше длины этого экземпляра.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> + <paramref name="count" /> больше длины этого экземпляра.  
  
-или- 
 Значение <paramref name="destinationIndex" /> + <paramref name="count" /> превышает длину <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Минимальная емкость для проверки.</param>
        <summary>Гарантирует, что емкость данного экземпляра <see cref="T:System.Text.StringBuilder" /> не меньше указанного значения.</summary>
        <returns>Новая емкость этого экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущая емкость меньше, чем параметр `capacity`, память для этого экземпляра повторно выделяется для хранения как минимум `capacity` числа символов; в противном случае память не изменяется.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.EnsureCapacity%2A>.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="capacity" /> меньше нуля.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="span">Диапазон символов для сравнения с текущим экземпляром.</param>
        <summary>Возвращает значение, указывающее, соответствуют ли символы в этом экземпляре символам в указанном диапазоне символов, доступном только для чтения.</summary>
        <returns><see langword="true" />, если символы в этом экземпляре и в <paramref name="span" /> совпадают; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Метод `Equals` выполняет порядковое сравнение, чтобы определить, равны ли символы в текущем экземпляре и `span`.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">Объект, сравниваемый с этим экземпляром, или значение <see langword="null" />.</param>
        <summary>Возвращает значение, показывающее, равен ли данный экземпляр заданному объекту.</summary>
        <returns><see langword="true" />, если данный экземпляр и <paramref name="sb" /> имеют одинаковую строку, <see cref="P:System.Text.StringBuilder.Capacity" /> и значения <see cref="P:System.Text.StringBuilder.MaxCapacity" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

**.NET Framework и .NET Core 2,2 и предыдущие версии:** Текущий экземпляр и `sb` равны, если они имеют одинаковые значения String, <xref:System.Text.StringBuilder.Capacity>и <xref:System.Text.StringBuilder.MaxCapacity>. Метод `Equals` использует порядковое сравнение для определения того, равны ли строки.

**.NET Core 3,0 и более поздние версии:** Текущий экземпляр и `sb` равны, если строки, назначенные обоим объектам <xref:System.Text.StringBuilder>, одинаковы.  Чтобы определить равенство, метод `Equals` использует порядковое сравнение. Значения свойств <xref:System.Text.StringBuilder.Capacity> и <xref:System.Text.StringBuilder.MaxCapacity> не используются в сравнении.

## Examples  
 В следующем коде используется метод <xref:System.Text.StringBuilder.Equals%2A> для проверки того, равны ли два объекта <xref:System.Text.StringBuilder>. Метод вызывается повторно после внесения небольших изменений в каждый объект, и результаты отображаются в консоли.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChunks">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder.ChunkEnumerator GetChunks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringBuilder/ChunkEnumerator GetChunks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.GetChunks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChunks () As StringBuilder.ChunkEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder::ChunkEnumerator GetChunks();" />
      <MemberSignature Language="F#" Value="member this.GetChunks : unit -&gt; System.Text.StringBuilder.ChunkEnumerator" Usage="stringBuilder.GetChunks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder+ChunkEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект, который можно использовать для прохода по фрагментам символов, представленных в <see langword="ReadOnlyMemory&lt;Char&gt;" />, созданном из данного экземпляра <see cref="T:System.Text.StringBuilder" />.</summary>
        <returns>Перечислитель для всех фрагментов в коллекции <see langword="ReadOnlyMemory&lt;Char&gt;" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Вы можете выполнить итерацию фрагментов в диапазоне памяти с помощью кода, подобного следующему: 

```csharp
foreach (ReadOnlyMemory<char> chunk in sb.GetChunks())
    foreach(char ch in chunk.Span)
        { /* operations on ch */ }
```
            
Этот метод предназначен для эффективного извлечения данных *константного* <xref:System.Text.StringBuilder>. Если <xref:System.Text.StringBuilder> изменяется в то время, как перечисление фрагментов не является полным, результат будет неопределенным. <xref:System.Text.StringBuilder> также не является потокобезопасным, поэтому его работа с параллельными потоками недопустима.

Возвращенные фрагменты <xref:System.ReadOnlyMemory%601> не всегда остаются неизменными при изменении <xref:System.Text.StringBuilder>, поэтому не следует кэшировать их для последующего использования.
             
Создание <xref:System.ReadOnlySpan%601> из <xref:System.ReadOnlyMemory%601> (как метод <xref:System.ReadOnlyMemory%601.Span?displayProperty=nameWithType> в предыдущем примере является дорогостоящим, поэтому создайте локальную переменную для этого диапазона, если ее нужно использовать во вложенном операторе `for`. Например: 

```csharp
foreach (ReadOnlyMemory<char> chunk in sb.GetChunks())
{
    var span = chunk.Span;
    for(int i = 0; i < span.Length; i++)
    { 
        /* operations on span[i] */ 
    }
}
```

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вставляет строковое представление указанного объекта в данный экземпляр на указанную позицию символа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление логического значения в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости емкость корректируется.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление указанного 8-разрядного целого числа без знака в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление указанного символа Юникода в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Массив символов для вставки.</param>
        <summary>Вставляет строковое представление указанного массива символов Юникода в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.  
  
 Если `value` `null`, <xref:System.Text.StringBuilder> не изменяется.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление десятичного числа в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление числа с плавающей запятой с удвоенной точностью в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление указанного 16-разрядного знакового целого числа в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление указанного 32-разрядного знакового целого числа в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление 64-разрядного знакового целого числа в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Объект для вставки или значение <see langword="null" />.</param>
        <summary>Вставляет строковое представление объекта в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.  
  
 Если `value` `null`, значение этого экземпляра не изменяется.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление указанного 8-разрядного знакового целого числа в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости емкость корректируется.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление числа одинарной точности с плавающей запятой с обычной точностью в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Строка, которую требуется вставить.</param>
        <summary>Вставляет строку в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости емкость корректируется.  
  
 Этот экземпляр <xref:System.Text.StringBuilder> не изменяется, если `value` `null`или `value` не `null`, но его длина равна нулю.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше текущей длины этого экземпляра.  
  
-или- 
Текущая длина этого объекта <see cref="T:System.Text.StringBuilder" /> плюс длина <paramref name="value" /> превышает <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление 16-разрядного целого числа без знака в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление 32-разрядного целого числа без знака в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Значение, которое следует вставить.</param>
        <summary>Вставляет строковое представление 64-разрядного целого числа без знака в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше длины этого экземпляра.</exception>
        <exception cref="T:System.OutOfMemoryException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Строка, которую требуется вставить.</param>
        <param name="count">Сколько раз следует вставить <paramref name="value" />.</param>
        <summary>Вставляет одну или более копий указанной строки в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.  
  
 Этот объект <xref:System.Text.StringBuilder> не изменяется, если `value` `null`, `value` не `null`, но его длина равна нулю или `count` равен нулю.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> имеет значение меньше нуля или больше текущей длины этого экземпляра.  
  
-или- 
 Значение параметра <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.OutOfMemoryException">Текущая длина этого объекта <see cref="T:System.Text.StringBuilder" /> плюс длина <paramref name="value" /> <paramref name="count" /> раз превышает <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Позиция в данном экземпляре, с которой начинается вставка.</param>
        <param name="value">Массив символов.</param>
        <param name="startIndex">Начальный индекс внутри <paramref name="value" />.</param>
        <param name="charCount">Число символов для вставки.</param>
        <summary>Вставляет строковое представление указанного подмассива символов Юникода в данный экземпляр на указанную позицию символа.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Insert%2A>.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> имеет значение <see langword="null" />, а <paramref name="startIndex" /> и <paramref name="charCount" /> не равны нулю.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="index" />, <paramref name="startIndex" /> или <paramref name="charCount" /> меньше нуля.  
  
-или- 
 <paramref name="index" /> больше длины этого экземпляра.  
  
-или- 
 <paramref name="startIndex" /> плюс <paramref name="charCount" /> не является позицией в <paramref name="value" />.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает длину текущего объекта <see cref="T:System.Text.StringBuilder" />.</summary>
        <value>Длина этого экземпляра.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Длина объекта <xref:System.Text.StringBuilder> определяется по количеству <xref:System.Char> объектов.  
  
 Как и свойство <xref:System.String.Length%2A?displayProperty=nameWithType>, свойство <xref:System.Text.StringBuilder.Length%2A> указывает длину текущего строкового объекта. В отличие от свойства <xref:System.String.Length%2A?displayProperty=nameWithType>, которое доступно только для чтения, свойство <xref:System.Text.StringBuilder.Length%2A> позволяет изменить длину строки, хранящейся в объекте <xref:System.Text.StringBuilder>.  
  
 Если указанная длина меньше текущей длины, текущий объект <xref:System.Text.StringBuilder> усекается до указанной длины. Если указанная длина больше текущей длины, конец строкового значения текущего <xref:System.Text.StringBuilder> объекта дополняется символом NULL в Юникоде (U + 0000).  
  
 Если указанная длина больше текущей емкости, <xref:System.Text.StringBuilder.Capacity%2A> увеличивается, чтобы она была больше или равна указанной длине.  
  
   
  
## Examples  
 В следующем примере демонстрируется свойство <xref:System.Text.StringBuilder.Length%2A>.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, заданное для операции задания, меньше нуля или больше <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает максимальную емкость данного экземпляра.</summary>
        <value>Наибольшее количество символов, которое может содержать данный экземпляр.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Максимальная емкость для этой реализации — <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Однако это значение зависит от реализации и может отличаться в других реализациях или более поздних версиях. Можно явно задать максимальную емкость объекта <xref:System.Text.StringBuilder>, вызвав конструктор <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>.  
  
В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <xref:System.Text.StringBuilder> путем вызова конструктора <xref:System.Text.StringBuilder.%23ctor(System.Int32,System.Int32)> Длина и емкость экземпляра <xref:System.Text.StringBuilder> могут увеличиваться за пределами значения свойства <xref:System.Text.StringBuilder.MaxCapacity>. Это может произойти в частности при вызове методов <xref:System.Text.StringBuilder.Append(System.String)> и <xref:System.Text.StringBuilder.AppendFormat(System.String,System.Object)> для добавления небольших строк.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Отсчитываемая с нуля позиция в данном экземпляре, с которой начинается удаление.</param>
        <param name="length">Число знаков для удаления.</param>
        <summary>Удаляет указанный диапазон символов из данного экземпляра.</summary>
        <returns>Ссылка на этот экземпляр после завершения операции удаления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий метод удаляет указанный диапазон символов из текущего экземпляра. Символы в (`startIndex` + `length`) перемещаются в `startIndex`, а строковое значение текущего экземпляра сокращается на `length`. Емкость текущего экземпляра не затрагивается.  
  
> [!NOTE]
>  Метод <xref:System.Text.StringBuilder.Remove%2A> изменяет значение текущего экземпляра <xref:System.Text.StringBuilder> и возвращает этот экземпляр. Он не создает и не возвращает новый объект <xref:System.Text.StringBuilder>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Remove%2A>.  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Если <paramref name="startIndex" /> или <paramref name="length" /> меньше нуля или <paramref name="startIndex" /> + <paramref name="length" /> больше длины этого экземпляра.</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Замещает все вхождения указанного символа или строки в данном экземпляре на другой указанный символ или строку.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Замещаемый символ.</param>
        <param name="newChar">Символ, замещающий <paramref name="oldChar" />.</param>
        <summary>Замещает все вхождения указанного символа в данном экземпляре на другой указанный знак.</summary>
        <returns>Ссылка на данный экземпляр с помощью <paramref name="oldChar" /> заменяется на <paramref name="newChar" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет порядковый номер, сравнение с учетом регистра для обнаружения вхождений `oldChar` в текущем экземпляре. После замены размер текущего экземпляра <xref:System.Text.StringBuilder> не изменяется.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Replace%2A>.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Замещаемая строка.</param>
        <param name="newValue">Строка, замещающая <paramref name="oldValue" />, или <see langword="null" />.</param>
        <summary>Замещает все вхождения указанной строки в данном экземпляре на другую указанную строку.</summary>
        <returns>Ссылка на данный экземпляр со всеми экземплярами <paramref name="oldValue" /> заменяется на <paramref name="newValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет порядковый номер, сравнение с учетом регистра для обнаружения вхождений `oldValue` в текущем экземпляре. Если `newValue` имеет `null` или <xref:System.String.Empty?displayProperty=nameWithType>, удаляются все вхождения `oldValue`.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Replace%2A>.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="oldValue" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="oldValue" /> равна нулю.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">Замещаемый символ.</param>
        <param name="newChar">Символ, замещающий <paramref name="oldChar" />.</param>
        <param name="startIndex">Позиция в данном экземпляре, с которой начинается подстрока.</param>
        <param name="count">Длина подстроки.</param>
        <summary>Замещает все вхождения указанного символа в подстроке данного экземпляра на другой указанный символ.</summary>
        <returns>Ссылка на данный экземпляр с <paramref name="oldChar" /> заменяется на <paramref name="newChar" /> в диапазоне от <paramref name="startIndex" /> до <paramref name="startIndex" /> + <paramref name="count" /> –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет порядковый номер, сравнение с учетом регистра для обнаружения вхождений `oldChar` в текущем экземпляре. После замены размер текущего объекта <xref:System.Text.StringBuilder> не изменяется.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Replace%2A>.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> + <paramref name="count" /> больше длины значения этого экземпляра.  
  
-или- 
 Значение параметра <paramref name="startIndex" /> или <paramref name="count" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">Замещаемая строка.</param>
        <param name="newValue">Строка, замещающая <paramref name="oldValue" />, или <see langword="null" />.</param>
        <param name="startIndex">Позиция в данном экземпляре, с которой начинается подстрока.</param>
        <param name="count">Длина подстроки.</param>
        <summary>Замещает все вхождения указанной строки в подстроке данного экземпляра на другую указанную строку.</summary>
        <returns>Ссылка на данный экземпляр со всеми экземплярами <paramref name="oldValue" /> заменяется на <paramref name="newValue" /> в диапазоне от <paramref name="startIndex" /> до <paramref name="startIndex" /> + <paramref name="count" /> – 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет порядковое сравнение с учетом регистра для обнаружения вхождений `oldValue` в указанной подстроке. Если `newValue` имеет `null` или <xref:System.String.Empty?displayProperty=nameWithType>, удаляются все вхождения `oldValue`.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование метода <xref:System.Text.StringBuilder.Replace%2A>.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="oldValue" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="oldValue" /> равна нулю.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> или <paramref name="count" /> меньше нуля.  
  
-или- 
 <paramref name="startIndex" /> плюс <paramref name="count" /> указывает на позицию символа за пределами данного экземпляра.  
  
-или- 
Увеличение значения этого экземпляра может привести к превышению <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Объект, который требуется заполнить информацией о сериализации.</param>
        <param name="context">Место для хранения и извлечения сериализованных данных. Зарезервировано для будущего использования.</param>
        <summary>Заполняет объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> данными даты, необходимыми для десериализации текущего объекта <see cref="T:System.Text.StringBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `context` зарезервирован для будущего использования и не участвует в этой операции.  
  
 Дополнительные сведения см. в описании метода <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="info" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразовывает значение типа <see cref="T:System.Text.StringBuilder" /> в значение <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Преобразует значение данного экземпляра в <see cref="T:System.String" />.</summary>
        <returns>Строка, чье значение совпадает с данным экземпляром.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо вызвать метод <xref:System.Text.StringBuilder.ToString%2A> для преобразования объекта <xref:System.Text.StringBuilder> в <xref:System.String> объект, прежде чем передавать строку, представленную объектом <xref:System.Text.StringBuilder>, в метод, имеющий параметр <xref:System.String> или отображаемый в пользовательском интерфейсе.  
  
   
  
## Examples  
 В следующем примере демонстрируется вызов метода <xref:System.Text.StringBuilder.ToString%2A>. Этот пример является частью большого примера, приведенного для класса <xref:System.Text.StringBuilder>.  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Начальная позиция подстроки в данном экземпляре.</param>
        <param name="length">Длина подстроки.</param>
        <summary>Преобразует значение подстроки этого экземпляра в <see cref="T:System.String" />.</summary>
        <returns>Строка, чье значение совпадает с указанной подстрокой данного экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо вызвать метод <xref:System.Text.StringBuilder.ToString%2A> для преобразования объекта <xref:System.Text.StringBuilder> в <xref:System.String> объект, прежде чем передавать строку, представленную объектом <xref:System.Text.StringBuilder>, в метод, имеющий параметр <xref:System.String> или отображаемый в пользовательском интерфейсе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="startIndex" /> или <paramref name="length" /> меньше нуля.  
  
-или- 
Сума значений <paramref name="startIndex" /> и <paramref name="length" /> превышает длину текущего экземпляра.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
