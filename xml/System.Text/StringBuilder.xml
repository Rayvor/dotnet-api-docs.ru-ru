<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fceeb096e3831bbdc326359702c1f7724fe1af63" /><Meta Name="ms.sourcegitcommit" Value="f6fc130f7b9399b2b130a137d6b0b2b73c1d17b3" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="11/18/2019" /><Meta Name="ms.locfileid" Value="74154534" /></Metadata><TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a mutable string of characters. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 Этот класс представляет объект, подобный строке, значение которого является изменяемой последовательностью символов.

 Содержание

-   [Типы String и StringBuilder](#StringAndSB)

-   [Принцип работы StringBuilder](#HowWorks)

-   [Выделение памяти](#Memory)

-   [Создание экземпляра объекта StringBuilder](#Instantiating)

-   [Вызов методов StringBuilder](#Calling)

-   [Выполнение операций StringBuilder](#Operations)

    -   [Итерация символов StringBuilder](#Iterating)

    -   [Добавление текста в объект StringBuilder](#Adding)

    -   [Удаление текста из объекта StringBuilder](#Deleting)

    -   [Изменение текста в объекте StringBuilder](#Modifying)

-   [Поиск текста в объекте StringBuilder](#Searching)

-   [Преобразование объекта StringBuilder в строку](#Converting)

<a name="StringAndSB"></a>
## <a name="the-string-and-stringbuilder-types"></a>Типы String и StringBuilder
 Хотя <xref:System.Text.StringBuilder> и <xref:System.String> оба представляют последовательности символов, они реализуются по-разному. <xref:System.String> является неизменяемым типом. То есть каждая операция, которая может изменить объект <xref:System.String>, фактически создает новую строку.

 Например, вызов метода <xref:System.String.Concat%2A?displayProperty=nameWithType> в следующем примере приводит C# к изменению значения строковой переменной с именем `value`. Фактически, метод <xref:System.String.Concat%2A> возвращает объект `value` с другим значением и адресом из объекта `value`, который был передан в метод. Обратите внимание, что пример необходимо скомпилировать с помощью параметра компилятора `/unsafe`.

 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]

 Для подпрограмм, выполняющих обширную обработку строк (например, приложения, которые изменяют строку несколько раз в цикле), многократное изменение строки может привести к значительному снижению производительности. Альтернативой является использование <xref:System.Text.StringBuilder>, который является изменяемым строковым классом. Изменяемость означает, что после создания экземпляра класса его можно изменить путем добавления, удаления, замены или вставки символов. Объект <xref:System.Text.StringBuilder> поддерживает буфер для расширения строки. При наличии свободного места новые данные добавляются в буфер. в противном случае выделяется новый буфер большего размера, данные из исходного буфера копируются в новый буфер, а новые данные добавляются в новый буфер.

> [!IMPORTANT]
>  Хотя класс <xref:System.Text.StringBuilder>, как правило, обеспечивает лучшую производительность, чем класс <xref:System.String>, не следует автоматически заменять <xref:System.String> на <xref:System.Text.StringBuilder>, когда требуется управлять строками. Производительность зависит от размера строки, объема памяти, выделяемого для новой строки, системы, в которой выполняется приложение, и типа операции. Необходимо подготовиться к тестированию приложения, чтобы определить, действительно ли <xref:System.Text.StringBuilder> на самом деле обеспечивает значительное повышение производительности.

 Рассмотрите возможность использования класса <xref:System.String> в следующих условиях:

-   Когда число изменений, которое приложение будет вносить в строку, невелико. В таких случаях <xref:System.Text.StringBuilder> может предложить незначительное повышение производительности по сравнению с <xref:System.String>.

-   При выполнении фиксированного числа операций объединения, особенно с строковыми литералами. В этом случае компилятор может объединить операции объединения в одну операцию.

-   Если при построении строки необходимо выполнять широкие операции поиска. Класс <xref:System.Text.StringBuilder> не имеет методов поиска, таких как `IndexOf` или `StartsWith`. Необходимо преобразовать объект <xref:System.Text.StringBuilder> в <xref:System.String> для этих операций. это может отрицательно повлиять на производительность при использовании <xref:System.Text.StringBuilder>. Дополнительные сведения см. в разделе [Поиск текста в объекте StringBuilder](#Searching) .

 Рассмотрите возможность использования класса <xref:System.Text.StringBuilder> в следующих условиях:

-   Если вы ожидаете, что приложение будет вносить неизвестное количество изменений в строку во время разработки (например, при использовании цикла для сцепления случайного числа строк, содержащего введенные пользователем данные).

-   Если предполагается, что приложение вносит значительное количество изменений в строку.

<a name="HowWorks"></a>
## <a name="how-stringbuilder-works"></a>Принцип работы StringBuilder
 Свойство <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> указывает количество символов, которое в данный момент содержит объект <xref:System.Text.StringBuilder>. При добавлении символов в объект <xref:System.Text.StringBuilder> его длина увеличивается до тех пор, пока не будет равен размеру свойства <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType>, определяющего количество символов, которое может содержать объект. Если количество добавленных символов приводит к тому, что длина объекта <xref:System.Text.StringBuilder> превышает текущую емкость, выделяется новая память, значение свойства <xref:System.Text.StringBuilder.Capacity%2A> удваивается, в объект <xref:System.Text.StringBuilder> добавляются новые символы, а свойство <xref:System.Text.StringBuilder.Length%2A> — настройки. Дополнительная память для объекта <xref:System.Text.StringBuilder> выделяется динамически до тех пор, пока не достигнет значения, определенного свойством <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType>. По достижении максимальной емкости не удается выделить память для объекта <xref:System.Text.StringBuilder>, и при попытке добавить символы или расширить его после максимальной емкости выдается исключение <xref:System.ArgumentOutOfRangeException> или <xref:System.OutOfMemoryException>.

 В следующем примере показано, как объект <xref:System.Text.StringBuilder> выделяет новую память и увеличивает ее емкость динамически по мере расширения строки, назначенной объекту. Код создает объект <xref:System.Text.StringBuilder>, вызывая конструктор по умолчанию (без параметров). Емкость этого объекта по умолчанию составляет 16 символов, а ее максимальная емкость превышает 2 000 000 000 символов. Добавление строки «это предложение». приводит к новому выделению памяти, так как длина строки (19 символов) превышает емкость объекта <xref:System.Text.StringBuilder> по умолчанию. Емкость объекта удваивается до 32 символов, добавляется новая строка, а длина объекта теперь равна 19 символам. Затем код добавляет строку «это дополнительное предложение». в значение объекта <xref:System.Text.StringBuilder> 11 раз. Когда операция добавления приводит к превышению емкости объекта <xref:System.Text.StringBuilder>, его существующая емкость удваивается и операция <xref:System.Text.StringBuilder.Append%2A> завершается с ошибкой.

 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]

<a name="Memory"></a>
## <a name="memory-allocation"></a>Выделение памяти
 Емкость по умолчанию для объекта <xref:System.Text.StringBuilder> составляет 16 символов, а максимальная емкость по умолчанию — <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Эти значения по умолчанию используются при вызове конструкторов <xref:System.Text.StringBuilder.%23ctor> и <xref:System.Text.StringBuilder.%23ctor%28System.String%29>.

 Можно явно определить начальную емкость объекта <xref:System.Text.StringBuilder> следующими способами.

-   Путем вызова любого конструктора <xref:System.Text.StringBuilder>, который включает параметр `capacity` при создании объекта.

-   Путем явного присвоения свойству <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> нового значения, чтобы расширить существующий объект <xref:System.Text.StringBuilder>. Обратите внимание, что свойство создает исключение, если новая емкость меньше, чем существующая емкость, или больше, чем максимальная емкость объекта <xref:System.Text.StringBuilder>.

-   Путем вызова метода <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> с новой емкостью. Новая емкость не должна превышать максимальную емкость объекта <xref:System.Text.StringBuilder>. Однако, в отличие от присваивания свойству <xref:System.Text.StringBuilder.Capacity%2A>, <xref:System.Text.StringBuilder.EnsureCapacity%2A> не создает исключение, если нужная Новая емкость меньше, чем существующая емкость; в этом случае вызов метода не оказывает никакого влияния.

 Если длина строки, назначенной объекту <xref:System.Text.StringBuilder> в вызове конструктора, превышает емкость по умолчанию или указанную емкость, свойству <xref:System.Text.StringBuilder.Capacity%2A> присваивается длина строки, заданной параметром `value`.

 Можно явно определить максимальную емкость объекта <xref:System.Text.StringBuilder>, вызвав конструктор <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>. Вы не можете изменить максимальную емкость, назначив свойству <xref:System.Text.StringBuilder.MaxCapacity%2A> новое значение, так как оно доступно только для чтения.

 Как показано в предыдущем разделе, когда существующая емкость недостаточна, выделяется дополнительная память, а емкость объекта <xref:System.Text.StringBuilder> удваивается до значения, определенного свойством <xref:System.Text.StringBuilder.MaxCapacity%2A>.

 Как правило, емкость по умолчанию и максимальная емкость подходят для большинства приложений. Эти значения можно установить при следующих условиях.

-   Если в конечном итоге размер объекта <xref:System.Text.StringBuilder>, скорее всего, увеличится слишком большим, обычно он превышает несколько мегабайт. В этом случае может возникнуть некоторый выигрыш в производительности от установки значения свойства Initial <xref:System.Text.StringBuilder.Capacity%2A> в значительном высоком значении, чтобы исключить необходимость в слишком большом количестве перераспределения памяти.

-   Если приложение работает в системе с ограниченным объемом памяти. В этом случае, возможно, стоит рассмотреть возможность установки свойства <xref:System.Text.StringBuilder.MaxCapacity%2A> в значение меньше <xref:System.Int32.MaxValue?displayProperty=nameWithType>, если приложение обрабатывает большие строки, которые могут привести к его выполнению в среде с ограниченным объемом памяти.

<a name="Instantiating"></a>
## <a name="instantiating-a-stringbuilder-object"></a>Создание экземпляра объекта StringBuilder
 Вы создаете объект <xref:System.Text.StringBuilder>, вызывая один из шести перегруженных конструкторов классов, которые перечислены в следующей таблице. Три конструктора создают экземпляр объекта <xref:System.Text.StringBuilder>, значением которого является пустая строка, но устанавливайте значения <xref:System.Text.StringBuilder.Capacity%2A> и <xref:System.Text.StringBuilder.MaxCapacity%2A> по-разному. Остальные три конструктора определяют объект <xref:System.Text.StringBuilder> с определенным строковым значением и емкостью. Два из трех конструкторов используют максимальную емкость <xref:System.Int32.MaxValue?displayProperty=nameWithType>по умолчанию, а третья позволяет задать максимальную емкость.

|Конструктор|Строковое значение|Емкость|Максимальная емкость|
|-----------------|------------------|--------------|----------------------|
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Определяется параметром `capacity`|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Определяется параметром `capacity`|Определяется параметром `maxCapacity`|
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|Определяется параметром `value`|16 или `value`. <xref:System.String.Length%2A>, в зависимости от того, какое значение больше|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|Определяется параметром `value`|Определяется параметром `capacity` или `value`. <xref:System.String.Length%2A>, в зависимости от того, какое значение больше.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|Определяется в `value`. <xref:System.String.Substring%2A>(`startIndex`, `length`)|Определяется параметром `capacity` или `value`. <xref:System.String.Length%2A>, в зависимости от того, какое значение больше.|Определяется параметром `maxCapacity`|

 В следующем примере используются три из этих перегрузок конструктора для создания экземпляров объектов <xref:System.Text.StringBuilder>.

 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]

<a name="Calling"></a>
## <a name="calling-stringbuilder-methods"></a>Вызов методов StringBuilder
 Большинство методов, которые изменяют строку в экземпляре <xref:System.Text.StringBuilder>, возвращают ссылку на этот же экземпляр. Это позволяет вызывать методы <xref:System.Text.StringBuilder> двумя способами:

-   Можно выполнить отдельные вызовы метода и игнорировать возвращаемое значение, как показано в следующем примере.

     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]

-   В одной инструкции можно создать ряд вызовов методов. Это может быть удобно, если вы хотите написать одну инструкцию, которая повязывает последовательные операции. В следующем примере три вызова метода из предыдущего примера консолидируются в одну строку кода.

     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]

<a name="Operations"></a>
## <a name="performing-stringbuilder-operations"></a>Выполнение операций StringBuilder
 Методы класса <xref:System.Text.StringBuilder> можно использовать для итерации, добавления, удаления или изменения символов в объекте <xref:System.Text.StringBuilder>.

<a name="Iterating"></a>
### <a name="iterating-stringbuilder-characters"></a>Итерация символов StringBuilder
 Доступ к символам в <xref:System.Text.StringBuilder>ном объекте можно получить с помощью свойства <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>. В C#<xref:System.Text.StringBuilder.Chars%2A> является индексатором; в Visual Basic это свойство класса <xref:System.Text.StringBuilder> по умолчанию. Это позволяет задавать или извлекать отдельные символы, используя только индекс, без явной ссылки на свойство <xref:System.Text.StringBuilder.Chars%2A>. Символы в <xref:System.Text.StringBuilder>ном объекте начинаются с индекса 0 (ноль) и продолжают индексироваться <xref:System.Text.StringBuilder.Length%2A>-1.

 В следующем примере показано свойство <xref:System.Text.StringBuilder.Chars%2A>. Он добавляет десять случайных чисел к объекту <xref:System.Text.StringBuilder>, а затем выполняет итерацию каждого символа. Если категория символа в Юникоде имеет <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, то число уменьшается на 1 (или, если значение равно 0). В примере отображается содержимое объекта <xref:System.Text.StringBuilder> как до, так и после изменения значений отдельных символов.

 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

<a name="Adding"></a>
### <a name="adding-text-to-a-stringbuilder-object"></a>Добавление текста в объект StringBuilder
 Класс <xref:System.Text.StringBuilder> включает следующие методы для расширения содержимого объекта <xref:System.Text.StringBuilder>.

-   Метод <xref:System.Text.StringBuilder.Append%2A> добавляет строку, подстроку, массив символов, часть массива символов, один символ повторяется несколько раз или строковое представление примитивного типа данных в объект <xref:System.Text.StringBuilder>.

-   Метод <xref:System.Text.StringBuilder.AppendLine%2A> добавляет признак конца строки или строку вместе с признаком конца строки к объекту <xref:System.Text.StringBuilder>.

-   Метод <xref:System.Text.StringBuilder.AppendFormat%2A> добавляет [строку составного формата](~/docs/standard/base-types/composite-formatting.md) к объекту <xref:System.Text.StringBuilder>. Строковые представления объектов, входящих в результирующую строку, могут отражать соглашения о форматировании текущего языка и региональных параметров системы или указанного языка и региональных параметров.

-   Метод <xref:System.Text.StringBuilder.Insert%2A> вставляет строку, подстроку, несколько повторений строки, массив символов, часть массива символов или строковое представление примитивного типа данных в указанной позиции в объекте <xref:System.Text.StringBuilder>. Позиция определяется индексом, начинающимся с нуля.

 В следующем примере используются методы <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и <xref:System.Text.StringBuilder.Insert%2A> для расширения текста объекта <xref:System.Text.StringBuilder>.

 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]

<a name="Deleting"></a>
### <a name="deleting-text-from-a-stringbuilder-object"></a>Удаление текста из объекта StringBuilder
 Класс <xref:System.Text.StringBuilder> содержит методы, которые могут уменьшить размер текущего экземпляра <xref:System.Text.StringBuilder>. Метод <xref:System.Text.StringBuilder.Clear%2A> удаляет все символы и устанавливает для свойства <xref:System.Text.StringBuilder.Length%2A> значение 0. Метод <xref:System.Text.StringBuilder.Remove%2A> удаляет указанное число символов, начиная с определенной позиции индекса. Кроме того, можно удалить символы из конца объекта <xref:System.Text.StringBuilder>, задав свойству <xref:System.Text.StringBuilder.Length%2A> значение, которое меньше, чем длина текущего экземпляра.

 В следующем примере удаляется часть текста из объекта <xref:System.Text.StringBuilder>, выводится его результирующая емкость, максимальная емкость и значения свойств длины, а затем вызывается метод <xref:System.Text.StringBuilder.Clear%2A> для удаления всех символов из объекта <xref:System.Text.StringBuilder>.

 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]

<a name="Modifying"></a>
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>Изменение текста в объекте StringBuilder
 Метод <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> заменяет все вхождения символа или строки во всем объекте <xref:System.Text.StringBuilder> или в определенном диапазоне символов. В следующем примере используется метод <xref:System.Text.StringBuilder.Replace%2A> для замены всех восклицательных знаков (!) на вопросительные знаки (?) в объекте <xref:System.Text.StringBuilder>.

 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]

<a name="Searching"></a>
## <a name="searching-the-text-in-a-stringbuilder-object"></a>Поиск текста в объекте StringBuilder
 Класс <xref:System.Text.StringBuilder> не включает методы, аналогичные методам <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>и <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, предоставляемым классом <xref:System.String>, которые позволяют искать в объекте определенный символ или подстроку. Чтобы определить присутствие или начальную точку символа подстроки, необходимо выполнить поиск <xref:System.String> значения с помощью метода поиска строки или метода регулярного выражения. Существует четыре способа реализации таких поисков, как показано в следующей таблице.

|Процедура|ИТ специалистов|Недостатки|
|---------------|----------|----------|
|Поиск значений строки перед их добавлением в объект <xref:System.Text.StringBuilder>.|Полезно для определения того, существует ли подстрока.|Не может использоваться, если позиция подстроки индекса важна.|
|Вызовите <xref:System.Text.StringBuilder.ToString%2A> и найдите возвращаемый объект <xref:System.String>.|Простая в использовании, если вы назначаете весь текст объекту <xref:System.Text.StringBuilder>, а затем приступите к его изменению.|Громоздкий способ повторного вызова <xref:System.Text.StringBuilder.ToString%2A>, если необходимо внести изменения до того, как весь текст будет добавлен в объект <xref:System.Text.StringBuilder>.<br /><br /> При внесении изменений следует приступать к работе с конца текста объекта <xref:System.Text.StringBuilder>.|
|Используйте свойство <xref:System.Text.StringBuilder.Chars%2A> для последовательного поиска диапазона символов.|Полезно, если вы работаете с отдельными символами или небольшой подстрокой.|Громоздкий, если количество символов для поиска велико или если логика поиска сложна.<br /><br />Приводит к очень низкой производительности для объектов, которые увеличились очень крупнее с помощью повторяющихся вызовов методов.  |
|Преобразуйте объект <xref:System.Text.StringBuilder> в объект <xref:System.String> и выполните изменения в объекте <xref:System.String>.|Полезно, если число изменений невелико.|Инвертирует преимущество производительности класса <xref:System.Text.StringBuilder>, если число изменений велико.|

 Рассмотрим эти приемы более подробно.

-   Если целью поиска является определение того, существует ли конкретная подстрока (то есть если вы не заинтересованы в положении подстроки), можно искать строки перед их сохранением в объекте <xref:System.Text.StringBuilder>. В следующем примере показана одна возможная реализация. Он определяет класс `StringBuilderFinder`, конструктор которого передает ссылку на <xref:System.Text.StringBuilder> объект и подстроку для поиска в строке. В этом случае в примере предпринимается попытка определить, находится ли записанная температура в градусах Фаренгейта или Цельсия, и добавляет соответствующий вводный текст в начало объекта <xref:System.Text.StringBuilder>. Генератор случайных чисел используется для выбора массива, содержащего данные в градусах Цельсия или градусах Фаренгейта.

     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]

-   Вызовите метод <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>, чтобы преобразовать объект <xref:System.Text.StringBuilder> в объект <xref:System.String>. Можно выполнять поиск в строке с помощью таких методов, как <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> или <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, либо использовать регулярные выражения и класс <xref:System.Text.RegularExpressions.Regex> для поиска шаблонов. Поскольку как <xref:System.Text.StringBuilder>, так и <xref:System.String> объекты используют кодировку UTF-16 для хранения символов, позиции индекса, подстроки и совпадения регулярных выражений одинаковы в обоих объектах. Это позволяет использовать <xref:System.Text.StringBuilder> методы для внесения изменений в той же позиции, в которой этот текст находится в объекте <xref:System.String>.

    > [!NOTE]
    >  При применении этого подхода следует работать с конца объекта <xref:System.Text.StringBuilder> до его начала, чтобы не нужно было повторно преобразовывать объект <xref:System.Text.StringBuilder> в строку.

     Этот подход показан в приведенном ниже примере. Он сохраняет четыре вхождения каждой буквы английского алфавита в объект <xref:System.Text.StringBuilder>. Затем он преобразует текст в объект <xref:System.String> и использует регулярное выражение для обнаружения начальной позиции каждой последовательности из четырех символов. Наконец, он добавляет символ подчеркивания перед каждой последовательностью из четырех символов, за исключением первой последовательности, и преобразует первый символ последовательности в верхний регистр.

     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]

-   Используйте свойство <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> для последовательного поиска диапазона символов в объекте <xref:System.Text.StringBuilder>. Этот подход может оказаться нецелесообразным, если количество символов для поиска является большим или логика поиска особенно сложна. Сведения о влиянии на производительность при доступе к символьному индексу для очень больших, фрагментированных <xref:System.Text.StringBuilder> объектов см. в документации по свойству <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>.

     Следующий пример аналогичен функции предыдущего примера, но отличается в реализации. Он использует свойство <xref:System.Text.StringBuilder.Chars%2A> для обнаружения изменения значения символа, вставляет символ подчеркивания в эту точку и преобразует первый символ в новой последовательности в верхний регистр.

     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]

-   Сохраните весь неизмененный текст в объекте <xref:System.Text.StringBuilder>, вызовите метод <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>, чтобы преобразовать объект <xref:System.Text.StringBuilder> в объект <xref:System.String> и выполнить изменения в объекте <xref:System.String>. Этот подход можно использовать, если имеется всего несколько изменений. в противном случае стоимость работы с неизменяемыми строками может отрицательно отменять производительность при использовании объекта <xref:System.Text.StringBuilder>.

     Следующий пример аналогичен функциям предыдущих двух примеров, но отличается в реализации. Он создает объект <xref:System.Text.StringBuilder>, преобразует его в <xref:System.String> объект, а затем использует регулярное выражение для выполнения всех оставшихся изменений в строке. Метод <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> использует лямбда-выражение для замены каждого соответствия.

     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]

<a name="Converting"></a>
## <a name="converting-the-stringbuilder-object-to-a-string"></a>Преобразование объекта StringBuilder в строку
 Необходимо преобразовать объект <xref:System.Text.StringBuilder> в <xref:System.String>, прежде чем передавать представленную объектом <xref:System.Text.StringBuilder> строку методу, который содержит параметр <xref:System.String>, или вывести ее в пользовательском интерфейсе. Это преобразование выполняется путем вызова метода <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>. Иллюстрации см. в предыдущем примере, который вызывает метод <xref:System.Text.StringBuilder.ToString%2A> для преобразования объекта <xref:System.Text.StringBuilder> в строку, чтобы ее можно было передать в метод регулярного выражения.



## Examples
 В следующем примере показано, как вызвать множество методов, определенных классом <xref:System.Text.StringBuilder>.

 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]

 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Строковое значение этого экземпляра задается равным <xref:System.String.Empty?displayProperty=nameWithType>, а для емкости устанавливается емкость по умолчанию, зависящая от реализации.



## Examples
 В следующем примере показано, как вызвать конструктор <xref:System.Text.StringBuilder.%23ctor%2A> без параметров.

 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">The suggested starting size of this instance.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class using the specified capacity.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Параметр `capacity` определяет максимальное число символов, которые могут храниться в памяти, выделенной текущим экземпляром. Его значение присваивается свойству <xref:System.Text.StringBuilder.Capacity%2A>. Если число символов, сохраняемых в текущем экземпляре, превышает это значение `capacity`, объект <xref:System.Text.StringBuilder> выделяет дополнительную память для их хранения.

 Строковое значение этого экземпляра равно <xref:System.String.Empty?displayProperty=nameWithType>. Если `capacity` равен нулю, используется емкость по умолчанию, зависящая от реализации.



## Examples
 В следующем примере показано, как вызвать конструктор <xref:System.Text.StringBuilder.%23ctor%2A> с заданной емкостью.

 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> is less than zero.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string used to initialize the value of the instance. If <paramref name="value" /> is <see langword="null" />, the new <see cref="T:System.Text.StringBuilder" /> will contain the empty string (that is, it contains <see cref="F:System.String.Empty" />).</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class using the specified string.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Если `value` равно `null`, то новый <xref:System.Text.StringBuilder> будет содержать пустую строку (то есть, он содержит <xref:System.String.Empty>).



## Examples
 В следующем примере показано, как вызвать конструктор <xref:System.Text.StringBuilder.%23ctor%2A> с указанной строкой.

 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">The suggested starting size of the <see cref="T:System.Text.StringBuilder" />.</param>
        <param name="maxCapacity">The maximum number of characters the current string can contain.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class that starts with a specified capacity and can grow to a specified maximum.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Параметр `capacity` определяет максимальное число символов, которые могут храниться в памяти, выделенной текущим экземпляром. Его значение присваивается свойству <xref:System.Text.StringBuilder.Capacity%2A>. Если число символов, сохраняемых в текущем экземпляре, превышает это значение `capacity`, объект <xref:System.Text.StringBuilder> выделяет дополнительную память для их хранения.

 Если `capacity` равен нулю, используется емкость по умолчанию, зависящая от реализации.

 Свойство `maxCapacity` определяет максимальное число символов, которое может храниться в текущем экземпляре. Его значение присваивается свойству <xref:System.Text.StringBuilder.MaxCapacity%2A>. Если число символов, сохраняемых в текущем экземпляре, превышает это значение `maxCapacity`, объект <xref:System.Text.StringBuilder> не выделяет дополнительную память, а вместо этого создает исключение.



## Examples
 В следующем примере показано, как вызвать конструктор <xref:System.Text.StringBuilder.%23ctor%2A> с заданной емкостью и максимальной емкостью.

 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxCapacity" /> is less than one, <paramref name="capacity" /> is less than zero, or <paramref name="capacity" /> is greater than <paramref name="maxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The string used to initialize the value of the instance. If <paramref name="value" /> is <see langword="null" />, the new <see cref="T:System.Text.StringBuilder" /> will contain the empty string (that is, it contains <see cref="F:System.String.Empty" />).</param>
        <param name="capacity">The suggested starting size of the <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class using the specified string and capacity.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Параметр `capacity` определяет максимальное число символов, которые могут храниться в памяти, выделенной текущим экземпляром. Его значение присваивается свойству <xref:System.Text.StringBuilder.Capacity%2A>. Если число символов, сохраняемых в текущем экземпляре, превышает это значение `capacity`, объект <xref:System.Text.StringBuilder> выделяет дополнительную память для их хранения.

 Если `capacity` равен нулю, используется емкость по умолчанию, зависящая от реализации.



## Examples
 В следующем примере показано, как вызвать конструктор <xref:System.Text.StringBuilder.%23ctor%2A> с начальной строкой и заданной емкостью.

 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> is less than zero.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The string that contains the substring used to initialize the value of this instance. If <paramref name="value" /> is <see langword="null" />, the new <see cref="T:System.Text.StringBuilder" /> will contain the empty string (that is, it contains <see cref="F:System.String.Empty" />).</param>
        <param name="startIndex">The position within <paramref name="value" /> where the substring begins.</param>
        <param name="length">The number of characters in the substring.</param>
        <param name="capacity">The suggested starting size of the <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.StringBuilder" /> class from the specified substring and capacity.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Параметр `capacity` определяет максимальное число символов, которые могут храниться в памяти, выделенной текущим экземпляром. Его значение присваивается свойству <xref:System.Text.StringBuilder.Capacity%2A>. Если число символов, сохраняемых в текущем экземпляре, превышает это значение `capacity`, объект <xref:System.Text.StringBuilder> выделяет дополнительную память для их хранения.

 Если `capacity` равен нулю, используется емкость по умолчанию, зависящая от реализации.



## Examples
 В следующем примере показано, как вызвать конструктор <xref:System.Text.StringBuilder.%23ctor%2A> с указанной строкой.

 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> is less than zero.

-or-

 <paramref name="startIndex" /> plus <paramref name="length" /> is not a position within <paramref name="value" />.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Appends the string representation of a specified object to this instance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">The Boolean value to append.</param>
        <summary>Appends the string representation of a specified Boolean value to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.Append%28System.Boolean%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]

 Метод <xref:System.Text.StringBuilder.Append%28System.Boolean%29> вызывает метод <xref:System.Boolean.ToString?displayProperty=nameWithType>, чтобы получить строковое представление `value`. Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 8-bit unsigned integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.Append%28System.Byte%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]

 Метод <xref:System.Text.StringBuilder.Append%28System.Byte%29> вызывает метод <xref:System.Byte.ToString%28System.IFormatProvider%29>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">The UTF-16-encoded code unit to append.</param>
        <summary>Appends the string representation of a specified <see cref="T:System.Char" /> object to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.Append%28System.Char%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">The array of characters to append.</param>
        <summary>Appends the string representation of the Unicode characters in a specified array to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Этот метод добавляет все символы в указанном массиве к текущему экземпляру в том же порядке, в котором они отображаются в `value`. Если `value` `null`, изменения не вносятся.

 Метод <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified decimal number to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.Append%28System.Decimal%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]

 Метод <xref:System.Text.StringBuilder.Append%28System.Decimal%29> вызывает метод <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified double-precision floating-point number to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.Append%28System.Double%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]

 Метод <xref:System.Text.StringBuilder.Append%28System.Double%29> вызывает метод <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 16-bit signed integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.Append%28System.Int16%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]

 Метод <xref:System.Text.StringBuilder.Append%28System.Int16%29> вызывает метод <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 32-bit signed integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.Append%28System.Int32%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]

 Метод <xref:System.Text.StringBuilder.Append%28System.Int32%29> вызывает метод <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 64-bit signed integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.Append%28System.Int64%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]

 Метод <xref:System.Text.StringBuilder.Append%28System.Int64%29> вызывает <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The object to append.</param>
        <summary>Appends the string representation of a specified object to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.Append%28System.Object%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере. Он определяет класс `Dog`, создает объект `Dog` и выполняет три вызова метода <xref:System.Text.StringBuilder.Append%2A>, чтобы создать строку, содержащую имя и породу Dog.

 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]

 Метод <xref:System.Text.StringBuilder.Append%28System.Object%29> вызывает метод <xref:System.Object.ToString%2A?displayProperty=nameWithType>, чтобы получить строковое представление `value`. Если `value` `null`, то в объект <xref:System.Text.StringBuilder> не вносятся изменения.

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlyMemory`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlyMemory(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlyMemory&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlyMemory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">The read-only character memory region to append.</param>
        <summary>Appends the string representation of a specified read-only character memory region to this instance.</summary>
        <returns>A reference to this instance after the append operation is completed.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">The read-only character span to append.</param>
        <summary>Appends the string representation of a specified read-only character span to this instance.</summary>
        <returns>A reference to this instance after the append operation is completed.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 8-bit signed integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.Append%28System.SByte%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]

 Метод <xref:System.Text.StringBuilder.Append%28System.SByte%29> вызывает метод <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified single-precision floating-point number to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.Append%28System.Single%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]

 Метод <xref:System.Text.StringBuilder.Append%28System.Single%29> вызывает метод <xref:System.Single.ToString%2A?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to append.</param>
        <summary>Appends a copy of the specified string to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.Append%28System.String%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]

 Если `value` `null`, изменения не вносятся.

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">The string builder to append.</param>
        <summary>Appends the string representation of a specified string builder to this instance.</summary>
        <returns>A reference to this instance after the append operation is completed.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 16-bit unsigned integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.Append%28System.UInt16%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]

 Метод <xref:System.Text.StringBuilder.Append%28System.UInt16%29> вызывает метод <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, чтобы получить строковое представление `value`. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 32-bit unsigned integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.Append%28System.UInt32%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]

 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> вызывает метод <xref:System.UInt32.ToString%2A?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">The value to append.</param>
        <summary>Appends the string representation of a specified 64-bit unsigned integer to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.Append%28System.UInt64%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]

 Метод <xref:System.Text.StringBuilder.Append%28System.UInt64%29> вызывает метод <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>, чтобы получить строковое представление `value` для текущего языка и региональных параметров. Чтобы управлять форматированием `value`, вызовите метод <xref:System.Text.StringBuilder.AppendFormat%2A>.

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The character to append.</param>
        <param name="repeatCount">The number of times to append <paramref name="value" />.</param>
        <summary>Appends a specified number of copies of the string representation of a Unicode character to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="repeatCount" /> is less than zero.

-or-

Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Out of memory.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A pointer to an array of characters.</param>
        <param name="valueCount">The number of characters in the array.</param>
        <summary>Appends an array of Unicode characters starting at a specified address to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Этот метод добавляет `valueCount` символов, начиная с адреса `value` с текущим экземпляром.

 Метод <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. По этой причине можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>.

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="valueCount" /> is less than zero.

-or-

Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> is a null pointer.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A character array.</param>
        <param name="startIndex">The starting position in <paramref name="value" />.</param>
        <param name="charCount">The number of characters to append.</param>
        <summary>Appends the string representation of a specified subarray of Unicode characters to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Этот метод добавляет указанный диапазон символов в `value` к текущему экземпляру. Если `value` имеет значение `null` а `startIndex` и `count` равны нулю, изменения не вносятся.

 Метод <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is <see langword="null" />, and <paramref name="startIndex" /> and <paramref name="charCount" /> are not zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> is less than zero.

-or-

 <paramref name="startIndex" /> is less than zero.

-or-

 <paramref name="startIndex" /> + <paramref name="charCount" /> is greater than the length of <paramref name="value" />.

-or-

Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The string that contains the substring to append.</param>
        <param name="startIndex">The starting position of the substring within <paramref name="value" />.</param>
        <param name="count">The number of characters in <paramref name="value" /> to append.</param>
        <summary>Appends a copy of a specified substring to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Этот метод добавляет указанный диапазон символов в `value` к текущему экземпляру. Если `value` имеет значение `null` а `startIndex` и `count` равны нулю, изменения не вносятся.

 Метод <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> изменяет существующий экземпляр этого класса. Он не возвращает новый экземпляр класса. В связи с этим можно вызвать метод или свойство для существующей ссылки, и вам не нужно присваивать возвращаемое значение объекту <xref:System.Text.StringBuilder>, как показано в следующем примере.

 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is <see langword="null" />, and <paramref name="startIndex" /> and <paramref name="count" /> are not zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> less than zero.

-or-

 <paramref name="startIndex" /> less than zero.

-or-

 <paramref name="startIndex" /> + <paramref name="count" /> is greater than the length of <paramref name="value" />.

-or-

Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">The string builder that contains the substring to append.</param>
        <param name="startIndex">The starting position of the substring within <paramref name="value" />.</param>
        <param name="count">The number of characters in <paramref name="value" /> to append.</param>
        <summary>Appends a copy of a substring within a specified string builder to this instance.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a corresponding object argument.</summary>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">A composite format string.</param>
        <param name="arg0">An object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a single argument.</summary>
        <returns>A reference to this instance with <paramref name="format" /> appended. Each format item in <paramref name="format" /> is replaced by the string representation of <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в текущий объект <xref:System.Text.StringBuilder>.

 Параметр `format` состоит из нуля или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами формата. Индекс элементов формата должен быть равен 0, чтобы соответствовать `arg0`, один объект в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования строковым представлением `arg0`.

 Синтаксис элемента форматирования выглядит следующим образом:

 {*index*[,*length*] [:*FormatString*]}

 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.

|Элемент|Описание|
|-------------|-----------------|
|*номер*|Отсчитываемая от нуля координата в списке параметров объекта для форматирования. Если объект, указанный в *индексе* , имеет `null`, элемент форматирования заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если в позиции *индекса* нет параметра, выдается <xref:System.FormatException>.|
|,*Длина*|Минимальное число символов в строковом представлении параметра. Если положительный, параметр размещается по правому краю; Если отрицательное, то оно по левому краю.|
|:*FormatString*|Строка стандартного или пользовательского формата, поддерживаемая параметром.|

> [!NOTE]
>  Для строк стандартного и пользовательского формата, используемых со значениями даты и времени, см. раздел [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Сведения о строках стандартных и пользовательских форматов, используемых с числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые с перечислениями, см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).

 `arg0` представляет форматируемый объект. Каждый элемент формата в `format` заменяется строковым представлением `arg0`. Если элемент форматирования включает `formatString` и `arg0` реализует интерфейс <xref:System.IFormattable>, то `arg0.ToString(formatString, null)` определяет форматирование. В противном случае `arg0.ToString()` определяет форматирование.

 Если строка, назначенная `format`, равна "Благодарим вас за ваше пожертвование {0: # # # #} за продукты в нашей благотворительной организации". а `arg0` — целое число со значением 10, возвращаемое значение будет "Благодарим вас за участие в 10 десятках продуктов нашей компании".



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.AppendFormat%2A>.

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> is invalid.

-or-

The index of a format item is less than 0 (zero), or greater than or equal to 1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">A composite format string.</param>
        <param name="args">An array of objects to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a corresponding argument in a parameter array.</summary>
        <returns>A reference to this instance with <paramref name="format" /> appended. Each format item in <paramref name="format" /> is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в текущий объект <xref:System.Text.StringBuilder>.

 Параметр `format` состоит из нуля или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объектам в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования строковым представлением соответствующего объекта.

 Синтаксис элемента форматирования выглядит следующим образом:

 {*index*[,*length*] [:*FormatString*]}

 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.

|Элемент|Описание|
|-------------|-----------------|
|*номер*|Отсчитываемая от нуля координата в списке параметров объекта для форматирования. Если объект, указанный в *индексе* , имеет `null`, элемент форматирования заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если в позиции *индекса* нет параметра, выдается <xref:System.FormatException>.|
|,*Длина*|Минимальное число символов в строковом представлении параметра. Если положительный, параметр размещается по правому краю; Если отрицательное, то оно по левому краю.|
|:*FormatString*|Строка стандартного или пользовательского формата, поддерживаемая параметром.|

> [!NOTE]
>  Для строк стандартного и пользовательского формата, используемых со значениями даты и времени, см. раздел [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Сведения о строках стандартных и пользовательских форматов, используемых с числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые с перечислениями, см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).

 `args` представляет объекты для форматирования. Каждый элемент формата в `format` заменяется строковым представлением соответствующего объекта в `args`. Если элемент форматирования включает `formatString` и соответствующий объект в `args` реализует интерфейс <xref:System.IFormattable>, `args[index].ToString(formatString, provider)` определяет форматирование. В противном случае `args[index].ToString()` определяет форматирование.

 Если строка, назначенная `format`, равна "Благодарим вас за ваше пожертвование {0: # # # #} за продукты в нашей благотворительной организации". а `arg0` — целое число со значением 10, возвращаемое значение будет "Благодарим вас за участие в 10 десятках продуктов нашей компании".



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.AppendFormat%2A>.

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> is invalid.

-or-

The index of a format item is less than 0 (zero), or greater than or equal to the length of the <paramref name="args" /> array.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <param name="format">A composite format string.</param>
        <param name="arg0">The object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a single argument using a specified format provider.</summary>
        <returns>A reference to this instance after the append operation has completed. After the append operation, this instance contains any data that existed before the operation, suffixed by a copy of <paramref name="format" /> in which any format specification is replaced by the string representation of <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения `arg0` в текстовое представление и внедрения этого представления в текущий объект <xref:System.Text.StringBuilder>.

 Параметр `format` состоит из нуля или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами формата. Индекс каждого элемента формата должен быть равен нулю (0), так как этот метод включает список аргументов с одним аргументом. Процесс форматирования заменяет каждый элемент форматирования строковым представлением `arg0`.

 Синтаксис элемента форматирования выглядит следующим образом:

 {*index*[,*length*] [:*FormatString*]}

 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.

|Элемент|Описание|
|-------------|-----------------|
|*номер*|Отсчитываемая от нуля координата в списке параметров объекта для форматирования. Если объект, указанный в *индексе* , имеет `null`, элемент форматирования заменяется <xref:System.String.Empty?displayProperty=nameWithType>. В этом случае, поскольку метод <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> содержит один аргумент в списке аргументов, значение *индекса* всегда должно быть равно 0. Если это не так, выдается <xref:System.FormatException>.|
|,*Длина*|Минимальное число символов в строковом представлении параметра. Если положительный, параметр размещается по правому краю; Если отрицательное, то оно по левому краю.|
|:*FormatString*|Строка стандартного или пользовательского формата, поддерживаемая параметром.|

> [!NOTE]
>  Для строк стандартного и пользовательского формата, используемых со значениями даты и времени, см. раздел [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Сведения о строках стандартных и пользовательских форматов, используемых с числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые с перечислениями, см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).

 Параметр `provider` указывает реализацию <xref:System.IFormatProvider>, которая может предоставлять сведения о форматировании для объектов в `args`. `provider` может быть одним из следующих:

-   Объект <xref:System.Globalization.CultureInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами.

-   Объект <xref:System.Globalization.NumberFormatInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами, для `arg0`, если это числовое значение.

-   Объект <xref:System.Globalization.DateTimeFormatInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами, для `arg0`, если это значение даты и времени.

-   Пользовательская реализация <xref:System.IFormatProvider>, которая предоставляет сведения о форматировании для `arg0`. Как правило, такая реализация также реализует интерфейс <xref:System.ICustomFormatter>.

 Если параметр `provider` имеет значение `null`, сведения о форматировании получаются из текущего языка и региональных параметров.

 `arg0` представляет форматируемый объект. Каждый элемент формата в `format` заменяется строковым представлением `arg0`. Если элемент форматирования включает `formatString` и `arg0` реализует интерфейс <xref:System.IFormattable>, то `arg0.ToString(formatString, provider)` определяет форматирование. В противном случае `arg0.ToString()` определяет форматирование.



## Examples
 Ниже приведены два вызова метода <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29>. Оба варианта используют соглашения о форматировании для языка и региональных параметров «Английский (EN-GB)». Первый Вставляет строковое представление валюты <xref:System.Decimal> значений в результирующую строку. Вторая вставляет <xref:System.DateTime> значение в двух местах в результирующей строке, первый включает только краткую строку даты и вторую короткую строку времени.

 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> is invalid.

-or-

The index of a format item is less than 0 (zero), or greater than or equal to one (1).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Практическое руководство. Определение и использование настраиваемых поставщиков числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <param name="format">A composite format string.</param>
        <param name="args">An array of objects to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of a corresponding argument in a parameter array using a specified format provider.</summary>
        <returns>A reference to this instance after the append operation has completed. After the append operation, this instance contains any data that existed before the operation, suffixed by a copy of <paramref name="format" /> where any format specification is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в текущий объект <xref:System.Text.StringBuilder>.

 Параметр `format` состоит из нуля или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объектам в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования строковым представлением соответствующего объекта.

 Синтаксис элемента форматирования выглядит следующим образом:

 {*index*[,*length*] [:*FormatString*]}

 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.

|Элемент|Описание|
|-------------|-----------------|
|*номер*|Отсчитываемая от нуля координата в списке параметров объекта для форматирования. Если объект, указанный в *индексе* , имеет `null`, элемент форматирования заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если в позиции *индекса* нет параметра, выдается <xref:System.FormatException>.|
|,*Длина*|Минимальное число символов в строковом представлении параметра. Если положительный, параметр размещается по правому краю; Если отрицательное, то оно по левому краю.|
|:*FormatString*|Строка стандартного или пользовательского формата, поддерживаемая параметром.|

> [!NOTE]
>  Для строк стандартного и пользовательского формата, используемых со значениями даты и времени, см. раздел [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Сведения о строках стандартных и пользовательских форматов, используемых с числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые с перечислениями, см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).

 Параметр `provider` указывает реализацию <xref:System.IFormatProvider>, которая может предоставлять сведения о форматировании для объектов в `args`. `provider` может быть одним из следующих:

-   Объект <xref:System.Globalization.CultureInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами.

-   Объект <xref:System.Globalization.NumberFormatInfo>, предоставляющий сведения об особенностях форматирования для числовых значений в `args`.

-   Объект <xref:System.Globalization.DateTimeFormatInfo>, предоставляющий сведения об особенностях форматирования для значений даты и времени в `args`.

-   Пользовательская реализация <xref:System.IFormatProvider>, которая предоставляет сведения о форматировании для одного или нескольких объектов в `args`. Как правило, такая реализация также реализует интерфейс <xref:System.ICustomFormatter>. Во втором примере в следующем разделе показан вызов метода <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> с реализацией пользовательского <xref:System.IFormatProvider>.

 Если параметр `provider` имеет значение `null`, сведения о поставщике формата получаются из текущего языка и региональных параметров.

 `args` представляет объекты для форматирования. Каждый элемент формата в `format` заменяется строковым представлением соответствующего объекта в `args`. Если элемент форматирования включает `formatString` и соответствующий объект в `args` реализует интерфейс <xref:System.IFormattable>, `args[index].ToString(formatString, provider)` определяет форматирование. В противном случае `args[index].ToString()` определяет форматирование.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.AppendFormat%2A>.

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 В следующем примере определяется пользовательская реализация <xref:System.IFormatProvider> с именем `CustomerFormatter`, которая форматирует 10-значный номер клиента дефисами после четвертой и седьмой цифр. Он передается методу <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> для создания строки, содержащей отформатированный номер клиента и имя клиента.

 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> is invalid.

-or-

The index of a format item is less than 0 (zero), or greater than or equal to the length of the <paramref name="args" /> array.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Практическое руководство. Определение и использование настраиваемых поставщиков числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">A composite format string.</param>
        <param name="arg0">The first object to format.</param>
        <param name="arg1">The second object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of either of two arguments.</summary>
        <returns>A reference to this instance with <paramref name="format" /> appended. Each format item in <paramref name="format" /> is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в текущий объект <xref:System.Text.StringBuilder>.

 Параметр `format` содержит ноль или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют `arg0` и `arg1`, два объекта в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования строковым представлением соответствующего объекта.

 Синтаксис элемента форматирования выглядит следующим образом:

 {*index*[,*length*] [:*FormatString*]}

 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.

|Элемент|Описание|
|-------------|-----------------|
|*номер*|Отсчитываемая от нуля координата в списке параметров объекта для форматирования. Если объект, указанный в *индексе* , имеет `null`, элемент форматирования заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если в позиции *индекса* нет параметра, выдается <xref:System.FormatException>.|
|,*Длина*|Минимальное число символов в строковом представлении параметра. Если положительный, параметр размещается по правому краю; Если отрицательное, то оно по левому краю.|
|:*FormatString*|Строка стандартного или пользовательского формата, поддерживаемая параметром.|

> [!NOTE]
>  Для строк стандартного и пользовательского формата, используемых со значениями даты и времени, см. раздел [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Сведения о строках стандартных и пользовательских форматов, используемых с числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые с перечислениями, см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).

 `arg0` и `arg1` представляют объекты для форматирования. Каждый элемент формата в `format` заменяется строковым представлением `arg0` или `arg1`. Если элемент форматирования включает `formatString` и соответствующий объект реализует интерфейс <xref:System.IFormattable>, то `arg`*x*`.ToString(formatString, provider)` определяет форматирование, где *x* — индекс аргумента. В противном случае форматирование определяется `arg`*x*`.ToString()`.

 Если строка, назначенная `format`, равна "Благодарим вас за ваше пожертвование {0: # # # #} за продукты в нашей благотворительной организации". а `arg0` — целое число со значением 10, возвращаемое значение будет "Благодарим вас за участие в 10 десятках продуктов нашей компании".



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.AppendFormat%2A>.

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> is invalid.

-or-

The index of a format item is less than 0 (zero), or greater than or equal to 2.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <param name="format">A composite format string.</param>
        <param name="arg0">The first object to format.</param>
        <param name="arg1">The second object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of either of two arguments using a specified format provider.</summary>
        <returns>A reference to this instance after the append operation has completed. After the append operation, this instance contains any data that existed before the operation, suffixed by a copy of <paramref name="format" /> where any format specification is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в текущий объект <xref:System.Text.StringBuilder>.

 Параметр `format` состоит из нуля или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объектам в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования строковым представлением соответствующего объекта.

 Синтаксис элемента форматирования выглядит следующим образом:

 {*index*[,*length*] [:*FormatString*]}

 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.

|Элемент|Описание|
|-------------|-----------------|
|*номер*|Отсчитываемая от нуля координата в списке параметров объекта для форматирования. Если объект, указанный в *индексе* , имеет `null`, элемент форматирования заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если в позиции *индекса* нет параметра, выдается <xref:System.FormatException>.|
|,*Длина*|Минимальное число символов в строковом представлении параметра. Если положительный, параметр размещается по правому краю; Если отрицательное, то оно по левому краю.|
|:*FormatString*|Строка стандартного или пользовательского формата, поддерживаемая параметром.|

> [!NOTE]
>  Для строк стандартного и пользовательского формата, используемых со значениями даты и времени, см. раздел [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Сведения о строках стандартных и пользовательских форматов, используемых с числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые с перечислениями, см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).

 Параметр `provider` указывает реализацию <xref:System.IFormatProvider>, которая может предоставить сведения о форматировании для `arg0` и `arg1`. `provider` может быть одним из следующих:

-   Объект <xref:System.Globalization.CultureInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами.

-   Объект <xref:System.Globalization.NumberFormatInfo>, предоставляющий сведения об особенностях форматирования для языка и региональных параметров для `arg0` или `arg1`, если они являются числовыми значениями.

-   Объект <xref:System.Globalization.DateTimeFormatInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами, для `arg0` или `arg1`, если они являются значениями даты и времени.

-   Пользовательская реализация <xref:System.IFormatProvider>, которая предоставляет сведения о форматировании для `arg0` и `arg1`. Как правило, такая реализация также реализует интерфейс <xref:System.ICustomFormatter>.

 Если параметр `provider` имеет значение `null`, сведения о поставщике формата получаются из текущего языка и региональных параметров.

 `arg0` и `arg1` представляют объекты для форматирования. Каждый элемент формата в `format` заменяется строковым представлением объекта с соответствующим индексом. Если элемент форматирования включает `formatString` и соответствующий аргумент реализует интерфейс <xref:System.IFormattable>, то форматирование определяется методом `ToString(formatString, provider)` аргумента. В противном случае форматирование определяет метод `ToString()` аргумента.



## Examples
 В следующем примере используется метод <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> для вывода данных о времени и температуре, хранящихся в универсальном <xref:System.Collections.Generic.Dictionary%602> объекте. Обратите внимание, что строка формата имеет три элемента форматирования, хотя есть только объекты для форматирования. Это происходит потому, что первый объект в списке (значение даты и времени) используется двумя элементами форматирования: в первом элементе форматирования отображается время, а во втором отображается дата.

 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> is invalid.

-or-

The index of a format item is less than 0 (zero), or greater than or equal to 2 (two).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>ИИН .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра <see cref="T:System.Text.StringBuilder" /> с помощью вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Практическое руководство. Определение и использование настраиваемых поставщиков числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">A composite format string.</param>
        <param name="arg0">The first object to format.</param>
        <param name="arg1">The second object to format.</param>
        <param name="arg2">The third object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of either of three arguments.</summary>
        <returns>A reference to this instance with <paramref name="format" /> appended. Each format item in <paramref name="format" /> is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в текущий объект <xref:System.Text.StringBuilder>.

 Параметр `format` состоит из нуля или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют `arg0` с помощью `arg2`, объектов в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования строковым представлением соответствующего объекта.

 Синтаксис элемента форматирования выглядит следующим образом:

 {*index*[,*length*] [:*FormatString*]}

 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.

|Элемент|Описание|
|-------------|-----------------|
|*номер*|Отсчитываемая от нуля координата в списке параметров объекта для форматирования. Если объект, указанный в *индексе* , имеет `null`, элемент форматирования заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если в позиции *индекса* нет параметра, выдается <xref:System.FormatException>.|
|,*Длина*|Минимальное число символов в строковом представлении параметра. Если положительный, параметр размещается по правому краю; Если отрицательное, то оно по левому краю.|
|:*FormatString*|Строка стандартного или пользовательского формата, поддерживаемая параметром.|

> [!NOTE]
>  Для строк стандартного и пользовательского формата, используемых со значениями даты и времени, см. раздел [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Сведения о строках стандартных и пользовательских форматов, используемых с числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые с перечислениями, см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).

 `arg0`, `arg1`и `arg2` представляют объекты для форматирования. Каждый элемент формата в `format` заменяется строковым представлением `arg0`, `arg1`или `arg2`в зависимости от индекса элемента формата. Если элемент форматирования включает `formatString` и соответствующий объект в `args` реализует интерфейс <xref:System.IFormattable>, то `arg`*x*`.ToString(formatString, null)` определяет форматирование, где *x* — индекс аргумента. В противном случае форматирование определяется `arg`*x*`.ToString()`.

 Если строка, назначенная `format`, равна "Благодарим вас за ваше пожертвование {0: # # # #} за продукты в нашей благотворительной организации". а `arg0` — целое число со значением 10, возвращаемое значение будет "Благодарим вас за участие в 10 десятках продуктов нашей компании".



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.AppendFormat%2A>.

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> is invalid.

-or-

The index of a format item is less than 0 (zero), or greater than or equal to 3.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <param name="format">A composite format string.</param>
        <param name="arg0">The first object to format.</param>
        <param name="arg1">The second object to format.</param>
        <param name="arg2">The third object to format.</param>
        <summary>Appends the string returned by processing a composite format string, which contains zero or more format items, to this instance. Each format item is replaced by the string representation of either of three arguments using a specified format provider.</summary>
        <returns>A reference to this instance after the append operation has completed. After the append operation, this instance contains any data that existed before the operation, suffixed by a copy of <paramref name="format" /> where any format specification is replaced by the string representation of the corresponding object argument.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Этот метод использует [функцию составного форматирования](~/docs/standard/base-types/composite-formatting.md) .NET Framework для преобразования значения объекта в текстовое представление и внедрения этого представления в текущий объект <xref:System.Text.StringBuilder>.

 Параметр `format` состоит из нуля или более фрагментов текста, которые пересмешиваются с нулевым или более индексированными заполнителями, называемыми элементами форматирования, которые соответствуют объектам в списке параметров этого метода. Процесс форматирования заменяет каждый элемент форматирования строковым представлением соответствующего объекта.

 Синтаксис элемента форматирования выглядит следующим образом:

 {*index*[,*length*] [:*FormatString*]}

 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.

|Элемент|Описание|
|-------------|-----------------|
|*номер*|Отсчитываемая от нуля координата в списке параметров объекта для форматирования. Если объект, указанный в *индексе* , имеет `null`, элемент форматирования заменяется <xref:System.String.Empty?displayProperty=nameWithType>. Если в позиции *индекса* нет параметра, выдается <xref:System.FormatException>.|
|,*Длина*|Минимальное число символов в строковом представлении параметра. Если положительный, параметр размещается по правому краю; Если отрицательное, то оно по левому краю.|
|:*FormatString*|Строка стандартного или пользовательского формата, поддерживаемая параметром.|

> [!NOTE]
>  Для строк стандартного и пользовательского формата, используемых со значениями даты и времени, см. раздел [строки стандартных форматов даты и времени](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [строки настраиваемых форматов даты и времени](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Сведения о строках стандартных и пользовательских форматов, используемых с числовыми значениями, см. в разделе [строки стандартных числовых форматов](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md). Строки стандартного формата, используемые с перечислениями, см. в разделе [строки формата перечисления](~/docs/standard/base-types/enumeration-format-strings.md).

 Параметр `provider` указывает реализацию <xref:System.IFormatProvider>, которая может предоставить сведения о форматировании для `arg0` и `arg1`. `provider` может быть одним из следующих:

-   Объект <xref:System.Globalization.CultureInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами.

-   Объект <xref:System.Globalization.NumberFormatInfo>, предоставляющий сведения об особенностях форматирования для языка и региональных параметров для `arg0` или `arg1`, если они являются числовыми значениями.

-   Объект <xref:System.Globalization.DateTimeFormatInfo>, предоставляющий сведения об особенностях форматирования, связанных с языком и региональными параметрами для `arg0`, `arg1`или `arg2`, если они являются значениями даты и времени.

-   Пользовательская реализация <xref:System.IFormatProvider>, которая предоставляет сведения о форматировании для `arg0`, `arg1`и `arg2`. Как правило, такая реализация также реализует интерфейс <xref:System.ICustomFormatter>.

 Если параметр `provider` имеет значение `null`, сведения о поставщике формата получаются из текущего языка и региональных параметров.

 `arg0`, `arg1`и `arg2` представляют объекты для форматирования. Каждый элемент формата в `format` заменяется строковым представлением объекта с соответствующим индексом. Если элемент форматирования включает `formatString` и соответствующий аргумент реализует интерфейс <xref:System.IFormattable>, то форматирование определяется методом `ToString(formatString, provider)` аргумента. В противном случае форматирование определяет метод `ToString()` аргумента.



## Examples
 В следующем примере используется метод <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> для иллюстрации результата операции логического `And` с целочисленными значениями. Обратите внимание, что строка формата включает шесть элементов форматирования, но метод имеет только три элемента в списке аргументов, поскольку каждый элемент форматируется двумя разными способами.

 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> is invalid.

-or-

The index of a format item is less than 0 (zero), or greater than or equal to 3 (three).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the expanded string would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Типы форматирования в .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Составное форматирование</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Практическое руководство. Определение и использование настраиваемых поставщиков числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Строки стандартных числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Строки настраиваемых числовых форматов</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Строки стандартных форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Строки настраиваемых форматов даты и времени</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Строки стандартного формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Строки пользовательского формата TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Строки форматов перечисления</related>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">The character to use as a separator. <paramref name="separator" /> is included in the joined strings only if <paramref name="values" /> has more than one element.</param>
        <param name="values">An array that contains the strings to concatenate and append to the current instance of the string builder.</param>
        <summary>Concatenates the string representations of the elements in the provided array of objects, using the specified char separator between each member, then appends the result to the current instance of the string builder.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">The character to use as a separator. <paramref name="separator" /> is included in the joined strings only if <paramref name="values" /> has more than one element.</param>
        <param name="values">An array that contains the strings to concatenate and append to the current instance of the string builder.</param>
        <summary>Concatenates the strings of the provided array, using the specified char separator between each string, then appends the result to the current instance of the string builder.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">The string to use as a separator. <paramref name="separator" /> is included in the joined strings only if <paramref name="values" /> has more than one element.</param>
        <param name="values">An array that contains the strings to concatenate and append to the current instance of the string builder.</param>
        <summary>Concatenates the string representations of the elements in the provided array of objects, using the specified separator between each member, then appends the result to the current instance of the string builder.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">The string to use as a separator. <paramref name="separator" /> is included in the joined strings only if <paramref name="values" /> has more than one element.</param>
        <param name="values">An array that contains the strings to concatenate and append to the current instance of the string builder.</param>
        <summary>Concatenates the strings of the provided array, using the specified separator between each string, then appends the result to the current instance of the string builder.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов параметра <paramref name="values" />.</typeparam>
        <param name="separator">The character to use as a separator. <paramref name="separator" /> is included in the concatenated and appended strings only if <paramref name="values" /> has more than one element.</param>
        <param name="values">A collection that contains the objects to concatenate and append to the current instance of the string builder.</param>
        <summary>Concatenates and appends the members of a collection, using the specified char separator between each member.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Тип элементов параметра <paramref name="values" />.</typeparam>
        <param name="separator">The string to use as a separator. <paramref name="separator" /> is included in the concatenated and appended strings only if <paramref name="values" /> has more than one element.</param>
        <param name="values">A collection that contains the objects to concatenate and append to the current instance of the string builder.</param>
        <summary>Concatenates and appends the members of a collection, using the specified separator between each member.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Appends the default line terminator, or a copy of a specified string and the default line terminator, to the end of this instance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appends the default line terminator to the end of the current <see cref="T:System.Text.StringBuilder" /> object.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Признак конца строки по умолчанию — текущее значение свойства <xref:System.Environment.NewLine%2A?displayProperty=nameWithType>.

 Емкость этого экземпляра корректируется по мере необходимости.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.AppendLine%2A>.

 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">The string to append.</param>
        <summary>Appends a copy of the specified string followed by the default line terminator to the end of the current <see cref="T:System.Text.StringBuilder" /> object.</summary>
        <returns>A reference to this instance after the append operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Признак конца строки по умолчанию — текущее значение свойства <xref:System.Environment.NewLine%2A?displayProperty=nameWithType>.

 Емкость этого экземпляра корректируется по мере необходимости.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <see cref="T:System.Text.StringBuilder" /> путем вызова конструктора <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> Длина и емкость экземпляра <see cref="T:System.Text.StringBuilder" /> могут увеличиваться за пределами значения свойства <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Это может произойти в частности при вызове методов <see cref="M:System.Text.StringBuilder.Append(System.String)" /> и <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> для добавления небольших строк.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum number of characters that can be contained in the memory allocated by the current instance.</summary>
        <value>Максимальное число символов, которое может содержаться в памяти, назначенной текущим экземпляром. Это значение может меняться в диапазоне от <see cref="P:System.Text.StringBuilder.Length" /> до <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Capacity%2A> не влияет на строковое значение текущего экземпляра. <xref:System.Text.StringBuilder.Capacity%2A> можно уменьшить, если он не меньше <xref:System.Text.StringBuilder.Length%2A>.

 <xref:System.Text.StringBuilder> динамически выделяет дополнительное пространство при необходимости и повышает <xref:System.Text.StringBuilder.Capacity%2A> соответствующим образом. По соображениям производительности <xref:System.Text.StringBuilder> может выделить больше памяти, чем требуется. Объем выделенной памяти зависит от конкретной реализации.



## Examples
 В следующем примере демонстрируется свойство <xref:System.Text.StringBuilder.Capacity%2A>.

 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is less than the current length of this instance.

 -or-

 The value specified for a set operation is greater than the maximum capacity.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The position of the character.</param>
        <summary>Gets or sets the character at the specified character position in this instance.</summary>
        <value>Символ Юникода в позиции <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Параметр `index` — это расположение символа в <xref:System.Text.StringBuilder>. Первый символ в строке находится по индексу 0. Длина строки — это количество содержащихся в ней символов. Последний доступный символ <xref:System.Text.StringBuilder> экземпляра находится в индексе <xref:System.Text.StringBuilder.Length%2A>-1.

 <xref:System.Text.StringBuilder.Chars%2A> является свойством по умолчанию класса <xref:System.Text.StringBuilder>. В C#это индексатор. Это означает, что отдельные символы можно получить из свойства <xref:System.Text.StringBuilder.Chars%2A>, как показано в следующем примере, который подсчитывает количество алфавитных, пробелов и знаков препинания в строке.

 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]

### <a name="performance-and-character-based-indexing"></a>Производительность и индексирование на основе символов

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is outside the bounds of this instance while setting a character.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> is outside the bounds of this instance while getting a character.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes all characters from the current <see cref="T:System.Text.StringBuilder" /> instance.</summary>
        <returns>An object whose <see cref="P:System.Text.StringBuilder.Length" /> is 0 (zero).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<xref:System.Text.StringBuilder.Clear%2A> — это удобный метод, эквивалентный присвоению свойству <xref:System.Text.StringBuilder.Length%2A> текущего экземпляра значения 0 (ноль).

## Examples

В следующем примере создается экземпляр <xref:System.Text.StringBuilder> объекта со строкой, вызывается метод <xref:System.Text.StringBuilder.Clear%2A>, а затем добавляется новая строка.

[!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
[!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">The starting position in this instance where characters will be copied from. The index is zero-based.</param>
        <param name="destination">The writable span where characters will be copied.</param>
        <param name="count">The number of characters to be copied.</param>
        <summary>Copies the characters from a specified segment of this instance to a destination <see cref="T:System.Char" /> span.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.CopyTo%2A> предназначен для использования в редких ситуациях, когда необходимо эффективно копировать последовательные разделы <xref:System.Text.StringBuilder> объекта в диапазон.

 Например, приложение может заполнить <xref:System.Text.StringBuilder> объект с большим количеством символов, а затем использовать метод <xref:System.Text.StringBuilder.CopyTo%2A> для копирования мелких последовательных фрагментов объекта <xref:System.Text.StringBuilder> в диапазон, где обрабатываются элементы. Когда все данные в объекте <xref:System.Text.StringBuilder> обрабатываются, размер <xref:System.Text.StringBuilder> объекта устанавливается равным нулю и цикл повторяется.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destination" Type="System.Char[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">The starting position in this instance where characters will be copied from. The index is zero-based.</param>
        <param name="destination">The array where characters will be copied.</param>
        <param name="destinationIndex">The starting position in <paramref name="destination" /> where characters will be copied. The index is zero-based.</param>
        <param name="count">The number of characters to be copied.</param>
        <summary>Copies the characters from a specified segment of this instance to a specified segment of a destination <see cref="T:System.Char" /> array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Метод <xref:System.Text.StringBuilder.CopyTo%2A> предназначен для использования в редких ситуациях, когда необходимо эффективно копировать последовательные разделы <xref:System.Text.StringBuilder> объекта в массив. Массив должен быть фиксированным размером, предварительно выделенным, многократно используемым и, возможно, глобально доступным.

 Например, приложение может заполнить <xref:System.Text.StringBuilder> объект с большим количеством символов, а затем использовать метод <xref:System.Text.StringBuilder.CopyTo%2A> для копирования мелких последовательных фрагментов объекта <xref:System.Text.StringBuilder> в массив, где обрабатываются элементы. Когда все данные в объекте <xref:System.Text.StringBuilder> обрабатываются, размер <xref:System.Text.StringBuilder> объекта устанавливается равным нулю и цикл повторяется.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.CopyTo%2A>.

 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />, <paramref name="destinationIndex" />, or <paramref name="count" />, is less than zero.

-or-

 <paramref name="sourceIndex" /> is greater than the length of this instance.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> + <paramref name="count" /> is greater than the length of this instance.

-or-

 <paramref name="destinationIndex" /> + <paramref name="count" /> is greater than the length of <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">The minimum capacity to ensure.</param>
        <summary>Ensures that the capacity of this instance of <see cref="T:System.Text.StringBuilder" /> is at least the specified value.</summary>
        <returns>The new capacity of this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Если текущая емкость меньше, чем параметр `capacity`, память для этого экземпляра повторно выделяется для хранения как минимум `capacity` числа символов; в противном случае память не изменяется.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.EnsureCapacity%2A>.

 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> is less than zero.

-or-

Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="span">The character span to compare with the current instance.</param>
        <summary>Returns a value indicating whether the characters in this instance are equal to the characters in a specified read-only character span.</summary>
        <returns><see langword="true" /> if the characters in this instance and <paramref name="span" /> are the same; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Метод `Equals` выполняет порядковое сравнение, чтобы определить, равны ли символы в текущем экземпляре и `span`.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">An object to compare with this instance, or <see langword="null" />.</param>
        <summary>Returns a value indicating whether this instance is equal to a specified object.</summary>
        <returns><see langword="true" /> if this instance and <paramref name="sb" /> have equal string, <see cref="P:System.Text.StringBuilder.Capacity" />, and <see cref="P:System.Text.StringBuilder.MaxCapacity" /> values; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

**.NET Framework и .NET Core 2,2 и предыдущие версии:** Текущий экземпляр и `sb` равны, если они имеют одинаковые значения String, <xref:System.Text.StringBuilder.Capacity>и <xref:System.Text.StringBuilder.MaxCapacity>. Метод `Equals` использует порядковое сравнение для определения того, равны ли строки.

**.NET Core 3,0 и более поздние версии:** Текущий экземпляр и `sb` равны, если строки, назначенные обоим объектам <xref:System.Text.StringBuilder>, одинаковы.  Чтобы определить равенство, метод `Equals` использует порядковое сравнение. Значения свойств <xref:System.Text.StringBuilder.Capacity> и <xref:System.Text.StringBuilder.MaxCapacity> не используются в сравнении.

## Examples
 В следующем коде используется метод <xref:System.Text.StringBuilder.Equals%2A> для проверки того, равны ли два объекта <xref:System.Text.StringBuilder>. Метод вызывается повторно после внесения небольших изменений в каждый объект, и результаты отображаются в консоли.

 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChunks">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder.ChunkEnumerator GetChunks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringBuilder/ChunkEnumerator GetChunks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.GetChunks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChunks () As StringBuilder.ChunkEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder::ChunkEnumerator GetChunks();" />
      <MemberSignature Language="F#" Value="member this.GetChunks : unit -&gt; System.Text.StringBuilder.ChunkEnumerator" Usage="stringBuilder.GetChunks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder+ChunkEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an object that can be used to iterate through the chunks of characters represented in a <see langword="ReadOnlyMemory&lt;Char&gt;" /> created from this <see cref="T:System.Text.StringBuilder" /> instance.</summary>
        <returns>An enumerator for the chunks in the <see langword="ReadOnlyMemory&lt;Char&gt;" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Вы можете выполнить итерацию фрагментов в диапазоне памяти с помощью кода, подобного следующему:

```csharp
foreach (ReadOnlyMemory<char> chunk in sb.GetChunks())
    foreach(char ch in chunk.Span)
        { /* operations on ch */ }
```

Этот метод предназначен для эффективного извлечения данных *константного* <xref:System.Text.StringBuilder>. Если <xref:System.Text.StringBuilder> изменяется в то время, как перечисление фрагментов не является полным, результат будет неопределенным. <xref:System.Text.StringBuilder> также не является потокобезопасным, поэтому его работа с параллельными потоками недопустима.

Возвращенные фрагменты <xref:System.ReadOnlyMemory%601> не всегда остаются неизменными при изменении <xref:System.Text.StringBuilder>, поэтому не следует кэшировать их для последующего использования.

Создание <xref:System.ReadOnlySpan%601> из <xref:System.ReadOnlyMemory%601> (как метод <xref:System.ReadOnlyMemory%601.Span?displayProperty=nameWithType> в предыдущем примере является дорогостоящим, поэтому создайте локальную переменную для этого диапазона, если ее нужно использовать во вложенном операторе `for`. Например:

```csharp
foreach (ReadOnlyMemory<char> chunk in sb.GetChunks())
{
    var span = chunk.Span;
    for(int i = 0; i < span.Length; i++)
    {
        /* operations on span[i] */
    }
}
```

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inserts the string representation of a specified object into this instance at a specified character position.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a Boolean value into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости емкость корректируется.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a specified 8-bit unsigned integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a specified Unicode character into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero or greater than the length of this instance.

-or-

Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The character array to insert.</param>
        <summary>Inserts the string representation of a specified array of Unicode characters into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.

 Если `value` `null`, <xref:System.Text.StringBuilder> не изменяется.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero or greater than the length of this instance.

-or-

Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a decimal number into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a double-precision floating-point number into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a specified 16-bit signed integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a specified 32-bit signed integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a 64-bit signed integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The object to insert, or <see langword="null" />.</param>
        <summary>Inserts the string representation of an object into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.

 Если `value` `null`, значение этого экземпляра не изменяется.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The character span to insert.</param>
        <summary>Inserts the sequence of characters into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Существующие символы сдвигаются, чтобы освободить место для последовательности символов в `value` для вставки. При необходимости емкость корректируется.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a specified 8-bit signed integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости емкость корректируется.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a single-precision floating point number into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The string to insert.</param>
        <summary>Inserts a string into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Существующие символы сдвигаются, чтобы освободить место для нового текста. При необходимости емкость корректируется.

 Этот экземпляр <xref:System.Text.StringBuilder> не изменяется, если `value` `null`или `value` не `null`, но его длина равна нулю.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero or greater than the current length of this instance.

-or-

The current length of this <see cref="T:System.Text.StringBuilder" /> object plus the length of <paramref name="value" /> exceeds <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a 16-bit unsigned integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a 32-bit unsigned integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The value to insert.</param>
        <summary>Inserts the string representation of a 64-bit unsigned integer into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> используется для получения строкового представления `value`. Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero or greater than the length of this instance.</exception>
        <exception cref="T:System.OutOfMemoryException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>В [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] и более ранних версиях вызовы этого метода породили <see cref="T:System.ArgumentOutOfRangeException" /> если вставка <paramref name="value" /> приведет к превышению общей длины объекта <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]метод создает исключение <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">The string to insert.</param>
        <param name="count">The number of times to insert <paramref name="value" />.</param>
        <summary>Inserts one or more copies of a specified string into this instance at the specified character position.</summary>
        <returns>A reference to this instance after insertion has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.

 Этот объект <xref:System.Text.StringBuilder> не изменяется, если `value` `null`, `value` не `null`, но его длина равна нулю или `count` равен нулю.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than zero or greater than the current length of this instance.

-or-

 <paramref name="count" /> is less than zero.</exception>
        <exception cref="T:System.OutOfMemoryException">The current length of this <see cref="T:System.Text.StringBuilder" /> object plus the length of <paramref name="value" /> times <paramref name="count" /> exceeds <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The position in this instance where insertion begins.</param>
        <param name="value">A character array.</param>
        <param name="startIndex">The starting index within <paramref name="value" />.</param>
        <param name="charCount">The number of characters to insert.</param>
        <summary>Inserts the string representation of a specified subarray of Unicode characters into this instance at the specified character position.</summary>
        <returns>A reference to this instance after the insert operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Существующие символы сдвигаются, чтобы освободить место для нового текста. Емкость этого экземпляра корректируется по мере необходимости.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Insert%2A>.

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is <see langword="null" />, and <paramref name="startIndex" /> and <paramref name="charCount" /> are not zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />, <paramref name="startIndex" />, or <paramref name="charCount" /> is less than zero.

-or-

 <paramref name="index" /> is greater than the length of this instance.

-or-

 <paramref name="startIndex" /> plus <paramref name="charCount" /> is not a position within <paramref name="value" />.

-or-

Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the length of the current <see cref="T:System.Text.StringBuilder" /> object.</summary>
        <value>Длина этого экземпляра.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Длина объекта <xref:System.Text.StringBuilder> определяется по количеству <xref:System.Char> объектов.

 Как и свойство <xref:System.String.Length%2A?displayProperty=nameWithType>, свойство <xref:System.Text.StringBuilder.Length%2A> указывает длину текущего строкового объекта. В отличие от свойства <xref:System.String.Length%2A?displayProperty=nameWithType>, которое доступно только для чтения, свойство <xref:System.Text.StringBuilder.Length%2A> позволяет изменить длину строки, хранящейся в объекте <xref:System.Text.StringBuilder>.

 Если указанная длина меньше текущей длины, текущий объект <xref:System.Text.StringBuilder> усекается до указанной длины. Если указанная длина больше текущей длины, конец строкового значения текущего <xref:System.Text.StringBuilder> объекта дополняется символом NULL в Юникоде (U + 0000).

 Если указанная длина больше текущей емкости, <xref:System.Text.StringBuilder.Capacity%2A> увеличивается, чтобы она была больше или равна указанной длине.



## Examples
 В следующем примере демонстрируется свойство <xref:System.Text.StringBuilder.Length%2A>.

 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is less than zero or greater than <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum capacity of this instance.</summary>
        <value>Наибольшее количество символов, которое может содержать данный экземпляр.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Максимальная емкость для этой реализации — <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Однако это значение зависит от реализации и может отличаться в других реализациях или более поздних версиях. Можно явно задать максимальную емкость объекта <xref:System.Text.StringBuilder>, вызвав конструктор <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>.

В .NET Core и в .NET Framework 4,0 и более поздних версиях при создании экземпляра объекта <xref:System.Text.StringBuilder> путем вызова конструктора <xref:System.Text.StringBuilder.%23ctor(System.Int32,System.Int32)> Длина и емкость экземпляра <xref:System.Text.StringBuilder> могут увеличиваться за пределами значения свойства <xref:System.Text.StringBuilder.MaxCapacity>. Это может произойти в частности при вызове методов <xref:System.Text.StringBuilder.Append(System.String)> и <xref:System.Text.StringBuilder.AppendFormat(System.String,System.Object)> для добавления небольших строк.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">The zero-based position in this instance where removal begins.</param>
        <param name="length">The number of characters to remove.</param>
        <summary>Removes the specified range of characters from this instance.</summary>
        <returns>A reference to this instance after the excise operation has completed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Текущий метод удаляет указанный диапазон символов из текущего экземпляра. Символы в (`startIndex` + `length`) перемещаются в `startIndex`, а строковое значение текущего экземпляра сокращается на `length`. Емкость текущего экземпляра не затрагивается.

> [!NOTE]
>  Метод <xref:System.Text.StringBuilder.Remove%2A> изменяет значение текущего экземпляра <xref:System.Text.StringBuilder> и возвращает этот экземпляр. Он не создает и не возвращает новый объект <xref:System.Text.StringBuilder>.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Remove%2A>.

 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="startIndex" /> or <paramref name="length" /> is less than zero, or <paramref name="startIndex" /> + <paramref name="length" /> is greater than the length of this instance.</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Replaces all occurrences of a specified character or string in this instance with another specified character or string.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">The character to replace.</param>
        <param name="newChar">The character that replaces <paramref name="oldChar" />.</param>
        <summary>Replaces all occurrences of a specified character in this instance with another specified character.</summary>
        <returns>A reference to this instance with <paramref name="oldChar" /> replaced by <paramref name="newChar" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Этот метод выполняет порядковый номер, сравнение с учетом регистра для обнаружения вхождений `oldChar` в текущем экземпляре. После замены размер текущего экземпляра <xref:System.Text.StringBuilder> не изменяется.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Replace%2A>.

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">The string to replace.</param>
        <param name="newValue">The string that replaces <paramref name="oldValue" />, or <see langword="null" />.</param>
        <summary>Replaces all occurrences of a specified string in this instance with another specified string.</summary>
        <returns>A reference to this instance with all instances of <paramref name="oldValue" /> replaced by <paramref name="newValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Этот метод выполняет порядковый номер, сравнение с учетом регистра для обнаружения вхождений `oldValue` в текущем экземпляре. Если `newValue` имеет `null` или <xref:System.String.Empty?displayProperty=nameWithType>, удаляются все вхождения `oldValue`.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Replace%2A>.

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The length of <paramref name="oldValue" /> is zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">The character to replace.</param>
        <param name="newChar">The character that replaces <paramref name="oldChar" />.</param>
        <param name="startIndex">The position in this instance where the substring begins.</param>
        <param name="count">The length of the substring.</param>
        <summary>Replaces, within a substring of this instance, all occurrences of a specified character with another specified character.</summary>
        <returns>A reference to this instance with <paramref name="oldChar" /> replaced by <paramref name="newChar" /> in the range from <paramref name="startIndex" /> to <paramref name="startIndex" /> + <paramref name="count" /> -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Этот метод выполняет порядковый номер, сравнение с учетом регистра для обнаружения вхождений `oldChar` в текущем экземпляре. После замены размер текущего объекта <xref:System.Text.StringBuilder> не изменяется.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Replace%2A>.

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> + <paramref name="count" /> is greater than the length of the value of this instance.

-or-

 <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">The string to replace.</param>
        <param name="newValue">The string that replaces <paramref name="oldValue" />, or <see langword="null" />.</param>
        <param name="startIndex">The position in this instance where the substring begins.</param>
        <param name="count">The length of the substring.</param>
        <summary>Replaces, within a substring of this instance, all occurrences of a specified string with another specified string.</summary>
        <returns>A reference to this instance with all instances of <paramref name="oldValue" /> replaced by <paramref name="newValue" /> in the range from <paramref name="startIndex" /> to <paramref name="startIndex" /> + <paramref name="count" /> - 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Этот метод выполняет порядковое сравнение с учетом регистра для обнаружения вхождений `oldValue` в указанной подстроке. Если `newValue` имеет `null` или <xref:System.String.Empty?displayProperty=nameWithType>, удаляются все вхождения `oldValue`.



## Examples
 В следующем примере демонстрируется метод <xref:System.Text.StringBuilder.Replace%2A>.

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The length of <paramref name="oldValue" /> is zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> or <paramref name="count" /> is less than zero.

-or-

 <paramref name="startIndex" /> plus <paramref name="count" /> indicates a character position not within this instance.

-or-

Enlarging the value of this instance would exceed <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">The object to populate with serialization information.</param>
        <param name="context">The place to store and retrieve serialized data. Reserved for future use.</param>
        <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with the data necessary to deserialize the current <see cref="T:System.Text.StringBuilder" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Параметр `context` зарезервирован для будущего использования и не участвует в этой операции.

 Дополнительные сведения см. в описании метода <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType>.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts the value of a <see cref="T:System.Text.StringBuilder" /> to a <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converts the value of this instance to a <see cref="T:System.String" />.</summary>
        <returns>A string whose value is the same as this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Необходимо вызвать метод <xref:System.Text.StringBuilder.ToString%2A> для преобразования объекта <xref:System.Text.StringBuilder> в <xref:System.String> объект, прежде чем передавать строку, представленную объектом <xref:System.Text.StringBuilder>, в метод, имеющий параметр <xref:System.String> или отображаемый в пользовательском интерфейсе.



## Examples
 В следующем примере демонстрируется вызов метода <xref:System.Text.StringBuilder.ToString%2A>. Этот пример является частью большого примера, приведенного для класса <xref:System.Text.StringBuilder>.

 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">The starting position of the substring in this instance.</param>
        <param name="length">The length of the substring.</param>
        <summary>Converts the value of a substring of this instance to a <see cref="T:System.String" />.</summary>
        <returns>A string whose value is the same as the specified substring of this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Необходимо вызвать метод <xref:System.Text.StringBuilder.ToString%2A> для преобразования объекта <xref:System.Text.StringBuilder> в <xref:System.String> объект, прежде чем передавать строку, представленную объектом <xref:System.Text.StringBuilder>, в метод, имеющий параметр <xref:System.String> или отображаемый в пользовательском интерфейсе.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.

-or-

The sum of <paramref name="startIndex" /> and <paramref name="length" /> is greater than the length of the current instance.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
