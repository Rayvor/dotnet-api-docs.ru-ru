<Type Name="HtmlElement" FullName="System.Windows.Forms.HtmlElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bce80241b72d7a09d5c7b0585a7cc810a5d7113d" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70418560" /></Metadata><TypeSignature Language="C#" Value="public sealed class HtmlElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HtmlElement extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.HtmlElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HtmlElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class HtmlElement sealed" />
  <TypeSignature Language="F#" Value="type HtmlElement = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Представляет элемент HTML в пределах веб-страницы.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement>представляет любой возможный тип элемента в HTML-документе, например `BODY`, `TABLE`, и `FORM`, среди прочих. Класс предоставляет наиболее распространенные свойства, которые можно найти на всех элементах.  
  
 Большинство элементов могут иметь *дочерние элементы*: другие элементы HTML, размещенные под ними. Используйте свойство, чтобы проверить, имеет ли данный элемент дочерние элементы <xref:System.Windows.Forms.HtmlElement.Children%2A> , и коллекцию для итерации по ним. <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> Свойство возвращает объект, <xref:System.Windows.Forms.HtmlElement> в котором вложен текущий элемент. <xref:System.Windows.Forms.HtmlElement.Parent%2A>  
  
 Часто требуется доступ <xref:System.Windows.Forms.HtmlElement>к атрибутам, свойствам и методам базового элемента, которые не предоставляются напрямую, например `SRC` атрибут `IMG` элемента или `Submit` метода в `FORM`. Методы <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> и <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> позволяют извлекать и изменять любые атрибуты или свойства определенного элемента, а также предоставляют доступ к любым методам, не предоставляемым в управляемом модель DOM (DOM). Если приложение имеет разрешение на неуправляемый код, можно также получить доступ к непредоставляемым свойствам и <xref:System.Windows.Forms.HtmlElement.DomElement%2A> методам с атрибутом.  
  
 <xref:System.Windows.Forms.HtmlElement.TagName%2A> Используйте свойство, чтобы проверить, относится ли элемент к конкретному типу.  
  
 Любой HTML-документ можно изменить во время выполнения. Вы можете создать новые <xref:System.Windows.Forms.HtmlElement> объекты <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> с помощью метода <xref:System.Windows.Forms.HtmlDocument> <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> и добавить их в другой элемент, используя методы или <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> . Можно также создать элементы в виде HTML-тегов и назначить их <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> свойству существующего элемента.  
  
   
  
## Examples  
 В следующем примере кода показано, как проверить произвольный HTML-документ и получить строку, описывающую элементы HTML, с использованием отступов и номеров уровней, используемых для указания того, насколько глубоко вложены элементы в документе. В этом примере кода требуется, чтобы в приложении <xref:System.Windows.Forms.WebBrowser> размещается элемент управления с именем `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlElement#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104876">Интерфейс Ихтмлелемент</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104877">Интерфейс IHTMLElement2</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104878">Интерфейс IHTMLElement3</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104879">Интерфейс IHTMLElement4</related>
  </Docs>
  <Members>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection All" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.All" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property All As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ All { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.All : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlElement.All" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию <see cref="T:System.Windows.Forms.HtmlElementCollection" /> всех элементов, расположенных под текущим элементом.</summary>
        <value>Коллекция всех элементов, которые являются прямыми или косвенными потомками текущего. Например <see cref="P:System.Windows.Forms.HtmlElement.All" /> , если текущий элемент является <c>таблицей</c>, то функция возвращает каждый элемент <c>th</c>, <c>tr</c>и <c>TD</c> внутри таблицы, а также любые другие элементы, такие как <c>div</c> и <c>span</c> , содержащиеся в элементе ячеек.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить доступ только к тем элементам, которые имеют текущий элемент в качестве непосредственного родителя <xref:System.Windows.Forms.HtmlElement.Children%2A> , используйте вместо этого коллекцию.  
  
 Элементы в этой коллекции не обязательно будут возвращены в исходном порядке.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.Children" />
      </Docs>
    </Member>
    <Member MemberName="AppendChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement AppendChild (System.Windows.Forms.HtmlElement newElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement AppendChild(class System.Windows.Forms.HtmlElement newElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.AppendChild(System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendChild (newElement As HtmlElement) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ AppendChild(System::Windows::Forms::HtmlElement ^ newElement);" />
      <MemberSignature Language="F#" Value="member this.AppendChild : System.Windows.Forms.HtmlElement -&gt; System.Windows.Forms.HtmlElement" Usage="htmlElement.AppendChild newElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newElement" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="newElement">Объект <see cref="T:System.Windows.Forms.HtmlElement" />, добавляемый в это расположение в дереве.</param>
        <summary>Добавляет элемент в поддерево другого элемента.</summary>
        <returns>Элемент после добавления к дереву.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML-модель DOM (DOM) позволяет изменять содержимое HTML-файла во время выполнения несколькими способами. Используйте <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> для добавления новых элементов в существующий документ или для перемещения элемента на странице.  
  
 Если элемент уже был родительским, Добавление элемента к другому элементу автоматически удалит этот элемент из предыдущего родительского элемента.  
  
 Любые добавления, внесенные в документ во время выполнения с <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> помощью, не сохраняются при <xref:System.Windows.Forms.WebBrowser.ShowSaveAsDialog%2A> вызове метода для <xref:System.Windows.Forms.WebBrowser> элемента управления.  
  
   
  
## Examples  
 В следующем примере кода создается новая гиперссылка с помощью <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> метода, которая добавляется в конец страницы с помощью `AppendChild` `BODY` элемента. В примере требуется, чтобы приложение содержало <xref:System.Windows.Forms.WebBrowser> элемент управления с именем. `WebBrowser1`  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlElement#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.CreateElement(System.String)" />
        <related type="ExternalDocumentation" href="https://developer.mozilla.org/docs/Web/API/Node/appendChild">Метод appendChild</related>
      </Docs>
    </Member>
    <Member MemberName="AttachEventHandler">
      <MemberSignature Language="C#" Value="public void AttachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.AttachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.AttachEventHandler : string * EventHandler -&gt; unit" Usage="htmlElement.AttachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Имя события для обработки.</param>
        <param name="eventHandler">Управляемый код, обрабатывающий событие.</param>
        <summary>Добавляет обработчик событий для события с заданным именем в модели HTML DOM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Управляемый модель DOM (DOM) предоставляет только выбранное число событий. Большинство непредоставляемых событий определяются только для определенных типов элементов. Например, `FORM` событие, допустимое только для элементов. `submit` Используйте <xref:System.Windows.Forms.HtmlElement.AttachEventHandler%2A> для добавления обработчика событий к этим неоткрытым событиям.  
  
 Не следует прикреплять событие к документу или одному из его объектов до завершения загрузки документа. Самый ранний вызов этого метода заключается в <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> событии <xref:System.Windows.Forms.WebBrowser> элемента управления.  
  
 Дополнительные сведения о доступных неуправляемых событиях см. в разделе [доступ к неоткрытым членам в управляемых HTML-модель DOM](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md) и интерфейсах Ихтмлелемент [: ихтмлелемент](https://go.microsoft.com/fwlink/?LinkId=104876), [IHTMLElement2](https://go.microsoft.com/fwlink/?LinkId=104877), [IHTMLElement3](https://go.microsoft.com/fwlink/?LinkId=104878), [ IHTMLElement4](https://go.microsoft.com/fwlink/?LinkId=104879).  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://developer.mozilla.org/docs/Web/API/EventTarget/addEventListener">Евенттаржет. addEventListener ()</related>
      </Docs>
    </Member>
    <Member MemberName="CanHaveChildren">
      <MemberSignature Language="C#" Value="public bool CanHaveChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHaveChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.CanHaveChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanHaveChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHaveChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanHaveChildren : bool" Usage="System.Windows.Forms.HtmlElement.CanHaveChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, может ли текущий элемент иметь дочерние элементы.</summary>
        <value>Значение <see langword="true" />, если элемент может иметь дочерние элементы, и значение <see langword="false" /> в противном случае.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые элементы, такие как `IMG` и `SCRIPT`, не могут иметь дочерних элементов. Это свойство следует использовать перед <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> вызовом <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> или для произвольного элемента.  
  
   
  
## Examples  
 В следующем примере кода обрабатывается <xref:System.Windows.Forms.HtmlElement.Click> событие в <xref:System.Windows.Forms.HtmlDocument>. Если элемент не был выбран ранее с помощью щелчка мышью, код присваивает элемент переменной закрытого класса с именем `MoveElement`. Если элемент был выбран, код пытается добавить его в элемент, который был только что щелкнул. В <xref:System.Windows.Forms.WebBrowser> `WebBrowser1` <xref:System.Windows.Forms.HtmlElement.Click> этом примере кода предполагается, что в приложении размещается элемент управления с именем и уже добавлен обработчик событий для этого события. <xref:System.Windows.Forms.HtmlDocument>  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.HtmlElement#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Children" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Children As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Children { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Children : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlElement.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию <see cref="T:System.Windows.Forms.HtmlElementCollection" /> всех дочерних элементов для текущего элемента.</summary>
        <value>Коллекция всех объектов <see cref="T:System.Windows.Forms.HtmlElement" />, для которых текущий элемент является родительским.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Во многих элементах в HTML-файле могут находиться и другие элементы HTML. <xref:System.Windows.Forms.HtmlElement.Children%2A> Коллекция предоставляет простой механизм для изучения древовидной структуры документа.  
  
 <xref:System.Windows.Forms.HtmlElement.Children%2A>предоставляет только те элементы, прямой родительский элемент которых является текущим элементом. Если у вас есть <xref:System.Windows.Forms.HtmlElement> `TABLE` элемент для, <xref:System.Windows.Forms.HtmlElement.Children%2A> предоставит все `TR` элементы (строки) внутри `TABLE`. Чтобы получить `TD` элементы (ячейки), содержащиеся внутри `TR` элементов, необходимо использовать <xref:System.Windows.Forms.HtmlElement.Children%2A> коллекцию <xref:System.Windows.Forms.HtmlElement.All%2A> для каждого отдельного `TR` элемента или использовать коллекцию в <xref:System.Windows.Forms.HtmlElement>.  
  
 Элементы в этой коллекции не обязательно должны находиться в исходном порядке.  
  
 Если <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> имеет `false`значение , `Children`  всегда будет пустым.  
  
   
  
## Examples  
 В следующем примере кода изучается произвольный HTML-документ и извлекается строка, описывающая элементы, с использованием отступов и номеров уровней, используемых для указания того, насколько глубоко вложены элементы в документе. Для этого выполняется рекурсивный поиск `Children` в коллекции всех элементов, начиная с HTML-элемента в верхней части документа. В этом примере кода требуется, чтобы в приложении <xref:System.Windows.Forms.WebBrowser> был элемент `WebBrowser1`управления с именем.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlElement#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.All" />
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Click : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь щелкает элемент левой кнопкой мыши.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно отменить действие <xref:System.Windows.Forms.HtmlElement.Click> по умолчанию для события в элементе, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> задав `true`свойству <xref:System.Windows.Forms.HtmlElementEventArgs> класса значение.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Событие элемента также будет происходить в родительских элементах этого элемента и в самом классе, если только свойству класса не присвоено значение. <xref:System.Windows.Forms.HtmlElement.Click>  
  
 Если пользователь щелкнет элемент, который в данный момент не имеет фокуса ввода, <xref:System.Windows.Forms.HtmlElement.Click> событие будет происходить <xref:System.Windows.Forms.HtmlElement.Focusing> после <xref:System.Windows.Forms.HtmlElement.LostFocus> события, но перед событием для этого элемента.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.Click> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> или добавления сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.Click> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#432](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#432)]
 [!code-vb[System.Windows.Forms.EventExamples#432](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#432)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536913.aspx">Событие OnClick</related>
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ClientRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ClientRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.ClientRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает границы клиентской области элемента в HTML-документе.</summary>
        <value>Клиентская область, занимаемая элементом, минус области, занятые границами и полосами прокрутки. Чтобы получить расположение и размеры элемента с учетом крайних элементов, используйте свойство <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.ClientRectangle%2A>будет возвращать данные о положении только для элементов, которым были назначены явные высота и ширина, или элементы, использующие абсолютное позиционирование. Документ имеет абсолютное положение `absolute`, если его стиль позиции имеет значение, после чего его можно разместить в любой координате на HTML-странице.  
  
   
  
## Examples  
 Предположим, вы загрузили следующую HTML-страницу в размещенный экземпляр <xref:System.Windows.Forms.WebBrowser> элемента управления.  
  
```  
<HTML>  
  
    <BODY>  
  
        <DIV id="div1" style="position:absolute;top:100px;left:100px;border-      style:solid;border-width:1px;">  
            Edit this text.  
        </DIV>  
  
    </BODY>  
  
</HTML>  
```  
  
 В следующем примере кода демонстрируется получение этого элемента и расширение его измерений, если размер клиентской области меньше 400 пикселей в ширину на 50 пикселей, а также задает `DIV` `contentEditable` для состояния значение, чтобы пользователь мог ввести текст.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.HtmlElement#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533564.aspx">Клиентлефт, свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533565.aspx">Клиенттоп, свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533566.aspx">Клиентвидс, свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533563.aspx">Клиенсеигхт, свойство</related>
      </Docs>
    </Member>
    <Member MemberName="DetachEventHandler">
      <MemberSignature Language="C#" Value="public void DetachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.DetachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.DetachEventHandler : string * EventHandler -&gt; unit" Usage="htmlElement.DetachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Имя события для обработки.</param>
        <param name="eventHandler">Управляемый код, обрабатывающий событие.</param>
        <summary>Удаляет обработчик событий из события с заданным именем в модели HTML DOM.</summary>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536411.aspx">Метод Детачевент</related>
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlDocument Document { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlDocument Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Document" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Document As HtmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlDocument ^ Document { System::Windows::Forms::HtmlDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Document : System.Windows.Forms.HtmlDocument" Usage="System.Windows.Forms.HtmlElement.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Windows.Forms.HtmlDocument" />, к которому принадлежит данный элемент.</summary>
        <value>Родительский документ для этого элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые HTML-страницы могут размещать фреймы `FRAMESET` с помощью тегов. В этом случае каждый отдельный `FRAME` элемент будет содержать свой собственный <xref:System.Windows.Forms.HtmlDocument>экземпляр. Это свойство наиболее полезно <xref:System.Windows.Forms.HtmlElementEventArgs>, когда вы получили ссылку на элемент в обработчике событий из, и необходимо выполнить какое-либо действие над документом, в котором находится элемент.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.HtmlDocument" />
      </Docs>
    </Member>
    <Member MemberName="DomElement">
      <MemberSignature Language="C#" Value="public object DomElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DomElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.DomElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomElement As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DomElement { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomElement : obj" Usage="System.Windows.Forms.HtmlElement.DomElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает указатель на неуправляемый интерфейс для этого элемента.</summary>
        <value>Указатель <c>IUnknown</c> com для элемента, который можно привести к одному из ИНТЕРФЕЙСОВ HTML-элемента, например <c>ихтмлелемент</c>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement>— Это оболочка для модель DOM Internet Explorer (DOM), написанная с использованием модели COM. Если необходимо получить доступ к непредоставляемым свойствам или методам в базовых COM-интерфейсах, таких как `IHTMLElement`, этот объект можно использовать для запроса.  
  
 Чтобы использовать неуправляемые интерфейсы, необходимо импортировать библиотеку MSHTML (MSHTML. dll) в приложение. Однако можно также выполнять непредставляемые свойства и методы с помощью `Invoke` метода.  
  
   
  
## Examples  
 В следующем примере кода неуправляемые интерфейсы используются для выделения текущего текста и преобразования его в гиперссылку с URL-адресом, выбранным пользователем. Этот код был написан с учетом предположения, что форма содержит <xref:System.Windows.Forms.WebBrowser> элемент управления `WebBrowser1`с именем, и что вы добавили неуправляемую библиотеку MSHTML в качестве ссылки на проект.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.HtmlElement#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.DomDocument" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104877">Интерфейс IHTMLElement2</related>
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DoubleClick;" />
      <MemberSignature Language="F#" Value="member this.DoubleClick : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DoubleClick : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь дважды в течение краткого промежутка времени щелкает элемент левой кнопкой мыши.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Двойной щелчок определяется параметрами мыши операционной системы пользователя. Пользователь может задать время между нажатиями кнопки мыши, которые будут считаться двойным щелчком, а не двумя отдельными щелчками.  
  
 Можно отменить действие <xref:System.Windows.Forms.HtmlElement.DoubleClick> по умолчанию для события в элементе, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> задав `true`свойству <xref:System.Windows.Forms.HtmlElementEventArgs> класса значение.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Событие элемента также будет происходить в родительских элементах этого элемента и в самом классе, если только свойству класса не присвоено значение. <xref:System.Windows.Forms.HtmlElement.DoubleClick>  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.DoubleClick> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> или добавления сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.DoubleClick> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#433](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#433)]
 [!code-vb[System.Windows.Forms.EventExamples#433](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#433)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536921.aspx">Событие ондблкликк</related>
      </Docs>
    </Member>
    <Member MemberName="Drag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Drag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Drag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Drag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drag As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Drag;" />
      <MemberSignature Language="F#" Value="member this.Drag : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Drag : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь перетаскивает текст в различные места.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает при перетаскивании текста в следующие места:  
  
-   Внутри или между HTML-страницами, <xref:System.Windows.Forms.WebBrowser> размещенными в элементе управления или Internet Explorer  
  
-   В другое приложение  
  
-   На Рабочий стол Windows  
  
 Можно отменить действие <xref:System.Windows.Forms.HtmlElement.Drag> по умолчанию для события в элементе, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> задав `true`свойству <xref:System.Windows.Forms.HtmlElementEventArgs> класса значение.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Событие элемента также будет происходить в родительских элементах этого элемента и в самом классе, если только свойству класса не присвоено значение. <xref:System.Windows.Forms.HtmlElement.Drag>  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.Drag> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> или добавления сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.Drag> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#434](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#434)]
 [!code-vb[System.Windows.Forms.EventExamples#434](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#434)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536923.aspx">Событие ondrag</related>
      </Docs>
    </Member>
    <Member MemberName="DragEnd">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragEnd" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragEnd" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnd As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragEnd;" />
      <MemberSignature Language="F#" Value="member this.DragEnd : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragEnd : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь завершает операцию перетаскивания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно отменить действие <xref:System.Windows.Forms.HtmlElement.DragEnd> по умолчанию для события в элементе, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> задав `true`свойству <xref:System.Windows.Forms.HtmlElementEventArgs> класса значение.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Событие элемента также будет происходить в родительских элементах этого элемента и в самом классе, если только свойству класса не присвоено значение. <xref:System.Windows.Forms.HtmlElement.DragEnd>  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.DragEnd> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> или добавления сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.DragEnd> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#435](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#435)]
 [!code-vb[System.Windows.Forms.EventExamples#435](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#435)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536924.aspx">Событие ондраженд</related>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь прекращает перетаскивание объекта через этот элемент.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.DragLeave> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> или добавления сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.DragLeave> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#436](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#436)]
 [!code-vb[System.Windows.Forms.EventExamples#436](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#436)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь перетаскивает текст над элементом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно отменить действие <xref:System.Windows.Forms.HtmlElement.DragOver> по умолчанию для события в элементе, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> задав `true`свойству <xref:System.Windows.Forms.HtmlElementEventArgs> класса значение.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Событие элемента также будет происходить в родительских элементах этого элемента и в самом классе, если только свойству класса не присвоено значение. <xref:System.Windows.Forms.HtmlElement.DragOver>  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.DragOver> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> или добавления сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.DragOver> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#437](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#437)]
 [!code-vb[System.Windows.Forms.EventExamples#437](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#437)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536927.aspx">Событие OnDragOver</related>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.HtmlElement.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или устанавливает возможность ввода пользователем данных в этот элемент.</summary>
        <value>Значение <see langword="true" />, если элемент допускает ввод данных пользователем, и  значение <see langword="false" /> в противном случае.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для `FORM` таких элементов, как текстовые поля и переключатели, <xref:System.Windows.Forms.HtmlElement.Enabled%2A> при `false` установке параметра в значение будет запрещать пользователю использовать эти поля формы. Для других элементов, таких как `DIV` или `SPAN`, установка <xref:System.Windows.Forms.HtmlElement.Enabled%2A> значения `false` приведет к тому, что весь текст в элементе будет отображаться затененным, однако текст по-прежнему будет выбираться. Чтобы отменить выбор, добавьте обработчик события для недоступного `onselectstart` события <xref:System.Windows.Forms.HtmlElement.AttachEventHandler%2A> с помощью метода.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533734.aspx">отключенное свойство</related>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="htmlElement.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для проверки на равенство.</param>
        <summary>Проверяет, равен ли переданный объект текущему элементу.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="obj" /> является элементом <see cref="T:System.Windows.Forms.HtmlElement" />, и значение <see langword="false" /> в противном случае.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FirstChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement FirstChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement FirstChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.FirstChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FirstChild As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ FirstChild { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FirstChild : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.FirstChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает следующий элемент, расположенный под этим элементом в дереве документа.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.HtmlElement" />, представляющий первый элемент, расположенный под текущим элементом (в исходном порядке).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используется <xref:System.Windows.Forms.HtmlElement.FirstChild%2A> в сочетании с <xref:System.Windows.Forms.HtmlElement.NextSibling%2A> для прохода по дереву документа для HTML-документа.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533755.aspx">firstChild, свойство</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; unit" Usage="htmlElement.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Помещает фокус ввода пользователя в текущий элемент.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При установке фокуса на элемент оба элемента получают фокус и становится активным элементу. Например, элемент, имеющий фокус, будет возвращен <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> свойством объекта. <xref:System.Windows.Forms.HtmlDocument>  
  
 Все нажатия клавиш, введенные пользователем после <xref:System.Windows.Forms.HtmlElement.Focus%2A> вызова метода, будут отправлены в этот элемент.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536425.aspx">Метод Focus</related>
      </Docs>
    </Member>
    <Member MemberName="Focusing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Focusing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Focusing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Focusing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Focusing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Focusing;" />
      <MemberSignature Language="F#" Value="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда элемент впервые получает фокус ввода пользователя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элемент, получивший фокус перед переключением пользователя на другое приложение с помощью панели задач или клавиш ALT + TAB, получит <xref:System.Windows.Forms.HtmlElement.Focusing> события и <xref:System.Windows.Forms.HtmlElement.GotFocus> снова, когда пользователь вернется к приложению.  
  
 Вы не можете отменить поведение этого события по умолчанию. Чтобы удалить фокус из элемента, вызовите <xref:System.Windows.Forms.HtmlElement.Focus%2A> другой элемент в <xref:System.Windows.Forms.HtmlElement.GotFocus> рамках события.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Событие элемента также будет происходить на родительских элементах и в самом классе, если только свойству класса не присвоено значение. <xref:System.Windows.Forms.HtmlElement.Focusing>  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.Focusing> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.Focusing> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#438](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#438)]
 [!code-vb[System.Windows.Forms.EventExamples#438](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#438)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536935.aspx">Событие onfocusing</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public string GetAttribute (string attributeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetAttribute(string attributeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttribute (attributeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetAttribute(System::String ^ attributeName);" />
      <MemberSignature Language="F#" Value="member this.GetAttribute : string -&gt; string" Usage="htmlElement.GetAttribute attributeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="attributeName">Имя атрибута. В этом аргументе не учитывается регистр.</param>
        <summary>Возвращает значение атрибута с заданным именем в элементе.</summary>
        <returns>Значение этого атрибута в элементе, например значение <see cref="T:System.String" />. Если указанный атрибут не существует в этом элементе, возвращает пустую строку.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Атрибутом в HTML является любая допустимая пара "имя-значение" для этого элемента. <xref:System.Windows.Forms.HtmlElement>предоставляет только те атрибуты, которые являются общими для всех элементов, оставляя те, которые применяются только к определенным типам элементов. — Это предопределенный атрибут `IMG` для тега, например `DIV` , но не для тега. `SRC` Используйте <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> и <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>  для управления атрибутами, не предоставляемыми в управляемом модель DOM (DOM).  
  
 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A>и <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> не учитывают регистр.  
  
   
  
## Examples  
 Следующий `META` пример кода извлекает все теги в документе HTML, используя <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> для поиска `META` тега с именем `Description`. В этом примере приложение должно иметь <xref:System.Windows.Forms.WebBrowser> элемент управления с именем. `WebBrowser1`  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536429.aspx">Метод InAttribute</related>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection GetElementsByTagName (string tagName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElementCollection GetElementsByTagName(string tagName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementsByTagName (tagName As String) As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElementCollection ^ GetElementsByTagName(System::String ^ tagName);" />
      <MemberSignature Language="F#" Value="member this.GetElementsByTagName : string -&gt; System.Windows.Forms.HtmlElementCollection" Usage="htmlElement.GetElementsByTagName tagName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tagName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tagName">Имя тега, с которым извлекаются объекты <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Возвращает коллекцию элементов, представленных в HTML-коде, по заданному тегу <c>HTML</c>.</summary>
        <returns>Коллекция <see cref="T:System.Windows.Forms.HtmlElementCollection" />, содержащая все элементы, у которых имя тега <c>HTML</c> совпадает с <paramref name="tagName" />.</returns>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536439.aspx">Метод getElementsByTagName</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="htmlElement.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Служит хэш-функцией для определенного типа.</summary>
        <returns>Хэш-код для текущего объекта <see cref="T:System.Object" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда элемент получил фокус ввода пользователя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы не можете отменить поведение этого события по умолчанию или запретить его восходящую маршрутизацию. Чтобы удалить фокус из элемента, вызовите <xref:System.Windows.Forms.HtmlElement.Focus%2A> другой элемент в <xref:System.Windows.Forms.HtmlElement.GotFocus> рамках события.  
  
   
  
## Examples  
 Сохраните следующий код HTML в файл и загрузите <xref:System.Windows.Forms.WebBrowser> его в элемент управления в Windows Forms проекте.  
  
```  
<HTML>  
    <BODY>  
        <FORM name="form1">  
            <INPUT type="text" size=20 name="text1">  
            <INPUT type="text" size=20 name="text2">  
            <INPUT type="text" size=20 name="text3">  
        </FORM>  
    </BODY>  
</HTML>  
```  
  
 В следующем примере кода следующий `INPUT` элемент в последовательности табуляции не получает фокус ввода пользователя, если предыдущий элемент содержит менее пяти символов. В этом примере предполагается, что упомянутый выше HTML-файл загружается <xref:System.Windows.Forms.WebBrowser> в экземпляр `WebBrowser1`элемента управления с именем.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#15)]
 [!code-vb[System.Windows.Forms.HtmlElement#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#15)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536934.aspx">Событие onfocus</related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Id" />
      <MemberSignature Language="VB.NET" Value="Public Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Id : string with get, set" Usage="System.Windows.Forms.HtmlElement.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает метку, по которой определяется элемент.</summary>
        <value>Уникальный идентификатор элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.Id%2A>должно быть уникальным; нельзя использовать два элемента с одинаковыми <xref:System.Windows.Forms.HtmlElement.Id%2A> внутри одного документа. <xref:System.Windows.Forms.HtmlElement.Name%2A> Используйте свойство, чтобы предоставить один и тот же идентификатор группе логически связанных элементов.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.Name" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533880.aspx">Свойство ID</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534184.aspx">Свойство name</related>
      </Docs>
    </Member>
    <Member MemberName="InnerHtml">
      <MemberSignature Language="C#" Value="public string InnerHtml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerHtml" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.InnerHtml" />
      <MemberSignature Language="VB.NET" Value="Public Property InnerHtml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InnerHtml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerHtml : string with get, set" Usage="System.Windows.Forms.HtmlElement.InnerHtml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает разметку HTML, расположенную под этим элементом.</summary>
        <value>Разметка HTML, определяющая дочерние элементы текущего элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существует несколько способов добавления новых элементов в существующую HTML-страницу, например <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> методы и. <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> Использование <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> часто является самым быстрым способом добавления нового содержимого, когда необходимо задать множество атрибутов или стилей для новых элементов.  
  
 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A>отличается от <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> в, <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> который не будет включать HTML-код, представляющий объект, который вы вызываете. Дополнительные <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> сведения о разнице между этими двумя свойствами см. в разделе.  
  
 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> Удаляет все дочерние элементы, добавленные ранее к элементу. Если получить элемент из модели DOM и затем назначить новый HTML <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> свойству родителей, ссылка на этот элемент будет бесполезна и его поведение при вызове его свойств и методов не определено.  
  
 Для некоторых элементов параметр <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> не является допустимой операцией. Некоторые HTML-теги не имеют закрывающего тега, например `IMG` тега, и поэтому не могут содержать вложенные элементы. Некоторые теги, такие как `SCRIPT` тег, могут содержать только текстовое содержимое; Настройка <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> приведет к ошибке. Для обоих типов тегов <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> свойство будет возвращать `false`значение. Однако вы также не можете задать <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> для `TABLE` элементов `TR` и, так как при назначении этих элементов неправильно сформированный код HTML может повредить отрисовку документа. Используйте <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> `IHTMLTable` или методы `insertCell` `TABLE`и для неуправляемого интерфейса, чтобы добавить строки и ячейки в. `insertRow`  
  
 Если требуется только назначить текст элементу, а не HTML-разметке, используйте <xref:System.Windows.Forms.HtmlElement.InnerText%2A> свойство.  
  
 Присвоение значения приведет <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> к уничтожению любых текстовых значений, назначенных ранее с помощью. <xref:System.Windows.Forms.HtmlElement.InnerText%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Для этого элемента не допускается создание дочерних.</exception>
        <altmember cref="M:System.Windows.Forms.HtmlElement.AppendChild(System.Windows.Forms.HtmlElement)" />
        <altmember cref="M:System.Windows.Forms.HtmlElement.InsertAdjacentElement(System.Windows.Forms.HtmlElementInsertionOrientation,System.Windows.Forms.HtmlElement)" />
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerText" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533897.aspx">innerHTML, свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536452.aspx">Метод Инсертаджаценстмл</related>
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public string InnerText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.InnerText" />
      <MemberSignature Language="VB.NET" Value="Public Property InnerText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InnerText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerText : string with get, set" Usage="System.Windows.Forms.HtmlElement.InnerText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или устанавливает текст, присваиваемый элементу.</summary>
        <value>Текст элемента, не содержащий разметки HTML. Если элемент содержит дочерние элементы, будет сохраняться только текст этих элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке назначить HTML для элемента с помощью <xref:System.Windows.Forms.HtmlElement.InnerText%2A>HTML-код будет отображаться в документе как литералы, как если бы вы просматривали HTML в текстовом файле. Если присвоить HTML элементу с помощью <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> свойства, <xref:System.Windows.Forms.HtmlElement.InnerText%2A> будет возвращен весь текст в этом HTML-коде с удаленной разметкой.  
  
 Присвоение значения приведет <xref:System.Windows.Forms.HtmlElement.InnerText%2A> к уничтожению всех дочерних элементов, принадлежащих элементу.  
  
   
  
## Examples  
 Следующий код создает новую гиперссылку с помощью <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>и назначает текст ссылке <xref:System.Windows.Forms.HtmlElement.InnerText%2A> с помощью свойства.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlElement#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Указанный элемент не может содержать текст (например, элемент <c>IMG</c>).</exception>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerHtml" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533899.aspx">innerText, свойство</related>
      </Docs>
    </Member>
    <Member MemberName="InsertAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement InsertAdjacentElement (System.Windows.Forms.HtmlElementInsertionOrientation orient, System.Windows.Forms.HtmlElement newElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement InsertAdjacentElement(valuetype System.Windows.Forms.HtmlElementInsertionOrientation orient, class System.Windows.Forms.HtmlElement newElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InsertAdjacentElement(System.Windows.Forms.HtmlElementInsertionOrientation,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAdjacentElement (orient As HtmlElementInsertionOrientation, newElement As HtmlElement) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ InsertAdjacentElement(System::Windows::Forms::HtmlElementInsertionOrientation orient, System::Windows::Forms::HtmlElement ^ newElement);" />
      <MemberSignature Language="F#" Value="member this.InsertAdjacentElement : System.Windows.Forms.HtmlElementInsertionOrientation * System.Windows.Forms.HtmlElement -&gt; System.Windows.Forms.HtmlElement" Usage="htmlElement.InsertAdjacentElement (orient, newElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="orient" Type="System.Windows.Forms.HtmlElementInsertionOrientation" />
        <Parameter Name="newElement" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="orient">Место вставки этого элемента относительно текущего элемента.</param>
        <param name="newElement">Новый элемент, который требуется вставить.</param>
        <summary>Вставляет новый элемент в модель DOM.</summary>
        <returns>Вставленный элемент <see cref="T:System.Windows.Forms.HtmlElement" />. Если не удалось вставить элемент, возвращается значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не вызывайте этот метод до тех пор <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> , пока не <xref:System.Windows.Forms.WebBrowser> будет вызвано событие в элементе управления. Вызов этого метода до того, как он может привести к исключению, поскольку загрузка документа не будет завершена.  
  
 Является ли значение <xref:System.Windows.Forms.HtmlElementInsertionOrientation> допустимым, зависит от типа элемента. Например, <xref:System.Windows.Forms.HtmlElementInsertionOrientation.AfterBegin> допустим, если элемент `DIV`является, но `SCRIPT` не является элементом или `IMG` , ни один из которых не может содержать дочерние элементы.  
  
   
  
## Examples  
 В следующем примере кода `DIV` элемент вставляется в верхнюю часть каждой страницы, которую пользователь просматривает за пределами сервера adatum.com. В примере требуется, чтобы форма содержала <xref:System.Windows.Forms.WebBrowser> элемент управления с именем. `WebBrowser1` Пример также должен импортировать пространство имен <xref:System.Text.RegularExpressions>.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlElement#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536451.aspx">Метод Инсертаджацентелемент</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет метод, являющийся уникальным для текущего элемента.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string methodName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string methodName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InvokeMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (methodName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ methodName);" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string -&gt; obj" Usage="htmlElement.InvokeMember methodName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="methodName">Имя вызываемого свойства или метода.</param>
        <summary>Выполняет невыявленный метод в базовом элементе DOM данного элемента.</summary>
        <returns>Элемент, возвращаемый данным методом и представленный в виде объекта <see cref="T:System.Object" />. Если этот объект <see cref="T:System.Object" /> является другим элементом HTML, и существует ссылка на неуправляемую библиотеку MSHTML, добавленную в проект, элемент можно привести к соответствующему неуправляемому интерфейсу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для вызова методов из модель DOM (DOM), которые не имеют эквивалентов в управляемом коде. Используйте эту версию <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> для выполнения непредоставленных методов, не принимающих аргументов. Пример см. в разделе <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string methodName, params object[] parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string methodName, object[] parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InvokeMember(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (methodName As String, ParamArray parameter As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ methodName, ... cli::array &lt;System::Object ^&gt; ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string * obj[] -&gt; obj" Usage="htmlElement.InvokeMember (methodName, parameter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="parameter" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="methodName">Имя вызываемого свойства или метода.</param>
        <param name="parameter">Список передаваемых параметров.</param>
        <summary>Выполняет функцию, определенную в текущей HTML-странице с помощью языка скриптов.</summary>
        <returns>Элемент, возвращаемый функцией и представленный в виде объекта <see cref="T:System.Object" />. Если этот объект <see cref="T:System.Object" /> является другим элементом HTML, и существует ссылка на неуправляемую библиотеку MSHTML, добавленную в проект, элемент можно привести к соответствующему неуправляемому интерфейсу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для вызова методов из модель DOM (DOM), которые не имеют эквивалентов в управляемом коде. Все аргументы, передаваемые в <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> , будут преобразованы в типы данных Win32 `VARIANT` перед передачей в именованную функцию создания скриптов.  
  
   
  
## Examples  
 В следующем примере кода возвращается `TABLE` вызванный `dataTable` метод, который использует непредоставленный `moveRow` способ перемещения строки из конца таблицы в начало.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlElement#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь нажимает клавишу на клавиатуре.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyDown>происходит перед <xref:System.Windows.Forms.HtmlElement.KeyPress>, который, в своюмся <xref:System.Windows.Forms.HtmlElement.KeyUp>, происходит раньше.  
  
 Можно отменить действие <xref:System.Windows.Forms.HtmlElement.KeyDown> по умолчанию для события в элементе, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> задав `true`свойству <xref:System.Windows.Forms.HtmlElementEventArgs> класса значение.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Событие элемента также будет происходить в родительских элементах этого элемента и в самом классе, если только свойству класса не присвоено значение. <xref:System.Windows.Forms.HtmlElement.KeyDown>  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.KeyDown> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> или добавления сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.KeyDown> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#442](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#442)]
 [!code-vb[System.Windows.Forms.EventExamples#442](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#442)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536938.aspx">Событие «вниз»</related>
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyPress As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyPress;" />
      <MemberSignature Language="F#" Value="member this.KeyPress : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyPress : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь нажимает и отпускает клавишу на клавиатуре.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyPress>происходит после <xref:System.Windows.Forms.HtmlElement.KeyDown> <xref:System.Windows.Forms.HtmlElement.KeyUp>и более.  
  
 Можно отменить действие <xref:System.Windows.Forms.HtmlElement.KeyPress> по умолчанию для события в элементе, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> задав `true`свойству <xref:System.Windows.Forms.HtmlElementEventArgs> класса значение.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Событие элемента также будет происходить в родительских элементах этого элемента и в самом классе, если только свойству класса не присвоено значение. <xref:System.Windows.Forms.HtmlElement.KeyPress>  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.KeyPress> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> или добавления сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.KeyPress> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#443](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#443)]
 [!code-vb[System.Windows.Forms.EventExamples#443](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#443)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536939.aspx">Событие OnKeyPress</related>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь отпускает клавишу на клавиатуре.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyUp>происходит после <xref:System.Windows.Forms.HtmlElement.KeyPress>, что происходит после <xref:System.Windows.Forms.HtmlElement.KeyDown>.  
  
 Это событие нельзя отменить.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Событие элемента также будет происходить в родительских элементах этого элемента и в самом классе, если только свойству класса не присвоено значение. <xref:System.Windows.Forms.HtmlElement.KeyUp>  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.KeyUp> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> или добавления сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.KeyUp> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#444](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#444)]
 [!code-vb[System.Windows.Forms.EventExamples#444](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#444)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536940.aspx">Событие онкэйуп</related>
      </Docs>
    </Member>
    <Member MemberName="LosingFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LosingFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LosingFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.LosingFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LosingFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LosingFocus;" />
      <MemberSignature Language="F#" Value="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда элемент теряет фокус ввода пользователя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.LosingFocus> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.LosingFocus> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#440](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#440)]
 [!code-vb[System.Windows.Forms.EventExamples#440](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#440)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда элемент потерял фокус ввода пользователя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элемент больше не будет получать события росчерка нажатия после <xref:System.Windows.Forms.HtmlElement.LostFocus> возникновения, пока он не передается в фокусе, либо пользователь выбирает его на странице, либо приложением, <xref:System.Windows.Forms.HtmlElement.Focus%2A> вызывающим метод для этого элемента.  
  
 Это событие нельзя отменить.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Событие элемента также будет происходить на родительских элементах и в самом классе, если только для свойства класса не задано значение. <xref:System.Windows.Forms.HtmlElement.LostFocus>  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.LostFocus> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.LostFocus> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#441](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#441)]
 [!code-vb[System.Windows.Forms.EventExamples#441](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#441)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536936.aspx">Событие onfocus</related>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь нажимает кнопку мыши.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно отменить действие <xref:System.Windows.Forms.HtmlElement.MouseDown> по умолчанию для события в элементе, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> задав `true`свойству <xref:System.Windows.Forms.HtmlElementEventArgs> класса значение.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Событие элемента также будет происходить в родительских элементах этого элемента и в самом классе, если только свойству класса не присвоено значение. <xref:System.Windows.Forms.HtmlElement.MouseDown>  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.MouseDown> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> или добавления сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.MouseDown> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#446](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#446)]
 [!code-vb[System.Windows.Forms.EventExamples#446](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#446)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536944.aspx">OnMouseDown, событие</related>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseEnter : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь впервые наводит указатель мыши на текущий элемент.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.MouseEnter> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> или добавления сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.MouseEnter> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#449](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#449)]
 [!code-vb[System.Windows.Forms.EventExamples#449](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#449)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь выводит указатель мыши из текущего элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.MouseLeave> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> или добавления сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.MouseLeave> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#450](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#450)]
 [!code-vb[System.Windows.Forms.EventExamples#450](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#450)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь перемещает указатель мыши по элементу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие нельзя отменить.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Событие элемента также будет происходить в родительских элементах этого элемента и в самом классе, если только свойству класса не присвоено значение. <xref:System.Windows.Forms.HtmlElement.MouseMove>  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.MouseMove> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> или добавления сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.MouseMove> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#445](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#445)]
 [!code-vb[System.Windows.Forms.EventExamples#445](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#445)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536947.aspx">Событие OnMouseMove</related>
      </Docs>
    </Member>
    <Member MemberName="MouseOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseOver;" />
      <MemberSignature Language="F#" Value="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда указатель мыши входит в пределы элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно отменить действие <xref:System.Windows.Forms.HtmlElement.MouseOver> по умолчанию для события в элементе, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> задав `true`свойству <xref:System.Windows.Forms.HtmlElementEventArgs> класса значение.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Событие элемента также будет происходить в родительских элементах этого элемента и в самом классе, если только свойству класса не присвоено значение. <xref:System.Windows.Forms.HtmlElement.MouseOver>  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.MouseOver> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> или добавления сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.MouseOver> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#447](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#447)]
 [!code-vb[System.Windows.Forms.EventExamples#447](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#447)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536949.aspx">Событие onmouseover</related>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь отпускает кнопку мыши.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно отменить действие <xref:System.Windows.Forms.HtmlElement.MouseUp> по умолчанию для события в элементе, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> задав `true`свойству <xref:System.Windows.Forms.HtmlElementEventArgs> класса значение.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Событие элемента также будет происходить в родительских элементах этого элемента и в самом классе, если только свойству класса не присвоено значение. <xref:System.Windows.Forms.HtmlElement.MouseUp>  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении <xref:System.Windows.Forms.HtmlElement.MouseUp> события. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> или добавления сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем. `HtmlElement1` Затем убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.MouseUp> событием.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#448](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#448)]
 [!code-vb[System.Windows.Forms.EventExamples#448](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#448)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536950.aspx">Событие OnMouseUp</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.HtmlElement.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя элемента.</summary>
        <value>Объект <see cref="T:System.String" />, представляющий имя элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство для получения элементов из документа <xref:System.Windows.Forms.HtmlElementCollection.GetElementsByName%2A> с помощью <xref:System.Windows.Forms.HtmlDocument>метода <xref:System.Windows.Forms.HtmlElement.All%2A> свойства. <xref:System.Windows.Forms.HtmlElement.Name%2A>  
  
 При применении к `INPUT` <xref:System.Windows.Forms.HtmlElement.Name%2A> элементам определяет имя переменной для данных этого элемента при отправке его формы на сервер.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534184.aspx">Свойство name</related>
      </Docs>
    </Member>
    <Member MemberName="NextSibling">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement NextSibling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement NextSibling" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.NextSibling" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextSibling As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ NextSibling { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextSibling : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.NextSibling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает следующий элемент, расположенный в дереве документа на одном уровне с данным элементом.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.HtmlElement" />, представляющий элемент, расположенный справа от текущего элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используется <xref:System.Windows.Forms.HtmlElement.NextSibling%2A> в сочетании с <xref:System.Windows.Forms.HtmlElement.FirstChild%2A> для прохода по дереву документа для элемента HTML.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534189.aspx">nextSibling, свойство</related>
      </Docs>
    </Member>
    <Member MemberName="OffsetParent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement OffsetParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement OffsetParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OffsetParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OffsetParent As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ OffsetParent { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetParent : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.OffsetParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает элемент, из которого вычисляется <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />.</summary>
        <value>Элемент, из которого вычисляются смещения.  
  
Если родительский элемент или другой элемент в иерархии элемента использует относительное или абсолютное расположение, значением <see langword="OffsetParent" /> будет первый элемент с относительным или абсолютным расположением, в который вложен текущий элемент. Если ни один из элементов, расположенных выше текущего элемента, не имеет абсолютного или <see langword="OffsetParent" /> относительного расположения, то будет являться тегом <c>текста</c> документа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы могут размещаться на HTML-странице одним из трех способов: размещение потока по умолчанию; относительное положение, в котором элемент смещается на фиксированную величину относительно родительского объекта; и абсолютное позиционирование, в котором элементу присвоено фиксированное координатное положение относительно верхнего левого угла документа.  
  
 Если элементы документа используют относительное или абсолютное позиционирование, можно использовать `OffsetParent` для вычисления положения координат элемента в клиентской области.  
  
 Дополнительные сведения о позиционировании элементов в HTML см. в разделе [о позиционировании элементов](https://msdn.microsoft.com/library/ms533005.aspx).  
  
   
  
## Examples  
 В следующем примере кода показано, <xref:System.Windows.Forms.HtmlElement.OffsetParent%2A> как <xref:System.Windows.Forms.HtmlElement.OffsetRectangle%2A> и различаются `span1`для `span2` , `span3`и:  
  
```  
<HTML>  
    <BODY id="documentBody">  
  
        <DIV id="div1">  
            <SPAN id="span1">Placeholder text 1.</SPAN>  
        </DIV>  
  
        <DIV id="div2" style="position:relative;top:100px;left:100px;">  
            <SPAN id="span2">Placeholder text 2.</SPAN>  
        </DIV>  
  
        <DIV id="div3" style="position:absolute;top:200px;left:200px;">  
            <DIV id="div4" style="position:relative;top:100px;left:100px;">  
                <SPAN id="span3">Placeholder text 3.</SPAN>  
            </DIV>  
        </DIV>  
  
    </BODY>  
</HTML>  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlElement#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534302.aspx">Оффсетпарент, свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms530302.aspx">Измерение элементов измерение и расположение</related>
      </Docs>
    </Member>
    <Member MemberName="OffsetRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle OffsetRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle OffsetRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OffsetRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle OffsetRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.OffsetRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает расположение элемента относительно его родительского элемента.</summary>
        <value>Координаты x и y элемента, а также его ширина и высота относительно родительского элемента.  
  
Если родительский элемент имеет относительное или абсолютное расположение, свойство <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> возвращает смещение родительского элемента. Если элемент располагается относительно своего родительского элемента, то свойство <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> возвращает смещение относительно родительского элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы могут размещаться на HTML-странице одним из трех способов:  
  
-   Позиционирование потока по умолчанию.  
  
-   Относительное положение, в котором элемент смещается на фиксированную величину относительно родительского объекта.  
  
-   Абсолютное позиционирование, в котором элементу присвоено фиксированное координатное положение относительно верхнего левого угла документа.  
  
 Дополнительные сведения о позиционировании элементов в HTML см. в разделе [о позиционировании элементов](https://msdn.microsoft.com/library/ms533005.aspx).  
  
   
  
## Examples  
 В следующем примере кода показано, <xref:System.Windows.Forms.HtmlElement.OffsetParent%2A> как <xref:System.Windows.Forms.HtmlElement.OffsetRectangle%2A> и различаются `span1`для `span2` , `span3`и:  
  
```  
<HTML>  
    <BODY id="documentBody">  
  
        <DIV id="div1">  
            <SPAN id="span1">Placeholder text 1.</SPAN>  
        </DIV>  
  
        <DIV id="div2" style="position:relative;top:100px;left:100px;">  
            <SPAN id="span2">Placeholder text 2.</SPAN>  
        </DIV>  
  
        <DIV id="div3" style="position:absolute;top:200px;left:200px;">  
            <DIV id="div4" style="position:relative;top:100px;left:100px;">  
                <SPAN id="span3">Placeholder text 3.</SPAN>  
            </DIV>  
        </DIV>  
  
    </BODY>  
</HTML>  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlElement#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.OffsetParent" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534200.aspx">Оффсетлефт, свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534303.aspx">offsetTop, свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534304.aspx">Оффсетвидс, свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534199.aspx">Оффсесеигхт, свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms530302.aspx">Измерение элементов измерение и расположение</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.HtmlElement left, System.Windows.Forms.HtmlElement right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.HtmlElement left, class System.Windows.Forms.HtmlElement right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.op_Equality(System.Windows.Forms.HtmlElement,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As HtmlElement, right As HtmlElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::HtmlElement ^ left, System::Windows::Forms::HtmlElement ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.HtmlElement * System.Windows.Forms.HtmlElement -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlElement" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="left">Первая коллекция <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <param name="right">Второй объект <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Проверяет равенство двух элементов.</summary>
        <returns>Значение <see langword="true" />, если оба параметра имеют значение <see langword="null" /> или имеют общий базовый интерфейс модели COM. В противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Оператор равенства проверяет `IUnknown` указатели базовых COM-объектов, инкапсулированных предоставленными <xref:System.Windows.Forms.HtmlElement> классами.  
  
 Эквивалентным методом для этого оператора является<xref:System.Windows.Forms.HtmlElement.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.HtmlElement left, System.Windows.Forms.HtmlElement right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.HtmlElement left, class System.Windows.Forms.HtmlElement right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.op_Inequality(System.Windows.Forms.HtmlElement,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As HtmlElement, right As HtmlElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::HtmlElement ^ left, System::Windows::Forms::HtmlElement ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.HtmlElement * System.Windows.Forms.HtmlElement -&gt; bool" Usage="System.Windows.Forms.HtmlElement.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlElement" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="left">Первая коллекция <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <param name="right">Второй объект <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Проверяет неравенство двух объектов <see cref="T:System.Windows.Forms.HtmlElement" />.</summary>
        <returns>Значение <see langword="true" />, если только один из элементов имеет значение <see langword="null" /> или эти два объекта не равны. В противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Эквивалентным методом для этого оператора является отрицание<xref:System.Windows.Forms.HtmlElement.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OuterHtml">
      <MemberSignature Language="C#" Value="public string OuterHtml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterHtml" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OuterHtml" />
      <MemberSignature Language="VB.NET" Value="Public Property OuterHtml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OuterHtml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OuterHtml : string with get, set" Usage="System.Windows.Forms.HtmlElement.OuterHtml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает HTML-код текущего элемента.</summary>
        <value>HTML-код текущего элемента и его дочерних элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В то время как возвращает все HTML-код, содержащийся в текущем элементе, за исключением <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> окружающих его тегов текущего элемента, включает тег текущего элемента, а также HTML-код, который содержит тег, например: <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A>  
  
 `<HTML>`  
  
 `<BODY>`  
  
 `<DIV id="div1">`  
  
 `Hello`  
  
 `<DIV id="div2">`  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 `</BODY>`  
  
 `</HTML>`  
  
 В этом примере вызов <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> в `div2` будет возвращать:  
  
 `<DIV id="div2">`  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 Вызов <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> возвратит:  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 Если присвоить новое значение <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A>, ссылка на текущий элемент станет недопустимой; она не будет отображать имя, свойства и дочернее содержимое только что назначенного кода HTML.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerHtml" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534310.aspx">outerHTML, свойство</related>
      </Docs>
    </Member>
    <Member MemberName="OuterText">
      <MemberSignature Language="C#" Value="public string OuterText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OuterText" />
      <MemberSignature Language="VB.NET" Value="Public Property OuterText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OuterText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OuterText : string with get, set" Usage="System.Windows.Forms.HtmlElement.OuterText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает текст текущего элемента.</summary>
        <value>Текст, расположенный внутри текущего элемента и его дочерних элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке назначить HTML для элемента с помощью <xref:System.Windows.Forms.HtmlElement.OuterText%2A>HTML-код будет отображаться в документе как литералы, как если бы вы просматривали HTML в текстовом файле. Если присвоить HTML элементу с помощью <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> свойства, <xref:System.Windows.Forms.HtmlElement.OuterText%2A> будет возвращен весь текст в этом HTML-коде с удаленной разметкой.  
  
 Присвоение значения приведет <xref:System.Windows.Forms.HtmlElement.OuterText%2A> к уничтожению всех дочерних элементов, принадлежащих элементу.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Текст нельзя расположить вне этого элемента.</exception>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerText" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534311.aspx">Аутертекст, свойство</related>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ Parent { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает родительский элемент текущего элемента.</summary>
        <value>Элемент, расположенный над текущим в иерархии HTML-документа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.Parent%2A> Свойство включает обнаружение контекста элемента. Он особенно полезен внутри обработчиков событий, таких <xref:System.Windows.Forms.HtmlElement.Click>как, которые могут срабатывать для любого элемента в иерархии объектов документа.  
  
 <xref:System.Windows.Forms.HtmlElement.Parent%2A> Свойство элемента HTML (начало документа HTML) указывает на себя. При вызове <xref:System.Windows.Forms.HtmlElement.Parent%2A> внутри цикла убедитесь, что условие останова цикла сравнивает тип текущего элемента и тип `Parent` свойства, или, в противном случае, код может выполнять бесконечный цикл.  
  
   
  
## Examples  
 В следующем примере кода выполняется поиск `IMG` всех тегов в документе и <xref:System.Windows.Forms.HtmlElement.Parent%2A> используется свойство для проверки, связан ли объект `IMG` с другой страницей. Если это так, код присваивает URL-адрес `ALT` атрибуту элемента `IMG`, чтобы пользователи могли навести указатель мыши на изображение, чтобы узнать, где они будут делать.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlElement#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534327.aspx">Родительскийэлемент, свойство</related>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (string eventName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RaiseEvent(string eventName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.RaiseEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (eventName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RaiseEvent(System::String ^ eventName);" />
      <MemberSignature Language="F#" Value="member this.RaiseEvent : string -&gt; unit" Usage="htmlElement.RaiseEvent eventName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventName">Имя создаваемого события.</param>
        <summary>Вызывает для события с указанным именем все зарегистрированные обработчики событий.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для доступа к событиям HTML модель DOM (DOM). Он напрямую вызывает метод [IHTMLElement3:: FireEvent](https://go.microsoft.com/fwlink/?LinkId=103189) . Дополнительные сведения об использовании модели DOM с помощью <xref:System.Windows.Forms.HtmlElement> класса см. в разделе [доступ к неоткрытым членам на управляемом модель Domе HTML](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFocus">
      <MemberSignature Language="C#" Value="public void RemoveFocus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFocus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.RemoveFocus" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFocus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFocus();" />
      <MemberSignature Language="F#" Value="member this.RemoveFocus : unit -&gt; unit" Usage="htmlElement.RemoveFocus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет фокус из текущего элемента, если этот элемент имеет фокус.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода вызывает <xref:System.Windows.Forms.HtmlElement.LostFocus> событие для элемента.  
  
 Когда фокус удаляется из элемента с помощью этого метода, он присваивается документу, содержащему элемент, а не следующему элементу в последовательности табуляции.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536347.aspx">Метод размытия</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignWithTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollIntoView(bool alignWithTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.ScrollIntoView(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollIntoView (alignWithTop As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollIntoView(bool alignWithTop);" />
      <MemberSignature Language="F#" Value="member this.ScrollIntoView : bool -&gt; unit" Usage="htmlElement.ScrollIntoView alignWithTop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignWithTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignWithTop">Если задано значение <see langword="true" />, верхняя часть объекта будет отображаться в верхней части окна. Если задано значение <see langword="false" />, нижняя часть объекта будет отображаться в нижней части окна.</param>
        <summary>Выполняет прокрутку документа, содержащего этот элемент, пока верхний или нижний край элемента не окажется выровненным с окном документа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода выполняется поиск элемента по имени и выполняется прокрутка страницы, чтобы верхняя часть элемента высовпадала с верхней частью видимой страницы.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#12)]
 [!code-vb[System.Windows.Forms.HtmlElement#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#12)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536730.aspx">Метод Скроллинтовиев</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollLeft">
      <MemberSignature Language="C#" Value="public int ScrollLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScrollLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollLeft" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScrollLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollLeft : int with get, set" Usage="System.Windows.Forms.HtmlElement.ScrollLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает расстояние между краем элемента и левым краем его содержимого.</summary>
        <value>Расстояние (в пикселях) между левым краем элемента и левым краем его содержимого.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все размеры области прокрутки доступны с помощью <xref:System.Windows.Forms.HtmlElement.ScrollRectangle%2A>; `ScrollLeft` и <xref:System.Windows.Forms.HtmlElement.ScrollTop%2A>  предоставляются независимо, поскольку это единственные свойства области прокрутки, которые могут быть заданы разработчиками.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534617.aspx">"scrollLeft", свойство</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ScrollRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ScrollRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ScrollRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ScrollRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ScrollRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.ScrollRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает размеры области прокрутки элемента.</summary>
        <value>Размер и координата области прокрутки элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элемент будет иметь прокручиваемую область, если ее содержимое превышает размер его размеров, если только стиль переполнения элемента не запрещает отрисовку полос прокрутки.  
  
 Нельзя изменить размер области прокрутки напрямую, но можно изменить расстояние между краями области прокрутки и краями элемента. Чтобы добиться этого <xref:System.Windows.Forms.HtmlElement.ScrollTop%2A> , используйте свойства и. <xref:System.Windows.Forms.HtmlElement.ScrollLeft%2A>  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534617.aspx">"scrollLeft", свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534618.aspx">"scrollTop", свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534615.aspx">Скроллхеигхт, свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534619.aspx">Скроллвидс, свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534312.aspx">Свойство Overflow</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollTop">
      <MemberSignature Language="C#" Value="public int ScrollTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScrollTop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollTop" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScrollTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollTop : int with get, set" Usage="System.Windows.Forms.HtmlElement.ScrollTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает расстояние между краем элемента и верхним краем его содержимого.</summary>
        <value>Расстояние (в пикселях) между верхним краем элемента и верхним краем его содержимого.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все размеры области прокрутки доступны с помощью <xref:System.Windows.Forms.HtmlElement.ScrollRectangle%2A>; <xref:System.Windows.Forms.HtmlElement.ScrollLeft%2A> и `ScrollTop`  предоставляются независимо, поскольку это единственные свойства области прокрутки, которые могут быть заданы разработчиками.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534618.aspx">"scrollTop", свойство</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttribute">
      <MemberSignature Language="C#" Value="public void SetAttribute (string attributeName, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAttribute(string attributeName, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.SetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttribute (attributeName As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAttribute(System::String ^ attributeName, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetAttribute : string * string -&gt; unit" Usage="htmlElement.SetAttribute (attributeName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="attributeName">Имя атрибута, который нужно установить.</param>
        <param name="value">Новое значение этого атрибута.</param>
        <summary>Задает значение атрибута с заданным именем в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Атрибутом в HTML является любая допустимая пара "имя-значение" для этого элемента. <xref:System.Windows.Forms.HtmlElement>предоставляет только те атрибуты, которые являются общими для всех элементов, оставляя те, которые применяются только к определенным типам элементов. — Это предопределенный атрибут `IMG` для тега, например `DIV` , но не для тега. `SRC` Используйте <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> и <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>  для управления атрибутами, не предоставляемыми в управляемом модель DOM (DOM).  
  
 Если `attributeName` не является определенным атрибутом элемента, <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> будет определять его в элементе как новый атрибут.  
  
 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A>и <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> не учитывают регистр.  
  
 Чтобы задать `class` атрибут <xref:System.Windows.Forms.HtmlElement> для, необходимо обратиться к атрибуту, как `className` при указании первого аргумента для<xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>  
  
   
  
## Examples  
 В следующем примере кода в текущий документ `IMG` добавляется новый элемент, с помощью <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> которого задается `SRC` атрибут для изображения.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlElement#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536739.aspx">Метод setAttribute</related>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public string Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Style { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : string with get, set" Usage="System.Windows.Forms.HtmlElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает список стилей текущего элемента, разделенных точкой с запятой.</summary>
        <value>Строка, состоящая из всех стилей элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML-модель DOM (DOM) использует стили, как определено в консорциуме World Wide Web Consortium каскадные таблицы стилей спецификации для управления отображением элемента. Стили в <xref:System.Windows.Forms.HtmlElement.Style%2A> свойстве принимают форму пар "имя-значение", разделенных двоеточием, каждая пара отделяется точкой с запятой следующим образом:  
  
 `style-name1:value1;...;[style-nameN:valueN;]`  
  
 Чтобы задать для `DIV` элемента шрифт, равный 14 пт новому полужирному шрифту, например, необходимо назначить следующую строку:  
  
 `font-face:Times New Roman;font-size:14px;font-weight:bold;`  
  
 Полный список всех доступных стилей в HTML DOM см. в разделе [атрибут style](https://msdn.microsoft.com/library/ms534651.aspx).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public short TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short TabIndex { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.TabIndex : int16 with get, set" Usage="System.Windows.Forms.HtmlElement.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает расположение этого элемента в последовательности перехода.</summary>
        <value>Числовой индекс элемента в последовательности перехода.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.TabIndex%2A>Определяет, какой элемент в документе HTML будет далее получать фокус, когда пользователь нажмет клавишу TAB. По умолчанию `INPUT` единственными элементами `SELECT` , включенными в последовательность табуляции, являются элементы, элемент управления и любой `contentEditable` элемент, свойство `true`которого имеет значение. Любой HTML-элемент можно включить в последовательность табуляции, например `DIV`, с помощью явного <xref:System.Windows.Forms.HtmlElement.TabIndex%2A>присвоения.  
  
 Допустимые значения <xref:System.Windows.Forms.HtmlElement.TabIndex%2A> в диапазоне от-32767 до 32767.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534654.aspx">Свойство tabIndex</related>
      </Docs>
    </Member>
    <Member MemberName="TagName">
      <MemberSignature Language="C#" Value="public string TagName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TagName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.TagName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TagName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TagName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TagName : string" Usage="System.Windows.Forms.HtmlElement.TagName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя HTML-тега.</summary>
        <value>Данное имя используется для создания этого элемента с помощью разметки HTML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Многие элементы в HTML-модель DOM имеют атрибуты, свойства и методы, которые являются уникальными для этих элементов. Например, `A` `Submit` атрибут элемента или метод в  `FORM` .  `HREF` Используется <xref:System.Windows.Forms.HtmlElement.TagName%2A> при наличии элемента потенциально произвольного типа и необходимости выполнения операции, зависящей от типа.  
  
   
  
## Examples  
 В следующем примере кода выполняется поиск `IMG` всех тегов в документе и `TagName` используется свойство для проверки, связан ли объект `IMG` с другой страницей. Если это так, код присваивает URL-адрес `ALT` атрибуту элемента `IMG`, чтобы пользователи могли навести указатель мыши на изображение, чтобы узнать, где они будут делать.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlElement#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.GetElementsByTagName(System.String)" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534657.aspx">tagName, свойство</related>
      </Docs>
    </Member>
  </Members>
</Type>
