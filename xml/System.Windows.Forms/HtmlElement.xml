<Type Name="HtmlElement" FullName="System.Windows.Forms.HtmlElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="95ab2be678ea24dac91b37885876931e53a41833" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66005794" /></Metadata><TypeSignature Language="C#" Value="public sealed class HtmlElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HtmlElement extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.HtmlElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HtmlElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class HtmlElement sealed" />
  <TypeSignature Language="F#" Value="type HtmlElement = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Представляет элемент HTML в пределах веб-страницы.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement> представляет все возможные тип элемента в HTML-документ, например `BODY`, `TABLE`, и `FORM`, среди прочего. Класс предоставляет наиболее распространенных свойств, которые вы сможете найти для всех элементов.  
  
 Большинство элементов могут иметь *дочерние элементы*: другие элементы HTML, помещаемые под ними. Используйте <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> свойство для проверки, является ли данный элемент имеет дочерние элементы и <xref:System.Windows.Forms.HtmlElement.Children%2A> коллекции итерацию по ним. <xref:System.Windows.Forms.HtmlElement.Parent%2A> Возвращает <xref:System.Windows.Forms.HtmlElement> в который вложен текущий элемент.  
  
 Часто требуется доступ к атрибутам, свойства и методы базового элемента, не предоставляются непосредственно <xref:System.Windows.Forms.HtmlElement>, такие как `SRC` атрибут `IMG` элемент или `Submit` метод `FORM`. <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> И <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> методы можно использовать для получения и изменения любого атрибута или свойства определенного элемента, хотя <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> предоставляет доступ к любым методам, которые не представлены в управляемый объект модели (DOM). Если приложение разрешение неуправляемого кода, можно также воспользоваться свойствам и методам с <xref:System.Windows.Forms.HtmlElement.DomElement%2A> атрибута.  
  
 Используйте <xref:System.Windows.Forms.HtmlElement.TagName%2A> свойство для проверки, является ли элемент определенного типа.  
  
 Любой HTML-документ можно изменить во время выполнения. Можно создавать новые <xref:System.Windows.Forms.HtmlElement> объекты с <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> метод <xref:System.Windows.Forms.HtmlDocument>и добавить их в другой элемент с помощью <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> или <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> методы. Можно также создать элементы, как HTML-теги и назначить их на существующий элемент <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода показано, как проверить произвольный HTML-документ и получить строку описания элементов HTML, с отступом, и позволяет указать, насколько глубоко номера уровней вложенных элементов в документе. Данный пример кода требует, узлы приложения <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlElement#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104876">Интерфейс IHTMLElement</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104877">Интерфейс IHTMLElement2</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104878">Интерфейс IHTMLElement3</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104879">Интерфейс IHTMLElement4</related>
  </Docs>
  <Members>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection All" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.All" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property All As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ All { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.All : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlElement.All" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию <see cref="T:System.Windows.Forms.HtmlElementCollection" /> всех элементов, расположенных под текущим элементом.</summary>
        <value>Коллекция всех элементов, которые являются прямыми или косвенными потомками текущего. Если текущим элементом является <c>таблицы</c>, например <see cref="P:System.Windows.Forms.HtmlElement.All" /> вернет каждый <c>TH</c>, <c>TR</c>, и <c>TD</c> элемент в пределах таблицы, а также как и любые другие элементы, такие как <c>DIV</c> и <c>диапазон</c> элементы, содержащиеся в ячейках.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить только те элементы, имеющие текущий элемент их непосредственного родительского, используйте <xref:System.Windows.Forms.HtmlElement.Children%2A> коллекции вместо этого.  
  
 В этой коллекции не обязательно возвращаются в исходном порядке.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.Children" />
      </Docs>
    </Member>
    <Member MemberName="AppendChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement AppendChild (System.Windows.Forms.HtmlElement newElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement AppendChild(class System.Windows.Forms.HtmlElement newElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.AppendChild(System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendChild (newElement As HtmlElement) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ AppendChild(System::Windows::Forms::HtmlElement ^ newElement);" />
      <MemberSignature Language="F#" Value="member this.AppendChild : System.Windows.Forms.HtmlElement -&gt; System.Windows.Forms.HtmlElement" Usage="htmlElement.AppendChild newElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newElement" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="newElement">Объект <see cref="T:System.Windows.Forms.HtmlElement" />, добавляемый в это расположение в дереве.</param>
        <summary>Добавляет элемент в поддерево другого элемента.</summary>
        <returns>Элемент после добавления к дереву.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Модель объектов документов (DOM) HTML позволяет изменить содержимое HTML-файла в ряд способов выполнения. Используйте <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> для добавления новых элементов к существующему документу или переместить элемент на странице.  
  
 Если элемент уже имеют родителей, присоединение элемента к другому элементу автоматически удалит этого элемента из его предыдущего родителя.  
  
 Любые дополнения, внесенные в документ во время выполнения с помощью <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> не будут сохранены при вызове <xref:System.Windows.Forms.WebBrowser.ShowSaveAsDialog%2A> метод <xref:System.Windows.Forms.WebBrowser> элемента управления.  
  
   
  
## Examples  
 В следующем примере кода создается новый гиперссылки с помощью <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> метод и добавляет его до конца страницы посредством `AppendChild` на `BODY` элемент. В этом примере предполагается, что приложение содержит <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlElement#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.CreateElement(System.String)" />
        <related type="ExternalDocumentation" href="https://developer.mozilla.org/docs/Web/API/Node/appendChild">Метод appendChild</related>
      </Docs>
    </Member>
    <Member MemberName="AttachEventHandler">
      <MemberSignature Language="C#" Value="public void AttachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.AttachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.AttachEventHandler : string * EventHandler -&gt; unit" Usage="htmlElement.AttachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Имя события для обработки.</param>
        <param name="eventHandler">Управляемый код, обрабатывающий событие.</param>
        <summary>Добавляет обработчик событий для события с заданным именем в модели HTML DOM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Управляемый объект модели (DOM) предоставляет выберите число событий. Большинство из них не предоставленным явно определены только для определенных типов элементов; Например, `submit` событие, которое может использоваться только в `FORM` элементов. Используйте <xref:System.Windows.Forms.HtmlElement.AttachEventHandler%2A> для добавления обработчика событий на эти события не предоставленным явно.  
  
 Не следует присоединять событие документа или один из его объектов, пока не завершится загрузка документа. Является самой ранней, этот метод следует вызывать в <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> событие <xref:System.Windows.Forms.WebBrowser> элемента управления.  
  
 Дополнительные сведения о доступных неуправляемых событий, см. в разделе [доступ к которым не предоставляется явно членов в управляемых объектной модели документов HTML](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md) и IHTMLElement интерфейсы: [IHTMLElement](https://go.microsoft.com/fwlink/?LinkId=104876), [IHTMLElement2](https://go.microsoft.com/fwlink/?LinkId=104877), [IHTMLElement3](https://go.microsoft.com/fwlink/?LinkId=104878), [IHTMLElement4](https://go.microsoft.com/fwlink/?LinkId=104879).  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://developer.mozilla.org/docs/Web/API/EventTarget/addEventListener">EventTarget.addEventListener()</related>
      </Docs>
    </Member>
    <Member MemberName="CanHaveChildren">
      <MemberSignature Language="C#" Value="public bool CanHaveChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHaveChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.CanHaveChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanHaveChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHaveChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanHaveChildren : bool" Usage="System.Windows.Forms.HtmlElement.CanHaveChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, может ли текущий элемент иметь дочерние элементы.</summary>
        <value>Значение <see langword="true" />, если элемент может иметь дочерние элементы, и значение <see langword="false" /> в противном случае.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые элементы, такие как `IMG` и `SCRIPT`, не может иметь дочерние элементы. Используйте это свойство перед вызовом метода <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> или <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> на произвольный элемент.  
  
   
  
## Examples  
 В следующем примере кода обрабатывается <xref:System.Windows.Forms.HtmlElement.Click> событий на <xref:System.Windows.Forms.HtmlDocument>. Если элемент не был выбран щелчком мыши, код присваивает элемент закрытой переменной класса с именем `MoveElement`. Если элемент был выбран, код пытается добавить его к элементу, в котором выполнен щелчок. Данный пример кода требует, узлы приложения <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`, и у вас уже добавил обработчик события для <xref:System.Windows.Forms.HtmlElement.Click> событий на <xref:System.Windows.Forms.HtmlDocument>.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.HtmlElement#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Children" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Children As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Children { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Children : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlElement.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию <see cref="T:System.Windows.Forms.HtmlElementCollection" /> всех дочерних элементов для текущего элемента.</summary>
        <value>Коллекция всех объектов <see cref="T:System.Windows.Forms.HtmlElement" />, для которых текущий элемент является родительским.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Многие элементы внутри HTML-файл может иметь другие элементы HTML, под ними. <xref:System.Windows.Forms.HtmlElement.Children%2A> Коллекции предоставляет простой механизм для изучения структуре дерева документа.  
  
 <xref:System.Windows.Forms.HtmlElement.Children%2A> предоставляет только элементы, прямой родительский объект которой является текущим элементом. Если у вас есть <xref:System.Windows.Forms.HtmlElement> для `TABLE` элемент, <xref:System.Windows.Forms.HtmlElement.Children%2A> предоставит все `TR` элементы (строки) внутри `TABLE`. Для получения `TD` (ячейка) элементов, содержащихся в словаре `TR` элементов, необходимо будет использовать либо <xref:System.Windows.Forms.HtmlElement.Children%2A> коллекции для каждого отдельного `TR` элемент, или используйте <xref:System.Windows.Forms.HtmlElement.All%2A> коллекции на <xref:System.Windows.Forms.HtmlElement>.  
  
 В этой коллекции не обязательно находиться в исходном порядке.  
  
 Если <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> — `false`, `Children` всегда будет пустым.  
  
   
  
## Examples  
 В следующем примере кода проверяет произвольный HTML-документ и получается строка, описывающая элементы с отступами и номера уровней, позволяет указать, насколько глубоко вложенных элементов в документе. Это достигается за счет поиска `Children` коллекцию рекурсивно, все элементы, начиная с элемента HTML в верхней части документа. Данный пример кода требует, что приложение имеет <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlElement#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.All" />
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Click : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь щелкает элемент левой кнопкой мыши.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.Click> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.Click> также может возникнуть событие для элемента в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> сам по себе, класс, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
 При нажатии на элемент, который не в данный момент имеет фокус ввода, <xref:System.Windows.Forms.HtmlElement.Click> событие произойдет после <xref:System.Windows.Forms.HtmlElement.Focusing> событий, но перед <xref:System.Windows.Forms.HtmlElement.LostFocus> событие для этого элемента.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.Click> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.Click> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#432](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#432)]
 [!code-vb[System.Windows.Forms.EventExamples#432](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#432)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536913.aspx">События OnClick</related>
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ClientRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ClientRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.ClientRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает границы клиентской области элемента в HTML-документе.</summary>
        <value>Клиентская область, занимаемая элементом, минус области, занятые границами и полосами прокрутки. Чтобы получить расположение и размеры элемента с учетом крайних элементов, используйте свойство <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.ClientRectangle%2A> Возвращает позицию данные только для элементов, которые были назначены точные значения высоты и ширины или элементы, использующие абсолютное позиционирование. Документ имеет абсолютное положение, если его стиль положения `absolute`, после которого он может располагаться в какой-либо координаты на HTML-страницы.  
  
   
  
## Examples  
 Предположим, вы загрузили на следующей странице HTML в размещенный экземпляр <xref:System.Windows.Forms.WebBrowser> элемента управления.  
  
```  
<HTML>  
  
    <BODY>  
  
        <DIV id="div1" style="position:absolute;top:100px;left:100px;border-      style:solid;border-width:1px;">  
            Edit this text.  
        </DIV>  
  
    </BODY>  
  
</HTML>  
```  
  
 В следующем примере кода демонстрируется извлечение этот элемент и увеличить его размеры, если клиентскую область является менее 400 пикселей в ширину и 50 пикселей, а также задает `DIV` для `contentEditable` состояния таким образом, чтобы пользователь мог вводить текст.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.HtmlElement#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533564.aspx">clientLeft свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533565.aspx">clientTop свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533566.aspx">clientWidth свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533563.aspx">clientHeight свойство</related>
      </Docs>
    </Member>
    <Member MemberName="DetachEventHandler">
      <MemberSignature Language="C#" Value="public void DetachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.DetachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.DetachEventHandler : string * EventHandler -&gt; unit" Usage="htmlElement.DetachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Имя события для обработки.</param>
        <param name="eventHandler">Управляемый код, обрабатывающий событие.</param>
        <summary>Удаляет обработчик событий из события с заданным именем в модели HTML DOM.</summary>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536411.aspx">Метод detachEvent</related>
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlDocument Document { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlDocument Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Document" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Document As HtmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlDocument ^ Document { System::Windows::Forms::HtmlDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Document : System.Windows.Forms.HtmlDocument" Usage="System.Windows.Forms.HtmlElement.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Windows.Forms.HtmlDocument" />, к которому принадлежит данный элемент.</summary>
        <value>Родительский документ для этого элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые HTML-страницы можно разместить кадров с помощью `FRAMESET` теги. В этом случае каждый отдельный `FRAME` элемент будет содержать свой собственный экземпляр <xref:System.Windows.Forms.HtmlDocument>. Это свойство особенно полезен, когда вы получили ссылку на элемент в обработчик событий из <xref:System.Windows.Forms.HtmlElementEventArgs>и необходимо выполнить какие-либо действия в документе, в которой находится элемент.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.HtmlDocument" />
      </Docs>
    </Member>
    <Member MemberName="DomElement">
      <MemberSignature Language="C#" Value="public object DomElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DomElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.DomElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomElement As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DomElement { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomElement : obj" Usage="System.Windows.Forms.HtmlElement.DomElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает указатель на неуправляемый интерфейс для этого элемента.</summary>
        <value>COM <c>IUnknown</c> указатель для элемента, который можно привести к одному из HTML-элемента интерфейсы, такие как <c>IHTMLElement</c>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement> является оболочкой для Internet Explorer объекта модели (DOM), которой написан с помощью модели объектов компонента (COM). Если вам требуется доступ к свойствам или методам базовых интерфейсов COM, такие как `IHTMLElement`, этот объект для запроса можно использовать для них.  
  
 Чтобы использовать неуправляемые интерфейсы, необходимо импортировать в библиотеку MSHTML (mshtml.dll) в приложение. Тем не менее, можно также выполнить свойствам и методам с помощью `Invoke` метод.  
  
   
  
## Examples  
 В следующем примере кода использует неуправляемые интерфейсы, чтобы получить текущий выделенный текст и преобразовать его в виде гиперссылки на URL-адрес, выбранный пользователем. Этот код был написан в предположении, что форма содержит <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`, и что учетная запись на неуправляемую библиотеку MSHTML как ссылку в проект.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.HtmlElement#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.DomDocument" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104877">Интерфейс IHTMLElement2</related>
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DoubleClick;" />
      <MemberSignature Language="F#" Value="member this.DoubleClick : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DoubleClick : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь дважды в течение краткого промежутка времени щелкает элемент левой кнопкой мыши.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как двойной щелчок определяется настройками мыши в операционной системе пользователя. Пользователь может задать время между нажатиями кнопки мыши, которые будут считаться двойным щелчком, а не двумя отдельными щелчками.  
  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.DoubleClick> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.DoubleClick> также может возникнуть событие для элемента в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> сам по себе, класс, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.DoubleClick> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.DoubleClick> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#433](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#433)]
 [!code-vb[System.Windows.Forms.EventExamples#433](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#433)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536921.aspx">OnDblClick событий</related>
      </Docs>
    </Member>
    <Member MemberName="Drag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Drag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Drag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Drag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drag As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Drag;" />
      <MemberSignature Language="F#" Value="member this.Drag : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Drag : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь перетаскивает текст в различные места.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает при перетаскивании текста в следующих расположениях:  
  
-   В пределах или между HTML-страницы, размещенные в <xref:System.Windows.Forms.WebBrowser> управления или Internet Explorer  
  
-   В другое приложение  
  
-   На рабочем столе Windows  
  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.Drag> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.Drag> также может возникнуть событие для элемента в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> сам по себе, класс, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.Drag> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.Drag> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#434](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#434)]
 [!code-vb[System.Windows.Forms.EventExamples#434](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#434)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536923.aspx">ondrag событий</related>
      </Docs>
    </Member>
    <Member MemberName="DragEnd">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragEnd" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragEnd" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnd As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragEnd;" />
      <MemberSignature Language="F#" Value="member this.DragEnd : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragEnd : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь завершает операцию перетаскивания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.DragEnd> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.DragEnd> также может возникнуть событие для элемента в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> сам по себе, класс, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.DragEnd> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.DragEnd> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#435](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#435)]
 [!code-vb[System.Windows.Forms.EventExamples#435](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#435)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536924.aspx">ondragend событий</related>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь прекращает перетаскивание объекта через этот элемент.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.DragLeave> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.DragLeave> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#436](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#436)]
 [!code-vb[System.Windows.Forms.EventExamples#436](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#436)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь перетаскивает текст над элементом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.DragOver> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.DragOver> также может возникнуть событие для элемента в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> сам по себе, класс, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.DragOver> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.DragOver> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#437](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#437)]
 [!code-vb[System.Windows.Forms.EventExamples#437](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#437)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536927.aspx">onDragOver событий</related>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.HtmlElement.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или устанавливает возможность ввода пользователем данных в этот элемент.</summary>
        <value>Значение <see langword="true" />, если элемент допускает ввод данных пользователем, и  значение <see langword="false" /> в противном случае.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для `FORM` элементы, такие как текстовые поля и переключателей, установка <xref:System.Windows.Forms.HtmlElement.Enabled%2A> для `false` будет предотвратить работу пользователя с помощью этих полей формы. Для других элементов таких как `DIV` или `SPAN`, задание <xref:System.Windows.Forms.HtmlElement.Enabled%2A> для `false` вызовет весь текст в элемент в затенены; Однако текст по-прежнему, могут быть выделены. Чтобы отменить выделение, добавьте обработчик событий для не предоставленным явно `onselectstart` событий с помощью <xref:System.Windows.Forms.HtmlElement.AttachEventHandler%2A> метод.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533734.aspx">Свойств disabled</related>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="htmlElement.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для проверки на равенство.</param>
        <summary>Проверяет, равен ли переданный объект текущему элементу.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="obj" /> является элементом <see cref="T:System.Windows.Forms.HtmlElement" />, и значение <see langword="false" /> в противном случае.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FirstChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement FirstChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement FirstChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.FirstChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FirstChild As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ FirstChild { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FirstChild : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.FirstChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает следующий элемент, расположенный под этим элементом в дереве документа.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.HtmlElement" />, представляющий первый элемент, расположенный под текущим элементом (в исходном порядке).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Windows.Forms.HtmlElement.FirstChild%2A> в сочетании с <xref:System.Windows.Forms.HtmlElement.NextSibling%2A> пройти по дереву документа HTML-документа.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533755.aspx">firstChild свойство</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; unit" Usage="htmlElement.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Помещает фокус ввода пользователя в текущий элемент.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Установка фокуса в элементе предоставляет фокус и делает элемент активным. Например, элемент, имеющий фокус будет возвращаться посредством <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> свойство <xref:System.Windows.Forms.HtmlDocument>.  
  
 Любой нажатий клавиш, введенные пользователем после <xref:System.Windows.Forms.HtmlElement.Focus%2A> вызова будет отправляться на этот элемент.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536425.aspx">Метод фокус</related>
      </Docs>
    </Member>
    <Member MemberName="Focusing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Focusing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Focusing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Focusing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Focusing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Focusing;" />
      <MemberSignature Language="F#" Value="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда элемент впервые получает фокус ввода пользователя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элемент, получившем фокус, прежде чем пользователь переключается на другое приложение, с помощью панели инструментов или клавиши ALT + TAB получит <xref:System.Windows.Forms.HtmlElement.Focusing> и <xref:System.Windows.Forms.HtmlElement.GotFocus> события еще раз при переключении обратно в приложение.  
  
 Не удается отменить поведение по умолчанию для этого события. Чтобы убрать фокус с элемента, вызовите <xref:System.Windows.Forms.HtmlElement.Focus%2A> на другой элемент изнутри <xref:System.Windows.Forms.HtmlElement.GotFocus> событий.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.Focusing> также может возникнуть событие для элемента в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> сам по себе, класс, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.Focusing> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.Focusing> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#438](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#438)]
 [!code-vb[System.Windows.Forms.EventExamples#438](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#438)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536935.aspx">onfocusin событий</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public string GetAttribute (string attributeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetAttribute(string attributeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttribute (attributeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetAttribute(System::String ^ attributeName);" />
      <MemberSignature Language="F#" Value="member this.GetAttribute : string -&gt; string" Usage="htmlElement.GetAttribute attributeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="attributeName">Имя атрибута. В этом аргументе не учитывается регистр.</param>
        <summary>Возвращает значение атрибута с заданным именем в элементе.</summary>
        <returns>Значение этого атрибута в элементе, например значение <see cref="T:System.String" />. Если указанный атрибут не существует в этом элементе, возвращает пустую строку.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Атрибут в формате HTML — любой парой допустимое имя/значение для этого элемента. <xref:System.Windows.Forms.HtmlElement> предоставляет только те атрибуты, которые являются общими для всех элементов, оставив те, которые применяются только к определенным типам элементов; `SRC` — это предопределенный атрибут для `IMG` тег, например, но не для `DIV` тега. Используйте <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> и <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> управления атрибутами, которые не представлены на управляемый объект модели (DOM).  
  
 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> и <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> регистр не учитывается.  
  
   
  
## Examples  
 В следующем примере кода извлекает все `META` теги в HTML документ, с помощью <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> найти `META` тег с именем `Description`. В этом примере предполагается, что приложение имеет <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536429.aspx">Метод getAttribute</related>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection GetElementsByTagName (string tagName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElementCollection GetElementsByTagName(string tagName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementsByTagName (tagName As String) As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElementCollection ^ GetElementsByTagName(System::String ^ tagName);" />
      <MemberSignature Language="F#" Value="member this.GetElementsByTagName : string -&gt; System.Windows.Forms.HtmlElementCollection" Usage="htmlElement.GetElementsByTagName tagName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tagName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tagName">Имя тега, с которым извлекаются объекты <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Возвращает коллекцию элементов, представленных в HTML-коде, по заданному тегу <c>HTML</c>.</summary>
        <returns>Коллекция <see cref="T:System.Windows.Forms.HtmlElementCollection" />, содержащая все элементы, у которых имя тега <c>HTML</c> совпадает с <paramref name="tagName" />.</returns>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536439.aspx">Метод getElementsByTagName</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="htmlElement.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Служит хэш-функцией для определенного типа.</summary>
        <returns>Хэш-код для текущего объекта <see cref="T:System.Object" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда элемент получил фокус ввода пользователя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Невозможно ни отменить поведение по умолчанию это событие, ни предотвратить восходящей маршрутизации. Чтобы убрать фокус с элемента, вызовите <xref:System.Windows.Forms.HtmlElement.Focus%2A> на другой элемент изнутри <xref:System.Windows.Forms.HtmlElement.GotFocus> событий.  
  
   
  
## Examples  
 Сохраните следующий код HTML в файл и загрузить файл в <xref:System.Windows.Forms.WebBrowser> элемента управления в проекте Windows Forms.  
  
```  
<HTML>  
    <BODY>  
        <FORM name="form1">  
            <INPUT type="text" size=20 name="text1">  
            <INPUT type="text" size=20 name="text2">  
            <INPUT type="text" size=20 name="text3">  
        </FORM>  
    </BODY>  
</HTML>  
```  
  
 В следующем примере кода предотвращает следующего `INPUT` элемент в последовательности табуляции получать фокус ввода пользователя, если предыдущий элемент содержит менее пяти символов. В этом примере предполагается, что ранее упомянутых HTML-файл загружается в экземпляр <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#15)]
 [!code-vb[System.Windows.Forms.HtmlElement#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#15)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536934.aspx">onfocus событий</related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Id" />
      <MemberSignature Language="VB.NET" Value="Public Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Id : string with get, set" Usage="System.Windows.Forms.HtmlElement.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает метку, по которой определяется элемент.</summary>
        <value>Уникальный идентификатор элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.Id%2A> должно быть уникальным; не может иметь два элемента с тем же <xref:System.Windows.Forms.HtmlElement.Id%2A> внутри того же документа. Используйте <xref:System.Windows.Forms.HtmlElement.Name%2A> свойство, чтобы предоставить тот же идентификатор, чтобы группа логически связанных элементов.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.Name" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533880.aspx">идентификатор свойства</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534184.aspx">Свойство name</related>
      </Docs>
    </Member>
    <Member MemberName="InnerHtml">
      <MemberSignature Language="C#" Value="public string InnerHtml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerHtml" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.InnerHtml" />
      <MemberSignature Language="VB.NET" Value="Public Property InnerHtml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InnerHtml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerHtml : string with get, set" Usage="System.Windows.Forms.HtmlElement.InnerHtml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает разметку HTML, расположенную под этим элементом.</summary>
        <value>Разметка HTML, определяющая дочерние элементы текущего элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существует несколько способов для добавления новых элементов в существующую страницу HTML, таких как <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> и <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> методы. С помощью <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> часто является самым быстрым способом добавления нового содержимого, когда это нужно сделать большим числом атрибутов или стили для новых элементов.  
  
 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> отличается от <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> в том, что <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> не будет содержать HTML-код, представляющий объект, который вы вызываете. См. в разделе <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> Дополнительные сведения о различиях между этими двумя свойствами.  
  
 Параметр <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> уничтожает все дочерние элементы, ранее добавляется к элементу. Если получить элемент из модели DOM и затем назначить новый HTML родительские <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> справочной информации для этого элемента будет бесполезной свойство, и его поведение при вызове его свойства и методы не определено.  
  
 Для некоторых элементов, установка <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> не является допустимой операцией. Некоторые теги HTML имеют отсутствует закрывающий тег, например `IMG` тег и поэтому не может содержать вложенные элементы. Некоторые теги, такие как `SCRIPT` тег, могут содержать только текстовое содержимое; параметр <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> будет привести к ошибке. Для обоих типов тегов <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> свойство возвратит `false`. Тем не менее, также нельзя задать <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> на `TABLE` и `TR` элементы, как присвоение код HTML неправильного формата этих элементов может повредить отрисовки документа. Используйте <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> или `insertRow` и `insertCell` методов в неуправляемом `IHTMLTable` интерфейса для добавления строк и ячеек для `TABLE`.  
  
 Если вам нужно только назначаете текст элемента и не HTML-разметка, используйте <xref:System.Windows.Forms.HtmlElement.InnerText%2A> свойство вместо этого.  
  
 Присвоения значения <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> будут уничтожены все текстовые значения, ранее назначенный с помощью <xref:System.Windows.Forms.HtmlElement.InnerText%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Для этого элемента не допускается создание дочерних.</exception>
        <altmember cref="M:System.Windows.Forms.HtmlElement.AppendChild(System.Windows.Forms.HtmlElement)" />
        <altmember cref="M:System.Windows.Forms.HtmlElement.InsertAdjacentElement(System.Windows.Forms.HtmlElementInsertionOrientation,System.Windows.Forms.HtmlElement)" />
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerText" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533897.aspx">Свойство innerHTML</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536452.aspx">Метод insertAdjacentHTML</related>
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public string InnerText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.InnerText" />
      <MemberSignature Language="VB.NET" Value="Public Property InnerText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InnerText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerText : string with get, set" Usage="System.Windows.Forms.HtmlElement.InnerText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или устанавливает текст, присваиваемый элементу.</summary>
        <value>Текст элемента, не содержащий разметки HTML. Если элемент содержит дочерние элементы, будет сохраняться только текст этих элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке назначить HTML к элементу <xref:System.Windows.Forms.HtmlElement.InnerText%2A>, HTML-код будет отображаться как литералы в документе, как если бы вы просматривали HTML в текстовый файл. Если назначить HTML к элементу с помощью <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> свойство, <xref:System.Windows.Forms.HtmlElement.InnerText%2A> возвращает весь текст в том, что удалены HTML с разметкой.  
  
 Присвоения значения <xref:System.Windows.Forms.HtmlElement.InnerText%2A> уничтожит дочерние элементы, которые принадлежат к элементу.  
  
   
  
## Examples  
 В следующем коде создается новый гиперссылки с помощью <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>и присваивает текста ссылки, используя <xref:System.Windows.Forms.HtmlElement.InnerText%2A> свойство.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlElement#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Указанный элемент не может содержать текст (например, элемент <c>IMG</c>).</exception>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerHtml" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533899.aspx">innerText, свойство</related>
      </Docs>
    </Member>
    <Member MemberName="InsertAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement InsertAdjacentElement (System.Windows.Forms.HtmlElementInsertionOrientation orient, System.Windows.Forms.HtmlElement newElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement InsertAdjacentElement(valuetype System.Windows.Forms.HtmlElementInsertionOrientation orient, class System.Windows.Forms.HtmlElement newElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InsertAdjacentElement(System.Windows.Forms.HtmlElementInsertionOrientation,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAdjacentElement (orient As HtmlElementInsertionOrientation, newElement As HtmlElement) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ InsertAdjacentElement(System::Windows::Forms::HtmlElementInsertionOrientation orient, System::Windows::Forms::HtmlElement ^ newElement);" />
      <MemberSignature Language="F#" Value="member this.InsertAdjacentElement : System.Windows.Forms.HtmlElementInsertionOrientation * System.Windows.Forms.HtmlElement -&gt; System.Windows.Forms.HtmlElement" Usage="htmlElement.InsertAdjacentElement (orient, newElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="orient" Type="System.Windows.Forms.HtmlElementInsertionOrientation" />
        <Parameter Name="newElement" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="orient">Место вставки этого элемента относительно текущего элемента.</param>
        <param name="newElement">Новый элемент, который требуется вставить.</param>
        <summary>Вставляет новый элемент в модель DOM.</summary>
        <returns>Вставленный элемент <see cref="T:System.Windows.Forms.HtmlElement" />. Если не удалось вставить элемент, возвращается значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не вызывайте этот метод до после <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> событий на <xref:System.Windows.Forms.WebBrowser> произошла элемента управления. Вызов этого метода до этого может привести к исключению, как документ еще не будет завершена загрузка.  
  
 Ли значение <xref:System.Windows.Forms.HtmlElementInsertionOrientation> является допустимым будет зависеть от типа элемента. Например <xref:System.Windows.Forms.HtmlElementInsertionOrientation.AfterBegin> является допустимым, если элемент является `DIV`, но не в случае `SCRIPT` или `IMG` элемент, ни один из которых может содержать дочерние элементы.  
  
   
  
## Examples  
 В следующем примере кода пример вставки `DIV` элемент в верхней части каждой страницы, которую пользователи просматривают вне сервера ADatum.com. В этом примере предполагается, что форма содержит <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`. Пример также необходимо импортировать пространство имен <xref:System.Text.RegularExpressions>.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlElement#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536451.aspx">Метод insertAdjacentElement</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет метод, являющийся уникальным для текущего элемента.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string methodName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string methodName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InvokeMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (methodName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ methodName);" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string -&gt; obj" Usage="htmlElement.InvokeMember methodName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="methodName">Имя вызываемого свойства или метода.</param>
        <summary>Выполняет невыявленный метод в базовом элементе DOM данного элемента.</summary>
        <returns>Элемент, возвращаемый данным методом и представленный в виде объекта <see cref="T:System.Object" />. Если этот объект <see cref="T:System.Object" /> является другим элементом HTML, и существует ссылка на неуправляемую библиотеку MSHTML, добавленную в проект, элемент можно привести к соответствующему неуправляемому интерфейсу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может использоваться для вызова методов из объекта модели (DOM), не имеют эквивалентов в управляемом коде. Эта версия <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> для выполнения не предоставленным явно методов, которые не принимают аргументов. Пример см. в разделе <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string methodName, params object[] parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string methodName, object[] parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InvokeMember(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (methodName As String, ParamArray parameter As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ methodName, ... cli::array &lt;System::Object ^&gt; ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string * obj[] -&gt; obj" Usage="htmlElement.InvokeMember (methodName, parameter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="parameter" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="methodName">Имя вызываемого свойства или метода.</param>
        <param name="parameter">Список передаваемых параметров.</param>
        <summary>Выполняет функцию, определенную в текущей HTML-странице с помощью языка скриптов.</summary>
        <returns>Элемент, возвращаемый функцией и представленный в виде объекта <see cref="T:System.Object" />. Если этот объект <see cref="T:System.Object" /> является другим элементом HTML, и существует ссылка на неуправляемую библиотеку MSHTML, добавленную в проект, элемент можно привести к соответствующему неуправляемому интерфейсу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может использоваться для вызова методов из объекта модели (DOM), не имеют эквивалентов в управляемом коде. Заданы все аргументы <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> будут преобразованы в Win32 `VARIANT` типы данных, прежде чем они передаются в функцию именованного сценариев.  
  
   
  
## Examples  
 В следующем коде получается пример `TABLE` вызывается `dataTable` и использует не предоставленным явно `moveRow` способ переместить в начало строки в конце таблицы.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlElement#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь нажимает клавишу на клавиатуре.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyDown> Происходит перед <xref:System.Windows.Forms.HtmlElement.KeyPress>, который, в предшествует <xref:System.Windows.Forms.HtmlElement.KeyUp>.  
  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.KeyDown> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.KeyDown> также может возникнуть событие для элемента в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> сам по себе, класс, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.KeyDown> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.KeyDown> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#442](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#442)]
 [!code-vb[System.Windows.Forms.EventExamples#442](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#442)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536938.aspx">Событие OnKeyDown</related>
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyPress As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyPress;" />
      <MemberSignature Language="F#" Value="member this.KeyPress : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyPress : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь нажимает и отпускает клавишу на клавиатуре.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyPress> Происходит после <xref:System.Windows.Forms.HtmlElement.KeyDown> и перед <xref:System.Windows.Forms.HtmlElement.KeyUp>.  
  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.KeyPress> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.KeyPress> также может возникнуть событие для элемента в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> сам по себе, класс, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.KeyPress> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.KeyPress> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#443](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#443)]
 [!code-vb[System.Windows.Forms.EventExamples#443](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#443)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536939.aspx">OnKeyPress событий</related>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь отпускает клавишу на клавиатуре.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyUp> Происходит после <xref:System.Windows.Forms.HtmlElement.KeyPress>, вызываемому после <xref:System.Windows.Forms.HtmlElement.KeyDown>.  
  
 Не удается отменить это событие.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.KeyUp> также может возникнуть событие для элемента в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> сам по себе, класс, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.KeyUp> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.KeyUp> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#444](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#444)]
 [!code-vb[System.Windows.Forms.EventExamples#444](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#444)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536940.aspx">onkeyup событий</related>
      </Docs>
    </Member>
    <Member MemberName="LosingFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LosingFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LosingFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.LosingFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LosingFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LosingFocus;" />
      <MemberSignature Language="F#" Value="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда элемент теряет фокус ввода пользователя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.LosingFocus> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.LosingFocus> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#440](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#440)]
 [!code-vb[System.Windows.Forms.EventExamples#440](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#440)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда элемент потерял фокус ввода пользователя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элемент больше не будет получать события нажатия клавиши после <xref:System.Windows.Forms.HtmlElement.LostFocus> происходит до его снова, получает фокус пользователя, выбрав его на страницы или приложения, вызывающего <xref:System.Windows.Forms.HtmlElement.Focus%2A> метод для этого элемента.  
  
 Не удается отменить это событие.  
  
 <xref:System.Windows.Forms.HtmlElement.LostFocus> Также может возникнуть событие для элемента в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> сам по себе, класс, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.LostFocus> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.LostFocus> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#441](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#441)]
 [!code-vb[System.Windows.Forms.EventExamples#441](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#441)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536936.aspx">параметр onfocusout событий</related>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь нажимает кнопку мыши.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.MouseDown> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.MouseDown> также может возникнуть событие для элемента в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> сам по себе, класс, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.MouseDown> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.MouseDown> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#446](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#446)]
 [!code-vb[System.Windows.Forms.EventExamples#446](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#446)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536944.aspx">onMouseDown событий</related>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseEnter : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь впервые наводит указатель мыши на текущий элемент.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.MouseEnter> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.MouseEnter> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#449](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#449)]
 [!code-vb[System.Windows.Forms.EventExamples#449](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#449)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь выводит указатель мыши из текущего элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.MouseLeave> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.MouseLeave> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#450](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#450)]
 [!code-vb[System.Windows.Forms.EventExamples#450](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#450)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь перемещает указатель мыши по элементу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не удается отменить это событие.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.MouseMove> также может возникнуть событие для элемента в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> сам по себе, класс, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.MouseMove> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.MouseMove> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#445](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#445)]
 [!code-vb[System.Windows.Forms.EventExamples#445](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#445)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536947.aspx">OnMouseMove событий</related>
      </Docs>
    </Member>
    <Member MemberName="MouseOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseOver;" />
      <MemberSignature Language="F#" Value="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда указатель мыши входит в пределы элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.MouseOver> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.MouseOver> также может возникнуть событие для элемента в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> сам по себе, класс, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.MouseOver> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.MouseOver> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#447](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#447)]
 [!code-vb[System.Windows.Forms.EventExamples#447](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#447)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536949.aspx">onmouseover событий</related>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь отпускает кнопку мыши.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.MouseUp> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.MouseUp> также может возникнуть событие для элемента в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> сам по себе, класс, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класс `true`.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.HtmlElement.MouseUp> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий, связанный с <xref:System.Windows.Forms.HtmlElement.MouseUp> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#448](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#448)]
 [!code-vb[System.Windows.Forms.EventExamples#448](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#448)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536950.aspx">onMouseUp событий</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.HtmlElement.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя элемента.</summary>
        <value>Объект <see cref="T:System.String" />, представляющий имя элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Windows.Forms.HtmlElement.Name%2A> свойство для извлечения элементов из документа с помощью <xref:System.Windows.Forms.HtmlElementCollection.GetElementsByName%2A> метод <xref:System.Windows.Forms.HtmlElement.All%2A> свойство <xref:System.Windows.Forms.HtmlDocument>.  
  
 При применении к `INPUT` элементы, <xref:System.Windows.Forms.HtmlElement.Name%2A> определяет имя переменной для этого элемента данных при отправке его формы на сервер.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534184.aspx">Свойство name</related>
      </Docs>
    </Member>
    <Member MemberName="NextSibling">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement NextSibling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement NextSibling" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.NextSibling" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextSibling As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ NextSibling { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextSibling : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.NextSibling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает следующий элемент, расположенный в дереве документа на одном уровне с данным элементом.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.HtmlElement" />, представляющий элемент, расположенный справа от текущего элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Windows.Forms.HtmlElement.NextSibling%2A> в сочетании с <xref:System.Windows.Forms.HtmlElement.FirstChild%2A> в обход дерева документа для HTML-элемента.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534189.aspx">Свойство nextSibling</related>
      </Docs>
    </Member>
    <Member MemberName="OffsetParent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement OffsetParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement OffsetParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OffsetParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OffsetParent As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ OffsetParent { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetParent : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.OffsetParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает элемент, из которого вычисляется <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />.</summary>
        <value>Элемент, из которого вычисляются смещения.  
  
Если родительский элемент или другой элемент в иерархии элемента использует относительное или абсолютное расположение, значением <see langword="OffsetParent" /> будет первый элемент с относительным или абсолютным расположением, в который вложен текущий элемент. Если ни один из элементов, расположенных выше текущего элемента, не имеет абсолютного или относительного положения, <see langword="OffsetParent" /> будет <c>текст</c> тега документа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы могут располагаться на HTML-страницу одним из трех способов: по умолчанию положение потока; относительное расположение, в котором элемент смещается на фиксированное значение, относительно его родительского элемента; и абсолютное позиционирование, в которой элемент получает фиксированные значения координат относительно верхнего левого угла документа.  
  
 Элементы документа относительное или абсолютное расположение, вы можете использовать `OffsetParent` для вычисления координат положения элемента в клиентской области.  
  
 Дополнительные сведения об элементе в HTML, см. в разделе [о позиционирование элементов](https://msdn.microsoft.com/library/ms533005.aspx).  
  
   
  
## Examples  
 В следующем примере кода как <xref:System.Windows.Forms.HtmlElement.OffsetParent%2A> и <xref:System.Windows.Forms.HtmlElement.OffsetRectangle%2A> отличаются для `span1`, `span2` и `span3`:  
  
```  
<HTML>  
    <BODY id="documentBody">  
  
        <DIV id="div1">  
            <SPAN id="span1">Placeholder text 1.</SPAN>  
        </DIV>  
  
        <DIV id="div2" style="position:relative;top:100px;left:100px;">  
            <SPAN id="span2">Placeholder text 2.</SPAN>  
        </DIV>  
  
        <DIV id="div3" style="position:absolute;top:200px;left:200px;">  
            <DIV id="div4" style="position:relative;top:100px;left:100px;">  
                <SPAN id="span3">Placeholder text 3.</SPAN>  
            </DIV>  
        </DIV>  
  
    </BODY>  
</HTML>  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlElement#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534302.aspx">значением offsetParent свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms530302.aspx">Измерения размеров и расположения элементов</related>
      </Docs>
    </Member>
    <Member MemberName="OffsetRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle OffsetRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle OffsetRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OffsetRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle OffsetRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.OffsetRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает расположение элемента относительно его родительского элемента.</summary>
        <value>Координаты x и y элемента, а также его ширина и высота относительно родительского элемента.  
  
Если родительский элемент имеет относительное или абсолютное расположение, свойство <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> возвращает смещение родительского элемента. Если элемент располагается относительно своего родительского элемента, то свойство <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> возвращает смещение относительно родительского элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы могут располагаться на HTML-страницу одним из трех способов:  
  
-   Потоковое расположение по умолчанию.  
  
-   Относительное расположение, в котором элемент смещается на фиксированное значение, относительно его родительского элемента.  
  
-   Абсолютное расположение, в котором элемент получает фиксированные значения координат относительно верхнего левого угла документа.  
  
 Дополнительные сведения об элементе в HTML, см. в разделе [о позиционирование элементов](https://msdn.microsoft.com/library/ms533005.aspx).  
  
   
  
## Examples  
 В следующем примере кода как <xref:System.Windows.Forms.HtmlElement.OffsetParent%2A> и <xref:System.Windows.Forms.HtmlElement.OffsetRectangle%2A> отличаются для `span1`, `span2` и `span3`:  
  
```  
<HTML>  
    <BODY id="documentBody">  
  
        <DIV id="div1">  
            <SPAN id="span1">Placeholder text 1.</SPAN>  
        </DIV>  
  
        <DIV id="div2" style="position:relative;top:100px;left:100px;">  
            <SPAN id="span2">Placeholder text 2.</SPAN>  
        </DIV>  
  
        <DIV id="div3" style="position:absolute;top:200px;left:200px;">  
            <DIV id="div4" style="position:relative;top:100px;left:100px;">  
                <SPAN id="span3">Placeholder text 3.</SPAN>  
            </DIV>  
        </DIV>  
  
    </BODY>  
</HTML>  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlElement#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.OffsetParent" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534200.aspx">offsetLeft свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534303.aspx">Свойство offsetTop</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534304.aspx">offsetWidth свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534199.aspx">offsetHeight свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms530302.aspx">Измерения размеров и расположения элементов</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.HtmlElement left, System.Windows.Forms.HtmlElement right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.HtmlElement left, class System.Windows.Forms.HtmlElement right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.op_Equality(System.Windows.Forms.HtmlElement,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As HtmlElement, right As HtmlElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::HtmlElement ^ left, System::Windows::Forms::HtmlElement ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.HtmlElement * System.Windows.Forms.HtmlElement -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlElement" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="left">Первая коллекция <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <param name="right">Второй объект <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Проверяет равенство двух элементов.</summary>
        <returns>Значение <see langword="true" />, если оба параметра имеют значение <see langword="null" /> или имеют общий базовый интерфейс модели COM. В противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Оператор проверок на равенство `IUnknown` указатели базовых объектов COM в оболочку с помощью предоставленного <xref:System.Windows.Forms.HtmlElement> классы.  
  
 Имеет эквивалентный метод для этого оператора <xref:System.Windows.Forms.HtmlElement.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.HtmlElement left, System.Windows.Forms.HtmlElement right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.HtmlElement left, class System.Windows.Forms.HtmlElement right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.op_Inequality(System.Windows.Forms.HtmlElement,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As HtmlElement, right As HtmlElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::HtmlElement ^ left, System::Windows::Forms::HtmlElement ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.HtmlElement * System.Windows.Forms.HtmlElement -&gt; bool" Usage="System.Windows.Forms.HtmlElement.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlElement" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="left">Первая коллекция <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <param name="right">Второй объект <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Проверяет неравенство двух объектов <see cref="T:System.Windows.Forms.HtmlElement" />.</summary>
        <returns>Значение <see langword="true" />, если только один из элементов имеет значение <see langword="null" /> или эти два объекта не равны. В противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Эквивалентный метод для этого оператора является отрицанием <xref:System.Windows.Forms.HtmlElement.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OuterHtml">
      <MemberSignature Language="C#" Value="public string OuterHtml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterHtml" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OuterHtml" />
      <MemberSignature Language="VB.NET" Value="Public Property OuterHtml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OuterHtml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OuterHtml : string with get, set" Usage="System.Windows.Forms.HtmlElement.OuterHtml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает HTML-код текущего элемента.</summary>
        <value>HTML-код текущего элемента и его дочерних элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тогда как <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> вернет все HTML, содержащихся в текущий элемент, за исключением текущего элемента окружающей теги, <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> включает тега текущего элемента, а также код HTML, содержащий тег, например:  
  
 `<HTML>`  
  
 `<BODY>`  
  
 `<DIV id="div1">`  
  
 `Hello`  
  
 `<DIV id="div2">`  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 `</BODY>`  
  
 `</HTML>`  
  
 В этом примере вызов <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> на `div2` возвращает:  
  
 `<DIV id="div2">`  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 Вызов <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> возвращает:  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 Если присвоить новое значение для <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A>, текущая ссылка на элемент станет недействительным; он не будет отражать имя, свойства и дочернего содержимого HTML-только назначенные.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerHtml" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534310.aspx">Свойство outerHTML</related>
      </Docs>
    </Member>
    <Member MemberName="OuterText">
      <MemberSignature Language="C#" Value="public string OuterText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OuterText" />
      <MemberSignature Language="VB.NET" Value="Public Property OuterText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OuterText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OuterText : string with get, set" Usage="System.Windows.Forms.HtmlElement.OuterText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает текст текущего элемента.</summary>
        <value>Текст, расположенный внутри текущего элемента и его дочерних элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке назначить HTML к элементу <xref:System.Windows.Forms.HtmlElement.OuterText%2A>, HTML-код будет отображаться как литералы в документе, как если бы вы просматривали HTML в текстовый файл. Если назначить HTML к элементу с помощью <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> свойство, <xref:System.Windows.Forms.HtmlElement.OuterText%2A> возвращает весь текст в том, что удалены HTML с разметкой.  
  
 Присвоения значения <xref:System.Windows.Forms.HtmlElement.OuterText%2A> уничтожит дочерние элементы, которые принадлежат к элементу.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Текст нельзя расположить вне этого элемента.</exception>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerText" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534311.aspx">outerText свойство</related>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ Parent { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает родительский элемент текущего элемента.</summary>
        <value>Элемент, расположенный над текущим в иерархии HTML-документа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.Parent%2A> Свойство обеспечивает обнаружение элемента контекста. Это наиболее полезно внутри обработчиков событий, таких как <xref:System.Windows.Forms.HtmlElement.Click>, которые вызывают срабатывание для любого элемента в любом месте иерархии объекта документа.  
  
 <xref:System.Windows.Forms.HtmlElement.Parent%2A> Свойство HTML-элемента (верхней части HTML-документ), указывает на него. При вызове метода <xref:System.Windows.Forms.HtmlElement.Parent%2A> в цикле, убедитесь, что условия разрыва цикла сравнивает тип текущего элемента и тип `Parent` свойство, в противном случае ваш код может выполнять бесконечный цикл.  
  
   
  
## Examples  
 В следующем примере кода находит все `IMG` теги в документе и использует <xref:System.Windows.Forms.HtmlElement.Parent%2A> свойство для проверки ли `IMG` является ссылкой на другую страницу; в противном случае код присваивает URL-адрес `ALT` атрибут `IMG`тег, таким образом, чтобы пользователи, наведя указатель мыши образ, чтобы увидеть, где потребуется их.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlElement#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534327.aspx">Родительскийэлемент свойство</related>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (string eventName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RaiseEvent(string eventName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.RaiseEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (eventName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RaiseEvent(System::String ^ eventName);" />
      <MemberSignature Language="F#" Value="member this.RaiseEvent : string -&gt; unit" Usage="htmlElement.RaiseEvent eventName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventName">Имя создаваемого события.</param>
        <summary>Вызывает для события с указанным именем все зарегистрированные обработчики событий.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для доступа к событиям объектной модели HTML документа (DOM). Напрямую вызывает [IHTMLElement3::fireEvent](https://go.microsoft.com/fwlink/?LinkId=103189) метод. Дополнительные сведения об использовании DOM через <xref:System.Windows.Forms.HtmlElement> , представлена в разделе [доступ к которым не предоставляется явно членов в управляемых объектной модели документов HTML](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFocus">
      <MemberSignature Language="C#" Value="public void RemoveFocus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFocus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.RemoveFocus" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFocus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFocus();" />
      <MemberSignature Language="F#" Value="member this.RemoveFocus : unit -&gt; unit" Usage="htmlElement.RemoveFocus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет фокус из текущего элемента, если этот элемент имеет фокус.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода вызывает <xref:System.Windows.Forms.HtmlElement.LostFocus> событий для элемента.  
  
 Если фокус установлен из элемента с помощью этого метода, ему присваивается документ, содержащий элемент, а не к следующему элементу в последовательности табуляции.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536347.aspx">Метод размытия</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignWithTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollIntoView(bool alignWithTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.ScrollIntoView(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollIntoView (alignWithTop As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollIntoView(bool alignWithTop);" />
      <MemberSignature Language="F#" Value="member this.ScrollIntoView : bool -&gt; unit" Usage="htmlElement.ScrollIntoView alignWithTop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignWithTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignWithTop">Если задано значение <see langword="true" />, верхняя часть объекта будет отображаться в верхней части окна. Если задано значение <see langword="false" />, нижняя часть объекта будет отображаться в нижней части окна.</param>
        <summary>Выполняет прокрутку документа, содержащего этот элемент, пока верхний или нижний край элемента не окажется выровненным с окном документа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода выполняет поиск элемента по имени и совершается прокрутку по странице, таким образом, чтобы верхний элемента выравнивается по верхней части страницы отображается.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#12)]
 [!code-vb[System.Windows.Forms.HtmlElement#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#12)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536730.aspx">Метод scrollIntoView</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollLeft">
      <MemberSignature Language="C#" Value="public int ScrollLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScrollLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollLeft" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScrollLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollLeft : int with get, set" Usage="System.Windows.Forms.HtmlElement.ScrollLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает расстояние между краем элемента и левым краем его содержимого.</summary>
        <value>Расстояние (в пикселях) между левым краем элемента и левым краем его содержимого.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Полный размеры области прокрутки могут использоваться <xref:System.Windows.Forms.HtmlElement.ScrollRectangle%2A>; `ScrollLeft` и <xref:System.Windows.Forms.HtmlElement.ScrollTop%2A> предоставляются независимо друг от друга, так как это только два свойства области прокрутки, разработчики могут установить.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534617.aspx">"scrollleft" свойство</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ScrollRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ScrollRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ScrollRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ScrollRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ScrollRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.ScrollRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает размеры области прокрутки элемента.</summary>
        <value>Размер и координата области прокрутки элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элемент будет иметь область прокрутки, если его содержимое превышает размер, его размеры, если стиль переполнения для элемента запрещает отрисовку полос прокрутки.  
  
 Нельзя напрямую изменять размер области прокрутки, но вы можете изменить расстояние между границами области прокрутки и границами элемента. Используйте <xref:System.Windows.Forms.HtmlElement.ScrollLeft%2A> и <xref:System.Windows.Forms.HtmlElement.ScrollTop%2A> свойства для этого.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534617.aspx">"scrollleft" свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534618.aspx">"scrolltop", свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534615.aspx">scrollHeight свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534619.aspx">scrollWidth свойство</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534312.aspx">Свойство переполнения</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollTop">
      <MemberSignature Language="C#" Value="public int ScrollTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScrollTop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollTop" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScrollTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollTop : int with get, set" Usage="System.Windows.Forms.HtmlElement.ScrollTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает расстояние между краем элемента и верхним краем его содержимого.</summary>
        <value>Расстояние (в пикселях) между верхним краем элемента и верхним краем его содержимого.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Полный размеры области прокрутки могут использоваться <xref:System.Windows.Forms.HtmlElement.ScrollRectangle%2A>; <xref:System.Windows.Forms.HtmlElement.ScrollLeft%2A> и `ScrollTop` предоставляются независимо друг от друга, так как это только два свойства области прокрутки, разработчики могут установить.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534618.aspx">"scrolltop", свойство</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttribute">
      <MemberSignature Language="C#" Value="public void SetAttribute (string attributeName, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAttribute(string attributeName, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.SetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttribute (attributeName As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAttribute(System::String ^ attributeName, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetAttribute : string * string -&gt; unit" Usage="htmlElement.SetAttribute (attributeName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="attributeName">Имя атрибута, который нужно установить.</param>
        <param name="value">Новое значение этого атрибута.</param>
        <summary>Задает значение атрибута с заданным именем в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Атрибут в формате HTML — любой допустимый пара имя значение для этого элемента. <xref:System.Windows.Forms.HtmlElement> предоставляет только те атрибуты, которые являются общими для всех элементов, оставив те, которые применяются только к определенным типам элементов; `SRC` — это предопределенный атрибут для `IMG` тег, например, но не для `DIV` тега. Используйте <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> и <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> управления атрибутами, которые не представлены на управляемый объект модели (DOM).  
  
 Если `attributeName` не является определенным атрибутом элемента, <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> будет определить его в элемент как новый атрибут.  
  
 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> и <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> регистр не учитывается.  
  
 Чтобы задать `class` атрибут <xref:System.Windows.Forms.HtmlElement> , необходимо сослаться на атрибут как `className` при указании первый аргумент <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>  
  
   
  
## Examples  
 В следующем примере кода добавляется новый `IMG` элемент в текущий документ, с помощью <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> присвоить `SRC` атрибут для образа.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlElement#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536739.aspx">Метод setAttribute</related>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public string Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Style { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : string with get, set" Usage="System.Windows.Forms.HtmlElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает список стилей текущего элемента, разделенных точкой с запятой.</summary>
        <value>Строка, состоящая из всех стилей элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Модель объектов документов (DOM) HTML используются стили, определенные в спецификации таблиц CSS консорциума World Wide Web для управления отображением элемента. Стили <xref:System.Windows.Forms.HtmlElement.Style%2A> свойства задаются в виде двоеточия пары имя значение, где каждая пара, разделенные точкой с запятой, как показано ниже:  
  
 `style-name1:value1;...;[style-nameN:valueN;]`  
  
 Чтобы задать шрифт для `DIV` элемента 14 пунктов Times New Roman полужирным шрифтом, например, можно назначить следующую строку:  
  
 `font-face:Times New Roman;font-size:14px;font-weight:bold;`  
  
 Полный список всех доступных стилей в модель DOM HTML, см. в разделе [атрибут СТИЛЯ](https://msdn.microsoft.com/library/ms534651.aspx).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public short TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short TabIndex { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.TabIndex : int16 with get, set" Usage="System.Windows.Forms.HtmlElement.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает расположение этого элемента в последовательности перехода.</summary>
        <value>Числовой индекс элемента в последовательности перехода.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.TabIndex%2A> Определяет, какой элемент в документе HTML далее получать фокус, когда пользователь нажимает клавишу TAB. По умолчанию, только элементы, включенные в последовательности табуляции `INPUT` элементов, `SELECT` элемента управления и любой элемент, `contentEditable` свойству `true`. Можно включить любой HTML-элемент в последовательности табуляции, такие как `DIV`, назначив явно <xref:System.Windows.Forms.HtmlElement.TabIndex%2A>.  
  
 Допустимые значения для <xref:System.Windows.Forms.HtmlElement.TabIndex%2A> в диапазоне от-32767 до 32767.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534654.aspx">tabIndex свойство</related>
      </Docs>
    </Member>
    <Member MemberName="TagName">
      <MemberSignature Language="C#" Value="public string TagName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TagName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.TagName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TagName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TagName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TagName : string" Usage="System.Windows.Forms.HtmlElement.TagName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя HTML-тега.</summary>
        <value>Данное имя используется для создания этого элемента с помощью разметки HTML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Многие элементы в объектной модели документов HTML имеют атрибуты, свойства и методы, которые являются уникальными для этих элементов; Например, `HREF` атрибут `A` элемент, или `Submit` метод `FORM`. Используйте <xref:System.Windows.Forms.HtmlElement.TagName%2A> при установлены элемент потенциально произвольного типа, а также требуется для выполнения операции определенного типа.  
  
   
  
## Examples  
 В следующем примере кода находит все `IMG` теги в документе и использует `TagName` свойство для проверки ли `IMG` является ссылкой на другую страницу; в противном случае код присваивает URL-адрес `ALT` атрибут `IMG`тег, таким образом, чтобы пользователи, наведя указатель мыши образ, чтобы увидеть, где потребуется их.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlElement#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.GetElementsByTagName(System.String)" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534657.aspx">tagName свойство</related>
      </Docs>
    </Member>
  </Members>
</Type>