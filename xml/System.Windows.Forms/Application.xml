<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="01af54bca39aa90aac0e7bfe7f559ef4a32d5a49" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73397448" /></Metadata><TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет методы и свойства <see langword="static" /> для управления приложением, например методы для запуска и остановки приложения, для обработки сообщений Windows и свойства для получения сведений о приложении. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Windows.Forms.Application> имеет методы для запуска и завершения приложений и потоков, а также для обработки сообщений Windows следующим образом:  
  
-   <xref:System.Windows.Forms.Application.Run%2A> запускает цикл обработки сообщений приложения в текущем потоке и, при необходимости, делает форму видимой.  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> или <xref:System.Windows.Forms.Application.ExitThread%2A> останавливает цикл обработки сообщений.  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> обрабатывает сообщения, пока программа находится в цикле.  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> добавляет фильтр сообщений в конвейер сообщений приложения для отслеживания сообщений Windows.  
  
-   <xref:System.Windows.Forms.IMessageFilter> позволяет предотвратить возникновение события или выполнить специальные операции перед вызовом обработчика событий.  
  
 Этот класс имеет свойства <xref:System.Windows.Forms.Application.CurrentCulture%2A> и <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> для получения или задания сведений о культуре для текущего потока.  
  
 Нельзя создать экземпляр этого класса.  
  
   
  
## Examples  
 В следующем примере кода показаны числа из списка в форме. Каждый раз при нажатии `button1` приложение добавляет еще один номер в список.  
  
 Метод `Main` вызывает <xref:System.Windows.Forms.Application.Run%2A> для запуска приложения, которое создает форму, `listBox1` и `button1`. Когда пользователь нажимает кнопку `button1`, метод `button1_Click` отображает <xref:System.Windows.Forms.MessageBox>. Если пользователь нажимает кнопку `No` на <xref:System.Windows.Forms.MessageBox>, метод `button1_Click` добавляет число в список. Если пользователь нажимает кнопку `Yes`, приложение вызывает <xref:System.Windows.Forms.Application.Exit%2A> для обработки всех оставшихся сообщений в очереди, а затем для выхода.  
  
> [!NOTE]
>  Вызов <xref:System.Windows.Forms.Application.Exit%2A> приведет к сбою при частичном доверии.  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Реализация интерфейса <see cref="T:System.Windows.Forms.IMessageFilter" />, который планируется установить.</param>
        <summary>Добавляет фильтр сообщений для мониторинга сообщений Windows при их маршрутизации к местам назначения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте фильтр сообщений, чтобы предотвратить возникновение определенных событий или выполнение специальных операций для события перед его передачей в обработчик событий. Фильтры сообщений уникальны для конкретного потока.  
  
 Чтобы предотвратить отправку сообщения, экземпляр параметра `value`, передаваемый в этот метод, должен переопределять метод <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> с кодом, обрабатывающим сообщение. Метод должен вернуть `false`.  
  
> [!CAUTION]
>  Добавление фильтров сообщений в конвейер сообщений для приложения может привести к снижению производительности.  
  
   
  
## Examples  
 В следующем примере кода создается фильтр сообщений с именем `TestMessageFilter`. Этот фильтр блокирует все сообщения, относящиеся к левой кнопке мыши. Прежде чем можно будет использовать фильтр сообщений, необходимо предоставить реализацию для интерфейса <xref:System.Windows.Forms.IMessageFilter>.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для непосредственного вызывающего объекта, чтобы вызвать неуправляемый код. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, определяющее, может ли вызывающий объект выйти из этого приложения.</summary>
        <value>Значение <see langword="true" />, если вызывающий объект может выйти из этого приложения; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает значение `false`, если оно вызывается из <xref:System.Windows.Forms.Control>, размещенного в веб-браузере. Таким же <xref:System.Windows.Forms.Control> не может выйти из <xref:System.Windows.Forms.Application>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при закрытии приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо присоединить обработчики событий к событию `ApplicationExit` для выполнения необработанных необходимых задач перед прекращением работы приложения. Можно закрыть файлы, открытые этим приложением, или удалить объекты, которые не были освобождены при сборке мусора.  
  
 Поскольку это статическое событие, необходимо отсоединить все обработчики событий, присоединенные к этому событию, в самом обработчике событий `ApplicationExit`. Если вы не отсоединяете эти обработчики, они остаются прикрепленными к событию и продолжают потреблять память.  
  
   
  
## Examples  
 В следующем примере кода показаны две формы и выход из приложения при закрытии обеих форм. Когда приложение запускается и завершает работу, сохраняется расположение каждой формы. В этом примере показано использование события `ApplicationExit` для получения сведений о том, когда должно сохраняться положение формы в файле, а также когда `FileStream` должно быть закрыто.  
  
 Класс `MyApplicationContext` наследует от <xref:System.Windows.Forms.ApplicationContext> и отслеживает, когда каждая форма закрывается, и завершает текущий поток, когда они оба. Класс запоминает расположение каждой формы при его закрытии. При возникновении события `ApplicationExit` класс записывает позиции каждого пользователя в файл. Данные о положении формы хранятся в файле, озаглавленном `appdata.txt`, который создается в расположении, определенном <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. Метод `Main` вызывает `Application.Run(context)` для запуска приложения с учетом <xref:System.Windows.Forms.ApplicationContext>.  
  
 Этот код является выдержкой из примера, показанного в обзоре класса <xref:System.Windows.Forms.ApplicationContext>. Полный листинг кода см. <xref:System.Windows.Forms.ApplicationContext>.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает путь для данных приложения, являющихся общими для всех пользователей.</summary>
        <value>Путь для данных приложения, являющихся общими для всех пользователей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если путь не существует, он создается в следующем формате:  
  
 *Базовый путь*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> сначала проверяет, имеет ли сборка, содержащая главный исполняемый файл, атрибут `AssemblyInformationalVersion`. Если этот атрибут существует, он используется как для <xref:System.Windows.Forms.Application.ProductVersion%2A>, так и для <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Если этот атрибут не существует, то оба свойства используют вместо этого версию исполняемого файла.  
  
 Путь будет отличаться в зависимости от того, развернуто ли Windows Forms приложение с помощью [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложения хранятся в кэше приложений для каждого пользователя в каталоге C:\Documents and Settings\\*username* . Дополнительные сведения см. [в разделе доступ к локальным и удаленным данным в приложениях ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает раздел реестра для данных приложения, являющихся общими для всех пользователей.</summary>
        <value>Объект <see cref="T:Microsoft.Win32.RegistryKey" />, который представляет раздел реестра данных приложения, являющихся общими для всех пользователей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ключ не существует, он создается в следующем формате:  
  
 Локалмачине\софтваре\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает название компании, сопоставленное с приложением.</summary>
        <value>Название компании.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример кода получает это свойство и отображает его значение в текстовом поле. В этом примере требуется, чтобы `textBox1` был помещен в форму.  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает данные о языке и региональных параметрах для текущего потока.</summary>
        <value>Объект <see cref="T:System.Globalization.CultureInfo" />, предоставляющий данные о языке и региональных параметрах для текущего потока.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример кода получает это свойство и отображает его значение в текстовом поле. В этом примере требуется, чтобы `textBox1` был помещен в форму.  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">чтобы задать это свойство для всех окон. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает текущий язык ввода для текущего потока.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.InputLanguage" />, представляющий текущий язык ввода для текущего потока.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример кода получает это свойство и отображает его значение в текстовом поле. В этом примере требуется, чтобы `textBox1` был помещен в форму.  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для непосредственного вызывающего объекта, чтобы вызвать неуправляемый код. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обрабатывает все сообщения Windows, которые в данный момент находятся в очереди сообщений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При запуске формы Windows Forms создается новая форма, которая затем ожидает, пока события будут обработаны. Каждый раз, когда форма обрабатывает событие, она обрабатывает весь код, связанный с этим событием. Все остальные события ожидают в очереди. Пока код обрабатывает событие, приложение не отвечает. Например, окно не перерисовывается, если в верхней части перетаскивается другое окно.  
  
 При вызове <xref:System.Windows.Forms.Application.DoEvents%2A> в коде приложение может выполнять другие события. Например, если имеется форма, добавляющая данные в <xref:System.Windows.Forms.ListBox>, и добавляет <xref:System.Windows.Forms.Application.DoEvents%2A> в код, форма перерисовывается при перетаскивании на другое окно. Если удалить <xref:System.Windows.Forms.Application.DoEvents%2A> из кода, форма не будет перерисовываться до завершения выполнения обработчика событий нажатия кнопки. Дополнительные сведения об обмене сообщениями см. [в разделе Ввод данных пользователем в Windows Forms](~/docs/framework/winforms/user-input-in-windows-forms.md).  
  
 В отличие от Visual Basic 6,0, метод <xref:System.Windows.Forms.Application.DoEvents%2A> не вызывает метод <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>.  
  
 Как правило, этот метод используется в цикле для обработки сообщений.  
  
> [!CAUTION]
>  Вызов этого метода приводит к приостановке текущего потока во время обработки всех ожидающих окон сообщений. Если сообщение вызывает срабатывание события, то могут выполняться другие области кода приложения. Это может привести к тому, что приложение будет демонстрировать непредвиденные поведения, которые трудно отладить. При выполнении операций или вычислений, которые выполняются длительное время, часто бывает предпочтительнее выполнить эти операции в новом потоке. Дополнительные сведения об асинхронном программировании см. в разделе [модель асинхронного программирования (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование метода <xref:System.Windows.Forms.Application.DoEvents%2A>. При выполнении примера пользователь может выбрать графические файлы из <xref:System.Windows.Forms.OpenFileDialog>. Выбранные файлы отображаются в форме. Метод <xref:System.Windows.Forms.Application.DoEvents%2A> вызывает перерисовку формы для каждого открытого графического файла. Чтобы выполнить этот пример, вставьте следующий код в форму, содержащую <xref:System.Windows.Forms.PictureBox> с именем `PictureBox1`, <xref:System.Windows.Forms.OpenFileDialog> с именем `OpenFileDialog1` и кнопку с именем `fileButton`. Вызовите методы `InitializePictureBox` и `InitializeOpenFileDialog` из конструктора формы или метода `Load`.  
  
> [!NOTE]
>  В Visual Studio при добавлении <xref:System.Windows.Forms.OpenFileDialog> в форму с помощью операции перетаскивания необходимо изменить следующий метод `InitializeOpenFileDialog`, удалив строку, которая создает новый экземпляр <xref:System.Windows.Forms.OpenFileDialog>.  
  
 В этом примере также требуется, чтобы событие <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> элемента управления <xref:System.Windows.Forms.Button> и событие <xref:System.Windows.Forms.FileDialog.FileOk> <xref:System.Windows.Forms.OpenFileDialog> были соединены с обработчиками событий, определенными в примере. При выполнении примера откройте диалоговое окно, нажав кнопку.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Включает визуальные стили для приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод включает визуальные стили для приложения. Визуальные стили — это цвета, шрифты и другие визуальные элементы, которые формируют тему операционной системы. Элементы управления будут рисоваться с визуальными стилями, если элемент управления и операционная система его поддерживают. Чтобы получить результат, перед созданием элементов управления в приложении необходимо вызвать <xref:System.Windows.Forms.Application.EnableVisualStyles>. как правило, <xref:System.Windows.Forms.Application.EnableVisualStyles> является первой строкой функции `Main`. Отдельный манифест не требуется для включения визуальных стилей при вызове <xref:System.Windows.Forms.Application.EnableVisualStyles>.  
  
> [!NOTE]
>  До .NET Framework 2,0 свойству `FlatStyle` некоторых элементов управления, таких как элементы управления, производные от <xref:System.Windows.Forms.ButtonBase>, было присвоено значение <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType>, чтобы элементы управления рисулись с помощью визуальных стилей. В приложениях, написанных с помощью .NET Framework 2,0, это больше не требуется.  
  
> [!NOTE]
>  Этот метод не будет оказывать влияния на элементы управления, размещенные в Internet Explorer.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется вызов <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> в функции `Main` для включения визуальных стилей для приложения.  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при переходе приложения в модальное состояние.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Поскольку это статическое событие, необходимо отсоединить обработчики событий при удалении приложения или привести к утечке памяти.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Application.EnterThreadModal>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в Windows Forms и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Application.EnterThreadModal>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Требуется разрешение <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> для прослушивания события.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает путь для исполняемого файла, запустившего приложение, включая исполняемое имя.</summary>
        <value>Путь и исполняемое имя для исполняемого файла, запустившего приложение.  
  
Этот путь будет отличаться в зависимости от того, развернуто ли приложение Windows Forms с использованием [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложения хранятся в кэше приложений для каждого пользователя в каталоге C:\Documents and Settings\\*username* . Дополнительные сведения см. [в разделе доступ к локальным и удаленным данным в приложениях ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для получения пути. Связанное перечисление: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сообщает всем средствам переноса сообщений, что они должны завершить работу, а затем закрывает все окна приложения после обработки сообщений.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сообщает всем средствам переноса сообщений, что они должны завершить работу, а затем закрывает все окна приложения после обработки сообщений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Forms.Application.Exit%2A> останавливает все выполняющиеся циклы сообщений во всех потоках и закрывает все окна приложения. Этот метод не обязательно приводит к принудительному завершению работы приложения. Метод <xref:System.Windows.Forms.Application.Exit%2A> обычно вызывается из цикла обработки сообщений и заставляет <xref:System.Windows.Forms.Application.Run%2A> возвращаться. Чтобы выйти из цикла обработки сообщений только для текущего потока, вызовите <xref:System.Windows.Forms.Application.ExitThread%2A>.  
  
 <xref:System.Windows.Forms.Application.Exit%2A> вызывает следующие события и выполняет связанные условные действия:  
  
-   Событие <xref:System.Windows.Forms.Form.FormClosing> возникает для каждой формы, представленной свойством <xref:System.Windows.Forms.Application.OpenForms%2A>. Это событие можно отменить, задав для свойства <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> параметра <xref:System.Windows.Forms.FormClosingEventArgs> значение `true`.  
  
-   Если один из обработчиков отменяет событие, <xref:System.Windows.Forms.Application.Exit%2A> возвращается без дальнейших действий. В противном случае для каждой открытой формы вызывается событие <xref:System.Windows.Forms.Form.FormClosed>, после чего все выполняющиеся циклы сообщений и формы закрываются.  
  
> [!NOTE]
>  Метод <xref:System.Windows.Forms.Application.Exit%2A> не вызывает события <xref:System.Windows.Forms.Form.Closed> и <xref:System.Windows.Forms.Form.Closing>, которые устарели по отношению к [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
   
  
## Examples  
 В следующем примере кода показаны числа из списка в форме. Каждый раз при нажатии `button1` приложение добавляет еще один номер в список.  
  
 Метод `Main` вызывает <xref:System.Windows.Forms.Application.Run%2A> для запуска приложения, которое создает форму, `listBox1` и `button1`. Когда пользователь нажимает кнопку `button1`, метод `button1_Click` добавляет числа от 1 до 3 в список и отображает <xref:System.Windows.Forms.MessageBox>. Если пользователь нажмет кнопку **нет** на <xref:System.Windows.Forms.MessageBox>, метод `button1_Click` добавляет еще один номер в список. Если пользователь нажмет кнопку **Да**, приложение вызывает <xref:System.Windows.Forms.Application.Exit%2A>, чтобы обработать все оставшиеся сообщения в очереди, а затем завершить работу.  
  
 В этом примере требуется, чтобы экземпляры `listBox1` и `button1` были созданы и помещены в форму.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для непосредственного вызывающего объекта, чтобы вызвать неуправляемый код. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Возвращает сведения о том, отменил ли выход какой-либо объект <see cref="T:System.Windows.Forms.Form" /> в приложении.</param>
        <summary>Сообщает всем средствам переноса сообщений, что они должны завершить работу, а затем закрывает все окна приложения после обработки сообщений.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">Разрешение на завершение выполняющегося потока приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выходит из цикла обработки сообщений в текущем потоке и закрывает все окна в потоке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для выхода из цикла обработки сообщений текущего потока. Этот метод приводит к возвращению вызова <xref:System.Windows.Forms.Application.Run%2A> для текущего потока. Чтобы выйти из приложения целиком, вызовите <xref:System.Windows.Forms.Application.Exit%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для непосредственного вызывающего объекта, чтобы вызвать неуправляемый код. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage : Message -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="message">Фильтруемое сообщение о событии Windows.</param>
        <summary>Запускает любые фильтры для сообщения окна и возвращает копию измененного сообщения.</summary>
        <returns>Значение <see langword="true" />, если фильтр был обработан; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HighDpiMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.HighDpiMode HighDpiMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.HighDpiMode HighDpiMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.HighDpiMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HighDpiMode As HighDpiMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::HighDpiMode HighDpiMode { System::Windows::Forms::HighDpiMode get(); };" />
      <MemberSignature Language="F#" Value="member this.HighDpiMode : System.Windows.Forms.HighDpiMode" Usage="System.Windows.Forms.Application.HighDpiMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HighDpiMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущий режим высокого DPI для данного приложения.</summary>
        <value>Одно из значений перечисления, указывающее режим высокого DPI.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда приложение заканчивает обработку и собирается перейти в состояние простоя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если у вас есть задачи, которые необходимо выполнить до того, как поток переходит в состояние бездействия, присоедините их к этому событию.  
  
> [!CAUTION]
>  Поскольку это статическое событие, необходимо отсоединить обработчики событий при удалении приложения или привести к утечке памяти.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Application.Idle>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в форму Windows Forms и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Application.Idle>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает, когда приложение собирается выйти из модального состояния.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Поскольку это статическое событие, необходимо отсоединить обработчики событий при удалении приложения или привести к утечке памяти.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Application.LeaveThreadModal>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в Windows Forms и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Application.LeaveThreadModal>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает путь для данных приложения локального неперемещающегося пользователя.</summary>
        <value>Путь для данных приложения локального неперемещающегося пользователя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Локальный пользователь — это тот, чей профиль пользователя хранится в системе, в которой пользователь вошел в систему. Если путь не существует, он создается в следующем формате:  
  
 *Базовый путь*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Типичным базовым путем является C:\Documents и Settings\\*username*\Local Settings\Application Data. Однако этот путь будет отличаться, если Windows Forms приложение развертывается с помощью [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] создает собственный каталог данных приложения, изолированный от всех других приложений. Дополнительные сведения см. [в разделе доступ к локальным и удаленным данным в приложениях ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 В следующем примере кода показаны две формы и выход из приложения при закрытии обеих форм. Когда приложение запускается и завершает работу, сохраняется расположение каждой формы. Хотя в этом примере демонстрируется использование свойства <xref:System.Windows.Forms.Application.UserAppDataPath%2A> для хранения данных приложения для пользователя, вместо него можно использовать <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A>.  
  
 Класс `MyApplicationContext` наследует от <xref:System.Windows.Forms.ApplicationContext> и отслеживает, когда каждая форма закрывается, и завершает текущий поток, когда они оба. Класс хранит позиции каждой формы для пользователя. Данные о положении формы хранятся в файле, озаглавленном `Appdata.txt`, который создается в расположении, определенном <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. Метод `Main` вызывает `Application.Run(context)` для запуска приложения с учетом <xref:System.Windows.Forms.ApplicationContext>.  
  
 Этот код является выдержкой из примера, показанного в обзоре класса <xref:System.Windows.Forms.ApplicationContext>. Для краткости не указан некоторый код. Полный листинг кода см. <xref:System.Windows.Forms.ApplicationContext>.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, существует ли цикл обработки сообщений в данном потоке.</summary>
        <value>Значение <see langword="true" />, если цикл обработки сообщений существует; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При размещении Windows Forms в других средах, таких как неуправляемые приложения, это свойство всегда будет возвращать `false`. Используйте <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A>, чтобы указать Windows Forms, если среда размещения по-прежнему содержит активный цикл обработки сообщений.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициализирует OLE в текущем потоке.</summary>
        <returns>Одно из значений перечисления <see cref="T:System.Threading.ApartmentState" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом любого метода `Microsoft.Win32`, для которого требуется OLE. <xref:System.Windows.Forms.Application.OleRequired%2A> сначала проверяет, инициализирован ли OLE в текущем потоке. В противном случае он инициализирует поток для OLE.  
  
> [!NOTE]
>  Если поток не вызывает методы OLE напрямую, вызывать этот метод не нужно.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">Объект <see cref="T:System.Exception" /> представляет вызванное исключение.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Application.ThreadException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите <xref:System.Windows.Forms.Application.OnThreadException%2A>, чтобы вызвать исключение, которое остановит обработку приложения.  
  
 Класс <xref:System.Windows.Forms.Application> имеет событие <xref:System.Windows.Forms.Application.ThreadException>. Обработчик событий можно подключить к этому событию для выполнения любой пользовательской обработки, необходимой для необработанных исключений. Если не присоединить обработчик событий, <xref:System.Windows.Forms.Application.OnThreadException%2A> будет выполнять поведение по умолчанию, которое включает отображение диалогового окна для информирования пользователя об ошибке.  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> только реализует поведение исключений по умолчанию для необработанных исключений, происходящих в потоках, принадлежащих Windows Forms. Необработанные исключения в других потоках обрабатываются событием <xref:System.AppDomain.UnhandledException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию открытых форм, принадлежащих приложению.</summary>
        <value>Коллекция <see cref="T:System.Windows.Forms.FormCollection" />, содержащая все открытые в данный момент формы, принадлежащие этому приложению.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Application.OpenForms%2A> представляет доступную только для чтения коллекцию форм, принадлежащих приложению. Поиск в этой коллекции может осуществляться по позиции индекса или <xref:System.Windows.Forms.Control.Name%2A> <xref:System.Windows.Forms.Form>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Вызывающий объект должен иметь разрешение на доступ ко всем окнам, как определено значением <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> в перечислении <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает название продукта, сопоставленного с данным приложением.</summary>
        <value>Название продукта.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName` берется из метаданных сборки, содержащей основную форму текущего приложения. Его можно задать, задав <xref:System.Reflection.AssemblyProductAttribute> в манифесте сборки. Дополнительные сведения см. в статье [Манифест сборки](~/docs/standard/assembly/manifest.md).  
  
   
  
## Examples  
 Следующий пример кода получает это свойство и отображает его значение в текстовом поле. В этом примере требуется, чтобы `textBox1` был помещен в форму.  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает версию продукта, сопоставленную с данным приложением.</summary>
        <value>Версия продукта.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как правило, номер версии отображается как *основной номер*. *дополнительный номер*. *номер сборки*. *частный номер части*. Его можно задать явным образом, задав версию сборки в манифесте сборки. Дополнительные сведения см. в статье [Манифест сборки](~/docs/standard/assembly/manifest.md).  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> сначала проверяет, имеет ли сборка, содержащая главный исполняемый файл, атрибут `AssemblyInformationalVersion`. Если этот атрибут существует, он используется как для <xref:System.Windows.Forms.Application.ProductVersion%2A>, так и для <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Если этот атрибут не существует, то оба свойства используют вместо этого версию исполняемого файла.  
  
   
  
## Examples  
 Следующий пример кода получает это свойство и отображает его значение в текстовом поле. В этом примере требуется, чтобы `textBox1` был помещен в форму.  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.EventArgs" />, передаваемый событию <see cref="E:System.Windows.Forms.Application.Idle" />.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Application.Idle" /> в размещенных скриптах.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется при размещении Windows Forms в другой среде, например в неуправляемом приложении. Необходимо вызвать <xref:System.Windows.Forms.Application.RaiseIdle%2A>, когда размещаемое приложение переходит в состояние простоя. Это позволяет некоторым элементам управления Windows Forms и компонентам выполнять важную фоновую работу, в то время как пользователь не взаимодействует с приложением.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Метод, вызываемый, когда для Windows Forms требуется проверить, продолжают ли отправляться сообщения в размещаемых средах.</param>
        <summary>Регистрирует ответный вызов, чтобы проверить, выполняется ли цикл обработки сообщений в размещенных средах.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется при размещении Windows Forms в другой среде, например в неуправляемом приложении. В размещенных средах свойство <xref:System.Windows.Forms.Application.MessageLoop%2A> всегда возвращает значение false, если Windows Forms не обрабатывает сообщения. Используйте этот обратный вызов, чтобы указать Windows Forms, если среда размещения по-прежнему обрабатывает сообщения.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Реализация объекта <see cref="T:System.Windows.Forms.IMessageFilter" /> для удаления из приложения.</param>
        <summary>Удаляет фильтр сообщений из средства переноса сообщений приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете удалить фильтр сообщений, если вы больше не хотите записывать сообщения Windows до их отправки.  
  
   
  
## Examples  
 Прежде чем можно будет использовать фильтр сообщений, необходимо предоставить реализацию для интерфейса <xref:System.Windows.Forms.IMessageFilter>. Следующий класс создает фильтр сообщений с именем `TestMessageFilter`. Этот фильтр блокирует все сообщения, относящиеся к левой кнопке мыши.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, будет ли текущее приложение прорисовывать элементы управления с помощью визуальных стилей.</summary>
        <value>Значение <see langword="true" />, если визуальные стили включены для элементов управления в клиентской области окна приложения; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При рисовании пользовательского элемента управления используйте это свойство, чтобы решить, следует ли рисовать элемент управления с визуальными стилями или без него, чтобы его внешний вид соответствовал другим элементам управления в приложении.  
  
 В следующей таблице приведены четыре условия, которые должны присутствовать в <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> для возврата `true`.  
  
|Условие|Описание|  
|---------------|-----------------|  
|Операционная система поддерживает стили оформления|Чтобы проверить это условие отдельно, используйте свойство <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> класса <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> .|  
|Пользователь включил стили оформления в операционной системе|Чтобы проверить это условие отдельно, используйте свойство <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> класса <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> .|  
|Стили оформления включены в приложении|Стили оформления можно включить в приложении, вызвав метод <xref:System.Windows.Forms.Application.EnableVisualStyles> или воспользовавшись манифестом приложения, указывающим, что для рисования элементов управления будет применяться ComCtl32.dll версии 6 или более поздней.|  
|Визуальные стили используются для рисования клиентской области окон приложений|Чтобы проверить это условие отдельно, используйте свойство <xref:System.Windows.Forms.Application.VisualStyleState%2A> класса <xref:System.Windows.Forms.Application> и убедитесь, что оно имеет значение <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> или <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Завершает работу приложения и немедленно запускает новый экземпляр.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наиболее распространенной причиной вызова `Restart` является запуск новой версии приложения, загруженной с помощью [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], с помощью метода `Update` или `UpdateAsync`.  
  
 Приложения перезапускаются в контексте, в котором они были первоначально запущены. Если приложение было запущено с использованием URL-адреса, указывающего непосредственно на основной исполняемый файл приложения, он будет перезапущен с использованием того же URL-адреса. Если приложение является приложением [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], оно будет перезапущено с помощью [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].  
  
 Если приложение изначально представило параметры командной строки при первом выполнении, <xref:System.Windows.Forms.Application.Restart%2A> запустит приложение еще раз с теми же параметрами.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Код пользователя не является приложением Windows Forms. Пользователь не может вызвать этот метод в данном контексте.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Требуется разрешение <see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Запускает стандартный цикл обработки сообщений приложения в текущем потоке.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Запускает стандартный цикл обработки сообщений приложения в текущем потоке, без формы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В приложении на основе Win32 или Windows Forms цикл обработки сообщений является подпрограммой в коде, который обрабатывает события пользователя, такие как щелчки мыши и клавиатуры. Для каждого работающего приложения на основе Windows требуется активный цикл обработки сообщений, который называется основным циклом обработки сообщений. Когда главный цикл обработки сообщений закрыт, приложение завершает работу. В Windows Forms этот цикл закрывается при вызове метода <xref:System.Windows.Forms.Application.Exit%2A> или при вызове метода <xref:System.Windows.Forms.Application.ExitThread%2A> в потоке, выполняющем основной цикл обработки сообщений.  
  
 Большинству Windows Forms разработчикам не потребуется использовать эту версию метода. Для запуска приложения с главной формой следует использовать перегрузку <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29>, чтобы приложение завершит работу при закрытии главной формы. Во всех остальных ситуациях используйте перегрузку <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29>, которая поддерживает предоставление объекта <xref:System.Windows.Forms.ApplicationContext> для лучшего контроля за временем существования приложения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Основной цикл обработки сообщений уже запущен в данном потоке.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">Объект <see cref="T:System.Windows.Forms.ApplicationContext" />, в котором запускается приложение.</param>
        <summary>Запускает стандартный цикл обработки сообщений приложения в текущем потоке с <see cref="T:System.Windows.Forms.ApplicationContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Цикл обработки сообщений выполняется до тех пор, пока не будет вызван <xref:System.Windows.Forms.Application.Exit%2A> или <xref:System.Windows.Forms.Application.ExitThread%2A> или для контекстного объекта возникнет событие <xref:System.Windows.Forms.Application.ThreadExit>.  
  
   
  
## Examples  
 В примере показаны две формы и выход из приложения при закрытии обеих форм. Когда приложение запускается и завершает работу, сохраняется расположение каждой формы. В этом примере показано, как использовать <xref:System.Windows.Forms.ApplicationContext> вместе с методом `Application.Run(context)` для отображения нескольких форм при запуске приложения.  
  
 Класс `MyApplicationContext` наследует от <xref:System.Windows.Forms.ApplicationContext> и отслеживает, когда каждая форма закрывается, и завершает текущий поток, когда они оба. Класс хранит позиции каждой формы для пользователя. Данные о положении формы хранятся в файле, озаглавленном `Appdata.txt`, который создается в расположении, определенном <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. Метод `Main` вызывает `Application.Run(context)` для запуска приложения с учетом <xref:System.Windows.Forms.ApplicationContext>.  
  
 Код для форм `AppForm1` и `AppForm2` не показан в целях краткости. Полный листинг кода см. в обзоре класса <xref:System.Windows.Forms.ApplicationContext>.  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Основной цикл обработки сообщений уже запущен в данном потоке.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">Код <see cref="T:System.Windows.Forms.Form" />, представляющий форму, которую следует сделать видимой.</param>
        <summary>Запускает стандартный цикл обработки сообщений приложения в текущем потоке и делает указанную форму видимой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как правило, основная функция приложения вызывает этот метод и передает его главному окну приложения.  
  
 Этот метод добавляет обработчик событий к параметру `mainForm` для события <xref:System.Windows.Forms.Form.Closed>. Обработчик событий вызывает <xref:System.Windows.Forms.Application.ExitThread%2A> для очистки приложения.  
  
> [!NOTE]
>  Метод <xref:System.Windows.Forms.Control.Dispose%2A> класса <xref:System.Windows.Forms.Form> будет вызван до возврата этого метода.  
  
   
  
## Examples  
 В следующем примере кода показаны числа из списка в форме. Каждый раз при нажатии `button1` приложение добавляет еще один номер в список.  
  
 Метод `Main` вызывает <xref:System.Windows.Forms.Application.Run%2A> для запуска приложения, которое создает форму, `listBox1` и `button1`. Когда пользователь нажимает кнопку `button1`, метод `button1_Click` добавляет числа от 1 до 3 в список и отображает <xref:System.Windows.Forms.MessageBox>. Если пользователь нажмет кнопку **нет** на <xref:System.Windows.Forms.MessageBox>, метод `button1_Click` добавляет еще один номер в список. Если пользователь нажмет кнопку **Да**, приложение вызывает <xref:System.Windows.Forms.Application.Exit%2A> для обработки всех оставшихся сообщений в очереди, а затем для выхода.  
  
 В этом примере требуется, чтобы `listBox1` и `button1` были созданы и помещены в форму.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Основной цикл обработки сообщений уже запущен в текущем потоке.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает строку формата для использования в заголовках окон верхнего уровня, когда они отображаются с предупреждающим объявлением.</summary>
        <value>Строка формата, применяемая для заголовков окон верхнего уровня.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">чтобы задать это свойство для всех окон. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Значение по умолчанию, используемое для новых элементов управления. Если задано значение <see langword="true" />, новые элементы управления, поддерживающие <c>UseCompatibleTextRendering</c>, используют для отрисовки текста класс <see cref="T:System.Drawing.Graphics" /> основанный на [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]; если задано значение <see langword="false" />, новые элементы управления используют класс <see cref="T:System.Windows.Forms.TextRenderer" />, основанный на [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)].</param>
        <summary>Задает значения по умолчанию во всем приложении для свойства <c>UseCompatibleTextRendering</c>, определенного в конкретных элементах управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые элементы управления Windows Forms могут визуализировать свой текст, используя класс <xref:System.Windows.Forms.TextRenderer>, основанный на библиотеке графических [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)], или класс <xref:System.Drawing.Graphics>, основанный на библиотеке графики [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. Это изменение было внесено в [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] по причине проблем с производительностью и локализацией [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. Используйте <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>, чтобы задать значение по умолчанию для свойства `UseCompatibleTextRendering` для элементов управления, которые его поддерживают.  
  
 Свойство `UseCompatibleTextRendering` предназначено для обеспечения визуальной совместимости между элементами управления Windows Forms, которые отображают текст с помощью класса <xref:System.Windows.Forms.TextRenderer> и приложений [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] и [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], которые выполняют настраиваемую отрисовку текста с помощью класса <xref:System.Drawing.Graphics>. В большинстве случаев, если приложение не обновляется с [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] или [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], рекомендуется оставить для параметра `UseCompatibleTextRendering` значение по умолчанию `false`.  
  
 Класс <xref:System.Windows.Forms.TextRenderer> на основе [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] был представлен в [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] для повышения производительности, улучшения текста и улучшения поддержки международных шрифтов. В более ранних версиях [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] класс <xref:System.Drawing.Graphics> на основе [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] использовался для выполнения всей отрисовки текста. [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] вычисляет интервал между символами и перенос по словам отличается от [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. В Windows Forms приложении, которое использует класс <xref:System.Drawing.Graphics> для отрисовки текста, это может привести к тому, что текст для элементов управления, использующих <xref:System.Windows.Forms.TextRenderer>, будет отличаться от другого текста в приложении. Чтобы устранить эту несовместимость, можно задать для свойства `UseCompatibleTextRendering` значение `true`. Чтобы установить `UseCompatibleTextRendering` в `true` для всех поддерживаемых элементов управления в приложении, вызовите метод <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> с параметром `true`.  
  
 Этот метод никогда не следует вызывать, если код Windows Forms размещен в другом приложении, например в Internet Explorer. Этот метод следует вызывать только в изолированных Windows Forms приложениях.  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  Чтобы задать значение по умолчанию для `UseCompatibleTextRendering` в [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] или более поздней версии, см. раздел <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>.  
  
 В [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] или более поздней версии вызов <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> автоматически создается в файле Program.cs. Чтобы изменить значение по умолчанию для отрисовки текста, измените созданный код.  
  
```csharp  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот метод может быть вызван только до того, как первое окно будет создано приложением Windows Forms.</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetHighDpiMode">
      <MemberSignature Language="C#" Value="public static bool SetHighDpiMode (System.Windows.Forms.HighDpiMode highDpiMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetHighDpiMode(valuetype System.Windows.Forms.HighDpiMode highDpiMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetHighDpiMode(System.Windows.Forms.HighDpiMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetHighDpiMode(System::Windows::Forms::HighDpiMode highDpiMode);" />
      <MemberSignature Language="F#" Value="static member SetHighDpiMode : System.Windows.Forms.HighDpiMode -&gt; bool" Usage="System.Windows.Forms.Application.SetHighDpiMode highDpiMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highDpiMode" Type="System.Windows.Forms.HighDpiMode" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="highDpiMode">Одно из значений перечисления, указывающее режим высокого DPI, который необходимо установить.</param>
        <summary>Задает режим высокого DPI процесса.</summary>
        <returns><see langword="true" />, если установлен режим высокого DPI. В противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Если приложение содержит файл манифеста приложения и режим DPI был установлен в этом файле, этот метод не сможет установить или изменить режим, который уже был задан манифестом приложения. Режим высокого DPI устанавливается один раз для каждого процесса. Дополнительные сведения о настройке режима DPI с помощью файла манифеста приложения см. [в разделе Настройка отслеживания dpi для процесса по умолчанию](https://docs.microsoft.com/previous-versions/windows/desktop/legacy/mt846517(v%3Dvs.85)).

  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="force" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="state">Объект <see cref="T:System.Windows.Forms.PowerState" />, указывающий режим питания, в который следует перейти.</param>
        <param name="force">Значение <see langword="true" />, чтобы немедленно перейти в режим приостановки работы; значение <see langword="false" />, чтобы система Windows отправила запрос на приостановку работы каждому приложению.</param>
        <param name="disableWakeEvent">Значение <see langword="true" />, чтобы отключить восстановление активного состояния питания системы, если произойдет событие пробуждения, значение <see langword="false" />, чтобы включить восстановление активного состояния питания системы, если произойдет событие пробуждения.</param>
        <summary>Приостанавливает работу системы или переводит ее в спящий режим или же запрашивает приостановку работы системы или перевод ее в спящий режим.</summary>
        <returns>Значение <see langword="true" />, если работа системы приостанавливается, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если приложение не отвечает на запрос на приостановку в течение 20 секунд, Windows определяет, что он находится в неотвечающем состоянии, и что приложение может быть либо переведено в спящий режим, либо прерывается. Несмотря на то, что приложение отвечает на запрос на приостановку, оно может занять любое время, необходимое для очистки ресурсов и завершения работы активных процессов.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Указывает, как приложение должно реагировать на необработанные исключения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода задаются обработчики событий для исключений, происходящих в Windows Forms потоках и исключениях, происходящих в других потоках. Он задает <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>, чтобы все исключения обрабатывались приложением, независимо от параметров в файле конфигурации пользователя приложения. Он использует событие <xref:System.Windows.Forms.Application.ThreadException> для обработки исключений потока пользовательского интерфейса, а событие <xref:System.AppDomain.UnhandledException> — для обработки исключений потоков, не использующих пользовательский интерфейс. Поскольку <xref:System.AppDomain.UnhandledException> не может препятствовать завершению работы приложения, в примере просто записывается ошибка в журнал событий приложения перед завершением работы.  
  
 В этом примере предполагается, что вы определили два элемента управления <xref:System.Windows.Forms.Button>, `button1` и `button2` в классе <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">Значение <see cref="T:System.Windows.Forms.UnhandledExceptionMode" />, описывающее поведение приложения при выдаче исключения, которое не было перехвачено.</param>
        <summary>Указывает, как приложение должно реагировать на необработанные исключения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Часто нецелесообразно перехватывать все исключения, вызываемые Windows Forms. С помощью этого метода можно указать приложению, следует ли перехватывать все необработанные исключения, вызванные Windows Forms компонентами и продолжать работу или предоставлять их пользователю и останавливать выполнение.  
  
 Вызовите <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> перед созданием экземпляра основной формы приложения с помощью метода <xref:System.Windows.Forms.Application.Run%2A>.  
  
 Чтобы перехватить исключения, происходящие в потоках, не созданных и не принадлежащих Windows Forms, используйте обработчик событий <xref:System.AppDomain.UnhandledException>.  
  
   
  
## Examples  
 В следующем примере кода задаются обработчики событий для исключений, происходящих в Windows Forms потоках и исключениях, происходящих в других потоках. Он задает <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>, чтобы все исключения обрабатывались приложением, независимо от параметров в файле конфигурации пользователя приложения. Он использует событие <xref:System.Windows.Forms.Application.ThreadException> для обработки исключений потока пользовательского интерфейса, а событие <xref:System.AppDomain.UnhandledException> — для обработки исключений потоков, не использующих пользовательский интерфейс. Поскольку <xref:System.AppDomain.UnhandledException> не может препятствовать завершению работы приложения, в примере просто записывается ошибка в журнал событий приложения перед завершением работы.  
  
 В этом примере предполагается, что вы определили два элемента управления <xref:System.Windows.Forms.Button>, `button1` и `button2` в классе <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Режим исключения не может быть задан после того, как приложение создало свое первое окно.</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="threadScope" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">Значение <see cref="T:System.Windows.Forms.UnhandledExceptionMode" />, описывающее поведение приложения при выдаче исключения, которое не было перехвачено.</param>
        <param name="threadScope">Значение <see langword="true" />, чтобы задать режим исключения потока; в противном случае — значение <see langword="false" />.</param>
        <summary>Предоставляет приложению инструкции, определяющие, как приложение должно отвечать на необработанные исключения, при необходимости применяя поведение, зависящее от потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Часто нецелесообразно перехватывать все исключения, вызываемые Windows Forms. С помощью этого метода можно указать приложению, следует ли перехватывать все необработанные исключения, вызванные Windows Forms компонентами и продолжать работу или предоставлять их пользователю и останавливать выполнение.  
  
 Вызовите <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> перед созданием экземпляра основной формы приложения с помощью метода <xref:System.Windows.Forms.Application.Run%2A>.  
  
 Если `threadScope` имеет значение `true`, устанавливается режим исключения потока. Режим исключений потока переопределяет режим исключения приложения, если параметру `mode` не присвоено значение <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>.  
  
 Если `threadScope` имеет значение `false`, то устанавливается режим исключения приложения. Режим исключений приложения используется для всех потоков, имеющих режим <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>. Установка режима исключения приложения не влияет на настройку текущего потока.  
  
 Чтобы перехватить исключения, происходящие в потоках, не созданных и не принадлежащих Windows Forms, используйте обработчик событий <xref:System.AppDomain.UnhandledException>.  
  
   
  
## Examples  
 В следующем примере кода задаются обработчики событий для исключений, происходящих в Windows Forms потоках и исключениях, происходящих в других потоках. Он задает <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>, чтобы все исключения обрабатывались приложением, независимо от параметров в файле конфигурации пользователя приложения. Он использует событие <xref:System.Windows.Forms.Application.ThreadException> для обработки исключений потока пользовательского интерфейса, а событие <xref:System.AppDomain.UnhandledException> — для обработки исключений потоков, не использующих пользовательский интерфейс. Поскольку <xref:System.AppDomain.UnhandledException> не может препятствовать завершению работы приложения, в примере просто записывается ошибка в журнал событий приложения перед завершением работы.  
  
 В этом примере предполагается, что вы определили два элемента управления <xref:System.Windows.Forms.Button>, `button1` и `button2` в классе <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Режим исключения не может быть задан после того, как приложение создало свое первое окно.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает путь для исполняемого файла, запустившего приложение, не включая исполняемое имя.</summary>
        <value>Путь для исполняемого файла, запустившего приложение.  
  
Этот путь будет отличаться в зависимости от того, развернуто ли приложение Windows Forms с использованием [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложения хранятся в кэше приложений для каждого пользователя в каталоге C:\Documents and Settings\\*username* . Дополнительные сведения см. [в разделе доступ к локальным и удаленным данным в приложениях ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример кода получает это свойство и отображает его значение в текстовом поле. В этом примере требуется, чтобы `textBox1` был помещен в форму.  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для получения пути. Связанное перечисление: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при выдаче неперехваченного исключения потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие позволяет Windows Formsному приложению обрабатывать необработанные исключения, происходящие в потоках Windows Forms. Присоедините обработчик событий к событию <xref:System.Windows.Forms.Application.ThreadException>, чтобы обработать эти исключения, что приведет к неизвестному состоянию приложения. Там, где это возможно, исключения должны обрабатываться блоком структурированной обработки исключений.  
  
 Можно изменить, используется ли этот обратный вызов для необработанных Windows Forms исключений потоков, установив <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>. Чтобы перехватить исключения, происходящие в потоках, не созданных и не принадлежащих Windows Forms, используйте обработчик событий <xref:System.AppDomain.UnhandledException>.  
  
> [!NOTE]
>  Чтобы гарантировать отсутствие активации этого события, необходимо присоединить обработчик перед вызовом <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  К этому событию можно прикрепить только один обработчик. Если добавлено несколько обработчиков, для необработанного исключения будет вызван только самый последний добавленный обработчик.
  
> [!CAUTION]
>  Поскольку это статическое событие, необходимо отсоединить обработчики событий при удалении приложения или привести к утечке памяти.  
  
   
  
## Examples  
 В следующем примере кода задаются обработчики событий для исключений, происходящих в Windows Forms потоках и исключениях, происходящих в других потоках. Он задает <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>, чтобы все исключения обрабатывались приложением, независимо от параметров в файле конфигурации пользователя приложения. Он использует событие <xref:System.Windows.Forms.Application.ThreadException> для обработки исключений потока пользовательского интерфейса, а событие <xref:System.AppDomain.UnhandledException> — для обработки исключений потоков, не использующих пользовательский интерфейс. Поскольку <xref:System.AppDomain.UnhandledException> не может препятствовать завершению работы приложения, в примере просто записывается ошибка в журнал событий приложения перед завершением работы.  
  
 В этом примере предполагается, что вы определили два элемента управления <xref:System.Windows.Forms.Button>, `button1` и `button2` в классе <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для немедленного вызывающего объекта, чтобы вызвать неуправляемый код при добавлении обработчика к этому событию. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при закрытии потока. Перед закрытием главного потока для приложения вызывается данное событие, за которым следует событие <see cref="E:System.Windows.Forms.Application.ApplicationExit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо присоединить обработчики событий к событию <xref:System.Windows.Forms.Application.ThreadExit> для выполнения любых необработанных, обязательных задач до того, как поток прекратит выполнение. Закройте файлы, открытые в этом потоке, или удалите объекты, которые не были освобождены сборщиком мусора.  
  
> [!CAUTION]
>  Поскольку это статическое событие, необходимо отсоединить обработчики событий при удалении приложения или привести к утечке памяти.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Application.ThreadExit>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в Windows Forms и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Application.ThreadExit>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет регистрацию ответного вызова цикла обработки сообщений, сделанного с помощью метода <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает путь для данных приложения пользователя.</summary>
        <value>Путь для данных приложения пользователя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если путь не существует, он создается в следующем формате:  
  
 *Базовый путь*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 Данные, хранящиеся в этом пути, являются частью профиля пользователя, включенного для роуминга. Перемещаемый пользователь работает на нескольких компьютерах в сети. Профиль пользователя для перемещаемого пользователя хранится на сервере в сети и загружается в систему при входе пользователя. Чтобы профиль пользователя считался перемещаемым, операционная система должна поддерживать перемещаемые профили и должна быть включена.  
  
 Типичный базовый путь — C:\Documents, а параметры\\*username*\Application Data. Однако этот путь будет отличаться, если Windows Forms приложение развертывается с помощью [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] создает собственный каталог данных приложения, изолированный от всех других приложений. Дополнительные сведения см. [в разделе доступ к локальным и удаленным данным в приложениях ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 В следующем примере кода показаны две формы и выход из приложения при закрытии обеих форм. Когда приложение запускается и завершает работу, сохраняется расположение каждой формы. В этом примере демонстрируется использование свойства <xref:System.Windows.Forms.Application.UserAppDataPath%2A> для хранения данных приложения для пользователя.  
  
 Класс `MyApplicationContext` наследует от <xref:System.Windows.Forms.ApplicationContext> и отслеживает, когда каждая форма закрывается, и завершает текущий поток, когда они оба. Класс хранит позиции каждой формы для пользователя. Данные о положении формы хранятся в файле, озаглавленном `Appdata.txt`, который создается в расположении, определенном <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. Метод `Main` вызывает `Application.Run(context)` для запуска приложения с учетом <xref:System.Windows.Forms.ApplicationContext>.  
  
 Этот код является выдержкой из примера, показанного в обзоре класса <xref:System.Windows.Forms.ApplicationContext>. Для краткости не указан некоторый код. Полный листинг кода см. <xref:System.Windows.Forms.ApplicationContext>.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает раздел реестра для данных приложения пользователя.</summary>
        <value>Объект <see cref="T:Microsoft.Win32.RegistryKey" /> представляет раздел реестра для данных приложения конкретного пользователя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ключ не существует, он создается в следующем формате:  
  
 Куррентусер\софтваре\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Данные, хранящиеся в этом ключе, являются частью профиля пользователя, включенного для роуминга. Перемещаемый пользователь работает на нескольких компьютерах в сети. Профиль пользователя для перемещаемого пользователя хранится на сервере в сети и загружается в систему при входе пользователя. Чтобы профиль пользователя считался перемещаемым, операционная система должна поддерживать перемещаемые профили и должна быть включена.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseVisualStyles">
      <MemberSignature Language="C#" Value="public static bool UseVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UseVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UseVisualStyles : bool" Usage="System.Windows.Forms.Application.UseVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, включены ли визуальные стили для приложения.</summary>
        <value><see langword="true" />, если стили оформления включены; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Стили оформления можно включить, вызвав <xref:System.Windows.Forms.Application.EnableVisualStyles>.

Стили оформления не будут включены, если операционная система не поддерживает их или отключена на уровне операционной системы.

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, которое указывает, используется ли курсор ожидания для всех открытых форм приложения.</summary>
        <value>Значение <see langword="true" />, если курсор ожидания будет использоваться для всех открытых форм; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если для этого свойства задано значение `true`, свойству <xref:System.Windows.Forms.Control.UseWaitCursor%2A> всех открытых форм в приложении будет присвоено значение `true`. Этот вызов не будет возвращать значение, пока это свойство не заполнится всеми формами. Используйте это свойство при длительной операции и необходимо указать во всех формах приложения, которые все еще обрабатываются операцией.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, каким образом визуальные стили применяются к окну приложения.</summary>
        <value>Поразрядное сочетание значений <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство <xref:System.Windows.Forms.Application.VisualStyleState%2A> определяет, включены ли визуальные стили в клиентских областях или в неклиентских областях окон приложений. Как правило, это свойство должно быть задано в конструкторе главной формы или обработчике событий <xref:System.Windows.Forms.Form.Load>.  
  
   
  
## Examples  
 В следующем примере кода свойству <xref:System.Windows.Forms.Application.VisualStyleState%2A> присваивается одно из значений <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> в обработчике событий <xref:System.Windows.Forms.Control.Click> для элемента управления <xref:System.Windows.Forms.Button>. Этот пример кода является частью более крупного примера, приведенного для перечисления <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType>.  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
