<Type Name="Control" FullName="System.Windows.Forms.Control">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4f10e7c79ce94d8b4ac6eef68bb3788ff4069811" /><Meta Name="ms.sourcegitcommit" Value="c573d537afba2d4c1463538f1095f2f155025464" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/16/2019" /><Meta Name="ms.locfileid" Value="72401849" /></Metadata><TypeSignature Language="C#" Value="public class Control : System.ComponentModel.Component, IDisposable, System.ComponentModel.ISynchronizeInvoke, System.Windows.Forms.IBindableComponent, System.Windows.Forms.IDropTarget, System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Control extends System.ComponentModel.Component implements class System.ComponentModel.IComponent, class System.ComponentModel.ISynchronizeInvoke, class System.IDisposable, class System.Windows.Forms.IBindableComponent, class System.Windows.Forms.IDropTarget, class System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Inherits Component&#xA;Implements IBindableComponent, IDisposable, IDropTarget, ISynchronizeInvoke, IWin32Window" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : System::ComponentModel::Component, IDisposable, System::ComponentModel::ISynchronizeInvoke, System::Windows::Forms::IBindableComponent, System::Windows::Forms::IDropTarget, System::Windows::Forms::IWin32Window" />
  <TypeSignature Language="F#" Value="type Control = class&#xA;    inherit Component&#xA;    interface IDropTarget&#xA;    interface ISynchronizeInvoke&#xA;    interface IWin32Window&#xA;    interface IComponent&#xA;    interface IDisposable&#xA;    interface IBindableComponent" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISynchronizeInvoke</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IBindableComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IDropTarget</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IWin32Window</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Определяет базовый класс для элементов управления, являющихся компонентами с визуальным представлением.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы создать собственный класс элемента управления, следует наследовать от классов <xref:System.Windows.Forms.UserControl>, <xref:System.Windows.Forms.Control> или из других элементов управления, предоставленных Windows Forms. Дополнительные сведения о создании пользовательских элементов управления см. [в разделе Разработка пользовательских элементов управления Windows Forms с помощью .NET Framework](~/docs/framework/winforms/controls/developing-custom-windows-forms-controls.md).  
  
 Класс <xref:System.Windows.Forms.Control> реализует очень простую функциональность, необходимую классам, которые отображают сведения для пользователя. Он обрабатывает ввод пользователя с помощью клавиатуры и указывающих устройств. Он обрабатывает маршрутизацию сообщений и безопасность. Он определяет границы элемента управления (его расположение и размер), хотя он не реализует рисование. Он предоставляет описатель окна (`hWnd`).  
  
 Элементы управления Windows Forms используют свойства окружения, поэтому дочерние элементы управления могут выглядеть как окружающая среда. *Внешнее свойство* — это свойство элемента управления, которое, если оно не задано, извлекается из родительского элемента управления. Если элемент управления не имеет <xref:System.Windows.Forms.Control.Parent%2A>, а свойство не задано, элемент управления пытается определить значение свойства окружения через свойство <xref:System.Windows.Forms.Control.Site%2A>. Если элемент управления не является узлом, если сайт не поддерживает свойства окружения или если свойство не задано для <xref:System.Windows.Forms.AmbientProperties>, элемент управления использует собственные значения по умолчанию. Как правило, внешнее свойство представляет характеристику элемента управления, например <xref:System.Windows.Forms.Control.BackColor%2A>, который передается в дочерний элемент управления. Например, <xref:System.Windows.Forms.Button> будет иметь то же <xref:System.Windows.Forms.Control.BackColor%2A>, что и родительский <xref:System.Windows.Forms.Form> по умолчанию. Свойства окружения, предоставляемые классом <xref:System.Windows.Forms.Control>, включают следующие: <xref:System.Windows.Forms.Control.Cursor%2A>, <xref:System.Windows.Forms.Control.Font%2A>, <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.ForeColor%2A> и <xref:System.Windows.Forms.Control.RightToLeft%2A>.  
  
> [!NOTE]
>  Чтобы Windows Forms приложение поддерживало визуальные стили, обязательно задайте для свойства <xref:System.Windows.Forms.FlatStyle> значение `System` и включите манифест в исполняемый файл. Манифест — это XML-файл, который включается как ресурс в исполняемый файл приложения или как отдельный файл, находящийся в том же каталоге, что и исполняемый. Пример манифеста см. в разделе "пример" перечисления <xref:System.Windows.Forms.FlatStyle>. Дополнительные сведения об использовании стилей оформления см. в разделе [стили визуальных](https://msdn.microsoft.com/library/windows/desktop/bb773187.aspx)элементов.  
  
 Windows Forms обладает встроенной поддержкой специальных возможностей и предоставляет сведения о приложении, которое позволяет им работать с клиентскими приложениями специальных возможностей, такими как программы увеличения экрана и средства просмотра, служебные программы для ввода голоса, экранные клавиатуры, альтернативные устройства ввода и служебные программы для улучшения клавиатуры. Иногда вам потребуется предоставить дополнительные сведения для клиентских приложений со специальными возможностями. Существует два способа предоставления этой дополнительной информации. Можно задать значения свойств <xref:System.Windows.Forms.Control.AccessibleName%2A>, <xref:System.Windows.Forms.Control.AccessibleDescription%2A>, <xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A> и <xref:System.Windows.Forms.Control.AccessibleRole%2A>, которые будут передаваться в клиентские приложения со специальными возможностями. Этот метод обычно используется для предоставления ограниченных сведений о специальных возможностях для существующих элементов управления. Кроме того, можно написать собственный класс, производный от класса <xref:System.Windows.Forms.AccessibleObject> или <xref:System.Windows.Forms.Control.ControlAccessibleObject>, при необходимости предоставив сведения о специальных возможностях.  
  
> [!NOTE]
>  Чтобы обеспечить лучшую производительность, не устанавливайте размер элемента управления в конструкторе. Предпочтительным методом является переопределение свойства <xref:System.Windows.Forms.Control.DefaultSize%2A>.  
  
> [!NOTE]
>  Не добавляйте привязки данных для <xref:System.Windows.Forms.Control> в своем конструкторе. Это вызовет ошибки при создании кода и может привести к нежелательному поведению.  
  
 Большинство элементов управления в пространстве имен <xref:System.Windows.Forms> используют базовый общий элемент управления Windows в качестве основы для сборки. Дополнительные сведения о стандартных элементах управления Windows см. в разделе [Справочник по общим элементам управления](https://msdn.microsoft.com/library/windows/desktop/bb775497.aspx).  
  
 Чтобы выделить Windows Forms элементы управления из отдельного процесса, используйте стандартный вызов `SendMessage`, чтобы передать сообщение WM_GETCONTROLNAME. WM_GETCONTROLNAME не зависит от языка и иерархии Windows. Дополнительные сведения см. в разделе "Рекомендуемое решение для Windows Forms" раздела[автоматизация Windows Forms](https://msdn.microsoft.com/library/ms996405.aspx).  
  
 Используйте свойство <xref:System.Windows.Forms.Control.InvokeRequired%2A> для синхронизации доступа к элементу управления из нескольких потоков. Дополнительные сведения о многопоточных Windows Formsных элементах управления см. в разделе [How to: Сделать потокобезопасные вызовы Windows Forms элементов управления @ no__t-0  
  
 ]]></format>
    </remarks>
    <threadsafe>Только следующие члены являются потокобезопасными: <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />, <see cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />, <see cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />, <see cref="P:System.Windows.Forms.Control.InvokeRequired" /> и <see cref="M:System.Windows.Forms.Control.CreateGraphics" />, если маркер для элемента управления уже был создан. Вызов <see cref="M:System.Windows.Forms.Control.CreateGraphics" /> перед созданием маркера элемента управления в фоновом потоке может привести к недопустимым перекрестным вызовам потоков.</threadsafe>
    <altmember cref="T:System.Windows.Forms.Form" />
    <altmember cref="T:System.Windows.Forms.ScrollableControl" />
    <altmember cref="T:System.Windows.Forms.ContainerControl" />
    <altmember cref="T:System.ComponentModel.Component" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Forms.Control" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Forms.Control" /> с параметрами по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Windows.Forms.Control> является базовым классом для всех элементов управления, используемых в приложении Windows Forms. Поскольку этот класс обычно не используется для создания экземпляра класса, этот конструктор обычно не вызывается напрямую, а вызывается производным классом.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : string -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control text" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Текст, отображаемый элементом управления.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Forms.Control" /> с конкретным текстом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Windows.Forms.Control> является базовым классом для всех элементов управления, используемых в приложении Windows Forms. Поскольку этот класс обычно не используется для создания экземпляра класса, этот конструктор обычно не вызывается напрямую, а вызывается производным классом.  
  
 Эта версия конструктора <xref:System.Windows.Forms.Control.%23ctor%2A> задает начальное значение свойства <xref:System.Windows.Forms.Control.Text%2A> для значения параметра `text`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parent As Control, text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::Windows::Forms::Control ^ parent, System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : System.Windows.Forms.Control * string -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (parent, text)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="parent">Объект <see cref="T:System.Windows.Forms.Control" />, который будет родительским по отношению к элементу управления.</param>
        <param name="text">Текст, отображаемый элементом управления.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Forms.Control" /> как дочерний элемент управления с конкретным текстом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Windows.Forms.Control> является базовым классом для всех элементов управления, используемых в приложении Windows Forms. Поскольку этот класс обычно не используется для создания экземпляра класса, этот конструктор обычно не вызывается напрямую, а вызывается производным классом.  
  
 Эта версия конструктора <xref:System.Windows.Forms.Control.%23ctor%2A> задает начальное значение свойства <xref:System.Windows.Forms.Control.Text%2A> для значения параметра `text`. Конструктор также добавляет элемент управления в <xref:System.Windows.Forms.Control.ControlCollection> родительского элемента управления.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, left As Integer, top As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::String ^ text, int left, int top, int width, int height);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : string * int * int * int * int -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (text, left, top, width, height)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">Текст, отображаемый элементом управления.</param>
        <param name="left">Позиция <see cref="P:System.Drawing.Point.X" /> элемента управления относительно левого края контейнера элемента управления (в пикселях). Значение присваивается свойству <see cref="P:System.Windows.Forms.Control.Left" />.</param>
        <param name="top">Позиция <see cref="P:System.Drawing.Point.Y" /> элемента управления относительно верхнего края контейнера элемента управления (в пикселях). Значение присваивается свойству <see cref="P:System.Windows.Forms.Control.Top" />.</param>
        <param name="width">Ширина элемента управления (в пикселях). Значение присваивается свойству <see cref="P:System.Windows.Forms.Control.Width" />.</param>
        <param name="height">Высота элемента управления (в пикселях). Значение присваивается свойству <see cref="P:System.Windows.Forms.Control.Height" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Forms.Control" /> с конкретным текстом, размером и расположением.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Windows.Forms.Control> является базовым классом для всех элементов управления, используемых в приложении Windows Forms. Поскольку этот класс обычно не используется для создания экземпляра класса, этот конструктор обычно не вызывается напрямую, а вызывается производным классом.  
  
 Эта версия конструктора <xref:System.Windows.Forms.Control.%23ctor%2A> задает начальное значение свойства <xref:System.Windows.Forms.Control.Text%2A> для значения параметра `text`. Начальная <xref:System.Windows.Forms.Control.Size%2A> и <xref:System.Windows.Forms.Control.Location%2A> элемента управления определяются значениями параметров `left`, `top`, `width` и `height`.  
  
> [!NOTE]
>  Чтобы обеспечить лучшую производительность, не устанавливайте размер элемента управления в конструкторе. Предпочтительным методом является переопределение свойства <xref:System.Windows.Forms.Control.DefaultSize%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parent As Control, text As String, left As Integer, top As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::Windows::Forms::Control ^ parent, System::String ^ text, int left, int top, int width, int height);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : System.Windows.Forms.Control * string * int * int * int * int -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (parent, text, left, top, width, height)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parent">Объект <see cref="T:System.Windows.Forms.Control" />, который будет родительским по отношению к элементу управления.</param>
        <param name="text">Текст, отображаемый элементом управления.</param>
        <param name="left">Позиция <see cref="P:System.Drawing.Point.X" /> элемента управления относительно левого края контейнера элемента управления (в пикселях). Значение присваивается свойству <see cref="P:System.Windows.Forms.Control.Left" />.</param>
        <param name="top">Позиция <see cref="P:System.Drawing.Point.Y" /> элемента управления относительно верхнего края контейнера элемента управления (в пикселях). Значение присваивается свойству <see cref="P:System.Windows.Forms.Control.Top" />.</param>
        <param name="width">Ширина элемента управления (в пикселях). Значение присваивается свойству <see cref="P:System.Windows.Forms.Control.Width" />.</param>
        <param name="height">Высота элемента управления (в пикселях). Значение присваивается свойству <see cref="P:System.Windows.Forms.Control.Height" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Forms.Control" /> как дочерний элемент управления с определенным текстом, размером и местоположением.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Windows.Forms.Control> является базовым классом для всех элементов управления, используемых в приложении Windows Forms. Поскольку этот класс обычно не используется для создания экземпляра класса, этот конструктор обычно не вызывается напрямую, а вызывается производным классом.  
  
 Эта версия конструктора <xref:System.Windows.Forms.Control.%23ctor%2A> задает начальное значение свойства <xref:System.Windows.Forms.Control.Text%2A> для значения параметра `text`. Конструктор также добавляет элемент управления в <xref:System.Windows.Forms.Control.ControlCollection> родительского элемента управления. Начальная <xref:System.Windows.Forms.Control.Size%2A> и <xref:System.Windows.Forms.Control.Location%2A> элемента управления определяются значениями параметров `left`, `top`, `width` и `height`.  
  
> [!NOTE]
>  Чтобы обеспечить лучшую производительность, не устанавливайте размер элемента управления в конструкторе. Предпочтительным методом является переопределение свойства <xref:System.Windows.Forms.Control.DefaultSize%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AccessibilityNotifyClients">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Уведомляет клиентские приложения со специальными возможностями об объекте <see cref="T:System.Windows.Forms.AccessibleEvents" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected internal void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int childID);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 childID) cil managed" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, childID As Integer)" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int childID);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.AccessibilityNotifyClients : System.Windows.Forms.AccessibleEvents * int -&gt; unit" Usage="control.AccessibilityNotifyClients (accEvent, childID)" />
      <MemberSignature Language="C#" Value="protected void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int childID);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 childID) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, childID As Integer)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int childID);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" />
        <Parameter Name="childID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="accEvent">Объект <see cref="T:System.Windows.Forms.AccessibleEvents" />, о котором требуется уведомлять клиентские приложения со специальными возможностями.</param>
        <param name="childID">Дочерний объект <see cref="T:System.Windows.Forms.Control" />, который требуется уведомлять о событии, связанном со специальными возможностями.</param>
        <summary>Уведомляет клиентские приложения со специальными возможностями об указанном перечислении <see cref="T:System.Windows.Forms.AccessibleEvents" /> для указанного дочернего элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо вызвать метод <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A?displayProperty=nameWithType> для каждого <xref:System.Windows.Forms.AccessibleEvents> клиентские приложения со специальными возможностями будут уведомлены. Метод <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A> обычно вызывается, когда свойство задано или находится в обработчике событий. Например, можно вызвать метод <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A> и передать значение <xref:System.Windows.Forms.AccessibleEvents> в `Hide` из обработчика событий для события <xref:System.Windows.Forms.Control.VisibleChanged?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода показано создание элемента управления диаграммы с поддержкой специальных возможностей с помощью классов <xref:System.Windows.Forms.AccessibleObject> и <xref:System.Windows.Forms.Control.ControlAccessibleObject> для предоставления доступной информации. Элемент управления отображает две кривые вместе с условными обозначениями. Класс `ChartControlAccessibleObject`, который является производным от `ControlAccessibleObject`, используется в методе <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> для предоставления настраиваемой информации, доступной для элемента управления диаграммы. Поскольку условные обозначения диаграммы не являются фактическим элементом управления на основе <xref:System.Windows.Forms.Control>, а нарисованы элементом управления диаграммы, он не содержит встроенных доступных сведений. В связи с этим класс `ChartControlAccessibleObject` переопределяет метод <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> для возврата `CurveLegendAccessibleObject`, который представляет доступную информацию для каждой части условных обозначений. Если приложение, поддерживающее доступ, использует этот элемент управления, элемент управления может предоставить необходимые сведения о специальных возможностях.  
  
 Этот фрагмент кода демонстрирует вызов метода <xref:System.Windows.Forms.Control.AccessibilityNotifyClients%2A>. Полный пример кода см. в обзоре класса <xref:System.Windows.Forms.AccessibleObject>.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#5)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#5)]
 [!code-vb[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleEvents" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
      </Docs>
    </Member>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 objectID, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, objectID As Integer, childID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberSignature Language="F#" Value="member this.AccessibilityNotifyClients : System.Windows.Forms.AccessibleEvents * int * int -&gt; unit" Usage="control.AccessibilityNotifyClients (accEvent, objectID, childID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="objectID" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="childID" Type="System.Int32" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="accEvent">Объект <see cref="T:System.Windows.Forms.AccessibleEvents" />, о котором требуется уведомлять клиентские приложения со специальными возможностями.</param>
        <param name="objectID">Идентификатор объекта <see cref="T:System.Windows.Forms.AccessibleObject" />.</param>
        <param name="childID">Дочерний объект <see cref="T:System.Windows.Forms.Control" />, который требуется уведомлять о событии, связанном со специальными возможностями.</param>
        <summary>Уведомляет клиентские приложения со специальными возможностями об указанном перечислении <see cref="T:System.Windows.Forms.AccessibleEvents" /> для указанного дочернего элемента управления.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityObject">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleObject AccessibilityObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.AccessibleObject AccessibilityObject" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibilityObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessibilityObject As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AccessibleObject ^ AccessibilityObject { System::Windows::Forms::AccessibleObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessibilityObject : System.Windows.Forms.AccessibleObject" Usage="System.Windows.Forms.Control.AccessibilityObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Windows.Forms.AccessibleObject" />, назначенный элементу управления.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.AccessibleObject" />, присвоенный элементу управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для управления экземпляром, возвращаемым этим методом, переопределите метод <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>.  
  
 Если в данный момент элементу управления не назначен объект класса <xref:System.Windows.Forms.AccessibleObject>, создается новый экземпляр этого объекта.  
  
> [!NOTE]
>  Чтобы получить или задать свойство <xref:System.Windows.Forms.Control.AccessibilityObject%2A>, необходимо добавить ссылку на сборку `Accessibility`, установленную с параметром @ no__t-2.  
  
 Дополнительные сведения о доступных объектах см. в разделе [Active Accessibility](https://msdn.microsoft.com/library/windows/desktop/dd373592.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
        <altmember cref="T:System.Windows.Forms.Control.ControlAccessibleObject" />
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleDefaultActionDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDefaultActionDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDefaultActionDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleDefaultActionDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleDefaultActionDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleDefaultActionDescription : string with get, set" Usage="System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает описание выполняемого по умолчанию действия элемента управления для использования клиентскими приложениями со специальными возможностями.</summary>
        <value>Выполняемое по умолчанию действие элемента управления для использования клиентскими приложениями со специальными возможностями.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A> объекта описывает основной метод обработки объекта из точки зрения пользователя. Это свойство должно быть глаголом или короткой глаголовой фразой.  
  
> [!NOTE]
>  Не все объекты имеют действия по умолчанию, и некоторые объекты могут иметь действие по умолчанию, связанное со свойством <xref:System.Windows.Forms.AccessibleObject.Value%2A?displayProperty=nameWithType>, как в следующих примерах:  
  
-   Установленный флажок имеет действие по умолчанию "снять флажок" и значение "Проверено".  
  
-   Снятый флажок имеет действие по умолчанию "проверить" и значение "снят флажок".  
  
-   Кнопка «Печать» имеет действие по умолчанию «Press» без значения.  
  
-   Метка или элемент управления "текстовое поле", который отображает "принтер", не имеет действия по умолчанию, но имеет значение "принтер".  
  
 Дополнительные сведения о свойствах доступных объектов см. в разделе [содержимое описательных свойств](https://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleDescription : string with get, set" Usage="System.Windows.Forms.Control.AccessibleDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает описание элемента управления, используемого клиентскими приложениями со специальными возможностями.</summary>
        <value>Описание элемента управления, используемого клиентскими приложениями со специальными возможностями. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.AccessibleDescription%2A> объекта содержит текстовое описание визуального представления объекта. Описание в основном используется для предоставления более высокого уровня контекста для пользователей с ослабленным зрением или пользователями с потерей зрения, но также может использоваться для контекстного поиска или других приложений.  
  
 Свойство <xref:System.Windows.Forms.Control.AccessibleDescription%2A> необходимо, если описание не очевидно или избыточно в зависимости от свойств объекта <xref:System.Windows.Forms.Control.AccessibleName%2A>, <xref:System.Windows.Forms.Control.AccessibleRole%2A>, <xref:System.Windows.Forms.AccessibleObject.State%2A> и <xref:System.Windows.Forms.AccessibleObject.Value%2A>. Например, кнопке с «ОК» не требуется дополнительная информация, а кнопка, показывающая изображение кактуса, будет. Свойства <xref:System.Windows.Forms.Control.AccessibleName%2A> и <xref:System.Windows.Forms.Control.AccessibleRole%2A> (и, возможно, <xref:System.Windows.Forms.AccessibleObject.Help%2A>) для кнопки кактуса описывают ее назначение, но свойство <xref:System.Windows.Forms.Control.AccessibleDescription%2A> будет передавать менее ощутимую информацию, например "кнопку, показывающую изображение кактуса".  
  
 Дополнительные сведения о свойствах доступных объектов см. в разделе [содержимое описательных свойств](https://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
   
  
## Examples  
 В следующем примере кода создается экземпляр производного класса <xref:System.Windows.Forms.CheckBox>, `MyCheckBox`, присваивает ему <xref:System.Drawing.Image> свойству <xref:System.Windows.Forms.ButtonBase.Image%2A> и задаются свойства <xref:System.Windows.Forms.Control.AccessibleName%2A> и <xref:System.Windows.Forms.Control.AccessibleDescription%2A>, так как свойство <xref:System.Windows.Forms.Control.Text%2A> имеет значение `null`. В этом примере требуется <xref:System.Windows.Forms.Form> с именем `MyForm`.  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Description" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleName">
      <MemberSignature Language="C#" Value="public string AccessibleName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleName" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleName : string with get, set" Usage="System.Windows.Forms.Control.AccessibleName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя элемента управления, используемого клиентскими приложениями со специальными возможностями.</summary>
        <value>Имя элемента управления, используемого клиентскими приложениями со специальными возможностями. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.AccessibleName%2A> — это метка, которая кратко описывает и идентифицирует объект в своем контейнере, например текст в <xref:System.Windows.Forms.Button>, имя <xref:System.Windows.Forms.MenuItem> или метку, отображаемую рядом с элементом управления <xref:System.Windows.Forms.TextBox>.  
  
 Дополнительные сведения о свойствах доступных объектов см. в разделе "[содержимое описательных свойств](https://msdn.microsoft.com/library/windows/desktop/dd318025.aspx)".  
  
   
  
## Examples  
 В следующем примере кода создается экземпляр производного класса <xref:System.Windows.Forms.CheckBox>, `MyCheckBox`, присваивает ему <xref:System.Drawing.Image> свойству <xref:System.Windows.Forms.ButtonBase.Image%2A> и задаются свойства <xref:System.Windows.Forms.Control.AccessibleName%2A> и <xref:System.Windows.Forms.Control.AccessibleDescription%2A>, так как свойство <xref:System.Windows.Forms.Control.Text%2A> имеет значение `null`. В этом примере требуется <xref:System.Windows.Forms.Form> с именем `MyForm`.  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Name" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleRole">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleRole AccessibleRole { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AccessibleRole AccessibleRole" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleRole" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleRole As AccessibleRole" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AccessibleRole AccessibleRole { System::Windows::Forms::AccessibleRole get(); void set(System::Windows::Forms::AccessibleRole value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleRole : System.Windows.Forms.AccessibleRole with get, set" Usage="System.Windows.Forms.Control.AccessibleRole" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleRole</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает доступную роль элемента управления.</summary>
        <value>Одно из значений <see cref="T:System.Windows.Forms.AccessibleRole" />. Значение по умолчанию — <see langword="Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.AccessibleRole%2A> описывает, каким элементом пользовательского интерфейса является объект. Если роль элемента управления не удается определить, свойству <xref:System.Windows.Forms.Control.AccessibleRole%2A> задается значение `Default`.  
  
 Дополнительные сведения о свойствах доступных объектов см. в разделе [содержимое описательных свойств](https://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Назначенное значение не является одном из значений <see cref="T:System.Windows.Forms.AccessibleRole" />.</exception>
        <altmember cref="T:System.Windows.Forms.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Role" />
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public virtual bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.Forms.Control.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, может ли элемент управления принимать данные, перетаскиваемые в него пользователем.</summary>
        <value><see langword="true" />, если операции перетаскивания поддерживаются элементом управления; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода пользователь может перетащить изображение или файл изображения на форму и отобразить его в момент удаления. Метод <xref:System.Windows.Forms.Control.OnPaint%2A> переопределен для перерисовки изображения при каждой отрисованной форме; в противном случае изображение будет сохранено только до следующего перерисовки. Метод обработки событий <xref:System.Windows.Forms.Control.DragEnter> определяет тип данных, которые перетаскиваются в форму, и предоставляет соответствующие отзывы. Метод обработки событий <xref:System.Windows.Forms.Control.DragDrop> отображает изображение в форме, если <xref:System.Drawing.Image> может быть создан из данных. Так как значения <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> и <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> являются экранными координатами, в примере используется метод <xref:System.Windows.Forms.Control.PointToClient%2A> для преобразования их в клиентские координаты.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для неограниченного доступа к буферу обмена для присвоения этому свойству значения <see langword="true" />. Связанное перечисление: значение <see langword="AllClipboard" /> <see cref="T:System.Security.Permissions.UIPermissionClipboard" /></permission>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.AllowDrop" /> в производном классе используйте свойство базового класса <see cref="P:System.Windows.Forms.Control.AllowDrop" /> для расширения базовой реализации. В противном случае необходимо предоставить всю реализацию. Не требуется переопределять методы доступа <see langword="get" /> и <see langword="set" /> свойства <see cref="P:System.Windows.Forms.Control.AllowDrop" />; При необходимости можно переопределить только один из них.</para></block>
        <altmember cref="T:System.Windows.Forms.DragEventArgs" />
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
        <altmember cref="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      </Docs>
    </Member>
    <Member MemberName="Anchor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AnchorStyles Anchor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AnchorStyles Anchor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Anchor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Anchor As AnchorStyles" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AnchorStyles Anchor { System::Windows::Forms::AnchorStyles get(); void set(System::Windows::Forms::AnchorStyles value); };" />
      <MemberSignature Language="F#" Value="member this.Anchor : System.Windows.Forms.AnchorStyles with get, set" Usage="System.Windows.Forms.Control.Anchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AnchorStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает границы контейнера, с которым связан элемент управления, и определяет способ изменения размеров элемента управления при изменении размеров его родительского элемента.</summary>
        <value>Поразрядное сочетание значений <see cref="T:System.Windows.Forms.AnchorStyles" />. Значения по умолчанию — <see langword="Top" /> и <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.Windows.Forms.Control.Anchor%2A>, чтобы определить, как автоматически изменяется размер элемента управления при изменении размера родительского элемента управления. Привязка элемента управления к его родительскому элементу управления гарантирует, что привязанные границы остаются в той же области, что и границы родительского элемента управления, когда изменяется размер родительского элемента управления.  
  
 Можно привязать элемент управления к одному или нескольким границам контейнера. Например, если имеется <xref:System.Windows.Forms.Form> с <xref:System.Windows.Forms.Button>, для свойства @no__t 2 которого задано значение `Top` и `Bottom`, <xref:System.Windows.Forms.Button> растягивается для поддержания привязанного расстояния к верхнему и нижнему краям <xref:System.Windows.Forms.Form>, так как <xref:System.Windows.Forms.Control.Height%2A> из <xref:System.Windows.Forms.Form> увеличивается.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Anchor%2A> И <xref:System.Windows.Forms.Control.Dock%2A> свойства являются взаимоисключающими. В каждый момент времени может быть задан только один, а последний набор имеет приоритет.  
  
   
  
## Examples  
 В следующем примере кода в форму добавляется <xref:System.Windows.Forms.Button> и задаются некоторые общие свойства. В этом примере кнопка привязывается к нижнему правому углу формы, чтобы сохранить ее относительное расположение при изменении размера формы. Затем он устанавливает <xref:System.Windows.Forms.Control.BackgroundImage%2A> и изменяет размер кнопки на тот же размер, что и <xref:System.Drawing.Image>. Затем в примере устанавливается <xref:System.Windows.Forms.Control.TabStop%2A> в `true` и задается свойство <xref:System.Windows.Forms.Control.TabIndex%2A>. Наконец, он добавляет обработчик событий для обработки события <xref:System.Windows.Forms.Control.Click> кнопки. В этом примере требуется <xref:System.Windows.Forms.ImageList> с именем `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.Anchor" /> в производном классе используйте свойство базового класса <see cref="P:System.Windows.Forms.Control.Anchor" /> для расширения базовой реализации. В противном случае необходимо предоставить всю реализацию. Не требуется переопределять методы доступа <see langword="get" /> и <see langword="set" /> свойства <see cref="P:System.Windows.Forms.Control.Anchor" />; При необходимости можно переопределить только один из них.</para></block>
        <altmember cref="T:System.Windows.Forms.AnchorStyles" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="AutoScrollOffset">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Point AutoScrollOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point AutoScrollOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoScrollOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoScrollOffset As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Point AutoScrollOffset { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScrollOffset : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Control.AutoScrollOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Point), "0, 0")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает местоположение, в котором выполняется прокрутка этого элемента управления в <see cref="M:System.Windows.Forms.ScrollableControl.ScrollControlIntoView(System.Windows.Forms.Control)" />.</summary>
        <value>Объект <see cref="T:System.Drawing.Point" />, задающий местоположение выполнения прокрутки. По умолчанию это левый верхний угол элемента управления.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public virtual bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.Control.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Данное свойство не применимо к этому классу.</summary>
        <value>Значение <see langword="true" />, если включен, в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данное свойство не применимо к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.AutoSizeChanged : EventHandler " Usage="member this.AutoSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Данное событие не применимо к этому классу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данное событие не применимо к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.Control.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-501)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает цвет фона для элемента управления.</summary>
        <value>Объект <see cref="T:System.Drawing.Color" />, представляющий цвет фона элемента управления. Значением по умолчанию является значение свойства <see cref="P:System.Windows.Forms.Control.DefaultBackColor" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.BackColor%2A> не поддерживает прозрачные цвета, если значение `SupportsTransparentBackColor` для <xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType> не равно `true`.  
  
 Свойство <xref:System.Windows.Forms.Control.BackColor%2A> является внешним свойством. Внешнее свойство — это свойство элемента управления, которое, если оно не задано, извлекается из родительского элемента управления. Например, <xref:System.Windows.Forms.Button> будет иметь то же <xref:System.Windows.Forms.Control.BackColor%2A>, что и родительский <xref:System.Windows.Forms.Form> по умолчанию. Дополнительные сведения о внешних свойствах см. в описании класса <xref:System.Windows.Forms.AmbientProperties> или в обзоре класса <xref:System.Windows.Forms.Control>.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Windows.Forms.Control.BackColor%2A> и <xref:System.Windows.Forms.Control.ForeColor%2A> для элементов управления устанавливаются в системные цвета по умолчанию. Код рекурсивно вызывает себя, если у элемента управления есть дочерние элементы управления. Этот пример кода требует наличия <xref:System.Windows.Forms.Form> с по крайней мере одним дочерним элементом управления. Однако элемент управления дочерним контейнером, например <xref:System.Windows.Forms.Panel> или <xref:System.Windows.Forms.GroupBox> с собственными дочерними элементами управления, лучше продемонстрировать рекурсию.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.BackColor" /> в производном классе используйте свойство базового класса <see cref="P:System.Windows.Forms.Control.BackColor" /> для расширения базовой реализации. В противном случае необходимо предоставить всю реализацию. Не требуется переопределять методы доступа <see langword="get" /> и <see langword="set" /> свойства <see cref="P:System.Windows.Forms.Control.BackColor" />; При необходимости можно переопределить только один из них.</para></block>
        <altmember cref="T:System.Windows.Forms.AmbientProperties" />
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="BackColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackColorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackColorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackColorChanged;" />
      <MemberSignature Language="F#" Value="member this.BackColorChanged : EventHandler " Usage="member this.BackColorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.BackColor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.BackColor%2A> изменено программным изменением или взаимодействием с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Следующий пример кода является обработчиком событий, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени *PropertyName*`Changed`, которые вызываются при изменении соответствующего значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> с отображением денежных данных. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере требуется <xref:System.Windows.Forms.Form>, содержащий <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.Control.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает фоновое изображение, отображаемое на элементе управления.</summary>
        <value>Объект <see cref="T:System.Drawing.Image" />, предоставляющий изображение, которое отображается в качестве фона элемента управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   Используйте свойство <xref:System.Windows.Forms.Control.BackgroundImage%2A> для размещения графического изображения на элементе управления.  
  
> [!NOTE]
>  Изображения с полупрозрачными или прозрачными цветами не поддерживаются элементами управления Windows Forms в качестве фоновых изображений.  
>   
>  Это свойство не поддерживается для дочерних элементов управления, свойство <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> которых равно `true`.  
  
   
  
## Examples  
 В следующем примере кода в форму добавляется <xref:System.Windows.Forms.Button> и задаются некоторые общие свойства. В этом примере кнопка привязывается к нижнему правому углу формы, чтобы сохранить ее относительное расположение при изменении размера формы. Затем он устанавливает <xref:System.Windows.Forms.Control.BackgroundImage%2A> и изменяет размер кнопки на тот же размер, что и <xref:System.Drawing.Image>. Затем в примере устанавливается <xref:System.Windows.Forms.Control.TabStop%2A> в `true` и задается свойство <xref:System.Windows.Forms.Control.TabIndex%2A>. Наконец, он добавляет обработчик событий для обработки события <xref:System.Windows.Forms.Control.Click> кнопки. В этом примере требуется <xref:System.Windows.Forms.ImageList> с именем `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> в производном классе используйте свойство базового класса <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> для расширения базовой реализации. В противном случае необходимо предоставить всю реализацию. Не требуется переопределять методы доступа <see langword="get" /> и <see langword="set" /> свойства <see cref="P:System.Windows.Forms.Control.BackgroundImage" />; При необходимости можно переопределить только один из них.</para></block>
        <altmember cref="T:System.Drawing.Image" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.BackgroundImage" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.BackgroundImage%2A> изменено программным изменением или взаимодействием с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Следующий пример кода является обработчиком событий, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени *PropertyName*`Changed`, которые вызываются при изменении соответствующего значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> с отображением денежных данных. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере требуется <xref:System.Windows.Forms.Form>, содержащий <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Image" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.Control.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает макет фонового изображения в соответствии с перечислением <see cref="T:System.Windows.Forms.ImageLayout" />.</summary>
        <value>Одно из значений <see cref="T:System.Windows.Forms.ImageLayout" /> (<see cref="F:System.Windows.Forms.ImageLayout.Center" />, <see cref="F:System.Windows.Forms.ImageLayout.None" />, <see cref="F:System.Windows.Forms.ImageLayout.Stretch" />, <see cref="F:System.Windows.Forms.ImageLayout.Tile" /> или <see cref="F:System.Windows.Forms.ImageLayout.Zoom" />). По умолчанию устанавливается значение <see cref="F:System.Windows.Forms.ImageLayout.Tile" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A>, чтобы указать расположение и поведение изображения, помещенного в элемент управления. <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> вступает в силу только в том случае, если задано свойство <xref:System.Windows.Forms.Control.BackgroundImage%2A>.  
  
 Можно увеличить производительность для больших изображений, если установить <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> на что-то другое, чем <xref:System.Windows.Forms.ImageLayout.Tile>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Указанное значение перечисления не существует.</exception>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении свойства <see cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> изменяется либо программно, либо путем взаимодействия с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа, который наследует от <xref:System.Windows.Forms.Control>, например <xref:System.Windows.Forms.Button> или <xref:System.Windows.Forms.ComboBox>. Затем присвойте экземпляру имя `Control1` и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#9)]
 [!code-vb[System.Windows.Forms.EventExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет делегат асинхронно в потоке, в котором был создан базовый дескриптор элемента управления.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate -&gt; IAsyncResult" Usage="control.BeginInvoke method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Делегат метода, который не принимает параметров.</param>
        <summary>Выполняет указанный делегат асинхронно в потоке, в котором был создан базовый дескриптор элемента управления.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который представляет результат выполнения операции <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается асинхронно, и этот метод немедленно возвращает значение. Этот метод можно вызвать из любого потока, даже из потока, владеющего маркером элемента управления. Если маркер элемента управления еще не существует, этот метод выполняет поиск по родительской цепочке элемента управления до тех пор, пока не обнаружит элемент управления или форму, у которых есть обработчик окна. Если не удается найти соответствующий обработчик, <xref:System.Windows.Forms.Control.BeginInvoke%2A> выдаст исключение. Исключения в методе делегата считаются неперехваченными и отправляются в обработчик исключений неперехваченного приложения.  
  
 Можно вызвать <xref:System.Windows.Forms.Control.EndInvoke%2A>, чтобы получить возвращаемое значение от делегата, если необходимых, но это не является обязательным. <xref:System.Windows.Forms.Control.EndInvoke%2A> будет блокироваться до тех пор, пока не будет получено возвращаемое значение.  
  
> [!NOTE]
>  Большинство методов элемента управления могут вызываться только из потока, в котором был создан элемент управления. В дополнение к свойству <xref:System.Windows.Forms.Control.InvokeRequired%2A> существуют четыре метода в элементе управления, которые являются потокобезопасными: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> и <xref:System.Windows.Forms.Control.CreateGraphics%2A>, если уже был создан маркер для элемента управления. Вызов <xref:System.Windows.Forms.Control.CreateGraphics%2A> перед созданием маркера элемента управления в фоновом потоке может привести к недопустимым перекрестным вызовам потоков. Для всех остальных вызовов методов следует использовать один из методов Invoke для маршалирования вызова в поток элемента управления. Методы Invoke всегда вызывают свои обратные вызовы в потоке элемента управления.  
  
> [!NOTE]
>  Исключение может быть вызвано, если поток, который должен обработать сообщение, больше не активен.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование метода <xref:System.Windows.Forms.Control.BeginInvoke%2A>.  
  
 [!code-cpp[Control_BeginInvoke#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#2)]
 [!code-csharp[Control_BeginInvoke#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#2)]
 [!code-vb[Control_BeginInvoke#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Соответствующий дескриптор окна не обнаружен.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для непосредственного вызывающего объекта, чтобы вызвать неуправляемый код. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.CreateGraphics" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method, params object[] args);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As IAsyncResult" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member BeginInvoke : Delegate * obj[] -&gt; IAsyncResult&#xA;override this.BeginInvoke : Delegate * obj[] -&gt; IAsyncResult" Usage="control.BeginInvoke (method, args)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method, object[] args);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, args As Object()) As IAsyncResult" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginInvoke(Delegate ^ method, cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISynchronizeInvoke.BeginInvoke(System.Delegate,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Делегат метода, принимающий параметры, количество и тип которых являются такими же, что и в параметре <paramref name="args" />.</param>
        <param name="args">Массив объектов, передаваемых в качестве аргументов указанному методу. Это может быть значение <see langword="null" />, если аргументы не требуются.</param>
        <summary>Выполняет указанный делегат асинхронно с указанными аргументами в потоке, в котором был создан базовый дескриптор элемента управления.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который представляет результат выполнения операции <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегат вызывается асинхронно, и этот метод немедленно возвращает значение. Этот метод можно вызвать из любого потока, даже из потока, владеющего маркером элемента управления. Если маркер элемента управления еще не существует, этот метод выполняет поиск по родительской цепочке элемента управления до тех пор, пока не обнаружит элемент управления или форму, у которых есть обработчик окна. Если не удается найти соответствующий обработчик, <xref:System.Windows.Forms.Control.BeginInvoke%2A> выдаст исключение. Исключения в методе делегата считаются неперехваченными и отправляются в обработчик исключений неперехваченного приложения.  
  
 Можно вызвать <xref:System.Windows.Forms.Control.EndInvoke%2A>, чтобы получить возвращаемое значение от делегата, если необходимых, но это не является обязательным. <xref:System.Windows.Forms.Control.EndInvoke%2A> будет блокироваться до тех пор, пока не будет получено возвращаемое значение.  
  
> [!NOTE]
>  Большинство методов элемента управления могут вызываться только из потока, в котором был создан элемент управления. В дополнение к свойству <xref:System.Windows.Forms.Control.InvokeRequired%2A> существуют четыре метода в элементе управления, которые являются потокобезопасными: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> и <xref:System.Windows.Forms.Control.CreateGraphics%2A>, если уже был создан маркер для элемента управления. Вызов <xref:System.Windows.Forms.Control.CreateGraphics%2A> перед созданием маркера элемента управления в фоновом потоке может привести к недопустимым перекрестным вызовам потоков. Для всех остальных вызовов методов следует использовать один из методов Invoke для маршалирования вызова в поток элемента управления. Методы Invoke всегда вызывают свои обратные вызовы в потоке элемента управления.  
  
> [!NOTE]
>  Исключение может быть вызвано, если поток, который должен обработать сообщение, больше не активен.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование метода <xref:System.Windows.Forms.Control.BeginInvoke%2A>.  
  
 [!code-cpp[Control_BeginInvoke#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#1)]
 [!code-csharp[Control_BeginInvoke#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#1)]
 [!code-vb[Control_BeginInvoke#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Соответствующий дескриптор окна не обнаружен.</exception>
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.CreateGraphics" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="BindingContext">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.BindingContext BindingContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingContext BindingContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BindingContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BindingContext As BindingContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::BindingContext ^ BindingContext { System::Windows::Forms::BindingContext ^ get(); void set(System::Windows::Forms::BindingContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingContext : System.Windows.Forms.BindingContext with get, set" Usage="System.Windows.Forms.Control.BindingContext" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IBindableComponent.BindingContext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Windows.Forms.BindingContext" /> для элемента управления.</summary>
        <value>Свойство <see cref="T:System.Windows.Forms.BindingContext" /> элемента управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 @No__t-0 из <xref:System.Windows.Forms.Control> используется для возврата одного <xref:System.Windows.Forms.BindingManagerBase> для всех элементов управления с привязкой к данным, содержащихся в <xref:System.Windows.Forms.Control>. @No__t-0 позволяет синхронизировать все элементы управления, привязанные к одному источнику данных. Например, установка свойства <xref:System.Windows.Forms.BindingManagerBase.Position%2A> для <xref:System.Windows.Forms.BindingManagerBase> указывает элемент в базовом списке, на который указывают все элементы управления с привязкой к данным.  
  
 Дополнительные сведения о создании нового <xref:System.Windows.Forms.BindingContext> и назначении его свойству <xref:System.Windows.Forms.Control.BindingContext%2A> см. в <xref:System.Windows.Forms.BindingContext.%23ctor%2A>.  
  
   
  
## Examples  
 В следующем примере кода создаются четыре объекта <xref:System.Windows.Forms.Binding> для привязки пяти элементов управления, <xref:System.Windows.Forms.DateTimePicker> и четыре <xref:System.Windows.Forms.TextBox> элемента управления к нескольким источникам данных. @No__t-0 используется для получения <xref:System.Windows.Forms.BindingManagerBase> для каждого источника данных.  
  
 [!code-cpp[Classic BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.BindingContext" /> в производном классе используйте свойство базового класса <see cref="P:System.Windows.Forms.Control.BindingContext" /> для расширения базовой реализации. В противном случае необходимо предоставить всю реализацию. Не требуется переопределять методы доступа <see langword="get" /> и <see langword="set" /> свойства <see cref="P:System.Windows.Forms.Control.BindingContext" />; При необходимости можно переопределить только один из них.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="BindingContextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BindingContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BindingContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BindingContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BindingContextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BindingContextChanged;" />
      <MemberSignature Language="F#" Value="member this.BindingContextChanged : EventHandler " Usage="member this.BindingContextChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="T:System.Windows.Forms.BindingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы добавить новый <xref:System.Windows.Forms.BindingContext> в <xref:System.Windows.Forms.Control> через свойство <xref:System.Windows.Forms.Control.BindingContext%2A>, см. конструктор <xref:System.Windows.Forms.BindingContext.%23ctor%2A>.  
  
 Это событие возникает, если изменение свойства <xref:System.Windows.Forms.Control.BindingContext%2A> изменено программным изменением или взаимодействием с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода добавляется делегат <xref:System.EventHandler> к событию <xref:System.Windows.Forms.Control.BindingContextChanged> элемента управления <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CS/source.cs#1)]
 [!code-vb[Classic Control.BindingContextChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingContext" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
        <altmember cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Bottom">
      <MemberSignature Language="C#" Value="public int Bottom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Bottom" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bottom" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Bottom As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Bottom { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Bottom : int" Usage="System.Windows.Forms.Control.Bottom" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает расстояние в пикселях между нижней границей элемента управления и верхней границей клиентской области контейнера.</summary>
        <value>Объект <see cref="T:System.Int32" />, представляющий расстояние (в пикселях) между нижней границей элемента управления и верхней границей клиентской области контейнера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этого свойства равно сумме значения свойства <xref:System.Windows.Forms.Control.Top%2A> и значения свойства <xref:System.Windows.Forms.Control.Height%2A>.  
  
 Свойство <xref:System.Windows.Forms.Control.Bottom%2A> является свойством только для чтения. Вы можете управлять этим значением свойства, изменив значения свойств <xref:System.Windows.Forms.Control.Top%2A> или <xref:System.Windows.Forms.Control.Height%2A> или вызвав методы <xref:System.Windows.Forms.Control.SetBounds%2A>, <xref:System.Windows.Forms.Control.SetBoundsCore%2A>, <xref:System.Windows.Forms.Control.UpdateBounds%2A> или <xref:System.Windows.Forms.Control.SetClientSizeCore%2A>.  
  
   
  
## Examples  
 В следующем примере кода свойство <xref:System.Windows.Forms.Control.Bottom%2A> используется для определения нижнего предела элемента управления <xref:System.Windows.Forms.TextBox> относительно клиентской области контейнера.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Top" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
      </Docs>
    </Member>
    <Member MemberName="Bounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle Bounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle Bounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bounds" />
      <MemberSignature Language="VB.NET" Value="Public Property Bounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle Bounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberSignature Language="F#" Value="member this.Bounds : System.Drawing.Rectangle with get, set" Usage="System.Windows.Forms.Control.Bounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает размер и местоположение (в пикселях) элемента управления, включая его неклиентские элементы, относительно его родительского элемента управления.</summary>
        <value>Объект <see cref="T:System.Drawing.Rectangle" /> в пикселях относительно родительского элемента управления, представляющий размер и местоположение элемента управления, включая его неклиентские элементы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Границы элемента управления включают неклиентские элементы, такие как полосы прокрутки, границы, строки заголовка и меню. Для установки свойства <xref:System.Windows.Forms.Control.Bounds%2A> вызывается метод <xref:System.Windows.Forms.Control.SetBoundsCore%2A>. Свойство <xref:System.Windows.Forms.Control.Bounds%2A> не всегда изменяется с помощью метода `set`, поэтому следует переопределить метод <xref:System.Windows.Forms.Control.SetBoundsCore%2A>, чтобы обеспечить выполнение кода, если задано свойство <xref:System.Windows.Forms.Control.Bounds%2A>.  
  
   
  
## Examples  
 В следующем примере кода создаются три элемента управления <xref:System.Windows.Forms.Button> в форме и задаются их размер и расположение с использованием различных свойств, связанных с размером и расположением. В этом примере требуется наличие <xref:System.Windows.Forms.Form> с шириной и высотой не менее 300 пикселей.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Top" />
        <altmember cref="P:System.Windows.Forms.Control.Left" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
      </Docs>
    </Member>
    <Member MemberName="BringToFront">
      <MemberSignature Language="C#" Value="public void BringToFront ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringToFront() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BringToFront" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringToFront ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringToFront();" />
      <MemberSignature Language="F#" Value="member this.BringToFront : unit -&gt; unit" Usage="control.BringToFront " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Помещает элемент управления в начало z-порядка.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элемент управления перемещается в начало z-порядка. Если элемент управления является дочерним для другого элемента управления, дочерний элемент управления перемещается в начало z-порядка. <xref:System.Windows.Forms.Control.BringToFront%2A> не делает элемент управления элементом верхнего уровня и не создает событие <xref:System.Windows.Forms.Control.Paint>.  
  
   
  
## Examples  
 В следующем примере кода гарантируется, что <xref:System.Windows.Forms.Label> виден, вызвав его метод <xref:System.Windows.Forms.Control.BringToFront%2A>. В этом примере требуется наличие <xref:System.Windows.Forms.Form> с <xref:System.Windows.Forms.Panel> с именем `panel1` и <xref:System.Windows.Forms.Label> с именем `label1`.  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SendToBack" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
      </Docs>
    </Member>
    <Member MemberName="CanEnableIme">
      <MemberSignature Language="C#" Value="protected virtual bool CanEnableIme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnableIme" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanEnableIme" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property CanEnableIme As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanEnableIme { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanEnableIme : bool" Usage="System.Windows.Forms.Control.CanEnableIme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, можно ли для свойства <see cref="P:System.Windows.Forms.Control.ImeMode" /> установить активное значение с целью включения поддержки IME.</summary>
        <value>Значение <see langword="true" /> во всех случаях.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Производные классы могут переопределять это свойство, чтобы оно возвращало `false`, если IME не поддерживается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFocus">
      <MemberSignature Language="C#" Value="public bool CanFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanFocus" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFocus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFocus : bool" Usage="System.Windows.Forms.Control.CanFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, может ли элемент управления получать фокус.</summary>
        <value>Значение <see langword="true" />, если элемент управления может получать фокус; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы элемент управления мог получать фокус ввода, элементу управления должен быть присвоен назначенный ему маркер, а свойства <xref:System.Windows.Forms.Control.Visible%2A> и <xref:System.Windows.Forms.Control.Enabled%2A> должны быть установлены в `true` как для элемента управления, так и для всех его родительских элементов управления, а элемент управления должен быть формой или самым внешним номиналом элемента управления. ENT должен быть формой.  
  
   
  
## Examples  
 В следующем примере кода фокус устанавливается на указанный <xref:System.Windows.Forms.Control>, если он может получить фокус.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
      </Docs>
    </Member>
    <Member MemberName="CanRaiseEvents">
      <MemberSignature Language="C#" Value="protected override bool CanRaiseEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRaiseEvents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanRaiseEvents" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CanRaiseEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanRaiseEvents { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRaiseEvents : bool" Usage="System.Windows.Forms.Control.CanRaiseEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет, могут ли вызываться события в элементе управления.</summary>
        <value>Значение <see langword="true" />, если элемент управления размещен как управляющий элемент ActiveX, события которого зафиксированы; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот элемент управления размещается как элемент управления ActiveX, это свойство будет возвращать значение `false`, если события элемента управления ActiveX заморожены.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSelect">
      <MemberSignature Language="C#" Value="public bool CanSelect { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSelect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanSelect" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanSelect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanSelect { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSelect : bool" Usage="System.Windows.Forms.Control.CanSelect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, доступен ли элемент управления для выбора.</summary>
        <value>Значение <see langword="true" />, если элемент управления может быть выбран; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает `true`, если `Selectable` значение <xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType> равно `true`, содержится в другом элементе управления, сам элемент управления является видимым и включенным, и все его родительские элементы управления видимы и включены.  
  
 Элементы управления Windows Forms в следующем списке недоступны для выбора и будут возвращать значение `false` для свойства <xref:System.Windows.Forms.Control.CanSelect%2A>. Элементы управления, производные от этих элементов управления, также не могут быть выбраны.  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel> (если в элементе управления отсутствует ссылка)  
  
   
  
## Examples  
 В следующем примере кода выбирается указанный <xref:System.Windows.Forms.Control>, если он доступен для выбора.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
 [!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
 [!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
      </Docs>
    </Member>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public bool Capture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Capture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Capture" />
      <MemberSignature Language="VB.NET" Value="Public Property Capture As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Capture { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Capture : bool with get, set" Usage="System.Windows.Forms.Control.Capture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, была ли мышь захвачена элементом управления.</summary>
        <value>Значение <see langword="true" />, если мышь захвачена элементом управления; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда элемент управления захватывает мышь, он получает ввод с клавиатуры независимо от того, находится ли курсор внутри его границ. Мышь обычно захватывается только во время операций перетаскивания.  
  
 Захват мыши может осуществляться только в окне переднего плана. Когда окно в фоновом режиме попытается сделать это, окно получает сообщения только для событий мыши, происходящих, когда курсор мыши находится в видимой части окна. Кроме того, даже если окно переднего плана захватило мышь, пользователь по-прежнему может щелкнуть другое окно, переведя его на передний план.  
  
 При захвате мыши сочетания клавиш не работают.  
  
   
  
## Examples  
 В следующем примере кода показано свойство <xref:System.Windows.Forms.Control.Capture%2A>. Чтобы выполнить этот пример, вставьте следующий код в форму, содержащую <xref:System.Windows.Forms.Label> с именем Label1, и два элемента управления <xref:System.Windows.Forms.ListBox> с именами ListBox1 и ListBox2. Убедитесь, что форма и элементы управления с событием <xref:System.Windows.Forms.Control.MouseDown> связаны с методом в этом примере.  
  
 [!code-cpp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlCapture#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">значение этого свойства для всех окон. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CausesValidation">
      <MemberSignature Language="C#" Value="public bool CausesValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CausesValidation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CausesValidation" />
      <MemberSignature Language="VB.NET" Value="Public Property CausesValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CausesValidation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CausesValidation : bool with get, set" Usage="System.Windows.Forms.Control.CausesValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, вызывает ли элемент управления выполнение проверки для всех элементов управления, требующих проверки, при получении фокуса.</summary>
        <value>Значение <see langword="true" />, если элемент управления вызывает выполнение проверки в любом элементе управления, требующем проверки при получении фокуса; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойство <xref:System.Windows.Forms.Control.CausesValidation%2A> имеет значение `false`, события <xref:System.Windows.Forms.Control.Validating> и <xref:System.Windows.Forms.Control.Validated> подавляются.  
  
 Значение свойства <xref:System.Windows.Forms.Control.CausesValidation%2A> обычно устанавливается равным `false` для таких элементов управления, как кнопка справки.  
  
   
  
## Examples  
 В следующем примере кода используется производный класс <xref:System.Windows.Forms.TextBox> и проверяется адрес электронной почты, который вводит пользователь. Если адрес электронной почты имеет формат, отличный от стандартного (содержащий "@" and "."), проверка завершается неудачно, отображается значок <xref:System.Windows.Forms.ErrorProvider>, и событие отменяется. У одной из кнопок формы свойство <xref:System.Windows.Forms.Control.CausesValidation%2A> имеет значение `false`. Если щелкнуть или установить фокус на эту кнопку, проверка не будет активирована. В этом примере требуется, чтобы в форме были созданы <xref:System.Windows.Forms.TextBox>, элемент управления <xref:System.Windows.Forms.ErrorProvider> и <xref:System.Windows.Forms.Button>.  
  
 [!code-cpp[Control.Validating#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#2)]
 [!code-csharp[Control.Validating#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#2)]
 [!code-vb[Control.Validating#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="CausesValidationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CausesValidationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CausesValidationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CausesValidationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CausesValidationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CausesValidationChanged;" />
      <MemberSignature Language="F#" Value="member this.CausesValidationChanged : EventHandler " Usage="member this.CausesValidationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.CausesValidation" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.CausesValidation%2A> изменено программным изменением или взаимодействием с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
      </Docs>
    </Member>
    <Member MemberName="ChangeUICues">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.UICuesEventHandler ChangeUICues;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.UICuesEventHandler ChangeUICues" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ChangeUICues" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ChangeUICues As UICuesEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::UICuesEventHandler ^ ChangeUICues;" />
      <MemberSignature Language="F#" Value="member this.ChangeUICues : System.Windows.Forms.UICuesEventHandler " Usage="member this.ChangeUICues : System.Windows.Forms.UICuesEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.UICuesEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при получении сигналов на изменение от фокуса или клавиатурного интерфейса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Control.ChangeUICues>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа, который наследует от <xref:System.Windows.Forms.Control>, например <xref:System.Windows.Forms.Button> или <xref:System.Windows.Forms.ComboBox>. Затем присвойте экземпляру имя `Control1` и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Control.ChangeUICues>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#67](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#67)]
 [!code-vb[System.Windows.Forms.EventExamples#67](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="CheckForIllegalCrossThreadCalls">
      <MemberSignature Language="C#" Value="public static bool CheckForIllegalCrossThreadCalls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckForIllegalCrossThreadCalls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckForIllegalCrossThreadCalls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckForIllegalCrossThreadCalls : bool with get, set" Usage="System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, показывающее, нужно ли перехватывать вызовы в ошибочном потоке, который осуществляет доступ к свойству <see cref="P:System.Windows.Forms.Control.Handle" /> элемента управления во время отладки.</summary>
        <value>Значение <see langword="true" />, если вызовы в ошибочном потоке перехватываются; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если поток, отличный от создания потока управления, пытается получить доступ к одному из методов или свойств этого элемента управления, это часто приводит к непредсказуемым результатам. Типичное недопустимое действие потока — это вызов неправильного потока, который обращается к свойству <xref:System.Windows.Forms.Control.Handle%2A> элемента управления. Установите <xref:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls%2A> в `true`, чтобы упростить поиск и диагностику этого действия потока во время отладки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при щелчке элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие <xref:System.Windows.Forms.Control.Click> передает <xref:System.EventArgs> обработчику событий, поэтому он только указывает, что произошло нажатие кнопки. Если вам нужны более конкретные сведения о мыши (кнопка, число щелчков, поворот колесика или расположение), используйте событие <xref:System.Windows.Forms.Control.MouseClick>. Однако событие <xref:System.Windows.Forms.Control.MouseClick> не будет вызываться, если щелчок вызывается действием, отличным от мыши, например нажатием клавиши ВВОД.  
  
 Двойной щелчок определяется параметрами мыши операционной системы пользователя. Пользователь может задать время между нажатиями кнопки мыши, которые будут считаться двойным щелчком, а не двумя отдельными щелчками. Событие <xref:System.Windows.Forms.Control.Click> возникает каждый раз при двойном щелчке элемента управления. Например, если у вас есть обработчики событий для событий <xref:System.Windows.Forms.Control.Click> и <xref:System.Windows.Forms.Control.DoubleClick> для <xref:System.Windows.Forms.Form>, события <xref:System.Windows.Forms.Control.Click> и <xref:System.Windows.Forms.Control.DoubleClick> возникают при двойном щелчке формы и вызове обоих методов. Если дважды щелкнуть элемент управления и этот элемент управления не поддерживает событие <xref:System.Windows.Forms.Control.DoubleClick>, событие <xref:System.Windows.Forms.Control.Click> может быть вызвано дважды.  
  
 Чтобы это событие было создано, необходимо установить значение `StandardClick` <xref:System.Windows.Forms.ControlStyles> в `true`.  
  
> [!NOTE]
>  Следующие события не вызываются для класса <xref:System.Windows.Forms.TabControl>, если в коллекции <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> не существует хотя бы один <xref:System.Windows.Forms.TabPage>: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> и 0. Если в коллекции имеется хотя бы один <xref:System.Windows.Forms.TabPage>, и пользователь взаимодействует с заголовком элемента управления вкладки (где отображаются имена <xref:System.Windows.Forms.TabPage>), <xref:System.Windows.Forms.TabControl> вызывает соответствующее событие. Однако если взаимодействие с пользователем происходит в клиентской области страницы вкладки, <xref:System.Windows.Forms.TabPage> вызывает соответствующее событие.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
## <a name="notes-to-inheritors"></a>Примечания к наследникам

Наследование от стандартного элемента управления Windows Forms и изменение значений `StandardClick` или `StandardDoubleClick` <xref:System.Windows.Forms.ControlStyles> на `true` может привести к непредвиденному поведению или не иметь никакого влияния на все, если элемент управления не поддерживает события <xref:System.Windows.Forms.Control.Click> или <xref:System.Windows.Forms.Control.DoubleClick>.
  
В следующей таблице перечислены Windows Formsные элементы управления и события (<xref:System.Windows.Forms.Control.Click> или <xref:System.Windows.Forms.Control.DoubleClick>), создаваемые в ответ на указанное действие мыши.

| Элемент управления | Щелчок левой кнопкой мыши | Двойной щелчок левой кнопкой мыши | Щелчок правой кнопкой мыши | Двойной щелчок правой кнопкой мыши | Щелчок средней кнопкой мыши | Двойной щелчок средней кнопкой мыши | Щелчок мыши XButton1 | Двойной щелчок по XButton1 мыши | Щелчок мыши XButton2 | Двойной щелчок по XButton2 мыши | 
| ------- | ---------------- | ----------------------- | ----------------- | ------------------------ | ------------------ | ------------------------- | -------------------- | --------------------------- | -------------------- | --------------------------- |
| <xref:System.Windows.Forms.MonthCalendar>, <xref:System.Windows.Forms.DateTimePicker>, <xref:System.Windows.Forms.HScrollBar>, <xref:System.Windows.Forms.VScrollBar> | Нет | Нет | Нет | Нет | Нет | Нет | Нет | Нет | Нет | Нет |
| <xref:System.Windows.Forms.Button>, <xref:System.Windows.Forms.CheckBox>, <xref:System.Windows.Forms.RichTextBox>, <xref:System.Windows.Forms.RadioButton> | Нажмите кнопку | Щелкните, щелкните | Нет | Нет | Нет | Нет | Нет | Нет | Нет | Нет |
| <xref:System.Windows.Forms.ListBox>, <xref:System.Windows.Forms.CheckedListBox>, <xref:System.Windows.Forms.ComboBox> | Нажмите кнопку | Щелкните, DoubleClick | Нет | Нет | Нет | Нет | Нет | Нет | Нет | Нет |
| <xref:System.Windows.Forms.TextBox>, <xref:System.Windows.Forms.DomainUpDown>, <xref:System.Windows.Forms.NumericUpDown> | Нажмите кнопку | Щелкните, DoubleClick | Нет | Нет | Нет | Нет | Нет | Нет | Нет | Нет |
| \* <xref:System.Windows.Forms.TreeView>, \* <xref:System.Windows.Forms.ListView> | Нажмите кнопку | Щелкните, DoubleClick | Нажмите кнопку | Щелкните, DoubleClick | Нет | Нет | Нет | Нет | Нет | Нет |
| <xref:System.Windows.Forms.ProgressBar>, <xref:System.Windows.Forms.TrackBar> | Нажмите кнопку | Щелкните, щелкните | Нажмите кнопку | Щелкните, щелкните | Нажмите кнопку | Щелкните, щелкните | Нажмите кнопку | Щелкните, щелкните | Нажмите кнопку | Щелкните, щелкните |
| <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.DataGrid>, <xref:System.Windows.Forms.Label>, <xref:System.Windows.Forms.LinkLabel>, <xref:System.Windows.Forms.Panel>, <xref:System.Windows.Forms.GroupBox>, <xref:System.Windows.Forms.PictureBox>, <xref:System.Windows.Forms.Splitter>, <xref:System.Windows.Forms.StatusBar>, <xref:System.Windows.Forms.ToolBar>, 0, 1 @ no__t-12 3 | Нажмите кнопку | Щелкните, DoubleClick | Нажмите кнопку | Щелкните, DoubleClick | Нажмите кнопку | Щелкните, DoubleClick | Нажмите кнопку | Щелкните, DoubleClick | Нажмите кнопку | Щелкните, DoubleClick |

\* указатель мыши должен находиться над дочерним объектом (<xref:System.Windows.Forms.TreeNode> или <xref:System.Windows.Forms.ListViewItem>).  
  
 * * @No__t-0 должен иметь хотя бы один <xref:System.Windows.Forms.TabPage> в своей коллекции <xref:System.Windows.Forms.TabControl.TabPages>.

## Examples  
 В следующем примере кода показано событие <xref:System.Windows.Forms.Control.Click> в обработчике событий.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ClientRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.Control.ClientRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает прямоугольник, представляющий клиентскую область элемента управления.</summary>
        <value>Объект <see cref="T:System.Drawing.Rectangle" />, представляющий клиентскую область элемента управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиентская область элемента управления — это границы элемента управления, за вычетом неклиентских элементов, таких как полосы прокрутки, границы, строки заголовка и меню.  
  
 Так как клиентские координаты задаются относительно левого верхнего угла клиентской области элемента управления, координаты левого верхнего угла прямоугольника, возвращаемого этим свойством, равны (0, 0). Это свойство можно использовать для получения размера и координат клиентской области элемента управления для таких задач, как рисование на поверхности элемента управления.  
  
 Дополнительные сведения о рисовании элементов управления см. [в разделе Подготовка к просмотру элемента управления Windows Forms](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md).  
  
   
  
## Examples  
 Следующий пример кода включает автоматическую прокрутку формы, изменяет размер формы и гарантирует, что кнопка остается видимой после изменения размера формы. В этом примере требуется наличие <xref:System.Windows.Forms.Form> с <xref:System.Windows.Forms.Button> с именем `button2`.  
  
 [!code-cpp[Windows.Forms.Control Member5#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#2)]
 [!code-csharp[Windows.Forms.Control Member5#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#2)]
 [!code-vb[Windows.Forms.Control Member5#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
        <altmember cref="T:System.Windows.Forms.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size ClientSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.ClientSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.ClientSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает высоту и ширину клиентской области элемента управления.</summary>
        <value>Объект <see cref="T:System.Drawing.Size" />, представляющий измерения клиентской области элемента управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиентская область элемента управления — это границы элемента управления, за вычетом неклиентских элементов, таких как полосы прокрутки, границы, строки заголовка и меню. Для установки свойства <xref:System.Windows.Forms.Control.ClientSize%2A> вызывается метод <xref:System.Windows.Forms.Control.SetClientSizeCore%2A>. Свойство <xref:System.Windows.Forms.Control.ClientSize%2A> не всегда изменяется с помощью метода `set`, поэтому следует переопределить метод <xref:System.Windows.Forms.Control.SetClientSizeCore%2A>, чтобы обеспечить выполнение кода, если задано свойство <xref:System.Windows.Forms.Control.ClientSize%2A>.  
  
 Свойства <xref:System.Drawing.Size.Width%2A?displayProperty=nameWithType> и <xref:System.Drawing.Size.Height%2A?displayProperty=nameWithType> представляют ширину и высоту клиентской области элемента управления. Это свойство можно использовать для получения размера клиентской области элемента управления для таких задач, как рисование на поверхности элемента управления.  
  
 Дополнительные сведения о рисовании элементов управления см. [в разделе Подготовка к просмотру элемента управления Windows Forms](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md).  
  
> [!NOTE]
>  Невозможно привязать параметры приложения к этому свойству. Дополнительные сведения о параметрах приложения см. в разделе [Общие сведения о параметрах приложения](~/docs/framework/winforms/advanced/application-settings-overview.md).  
  
   
  
## Examples  
 В следующем примере кода выполняется изменение размера указанного элемента управления, чтобы элемент управления соответствовал форматированному тексту. Форматированный текст — это свойство <xref:System.Windows.Forms.Control.Text%2A> с назначенным элементом управления <xref:System.Windows.Forms.Control.Font%2A>, применяемым к тексту. Метод `AutoSizeControl` в этом примере также имеет параметр `textPadding`, который представляет заполнение, применяемое ко всем краям элемента управления. Чтобы сделать заполнение одинаковым, выровняйте текст по значению <xref:System.Drawing.ContentAlignment.MiddleCenter?displayProperty=nameWithType>, если элемент управления поддерживает его.  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="T:System.Windows.Forms.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ClientSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ClientSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ClientSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ClientSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ClientSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ClientSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.ClientSizeChanged : EventHandler " Usage="member this.ClientSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.ClientSize" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Control.ClientSizeChanged>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа, который наследует от <xref:System.Windows.Forms.Control>, например <xref:System.Windows.Forms.Button> или <xref:System.Windows.Forms.ComboBox>. Затем присвойте экземпляру имя `Control1` и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Control.ClientSizeChanged>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#12)]
 [!code-vb[System.Windows.Forms.EventExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Control.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Description("ControlCompanyNameDescr")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает название организации или имя создателя приложения, содержащего элемент управления.</summary>
        <value>Название организации или имя создателя приложения, содержащего элемент управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.CompanyName%2A> является свойством только для чтения. Чтобы изменить значение этого свойства, задайте значение свойства <xref:System.Reflection.AssemblyCompanyAttribute.Company%2A> для <xref:System.Reflection.AssemblyCompanyAttribute>. В следующей строке C# кода задается свойство <xref:System.Windows.Forms.Control.CompanyName%2A>.  
  
```csharp  
[assembly: AssemblyCompany("Microsoft")]  
```  
  
> [!NOTE]
>  Настоятельно рекомендуется указать название компании, название продукта и версию продукта для приложения.  
  
   
  
## Examples  
 В следующем примере кода отображаются сведения о приложении в <xref:System.Windows.Forms.Label>, содержащемся в <xref:System.Windows.Forms.Form>. Для этого примера требуется, чтобы были заданы <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> и <xref:System.Windows.Forms.Control.ProductVersion%2A>.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyCompanyAttribute.Company" />
        <altmember cref="P:System.Diagnostics.FileVersionInfo.CompanyName" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Forms.Control ctl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Windows.Forms.Control ctl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Contains(System.Windows.Forms.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (ctl As Control) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Windows::Forms::Control ^ ctl);" />
      <MemberSignature Language="F#" Value="member this.Contains : System.Windows.Forms.Control -&gt; bool" Usage="control.Contains ctl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="ctl">Оцениваемый объект <see cref="T:System.Windows.Forms.Control" />.</param>
        <summary>Возвращает значение, указывающее, является ли указанный элемент управления дочерним элементом.</summary>
        <returns>Значение <see langword="true" />, если указанный элемент управления является дочерним элементом; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода гарантируется, что <xref:System.Windows.Forms.Label> виден, вызвав его метод <xref:System.Windows.Forms.Control.BringToFront%2A>. В этом примере требуется наличие <xref:System.Windows.Forms.Form> с <xref:System.Windows.Forms.Panel> с именем `panel1` и <xref:System.Windows.Forms.Label> с именем `label1`.  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ControlCollection.Contains(System.Windows.Forms.Control)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="ContainsFocus">
      <MemberSignature Language="C#" Value="public bool ContainsFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContainsFocus" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainsFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ContainsFocus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsFocus : bool" Usage="System.Windows.Forms.Control.ContainsFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, имеет ли элемент управления или один из его дочерних элементов фокус ввода в настоящий момент.</summary>
        <value>Значение <see langword="true" />, если элемент управления или один из его дочерних элементов в данный момент имеет фокус ввода; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 С помощью этого свойства можно определить, имеет ли элемент управления или элементы управления, содержащиеся в нем, фокус ввода. Чтобы определить, имеет ли элемент управления фокус, независимо от того, имеет ли его дочерний элемент управления фокус, используйте свойство <xref:System.Windows.Forms.Control.Focused%2A>. Чтобы присвоить элементу управления фокус ввода, используйте методы <xref:System.Windows.Forms.Control.Focus%2A> или <xref:System.Windows.Forms.Control.Select%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenu ^ ContextMenu { System::Windows::Forms::ContextMenu ^ get(); void set(System::Windows::Forms::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Forms.ContextMenu with get, set" Usage="System.Windows.Forms.Control.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает контекстное меню, связанное с элементом управления.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.ContextMenu" /> предоставляет контекстное меню, сопоставленное с элементом управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте контекстные меню, чтобы предоставить пользователям параметры контекстного меню, если они щелкнули правой кнопкой мыши элемент управления.  
  
   
  
## Examples  
 В следующем примере кода отображается <xref:System.Windows.Forms.ContextMenu>, назначенный <xref:System.Windows.Forms.TreeView> при нажатии и отпускании правой кнопки мыши. Этот код требует наличия <xref:System.Windows.Forms.Form> с <xref:System.Windows.Forms.TreeView>. Также требуется, чтобы <xref:System.Windows.Forms.TreeView> <xref:System.Windows.Forms.ContextMenu> назначено свойству <xref:System.Windows.Forms.Control.ContextMenu%2A>.  
  
 [!code-cpp[Windows.Forms.Control Properties2#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#5)]
 [!code-csharp[Windows.Forms.Control Properties2#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#5)]
 [!code-vb[Windows.Forms.Control Properties2#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.ContextMenu" /> в производном классе используйте свойство базового класса <see cref="P:System.Windows.Forms.Control.ContextMenu" /> для расширения базовой реализации. В противном случае необходимо предоставить всю реализацию. Не требуется переопределять методы доступа <see langword="get" /> и <see langword="set" /> свойства <see cref="P:System.Windows.Forms.Control.ContextMenu" />; При необходимости можно переопределить только один из них.</para></block>
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContextMenuChanged;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuChanged : EventHandler " Usage="member this.ContextMenuChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.ContextMenu" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.ContextMenu%2A> изменено программным изменением или взаимодействием с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода отображается сообщение при возникновении изменения в контекстном меню.  
  
 [!code-cpp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CPP/control_contextmenu_creategraphics.cpp#2)]
 [!code-csharp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CS/control_contextmenu_creategraphics.cs#2)]
 [!code-vb[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/VB/control_contextmenu_creategraphics.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ContextMenu" />
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStrip">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenuStrip ContextMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenuStrip ContextMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenuStrip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ContextMenuStrip As ContextMenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenuStrip ^ ContextMenuStrip { System::Windows::Forms::ContextMenuStrip ^ get(); void set(System::Windows::Forms::ContextMenuStrip ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenuStrip : System.Windows.Forms.ContextMenuStrip with get, set" Usage="System.Windows.Forms.Control.ContextMenuStrip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Windows.Forms.ContextMenuStrip" />, сопоставленный с этим элементом управления.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.ContextMenuStrip" /> для этого элемента управления или значение <see langword="null" />, если объект <see cref="T:System.Windows.Forms.ContextMenuStrip" /> отсутствует. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если элементу управления также присвоено значение <xref:System.Windows.Forms.ContextMenu>, <xref:System.Windows.Forms.ContextMenu> имеет приоритет над <xref:System.Windows.Forms.ContextMenuStrip>.  
  
   
  
## Examples  
 В следующем примере кода показано, как добавить три объекта <xref:System.Windows.Forms.ToolStripMenuItem> в <xref:System.Windows.Forms.ContextMenuStrip>. Кроме того, он демонстрирует задание свойства <xref:System.Windows.Forms.Control.ContextMenuStrip%2A> формы.  
  
 [!code-csharp[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStripChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuStripChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuStripChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuStripChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuStripChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContextMenuStripChanged;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuStripChanged : EventHandler " Usage="member this.ContextMenuStripChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.ContextMenuStrip" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Control.ContextMenuStripChanged>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа, который наследует от <xref:System.Windows.Forms.Control>, например <xref:System.Windows.Forms.Button> или <xref:System.Windows.Forms.ComboBox>. Затем присвойте экземпляру имя `Control1` и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Control.ContextMenuStripChanged>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#14)]
 [!code-vb[System.Windows.Forms.EventExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ControlAdded">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlAdded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ControlAdded As ControlEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ControlEventHandler ^ ControlAdded;" />
      <MemberSignature Language="F#" Value="member this.ControlAdded : System.Windows.Forms.ControlEventHandler " Usage="member this.ControlAdded : System.Windows.Forms.ControlEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при добавлении нового элемента управления в массив <see cref="T:System.Windows.Forms.Control.ControlCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Windows.Forms.Control.ControlAdded> используется для добавления элемента управления в форму и отображения имени добавленного элемента управления в <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ControlRemoved">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlRemoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ControlRemoved As ControlEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ControlEventHandler ^ ControlRemoved;" />
      <MemberSignature Language="F#" Value="member this.ControlRemoved : System.Windows.Forms.ControlEventHandler " Usage="member this.ControlRemoved : System.Windows.Forms.ControlEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при удалении элемента управления из <see cref="T:System.Windows.Forms.Control.ControlCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Windows.Forms.Control.ControlRemoved> используется для удаления элемента управления из формы и отображения имени удаленного элемента управления в <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control/ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Controls" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Controls As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control::ControlCollection ^ Controls { System::Windows::Forms::Control::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Windows.Forms.Control.ControlCollection" Usage="System.Windows.Forms.Control.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию элементов управления, содержащихся в элементе управления.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.Control.ControlCollection" /> представляет коллекцию элементов управления, содержащихся в элементе управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 @No__t-0 может действовать как родительская коллекция элементов управления. Например, когда к <xref:System.Windows.Forms.Form> добавляется несколько элементов управления, каждый из них является членом <xref:System.Windows.Forms.Control.ControlCollection>, присвоенным свойству <xref:System.Windows.Forms.Control.Controls%2A> формы, который является производным от класса <xref:System.Windows.Forms.Control>.  
  
 Элементы управления в <xref:System.Windows.Forms.Control.ControlCollection>, назначенные свойству <xref:System.Windows.Forms.Control.Controls%2A>, можно манипулировать с помощью методов, доступных в классе <xref:System.Windows.Forms.Control.ControlCollection>.  
  
 При добавлении нескольких элементов управления в родительский элемент управления рекомендуется вызвать метод <xref:System.Windows.Forms.Control.SuspendLayout%2A> перед инициализацией добавляемых элементов управления. После добавления элементов управления в родительский элемент управления вызовите метод <xref:System.Windows.Forms.Control.ResumeLayout%2A>. Это повысит производительность приложений с большим количеством элементов управления.  
  
 Используйте свойство <xref:System.Windows.Forms.Control.Controls%2A> для прохода по всем элементам управления формы, включая вложенные элементы управления. Используйте метод <xref:System.Windows.Forms.Control.GetNextControl%2A> для получения предыдущего или следующего дочернего элемента управления в последовательности табуляции. Свойство <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> используется для получения или задания активного элемента управления контейнерного элемента управления.  
  
   
  
## Examples  
 В следующем примере кода удаляется <xref:System.Windows.Forms.Control> из <xref:System.Windows.Forms.Control.ControlCollection> производного класса <xref:System.Windows.Forms.Panel>, если он является членом коллекции. В этом примере необходимо создать <xref:System.Windows.Forms.Panel>, <xref:System.Windows.Forms.Button> и хотя бы один элемент управления <xref:System.Windows.Forms.RadioButton> в <xref:System.Windows.Forms.Form>. Элементы управления <xref:System.Windows.Forms.RadioButton> добавляются в элемент управления <xref:System.Windows.Forms.Panel>, а элемент управления <xref:System.Windows.Forms.Panel> добавляется в <xref:System.Windows.Forms.Form>. При нажатии кнопки переключатель с именем `removeButton` удаляется из <xref:System.Windows.Forms.Control.ControlCollection>.  
  
 [!code-cpp[ControlCollection#4](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlCollection/CPP/controlcollection.cpp#4)]
 [!code-csharp[ControlCollection#4](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlCollection/CS/controlcollection.cs#4)]
 [!code-vb[ControlCollection#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlCollection/VB/controlcollection.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControlsInstance" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
      </Docs>
    </Member>
    <Member MemberName="CreateAccessibilityInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject CreateAccessibilityInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject CreateAccessibilityInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAccessibilityInstance () As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::AccessibleObject ^ CreateAccessibilityInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateAccessibilityInstance : unit -&gt; System.Windows.Forms.AccessibleObject&#xA;override this.CreateAccessibilityInstance : unit -&gt; System.Windows.Forms.AccessibleObject" Usage="control.CreateAccessibilityInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает для элемента управления новый объект с поддержкой специальных возможностей.</summary>
        <returns>Новый объект <see cref="T:System.Windows.Forms.AccessibleObject" /> для элемента управления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если метод <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> не вызывается явно, он будет вызван при обращении к свойству <xref:System.Windows.Forms.Control.AccessibilityObject%2A>.  
  
> [!NOTE]
>  Чтобы получить или задать свойство <xref:System.Windows.Forms.Control.AccessibilityObject%2A>, необходимо добавить ссылку на сборку `Accessibility`, установленную с [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
   
  
## Examples  
 В следующем примере кода показано создание элемента управления диаграммы с поддержкой специальных возможностей с помощью классов <xref:System.Windows.Forms.AccessibleObject> и <xref:System.Windows.Forms.Control.ControlAccessibleObject> для предоставления доступной информации. Элемент управления отображает две кривые вместе с условными обозначениями. Класс `ChartControlAccessibleObject`, который является производным от `ControlAccessibleObject`, используется в методе <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> для предоставления настраиваемой информации, доступной для элемента управления диаграммы. Поскольку условные обозначения диаграммы не являются фактическим элементом управления на основе <xref:System.Windows.Forms.Control>, а нарисованы элементом управления диаграммы, он не содержит встроенных доступных сведений. В связи с этим класс `ChartControlAccessibleObject` переопределяет метод <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> для возврата `CurveLegendAccessibleObject`, который представляет доступную информацию для каждой части условных обозначений. Если приложение, поддерживающее доступ, использует этот элемент управления, элемент управления может предоставить необходимые сведения о специальных возможностях.  
  
 Этот фрагмент кода демонстрирует переопределение метода <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>. Полный пример кода см. в обзоре класса <xref:System.Windows.Forms.AccessibleObject>.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#2)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#2)]
 [!code-vb[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" /> в производном классе не вызывайте метод <see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" /> базового класса.</para></block>
        <altmember cref="T:System.Windows.Forms.Control.ControlAccessibleObject" />
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="CreateControl">
      <MemberSignature Language="C#" Value="public void CreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControl" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateControl();" />
      <MemberSignature Language="F#" Value="member this.CreateControl : unit -&gt; unit" Usage="control.CreateControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает принудительное создание видимого элемента управления, включая создание дескриптора и всех видимых дочерних элементов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Forms.Control.CreateControl%2A> заставляет создать обработчик для элемента управления и его дочерних элементов управления. Этот метод используется, когда для обработки элемента управления или его дочерних элементов требуется немедленное управление; При простом вызове конструктора элемента управления <xref:System.Windows.Forms.Control.Handle%2A> не создается.  
  
 <xref:System.Windows.Forms.Control.CreateControl%2A> не создает управляющий маркер, если свойство <xref:System.Windows.Forms.Control.Visible%2A> элемента управления имеет значение `false`. Можно либо вызвать метод <xref:System.Windows.Forms.Control.CreateHandle%2A>, либо получить доступ к свойству <xref:System.Windows.Forms.Control.Handle%2A>, чтобы создать дескриптор элемента управления независимо от видимости элемента управления, но в данном случае для дочерних элементов элемента управления не создаются никакие дескрипторы окна.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControlsInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateControlsInstance () As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::Control::ControlCollection ^ CreateControlsInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateControlsInstance : unit -&gt; System.Windows.Forms.Control.ControlCollection&#xA;override this.CreateControlsInstance : unit -&gt; System.Windows.Forms.Control.ControlCollection" Usage="control.CreateControlsInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый экземпляр коллекции элементов управления для данного элемента управления.</summary>
        <returns>Новый экземпляр коллекции <see cref="T:System.Windows.Forms.Control.ControlCollection" />, назначенной элементу управления.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Версия базового класса этого метода не должна вызываться производным классом.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public bool Created { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Created" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Created" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Created As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Created { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Created : bool" Usage="System.Windows.Forms.Control.Created" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, был ли создан элемент управления.</summary>
        <value>Значение <see langword="true" />, если элемент был создан; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.Created%2A> возвращает значение `true`, если <xref:System.Windows.Forms.Control> было успешно создано, несмотря на то, что маркер элемента управления может быть не создан или воссоздан еще.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.OnCreateControl" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="CreateGraphics">
      <MemberSignature Language="C#" Value="public System.Drawing.Graphics CreateGraphics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Graphics CreateGraphics() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateGraphics" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateGraphics () As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Graphics ^ CreateGraphics();" />
      <MemberSignature Language="F#" Value="member this.CreateGraphics : unit -&gt; System.Drawing.Graphics" Usage="control.CreateGraphics " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает объект <see cref="T:System.Drawing.Graphics" /> для элемента управления.</summary>
        <returns>Объект <see cref="T:System.Drawing.Graphics" /> для элемента управления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Drawing.Graphics>, который извлекается с помощью метода <xref:System.Windows.Forms.Control.CreateGraphics%2A>, обычно не должен храниться после обработки текущего сообщения Windows, так как все, что закрашено этим объектом, будет стерто следующим сообщением WM_PAINT. Поэтому нельзя кэшировать объект <xref:System.Drawing.Graphics> для повторного использования, за исключением использования невизуальных методов, таких как <xref:System.Drawing.Graphics.MeasureString%2A?displayProperty=nameWithType>. Вместо этого необходимо вызвать <xref:System.Windows.Forms.Control.CreateGraphics%2A> каждый раз, когда требуется использовать объект <xref:System.Drawing.Graphics>, а затем вызвать <xref:System.Drawing.Graphics.Dispose%2A> по завершении его использования. Дополнительные сведения о сообщениях Windows см. в разделе <xref:System.Windows.Forms.Control.WndProc%2A>.  
  
 По проекту <xref:System.Windows.Forms.Control.CreateGraphics%2A> задает владение вызывающим потоком и завершается ошибкой, если он вызывается в других потоках.  
  
> [!NOTE]
>  В дополнение к свойству <xref:System.Windows.Forms.Control.InvokeRequired%2A> существуют четыре метода в элементе управления, которые являются потокобезопасными: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> и <xref:System.Windows.Forms.Control.CreateGraphics%2A>, если уже был создан маркер для элемента управления. Вызов <xref:System.Windows.Forms.Control.CreateGraphics%2A> перед созданием маркера элемента управления в фоновом потоке может привести к недопустимым перекрестным вызовам потоков. Для всех остальных вызовов методов следует использовать один из методов Invoke для маршалирования вызова в поток элемента управления.  
  
   
  
## Examples  
 В следующем примере кода выполняется изменение размера указанного элемента управления, чтобы элемент управления соответствовал форматированному тексту. Форматированный текст — это свойство <xref:System.Windows.Forms.Control.Text%2A> с назначенным элементом управления <xref:System.Windows.Forms.Control.Font%2A>, применяемым к тексту. Метод `AutoSizeControl` в этом примере также имеет параметр `textPadding`, который представляет заполнение, применяемое ко всем краям элемента управления. Чтобы сделать заполнение одинаковым, выровняйте текст по значению `MiddleCenter` <xref:System.Drawing.ContentAlignment?displayProperty=nameWithType>, если элемент управления поддерживает его.  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для безопасного подокна для вызова этого метода. Связанное перечисление: значение <see langword="SafeSubWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="T:System.Drawing.Graphics" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected virtual void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CreateHandle();" />
      <MemberSignature Language="F#" Value="abstract member CreateHandle : unit -&gt; unit&#xA;override this.CreateHandle : unit -&gt; unit" Usage="control.CreateHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает дескриптор для элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обычно не следует вызывать метод <xref:System.Windows.Forms.Control.CreateHandle%2A> напрямую. Предпочтительным методом является вызов метода <xref:System.Windows.Forms.Control.CreateControl%2A>, который вызывает принудительное создание маркера для элемента управления и его дочерних элементов управления при создании элемента управления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Состояние объекта — удален.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон наследуемых классов для вызова этого метода. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.Windows.Forms.Control.CreateHandle" /> в производном классе обязательно вызовите метод <see cref="M:System.Windows.Forms.Control.CreateHandle" /> базового класса, чтобы гарантировать создание маркера.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.Control.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает параметры, необходимые для создания дескриптора элемента управления.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.CreateParams" />, содержащий необходимые параметры процедуры создания дескриптора элемента управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.CreateParams%2A> не следует переопределять и использовать для настройки свойств производного элемента управления. Такие свойства, как <xref:System.Windows.Forms.CreateParams.Caption%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.CreateParams.Width%2A?displayProperty=nameWithType> и <xref:System.Windows.Forms.CreateParams.Height%2A?displayProperty=nameWithType>, должны быть заданы соответствующими свойствами в элементе управления, например <xref:System.Windows.Forms.Control.Text%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Control.Width%2A?displayProperty=nameWithType> и <xref:System.Windows.Forms.Control.Height%2A?displayProperty=nameWithType>. @No__t-0 следует расширять только при создании оболочки для стандартного класса элементов управления Windows или для установки стилей, не предоставляемых пространством имен Windows Forms. Дополнительные сведения о создании параметров элементов управления см. в разделе `CreateWindow` и `CreateWindowEx` и документации по структуре [CREATESTRUCT](https://msdn.microsoft.com/library/windows/desktop/ms632603.aspx) .  
  
   
  
## Examples  
 В следующем примере кода расширяется свойство <xref:System.Windows.Forms.Control.CreateParams%2A> производного класса <xref:System.Windows.Forms.Button>. Свойство <xref:System.Windows.Forms.CreateParams.Style%2A?displayProperty=nameWithType> изменено, в результате чего на кнопке отображается <xref:System.Drawing.Icon>, а не <xref:System.Drawing.Image>. В этом примере предполагается, что у вас есть класс, наследующий от класса <xref:System.Windows.Forms.Button>.  
  
 [!code-cpp[CreateParams#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CreateParams/CPP/createparams.cpp#3)]
 [!code-csharp[CreateParams#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CreateParams/CS/createparams.cs#3)]
 [!code-vb[CreateParams#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CreateParams/VB/createparams.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для немедленного вызывающего объекта, чтобы вызвать неуправляемый код при получении значения свойства. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.CreateParams" /> в производном классе используйте свойство базового класса <see cref="P:System.Windows.Forms.Control.CreateParams" /> для расширения базовой реализации. В противном случае необходимо предоставить всю реализацию.</para></block>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Cursor ^ Cursor { System::Windows::Forms::Cursor ^ get(); void set(System::Windows::Forms::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Forms.Cursor with get, set" Usage="System.Windows.Forms.Control.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает курсор, отображаемый, когда указатель мыши находится на элементе управления.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.Cursor" />, который представляет курсор, отображаемый, когда указатель мыши находится на элементе управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Назначьте <xref:System.Windows.Forms.Cursor> свойству <xref:System.Windows.Forms.Control.Cursor%2A> элемента управления, чтобы изменить курсор, отображаемый при наведении указателя мыши на элемент управления. Чтобы временно изменить курсор мыши для всех элементов управления в приложении, задайте свойство <xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType>. Обычно для свойства <xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType> устанавливается курсор ожидания при заполнении <xref:System.Windows.Forms.ComboBox> или сохранении или загрузке файла.  
  
 Свойство <xref:System.Windows.Forms.Control.Cursor%2A> является внешним свойством. Внешнее свойство — это свойство элемента управления, которое, если оно не задано, извлекается из родительского элемента управления. Например, <xref:System.Windows.Forms.Button> будет иметь то же <xref:System.Windows.Forms.Control.BackColor%2A>, что и родительский <xref:System.Windows.Forms.Form> по умолчанию. Дополнительные сведения о внешних свойствах см. в описании класса <xref:System.Windows.Forms.AmbientProperties> или в обзоре класса <xref:System.Windows.Forms.Control>.  
  
   
  
## Examples  
 В следующем примере кода производится заполнение <xref:System.Windows.Forms.ComboBox> с помощью доступных логических дисков пользователя. В примере также задается свойство <xref:System.Windows.Forms.Cursor> поля со списком, поэтому курсор <xref:System.Windows.Forms.Cursors.Hand%2A?displayProperty=nameWithType> отображается, когда указатель мыши находится над кнопкой раскрывающегося списка. Этот код требует наличия <xref:System.Windows.Forms.Form> с <xref:System.Windows.Forms.ComboBox>.  
  
 [!code-cpp[Windows.Forms.Control Properties2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для безопасного подокна, чтобы задать значение этого свойства. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.Cursor" /> в производном классе используйте свойство базового класса <see cref="P:System.Windows.Forms.Control.Cursor" /> для расширения базовой реализации. В противном случае необходимо предоставить всю реализацию. Не требуется переопределять методы <see langword="get" /> и <see langword="set" /> свойства <see cref="P:System.Windows.Forms.Control.Cursor" />; При необходимости можно переопределить только один из них.</para></block>
        <altmember cref="T:System.Windows.Forms.Cursor" />
        <altmember cref="T:System.Windows.Forms.Cursors" />
      </Docs>
    </Member>
    <Member MemberName="CursorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CursorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CursorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CursorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CursorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CursorChanged;" />
      <MemberSignature Language="F#" Value="member this.CursorChanged : EventHandler " Usage="member this.CursorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.Cursor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.Cursor%2A> изменено программным изменением или взаимодействием с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано изменение курсора мыши с помощью свойства <xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType>, класса <xref:System.Windows.Forms.Cursor> и класса <xref:System.Windows.Forms.Cursors>. В примере создается форма, содержащая элемент управления <xref:System.Windows.Forms.ComboBox>, элемент управления <xref:System.Windows.Forms.Panel> и элемент управления @no__t 2. @No__t-0 содержит все курсоры, предоставляемые классом <xref:System.Windows.Forms.Cursors>. Когда пользователь выбирает курсор мыши в <xref:System.Windows.Forms.ComboBox>, свойству <xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType> присваивается выбранный курсор, который обновляет курсор для <xref:System.Windows.Forms.Panel>. @No__t-0 обновляется каждый раз при возникновении события <xref:System.Windows.Forms.Control.CursorChanged?displayProperty=nameWithType>.  
  
 [!code-cpp[System.Windows.Forms.Cursors#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CPP/cursorexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursors#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CS/cursorexample.cs#1)]
 [!code-vb[System.Windows.Forms.Cursors#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursors/VB/cursorexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Cursor" />
        <altmember cref="T:System.Windows.Forms.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="DataBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ControlBindingsCollection DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ControlBindingsCollection DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DataBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataBindings As ControlBindingsCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ControlBindingsCollection ^ DataBindings { System::Windows::Forms::ControlBindingsCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataBindings : System.Windows.Forms.ControlBindingsCollection" Usage="System.Windows.Forms.Control.DataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IBindableComponent.DataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlBindingsCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает привязки данных для элемента управления.</summary>
        <value>Коллекция <see cref="T:System.Windows.Forms.ControlBindingsCollection" />, содержащая объекты <see cref="T:System.Windows.Forms.Binding" /> для элемента управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить доступ к <xref:System.Windows.Forms.ControlBindingsCollection>, используйте свойство <xref:System.Windows.Forms.Control.DataBindings%2A>. Добавляя объекты <xref:System.Windows.Forms.Binding> в коллекцию, можно привязать любое свойство элемента управления к свойству объекта.  
  
   
  
## Examples  
 В следующем примере кода в <xref:System.Windows.Forms.ControlBindingsCollection> из пяти элементов управления добавляются объекты <xref:System.Windows.Forms.Binding>: четыре элемента управления <xref:System.Windows.Forms.TextBox> и элемент управления <xref:System.Windows.Forms.DateTimePicker>. Доступ к коллекции <xref:System.Windows.Forms.ControlBindingsCollection> осуществляется с помощью свойства <xref:System.Windows.Forms.Control.DataBindings%2A> класса <xref:System.Windows.Forms.Control>.  
  
 [!code-cpp[Classic Control.DataBindings Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.DataBindings Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CS/source.cs#1)]
 [!code-vb[Classic Control.DataBindings Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.DataBindings Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingContext" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBackColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultBackColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Color DefaultBackColor { System::Drawing::Color get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBackColor : System.Drawing.Color" Usage="System.Windows.Forms.Control.DefaultBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает используемый по умолчанию цвет фона элемента управления.</summary>
        <value>Используемый по умолчанию цвет фона <see cref="T:System.Drawing.Color" /> для элемента управления. Значение по умолчанию — <see cref="P:System.Drawing.SystemColors.Control" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение по умолчанию для свойства <xref:System.Windows.Forms.Control.BackColor%2A> универсального элемента управления верхнего уровня. Производные классы могут иметь разные значения по умолчанию.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать элементы <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A> и <xref:System.Windows.Forms.Control.DefaultForeColor%2A>. Чтобы выполнить пример, вставьте следующий код в форму, содержащую <xref:System.Windows.Forms.ListBox> с именем ListBox1. Вызовите метод `Populate_ListBox` в конструкторе формы или в методе обработки событий <xref:System.Windows.Forms.Form.Load>.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
        <altmember cref="T:System.Drawing.Color" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="DefaultCursor">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Cursor DefaultCursor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor DefaultCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultCursor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Cursor ^ DefaultCursor { System::Windows::Forms::Cursor ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCursor : System.Windows.Forms.Cursor" Usage="System.Windows.Forms.Control.DefaultCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает курсор по умолчанию для элемента управления.</summary>
        <value>Объект типа <see cref="T:System.Windows.Forms.Cursor" />, представляющий текущий курсор по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Переопределите <xref:System.Windows.Forms.Control.DefaultCursor%2A>, чтобы настроить курсор по умолчанию для элемента управления. Это более эффективно, чем Установка курсора в конструкторе элемента управления и обеспечивает автоматическую поддержку определенных функций конструктора, связанных с курсором.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultFont">
      <MemberSignature Language="C#" Value="public static System.Drawing.Font DefaultFont { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Drawing.Font DefaultFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultFont" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Font ^ DefaultFont { System::Drawing::Font ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultFont : System.Drawing.Font" Usage="System.Windows.Forms.Control.DefaultFont" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает шрифт элемента управления, используемый по умолчанию.</summary>
        <value><see cref="T:System.Drawing.Font" /> по умолчанию для элемента управления. Возвращаемое значение изменяется в зависимости от операционной системы пользователя, а также от языка и региональных параметров используемой системы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице описывается значение, возвращаемое <xref:System.Windows.Forms.Control.DefaultFont%2A> в зависимости от операционной системы и локального языка и региональных параметров.  
  
|Система, язык и региональные параметры|Шрифт|  
|----------------------------|----------|  
|Windows NT 4X, японская версия|MS UI Gothic, 9 Point.|  
|Арабские окна|Tahoma, 8 точек.|  
|Другая операционная система или язык и региональные параметры|Логический шрифт MS Shell Dlg, обычно это точка Microsoft San с засечек 8.|  
  
 MS Shell Dlg сопоставляется с набором шрифтов в системном реестре.  
  
 Если предыдущие шрифты не установлены, шрифт по умолчанию — Tahoma, 8 точек. Если Tahoma, 8 точек, не установлен, <xref:System.Windows.Forms.Control.DefaultFont%2A> возвращает значение свойства <xref:System.Drawing.FontFamily.GenericSansSerif%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать элементы <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A> и <xref:System.Windows.Forms.Control.DefaultForeColor%2A>. Чтобы выполнить пример, вставьте следующий код в форму, содержащую <xref:System.Windows.Forms.ListBox> с именем ListBox1. Вызовите метод `Populate_ListBox` в конструкторе формы или в методе обработки событий <xref:System.Windows.Forms.Form.Load>.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">На клиентском компьютере не установлен шрифт по умолчанию или другие шрифты, определяемые языком и региональными параметрами.</exception>
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="DefaultForeColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultForeColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Color DefaultForeColor { System::Drawing::Color get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultForeColor : System.Drawing.Color" Usage="System.Windows.Forms.Control.DefaultForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает цвет элемента управления, используемый по умолчанию.</summary>
        <value>Цвет переднего плана <see cref="T:System.Drawing.Color" /> для элемента управления. Значение по умолчанию — <see cref="P:System.Drawing.SystemColors.ControlText" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение свойства по умолчанию <xref:System.Windows.Forms.Control.ForeColor%2A> для неродительского элемента управления. Производные классы могут иметь разные значения по умолчанию.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать элементы <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, <xref:System.Windows.Forms.Control.DefaultFont%2A> и <xref:System.Windows.Forms.Control.DefaultForeColor%2A>. Чтобы выполнить пример, вставьте следующий код в форму, содержащую <xref:System.Windows.Forms.ListBox> с именем ListBox1. Вызовите метод `Populate_ListBox` в конструкторе формы или в методе обработки событий <xref:System.Windows.Forms.Form.Load>.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ForeColor" />
        <altmember cref="T:System.Drawing.Color" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode DefaultImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultImeMode : System.Windows.Forms.ImeMode" Usage="System.Windows.Forms.Control.DefaultImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает стандартный режим редактора методов ввода, поддерживаемый данным элементом управления.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Windows.Forms.ImeMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Редактор методов ввода (IME) — это программа, которая позволяет пользователям вводить сложные символы и символы, например японские символы кандзи, с помощью стандартной клавиатуры.  
  
 Как реализовано в классе <xref:System.Windows.Forms.Control>, это свойство всегда возвращает значение <xref:System.Windows.Forms.ImeMode.Inherit?displayProperty=nameWithType>. Значение <xref:System.Windows.Forms.ImeMode.Inherit> указывает, что режим IME наследуется от родительского элемента управления.  
  
   
  
## Examples  
 В следующем примере кода переопределяется свойство <xref:System.Windows.Forms.Control.DefaultImeMode%2A>, чтобы отключить редактор метода ввода.  
  
 [!code-cpp[Windows.Forms.Control Properties2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#4)]
 [!code-csharp[Windows.Forms.Control Properties2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#4)]
 [!code-vb[Windows.Forms.Control Properties2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.DefaultImeMode" /> в производном классе используйте свойство базового класса <see cref="P:System.Windows.Forms.Control.DefaultImeMode" /> для расширения базовой реализации. В противном случае необходимо предоставить всю реализацию.</para></block>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMargin">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultMargin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMargin" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMargin As Padding" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Padding DefaultMargin { System::Windows::Forms::Padding get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMargin : System.Windows.Forms.Padding" Usage="System.Windows.Forms.Control.DefaultMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает размер пустого пространства в пикселях между элементами управления, которое определено по умолчанию.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.Padding" />, который представляет заданное по умолчанию пустое пространство между элементами управления.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMaximumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMaximumSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultMaximumSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultMaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает длину и высоту в пикселях, которые были указаны в качестве максимального размера элемента управления.</summary>
        <value>Метод <see cref="M:System.Drawing.Point.#ctor(System.Drawing.Size)" />, представляющий размер элемента управления.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMinimumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMinimumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMinimumSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultMinimumSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMinimumSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultMinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает длину и высоту в пикселях, которые были указаны в качестве минимального размера элемента управления.</summary>
        <value>Метод <see cref="T:System.Drawing.Size" />, представляющий размер элемента управления.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPadding">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultPadding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultPadding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultPadding" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultPadding As Padding" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Padding DefaultPadding { System::Windows::Forms::Padding get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPadding : System.Windows.Forms.Padding" Usage="System.Windows.Forms.Control.DefaultPadding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает внутренние промежутки в содержимом элемента управления в пикселях.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.Padding" />, который представляет внутренние промежутки в содержимом элемента управления.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает размер элемента управления по умолчанию.</summary>
        <value><see cref="T:System.Drawing.Size" /> по умолчанию для элемента управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.DefaultSize%2A> представляет <xref:System.Drawing.Size> элемента управления при его первоначальном создании. Размер элемента управления можно изменить, задав его значение свойства <xref:System.Windows.Forms.Control.Size%2A>.  
  
> [!NOTE]
>  Чтобы обеспечить лучшую производительность, не устанавливайте <xref:System.Drawing.Size> элемента управления в конструкторе. Предпочтительным методом является переопределение свойства <xref:System.Windows.Forms.Control.DefaultSize%2A>.  
  
> [!NOTE]
>  В системах Windows Server 2003 размер <xref:System.Windows.Forms.Form> ограничен максимальным значением ширины и высотой в пикселях монитора.  
  
   
  
## Examples  
 В следующем примере кода переопределяется свойство <xref:System.Windows.Forms.Control.DefaultSize%2A>, а размер по умолчанию составляет 500 пикселей в виде квадрата.  
  
 [!code-cpp[Windows.Forms.Control Properties2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.DefaultSize" /> в производном классе предпочтительнее возвращать <see cref="T:System.Drawing.Size" /> с нужными размерами, а не переопределять всю реализацию.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="T:System.Drawing.Size" />
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected virtual void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DefWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DefWndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member DefWndProc : Message -&gt; unit&#xA;override this.DefWndProc : Message -&gt; unit" Usage="control.DefWndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Сообщение <see cref="T:System.Windows.Forms.Message" /> Windows для обработки.</param>
        <summary>Отправляет заданное сообщение процедуре окна, используемой по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке сообщений Windows см. в разделе [функция WindowProc](https://go.microsoft.com/fwlink/?LinkId=181565).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для непосредственного вызывающего объекта, чтобы вызвать неуправляемый код. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="DestroyHandle">
      <MemberSignature Language="C#" Value="protected virtual void DestroyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DestroyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DestroyHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DestroyHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DestroyHandle();" />
      <MemberSignature Language="F#" Value="abstract member DestroyHandle : unit -&gt; unit&#xA;override this.DestroyHandle : unit -&gt; unit" Usage="control.DestroyHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет дескриптор, связанный с элементом управления.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для непосредственного вызывающего объекта, чтобы вызвать неуправляемый код. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.Windows.Forms.Control.DestroyHandle" /> в производном классе обязательно вызовите метод <see cref="M:System.Windows.Forms.Control.DestroyHandle" /> базового класса, чтобы гарантировать уничтожение этого маркера.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="DeviceDpi">
      <MemberSignature Language="C#" Value="public int DeviceDpi { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DeviceDpi" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DeviceDpi" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeviceDpi As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DeviceDpi { int get(); };" />
      <MemberSignature Language="F#" Value="member this.DeviceDpi : int" Usage="System.Windows.Forms.Control.DeviceDpi" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение DPI для устройства, на котором сейчас отображается элемент управления.</summary>
        <value>Значение DPI устройства отображения.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayRectangle">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Rectangle DisplayRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DisplayRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DisplayRectangle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DisplayRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Rectangle DisplayRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.Control.DisplayRectangle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.Layout.IArrangedElement.DisplayRectangle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает прямоугольник, представляющий отображаемую область элемента управления.</summary>
        <value>Объект <see cref="T:System.Drawing.Rectangle" />, представляющий область отображения элемента управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.DisplayRectangle%2A> возвращает клиентский прямоугольник отображаемой области элемента управления. Для базового класса Control это значение равно клиентскому прямоугольнику. Однако наследование элементов управления может захотеть изменить, если их клиентская область отличается от отображаемой области. Отображаемый прямоугольник — это наименьший <xref:System.Drawing.Rectangle>, охватывающий элемент управления и используемый для размещения элементов управления.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.DisplayRectangle" /> в производном классе используйте свойство базового класса <see cref="P:System.Windows.Forms.Control.DisplayRectangle" /> для расширения базовой реализации. Кроме того, необходимо предоставить всю реализацию.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="control.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</param>
        <summary>Освобождает неуправляемые ресурсы, используемые объектом <see cref="T:System.Windows.Forms.Control" /> и его дочерними элементами управления (при необходимости освобождает и управляемые ресурсы).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается с помощью открытого метода `Dispose()` и метода <xref:System.Object.Finalize%2A>. `Dispose()` вызывает защищенный метод `Dispose(Boolean)` с параметром `disposing`, установленным в значение `true`. <xref:System.Object.Finalize%2A> вызывает `Dispose` с `disposing`, установленным в `false`.  
  
 Если параметр `disposing` имеет значение `true`, то данный метод освобождает все ресурсы, занятые любыми управляемыми объектами, на которые ссылается этот объект <xref:System.Windows.Forms.Control>. Этот метод вызывает метод `Dispose()` каждого объекта, на который есть ссылка.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Метод 
            <see langword="Dispose" /> может вызываться несколько раз другими объектами. При переопределении <see langword="Dispose(Boolean)" /> следует избегать ссылок на объекты, которые ранее были удалены в предыдущем вызове <see langword="Dispose" />. Дополнительные сведения о реализации <see langword="Dispose(Boolean)" /> см. в разделе [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Дополнительные сведения о <see langword="Dispose" /> и <see cref="M:System.Object.Finalize" /> см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [Переопределение метода Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Disposing">
      <MemberSignature Language="C#" Value="public bool Disposing { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Disposing" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Disposing" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Disposing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Disposing { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Disposing : bool" Usage="System.Windows.Forms.Control.Disposing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, находится ли базовый класс <see cref="T:System.Windows.Forms.Control" /> в процессе удаления.</summary>
        <value>Значение <see langword="true" />, если базовый класс <see cref="T:System.Windows.Forms.Control" /> находится в процессе удаления; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда это свойство возвращает `true`, базовый класс <xref:System.Windows.Forms.Control> находится в процессе удаления. После удаления элемента управления на него нельзя ссылаться как на допустимый элемент управления Windows. Хотя экземпляр элемента управления удаляется, он по-прежнему сохраняется в памяти до тех пор, пока он не будет удален из памяти с помощью сборки мусора. При удалении элемента управления невозможно вызвать его метод <xref:System.Windows.Forms.Control.RecreateHandle%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
        <altmember cref="T:System.GC" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="Dock">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.DockStyle Dock { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DockStyle Dock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Dock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Dock As DockStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::DockStyle Dock { System::Windows::Forms::DockStyle get(); void set(System::Windows::Forms::DockStyle value); };" />
      <MemberSignature Language="F#" Value="member this.Dock : System.Windows.Forms.DockStyle with get, set" Usage="System.Windows.Forms.Control.Dock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DockStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает границы элемента управления, прикрепленные к его родительскому элементу управления, и определяет способ изменения размеров элемента управления с его родительским элементом управления.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Windows.Forms.DockStyle" />. Значение по умолчанию — <see cref="F:System.Windows.Forms.DockStyle.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.Windows.Forms.Control.Dock%2A>, чтобы определить, как автоматически изменяется размер элемента управления при изменении размера родительского элемента управления. Например, установка <xref:System.Windows.Forms.Control.Dock%2A> в <xref:System.Windows.Forms.DockStyle.Left?displayProperty=nameWithType> приводит к тому, что элемент управления выровняйте себя по левому краю родительского элемента управления и изменять размер при изменении размера родительского элемента управления. Элементы управления закрепляются в Z-порядке, который является визуальным слоем элементов управления на форме вдоль оси Z формы (глубина).  
  
 Элемент управления можно закрепить на одной границе родительского контейнера или прикрепить ко всем краям и заполнить родительский контейнер.  
  
 Установка свойства <xref:System.Windows.Forms.Control.Margin%2A> для закрепленного элемента управления не влияет на расстояние элемента управления от границ контейнера.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Anchor%2A> И <xref:System.Windows.Forms.Control.Dock%2A> свойства являются взаимоисключающими. В каждый момент времени может быть задан только один, а последний набор имеет приоритет.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.GroupBox> и задаются некоторые общие свойства. В примере создается <xref:System.Windows.Forms.TextBox> и задается его <xref:System.Windows.Forms.Control.Location%2A> в поле группы. Затем задается свойство <xref:System.Windows.Forms.Control.Text%2A> поля группы и закрепляет поле группы в верхней части формы. Наконец, он отключает поле группы, присвоив свойству <xref:System.Windows.Forms.Control.Enabled%2A> значение `false`, что приводит к отключению всех элементов управления, содержащихся в поле группы.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Назначенное значение не является одном из значений <see cref="T:System.Windows.Forms.DockStyle" />.</exception>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.Dock" /> в производном классе используйте свойство базового класса <see cref="P:System.Windows.Forms.Control.Dock" /> для расширения базовой реализации. В противном случае необходимо предоставить всю реализацию. Не требуется переопределять методы <see langword="get" /> и <see langword="set" /> свойства <see cref="P:System.Windows.Forms.Control.Dock" />; При необходимости можно переопределить только один из них.</para></block>
        <altmember cref="T:System.Windows.Forms.DockStyle" />
        <altmember cref="P:System.Windows.Forms.Control.Anchor" />
        <altmember cref="T:System.Windows.Forms.ScrollableControl.DockPaddingEdges" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="DockChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DockChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DockChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DockChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DockChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DockChanged;" />
      <MemberSignature Language="F#" Value="member this.DockChanged : EventHandler " Usage="member this.DockChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.Dock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.Dock%2A> изменено программным изменением или взаимодействием с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Следующий пример кода является обработчиком событий, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени *PropertyName*`Changed`, которые вызываются при изменении соответствующего значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> с отображением денежных данных. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере требуется <xref:System.Windows.Forms.Form>, содержащий <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="T:System.Windows.Forms.DockStyle" />
      </Docs>
    </Member>
    <Member MemberName="DoDragDrop">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DragDropEffects DoDragDrop (object data, System.Windows.Forms.DragDropEffects allowedEffects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DragDropEffects DoDragDrop(object data, valuetype System.Windows.Forms.DragDropEffects allowedEffects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      <MemberSignature Language="VB.NET" Value="Public Function DoDragDrop (data As Object, allowedEffects As DragDropEffects) As DragDropEffects" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DragDropEffects DoDragDrop(System::Object ^ data, System::Windows::Forms::DragDropEffects allowedEffects);" />
      <MemberSignature Language="F#" Value="member this.DoDragDrop : obj * System.Windows.Forms.DragDropEffects -&gt; System.Windows.Forms.DragDropEffects" Usage="control.DoDragDrop (data, allowedEffects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragDropEffects</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="allowedEffects" Type="System.Windows.Forms.DragDropEffects" />
      </Parameters>
      <Docs>
        <param name="data">Перетаскиваемые данные.</param>
        <param name="allowedEffects">Одно из значений перечисления <see cref="T:System.Windows.Forms.DragDropEffects" />.</param>
        <summary>Начинает операцию перетаскивания.</summary>
        <returns>Значение перечисления <see cref="T:System.Windows.Forms.DragDropEffects" />, представляющее конечный результат выполнения операции перетаскивания.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `allowedEffects` определяет, какие операции перетаскивания могут быть выполнены. Если операция перетаскивания должна взаимодействовать с приложениями в другом процессе, то данные должны быть базовым управляемым классом (<xref:System.String>, <xref:System.Drawing.Bitmap> или <xref:System.Drawing.Imaging.Metafile>) или объектом, реализующим <xref:System.Runtime.Serialization.ISerializable> или <xref:System.Windows.Forms.IDataObject>.  
  
 Далее описывается, как и когда возникают события, связанные с операциями перетаскивания.  
  
 Метод <xref:System.Windows.Forms.Control.DoDragDrop%2A> определяет элемент управления под текущим местоположением курсора. Затем он проверяет, является ли элемент управления допустимым целевым объектом перетаскивания.  
  
 Если элемент управления является допустимым целевым объектом перетаскивания, то событие <xref:System.Windows.Forms.Control.GiveFeedback> вызывается с указанными действиями перетаскивания. Список эффектов перетаскивания см. в перечислении <xref:System.Windows.Forms.DragDropEffects>.  
  
 Отслеживаются изменения позиции указателя мыши, состояния клавиатуры и кнопки мыши.  
  
-   Если пользователь перемещает указатель мыши за пределы окна, происходит событие <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Если указатель мыши перемещается на другой элемент управления, для этого элемента вызывается событие <xref:System.Windows.Forms.Control.DragEnter>.  
  
-   При перемещении мыши в пределах одного элемента управления возникает событие <xref:System.Windows.Forms.Control.DragOver>.  
  
 При изменении состояния клавиатуры или кнопки мыши возникает событие <xref:System.Windows.Forms.Control.QueryContinueDrag> и определяет, следует ли продолжить перетаскивание, для удаления данных или отмены операции на основе значения свойства <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> события <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Continue`, возникает событие <xref:System.Windows.Forms.Control.DragOver> для продолжения операции, а событие <xref:System.Windows.Forms.Control.GiveFeedback> вызывается с новым действием, чтобы можно было установить соответствующую визуальную обратную связь. Список допустимых эффектов сброса см. в перечислении <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  События <xref:System.Windows.Forms.Control.DragOver> и <xref:System.Windows.Forms.Control.GiveFeedback> сопряжены таким образом, что при перемещении мыши по направлению перетаскивания пользователь получает наиболее актуальную информацию о положении мыши.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Drop`, то значение результата перетаскивания возвращается в источник, поэтому исходное приложение может выполнить соответствующую операцию с исходными данными. Например, если операция была перемещена, вырежьте данные.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Cancel`, возникает событие <xref:System.Windows.Forms.Control.DragLeave>.  
  
> [!NOTE]
>  Метод <xref:System.Windows.Forms.Control.DoDragDrop%2A> перехватывает все исключения и повторно создает только следующие исключения безопасности или критические.  
  
-   SecurityException  
  
-   NullReferenceException  
  
-   StackOverflowException  
  
-   OutOfMemoryException  
  
-   ThreadAbortException  
  
-   ExecutionEngineException  
  
-   IndexOutOfRangeException  
  
-   AccessViolationException  
  
   
  
## Examples  
 В следующем примере кода демонстрируется операция перетаскивания между двумя элементами управления <xref:System.Windows.Forms.ListBox>. В примере вызывается метод <xref:System.Windows.Forms.Control.DoDragDrop%2A>, когда начинается действие перетаскивания. Действие перетаскивания начинается, если мышь переместила больше <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> из положения мыши во время события <xref:System.Windows.Forms.Control.MouseDown>. Метод <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> используется для определения индекса элемента, перетаскиваемого во время события `MouseDown`.  
  
 В примере также демонстрируется использование пользовательских курсоров для операции перетаскивания. Для этого примера требуются два файла курсора (`3dwarro.cur` и `3dwno.cur`) в каталоге приложения для настраиваемых курсоров перетаскивания и без перетаскивания соответственно. Пользовательские курсоры будут использоваться, если установлен флажок `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox>. Пользовательские курсоры задаются в обработчике событий <xref:System.Windows.Forms.Control.GiveFeedback>.  
  
 Состояние клавиатуры вычисляется в обработчике событий <xref:System.Windows.Forms.Control.DragOver> справа `ListBox`, чтобы определить, какая операция перетаскивания будет основываться на состоянии клавиш SHIFT, CTRL, ALT или CTRL + ALT. Расположение в `ListBox`, где происходит удаление, также определяется во время события `DragOver`. Если данные для удаления не являются `String`, <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> устанавливается в значение `None` в <xref:System.Windows.Forms.DragDropEffects>. Наконец, состояние удаления отображается в `DropLocationLabel` <xref:System.Windows.Forms.Label>.  
  
 Данные, которые нужно удалить справа `ListBox`, определяются в обработчике событий <xref:System.Windows.Forms.Control.DragDrop>, а значение `String` добавляется в соответствующее место `ListBox`. Если операция перетаскивания выходит за границы формы, операция перетаскивания отменяется в обработчике событий <xref:System.Windows.Forms.Control.QueryContinueDrag>.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#1)]  
  
 В следующем примере кода показано использование перечисления <xref:System.Windows.Forms.DragDropEffects> для указания способа передачи данных между элементами управления, вовлеченными в операцию перетаскивания. В этом примере предполагается, что форма содержит элемент управления <xref:System.Windows.Forms.RichTextBox> и элемент управления <xref:System.Windows.Forms.ListBox>, а элемент управления <xref:System.Windows.Forms.ListBox> заполняется списком допустимых имен файлов. Когда пользователь перетаскивает имя файла на элемент управления <xref:System.Windows.Forms.RichTextBox>, возникает событие <xref:System.Windows.Forms.Control.DragEnter> элемента управления. В обработчике событий свойство <xref:System.Windows.Forms.DragEventArgs.Effect%2A> <xref:System.Windows.Forms.DragEventArgs> инициализируется значением <xref:System.Windows.Forms.DragDropEffects>, чтобы указать, что данные, на которые ссылается путь к файлу, должны быть скопированы в элемент управления <xref:System.Windows.Forms.RichTextBox>.  
  
 [!code-cpp[RichTextDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextDragDrop/CS/form1.cs#1)]
 [!code-vb[RichTextDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextDragDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AllowDrop" />
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
      </Docs>
    </Member>
    <Member MemberName="DoubleBuffered">
      <MemberSignature Language="C#" Value="protected virtual bool DoubleBuffered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DoubleBuffered" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DoubleBuffered" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property DoubleBuffered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool DoubleBuffered { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DoubleBuffered : bool with get, set" Usage="System.Windows.Forms.Control.DoubleBuffered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, должна ли поверхность этого элемента управления перерисовываться с помощью дополнительного буфера, чтобы уменьшить или предотвратить мерцание.</summary>
        <value>Значение <see langword="true" />, если поверхность элемента управления должна перерисовываться с помощью двойной буферизации; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Буферизация графики может уменьшить или устранить мерцание, вызванное последовательной перерисовкой частей отображаемой поверхности. Буферизация графики требует, чтобы обновленные графические данные сначала записывались в буфер. Затем данные в графическом буфере быстро записываются в отображаемую память поверхности. Относительно быстрое переключение отображаемой графической памяти обычно сокращает мерцание, которое в противном случае может произойти.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.DoubleBuffered%2A> не является связываемым свойством.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.BufferedGraphics" />
        <altmember cref="T:System.Drawing.BufferedGraphicsContext" />
        <altmember cref="T:System.Drawing.BufferedGraphicsManager" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer" />
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event EventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DoubleClick;" />
      <MemberSignature Language="F#" Value="member this.DoubleClick : EventHandler " Usage="member this.DoubleClick : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при двойном щелчке элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Двойной щелчок определяется параметрами мыши операционной системы пользователя. Пользователь может задать время между нажатиями кнопки мыши, которые будут считаться двойным щелчком, а не двумя отдельными щелчками. Событие <xref:System.Windows.Forms.Control.Click> возникает каждый раз при двойном щелчке элемента управления. Например, если у вас есть обработчики событий для событий <xref:System.Windows.Forms.Control.Click> и <xref:System.Windows.Forms.Control.DoubleClick> для <xref:System.Windows.Forms.Form>, события <xref:System.Windows.Forms.Control.Click> и <xref:System.Windows.Forms.Control.DoubleClick> возникают при двойном щелчке формы и вызове обоих методов. Если дважды щелкнуть элемент управления и этот элемент управления не поддерживает событие <xref:System.Windows.Forms.Control.DoubleClick>, событие <xref:System.Windows.Forms.Control.Click> может быть вызвано дважды.  
  
 Чтобы это событие было создано, необходимо установить значения `StandardDoubleClick` и `StandardClick` для <xref:System.Windows.Forms.ControlStyles> в `true`. Возможно, для этих значений уже задано значение `true`, если вы наследуете от существующих элементов управления Windows Forms.  
  
> [!NOTE]
>  Следующие события не вызываются для класса <xref:System.Windows.Forms.TabControl>, если в коллекции <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> не существует хотя бы один <xref:System.Windows.Forms.TabPage>: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> и 0. Если в коллекции имеется хотя бы один <xref:System.Windows.Forms.TabPage>, и пользователь взаимодействует с заголовком элемента управления вкладки (где отображаются имена <xref:System.Windows.Forms.TabPage>), <xref:System.Windows.Forms.TabControl> вызывает соответствующее событие. Однако если взаимодействие с пользователем происходит в клиентской области страницы вкладки, <xref:System.Windows.Forms.TabPage> вызывает соответствующее событие.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода используется событие <xref:System.Windows.Forms.Control.DoubleClick> <xref:System.Windows.Forms.ListBox> для загрузки текстовых файлов, перечисленных в <xref:System.Windows.Forms.ListBox>, в элемент управления <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Наследование от стандартного элемента управления Windows Forms и изменение значений <see langword="StandardClick" /> или <see langword="StandardDoubleClick" /> <see cref="T:System.Windows.Forms.ControlStyles" /> на <see langword="true" /> может привести к непредвиденному поведению или не иметь никакого влияния на все, если элемент управления не поддерживает события <see cref="E:System.Windows.Forms.Control.Click" /> или <see cref="E:System.Windows.Forms.Control.DoubleClick" />.  
  
В следующей таблице перечислены Windows Formsные элементы управления и события (<see cref="E:System.Windows.Forms.Control.Click" /> или <see cref="E:System.Windows.Forms.Control.DoubleClick" />), создаваемые в ответ на указанное действие мыши.  
  
 <list type="table"><listheader><term> Элемент управления 
 </term><description> Щелчок левой кнопкой мыши 
 </description><description> Двойной щелчок левой кнопкой мыши 
 </description><description> Щелчок правой кнопкой мыши 
 </description><description> Двойной щелчок правой кнопкой мыши 
 </description><description> Щелчок средней кнопкой мыши 
 </description><description> Двойной щелчок средней кнопкой мыши 
 </description><description> Щелчок мыши XButton1 
 </description><description> Двойной щелчок по XButton1 мыши 
 </description><description> Щелчок мыши XButton2 
 </description><description> Двойной щелчок по XButton2 мыши 
 </description></listheader><item><term><see cref="T:System.Windows.Forms.MonthCalendar" />, 
 <see cref="T:System.Windows.Forms.DateTimePicker" />, 
 <see cref="T:System.Windows.Forms.RichTextBox" />, 
 <see cref="T:System.Windows.Forms.HScrollBar" />, 
 <see cref="T:System.Windows.Forms.VScrollBar" /></term><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description></item><item><term><see cref="T:System.Windows.Forms.Button" />, 
 <see cref="T:System.Windows.Forms.CheckBox" />, 
 <see cref="T:System.Windows.Forms.RadioButton" /></term><description> Нажмите кнопку 
 </description><description> Щелкните, щелкните 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description></item><item><term><see cref="T:System.Windows.Forms.ListBox" />, 
 <see cref="T:System.Windows.Forms.CheckedListBox" />, 
 <see cref="T:System.Windows.Forms.ComboBox" /></term><description> Нажмите кнопку 
 </description><description> Щелкните, DoubleClick 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description></item><item><term><see cref="T:System.Windows.Forms.TextBox" />, 
 <see cref="T:System.Windows.Forms.DomainUpDown" />, 
 <see cref="T:System.Windows.Forms.NumericUpDown" /></term><description> Нажмите кнопку 
 </description><description> Щелкните, DoubleClick 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description></item><item><term> *  @ no__t-1, 
\* <see cref="T:System.Windows.Forms.ListView" /></term><description> Нажмите кнопку 
 </description><description> Щелкните, DoubleClick 
 </description><description> Нажмите кнопку 
 </description><description> Щелкните, DoubleClick 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description><description> Нет 
 </description></item><item><term><see cref="T:System.Windows.Forms.ProgressBar" />, 
 <see cref="T:System.Windows.Forms.TrackBar" /></term><description> Нажмите кнопку 
 </description><description> Щелкните, щелкните 
 </description><description> Нажмите кнопку 
 </description><description> Щелкните, щелкните 
 </description><description> Нажмите кнопку 
 </description><description> Щелкните, щелкните 
 </description><description> Нажмите кнопку 
 </description><description> Щелкните, щелкните 
 </description><description> Нажмите кнопку 
 </description><description> Щелкните, щелкните 
 </description></item><item><term><see cref="T:System.Windows.Forms.Form" />, 
 <see cref="T:System.Windows.Forms.DataGrid" />, 
 <see cref="T:System.Windows.Forms.Label" />, 
 <see cref="T:System.Windows.Forms.LinkLabel" />, 
 <see cref="T:System.Windows.Forms.Panel" />, 
 <see cref="T:System.Windows.Forms.GroupBox" />, 
 <see cref="T:System.Windows.Forms.PictureBox" />, 
 <see cref="T:System.Windows.Forms.Splitter" />, 
 <see cref="T:System.Windows.Forms.StatusBar" />, 
 <see cref="T:System.Windows.Forms.ToolBar" />, 
 <see cref="T:System.Windows.Forms.TabPage" />, 
 ** <see cref="T:System.Windows.Forms.TabControl" /></term><description> Нажмите кнопку 
 </description><description> Щелкните, DoubleClick 
 </description><description> Нажмите кнопку 
 </description><description> Щелкните, DoubleClick 
 </description><description> Нажмите кнопку 
 </description><description> Щелкните, DoubleClick 
 </description><description> Нажмите кнопку 
 </description><description> Щелкните, DoubleClick 
 </description><description> Нажмите кнопку 
 </description><description> Щелкните, DoubleClick 
 </description></item></list>  

 \* указатель мыши должен находиться над дочерним объектом (<see cref="T:System.Windows.Forms.TreeNode" /> или <see cref="T:System.Windows.Forms.ListViewItem" />).  
  
* * @No__t-0 должен иметь хотя бы один <see cref="T:System.Windows.Forms.TabPage" /> в своей коллекции <see cref="P:System.Windows.Forms.TabControl.TabPages" />.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardClick" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardDoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="DpiChangedAfterParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedAfterParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedAfterParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedAfterParent" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChangedAfterParent As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DpiChangedAfterParent;" />
      <MemberSignature Language="F#" Value="member this.DpiChangedAfterParent : EventHandler " Usage="member this.DpiChangedAfterParent : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает, когда настройка DPI для элемента управления изменяется программным образом после изменения DPI связанного родительского элемента управления или формы.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedBeforeParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedBeforeParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedBeforeParent" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChangedBeforeParent As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DpiChangedBeforeParent;" />
      <MemberSignature Language="F#" Value="member this.DpiChangedBeforeParent : EventHandler " Usage="member this.DpiChangedBeforeParent : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает, когда настройка DPI для элемента управления изменяется программным образом, прежде чем возникает событие изменения DPI для соответствующего родительского элемента управления или формы.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragDrop;" />
      <MemberSignature Language="F#" Value="member this.DragDrop : System.Windows.Forms.DragEventHandler " Usage="member this.DragDrop : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывается при завершении операции перетаскивания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства <xref:System.Windows.Forms.DragEventArgs.X%2A> и <xref:System.Windows.Forms.DragEventArgs.Y%2A> <xref:System.Windows.Forms.DragEventArgs> находятся в экранных координатах, а не на клиентских координатах. Следующая строка визуального C# кода преобразует свойства в клиент <xref:System.Drawing.Point>.  
  
```  
Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
```  
  
> [!NOTE]
>  В версиях более ранних, чем [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], если поместить <xref:System.Windows.Forms.UserControl> с событиями <xref:System.Windows.Forms.Control.DragEnter> и <xref:System.Windows.Forms.Control.DragDrop> в форме Windows Forms и перетащить что-то на <xref:System.Windows.Forms.UserControl> во время разработки, будут вызваны события `DropDrop` и `DropEnter`. Однако при закрытии и повторном открытии решения события <xref:System.Windows.Forms.Control.DragEnter> и <xref:System.Windows.Forms.Control.DragDrop> снова не вызываются.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Этот фрагмент кода демонстрирует использование события <xref:System.Windows.Forms.Control.DragDrop>. Полный пример кода см. в описании метода <xref:System.Windows.Forms.Control.DoDragDrop%2A>.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#5)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#5)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
        <altmember cref="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
        <altmember cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.Forms.DragEventHandler " Usage="member this.DragEnter : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда объект перетаскивается в границы элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие <xref:System.Windows.Forms.Control.DragEnter> возникает, когда пользователь сначала перетаскивает курсор мыши над элементом управления во время операции перетаскивания.  
  
> [!NOTE]
>  В версиях более ранних, чем [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], если поместить <xref:System.Windows.Forms.UserControl> с событиями <xref:System.Windows.Forms.Control.DragEnter> и <xref:System.Windows.Forms.Control.DragDrop> в форме Windows Forms и перетащить что-то на <xref:System.Windows.Forms.UserControl> во время разработки, будут вызваны события `DropDrop` и `DropEnter`. Однако при закрытии и повторном открытии решения события <xref:System.Windows.Forms.Control.DragEnter> и <xref:System.Windows.Forms.Control.DragDrop> снова не вызываются.  
  
 Далее описывается, как и когда возникают события, связанные с операциями перетаскивания.  
  
 Метод <xref:System.Windows.Forms.Control.DoDragDrop%2A> определяет элемент управления под текущим местоположением курсора. Затем он проверяет, является ли элемент управления допустимым целевым объектом перетаскивания.  
  
 Если элемент управления является допустимым целевым объектом перетаскивания, то событие <xref:System.Windows.Forms.Control.GiveFeedback> вызывается с указанными действиями перетаскивания. Список эффектов перетаскивания см. в перечислении <xref:System.Windows.Forms.DragDropEffects>.  
  
 Отслеживаются изменения позиции указателя мыши, состояния клавиатуры и кнопки мыши.  
  
-   Если пользователь перемещает указатель мыши за пределы окна, происходит событие <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Если указатель мыши перемещается на другой элемент управления, для этого элемента вызывается событие <xref:System.Windows.Forms.Control.DragEnter>.  
  
-   При перемещении мыши в пределах одного элемента управления возникает событие <xref:System.Windows.Forms.Control.DragOver>.  
  
 При изменении состояния клавиатуры или кнопки мыши возникает событие <xref:System.Windows.Forms.Control.QueryContinueDrag> и определяет, следует ли продолжить перетаскивание, для удаления данных или отмены операции на основе значения свойства <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> события <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Continue`, возникает событие <xref:System.Windows.Forms.Control.DragOver> для продолжения операции, а событие <xref:System.Windows.Forms.Control.GiveFeedback> вызывается с новым действием, чтобы можно было установить соответствующую визуальную обратную связь. Список допустимых эффектов сброса см. в перечислении <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  События <xref:System.Windows.Forms.Control.DragOver> и <xref:System.Windows.Forms.Control.GiveFeedback> сопряжены таким образом, что при перемещении мыши по направлению перетаскивания пользователь получает наиболее актуальную информацию о положении мыши.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Drop`, то значение результата перетаскивания возвращается в источник, поэтому исходное приложение может выполнить соответствующую операцию с исходными данными. Например, если операция была перемещена, вырежьте данные.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Cancel`, возникает событие <xref:System.Windows.Forms.Control.DragLeave>.  
  
    > [!NOTE]
    >  Свойства <xref:System.Windows.Forms.DragEventArgs.X%2A> и <xref:System.Windows.Forms.DragEventArgs.Y%2A> <xref:System.Windows.Forms.DragEventArgs> находятся в экранных координатах, а не на клиентских координатах. Следующая строка визуального C# кода преобразует свойства в клиент <xref:System.Drawing.Point>.  
  
    ```  
    Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
    ```  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется операция перетаскивания между двумя элементами управления <xref:System.Windows.Forms.ListBox>. В примере вызывается метод <xref:System.Windows.Forms.Control.DoDragDrop%2A>, когда начинается действие перетаскивания. Действие перетаскивания начинается, если мышь переместила больше <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> из положения мыши во время события <xref:System.Windows.Forms.Control.MouseDown>. Метод <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> используется для определения индекса элемента, перетаскиваемого во время события `MouseDown`.  
  
 В примере также демонстрируется использование пользовательских курсоров для операции перетаскивания. Для этого примера требуются два файла курсора (`3dwarro.cur` и `3dwno.cur`) в каталоге приложения для настраиваемых курсоров перетаскивания и без перетаскивания соответственно. Пользовательские курсоры будут использоваться, если установлен флажок `UseCustomCursorsCheck` @ no__t-1. Пользовательские курсоры задаются в обработчике событий <xref:System.Windows.Forms.Control.GiveFeedback>.  
  
 Состояние клавиатуры вычисляется в обработчике событий <xref:System.Windows.Forms.Control.DragOver> справа `ListBox`, чтобы определить, какая операция перетаскивания будет основываться на состоянии клавиш SHIFT, CTRL, ALT или CTRL + ALT. Расположение в `ListBox`, где происходит удаление, также определяется во время события `DragOver`. Если данные для удаления не являются `String`, <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> устанавливается в значение `None` в <xref:System.Windows.Forms.DragDropEffects>. Наконец, состояние удаления отображается в `DropLocationLabel` @ no__t-1.  
  
 Данные, которые нужно удалить справа `ListBox`, определяются в обработчике событий <xref:System.Windows.Forms.Control.DragDrop>, а значение `String` добавляется в соответствующее место `ListBox`. Если операция перетаскивания выходит за границы формы, операция перетаскивания отменяется в обработчике событий <xref:System.Windows.Forms.Control.QueryContinueDrag>.  
  
 Этот фрагмент кода демонстрирует использование события <xref:System.Windows.Forms.Control.DragEnter>. Полный пример кода см. в описании метода <xref:System.Windows.Forms.Control.DoDragDrop%2A>.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : EventHandler " Usage="member this.DragLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывается, когда объект перетаскивается за пределы элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие <xref:System.Windows.Forms.Control.DragLeave> возникает, когда пользователь перетаскивает указатель мыши за пределы элемента управления или пользователь отменяет текущую операцию перетаскивания.  
  
 Далее описывается, как и когда возникают события, связанные с операциями перетаскивания.  
  
 Метод <xref:System.Windows.Forms.Control.DoDragDrop%2A> определяет элемент управления под текущим местоположением курсора. Затем он проверяет, является ли элемент управления допустимым целевым объектом перетаскивания.  
  
 Если элемент управления является допустимым целевым объектом перетаскивания, то событие <xref:System.Windows.Forms.Control.GiveFeedback> вызывается с указанными действиями перетаскивания. Список эффектов перетаскивания см. в перечислении <xref:System.Windows.Forms.DragDropEffects>.  
  
 Отслеживаются изменения позиции указателя мыши, состояния клавиатуры и кнопки мыши.  
  
-   Если пользователь перемещает указатель мыши за пределы окна, происходит событие <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Если указатель мыши перемещается на другой элемент управления, для этого элемента вызывается событие <xref:System.Windows.Forms.Control.DragEnter>.  
  
-   При перемещении мыши в пределах одного элемента управления возникает событие <xref:System.Windows.Forms.Control.DragOver>.  
  
 При изменении состояния клавиатуры или кнопки мыши возникает событие <xref:System.Windows.Forms.Control.QueryContinueDrag> и определяет, следует ли продолжить перетаскивание, для удаления данных или отмены операции на основе значения свойства <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> события <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Continue`, возникает событие <xref:System.Windows.Forms.Control.DragOver> для продолжения операции, а событие <xref:System.Windows.Forms.Control.GiveFeedback> вызывается с новым действием, чтобы можно было установить соответствующую визуальную обратную связь. Список допустимых эффектов сброса см. в перечислении <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  События <xref:System.Windows.Forms.Control.DragOver> и <xref:System.Windows.Forms.Control.GiveFeedback> сопряжены таким образом, что при перемещении мыши по направлению перетаскивания пользователь получает наиболее актуальную информацию о положении мыши.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Drop`, то значение результата перетаскивания возвращается в источник, поэтому исходное приложение может выполнить соответствующую операцию с исходными данными. Например, если операция была перемещена, вырежьте данные.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Cancel`, возникает событие <xref:System.Windows.Forms.Control.DragLeave>.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется операция перетаскивания между двумя элементами управления <xref:System.Windows.Forms.ListBox>. В примере вызывается метод <xref:System.Windows.Forms.Control.DoDragDrop%2A>, когда начинается действие перетаскивания. Действие перетаскивания начинается, если мышь переместила больше <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> из положения мыши во время события <xref:System.Windows.Forms.Control.MouseDown>. Метод <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> используется для определения индекса элемента, перетаскиваемого во время события `MouseDown`.  
  
 В примере также демонстрируется использование пользовательских курсоров для операции перетаскивания. Для этого примера требуются два файла курсора (`3dwarro.cur` и `3dwno.cur`) в каталоге приложения для настраиваемых курсоров перетаскивания и без перетаскивания соответственно. Пользовательские курсоры будут использоваться, если установлен флажок `UseCustomCursorsCheck` @ no__t-1. Пользовательские курсоры задаются в обработчике событий <xref:System.Windows.Forms.Control.GiveFeedback>.  
  
 Состояние клавиатуры вычисляется в обработчике событий <xref:System.Windows.Forms.Control.DragOver> справа `ListBox`, чтобы определить, какая операция перетаскивания будет основываться на состоянии клавиш SHIFT, CTRL, ALT или CTRL + ALT. Расположение в `ListBox`, где происходит удаление, также определяется во время события `DragOver`. Если данные для удаления не являются `String`, <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> устанавливается в значение `None` в <xref:System.Windows.Forms.DragDropEffects>. Наконец, состояние удаления отображается в `DropLocationLabel` @ no__t-1.  
  
 Данные, которые нужно удалить справа `ListBox`, определяются в обработчике событий <xref:System.Windows.Forms.Control.DragDrop>, а значение `String` добавляется в соответствующее место `ListBox`. Если операция перетаскивания выходит за границы формы, операция перетаскивания отменяется в обработчике событий <xref:System.Windows.Forms.Control.QueryContinueDrag>.  
  
 Этот фрагмент кода демонстрирует использование события <xref:System.Windows.Forms.Control.DragLeave>. Полный пример кода см. в описании метода <xref:System.Windows.Forms.Control.DoDragDrop%2A>.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#8)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#8)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.DragEventHandler " Usage="member this.DragOver : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда объект перетаскивается через границу элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие <xref:System.Windows.Forms.Control.DragOver> возникает, когда курсор мыши перемещается внутри границ элемента управления во время операции перетаскивания.  
  
 Далее описывается, как и когда возникают события, связанные с операциями перетаскивания.  
  
 Метод <xref:System.Windows.Forms.Control.DoDragDrop%2A> определяет элемент управления под текущим местоположением курсора. Затем он проверяет, является ли элемент управления допустимым целевым объектом перетаскивания.  
  
 Если элемент управления является допустимым целевым объектом перетаскивания, то событие <xref:System.Windows.Forms.Control.GiveFeedback> вызывается с указанными действиями перетаскивания. Список эффектов перетаскивания см. в перечислении <xref:System.Windows.Forms.DragDropEffects>.  
  
 Отслеживаются изменения позиции указателя мыши, состояния клавиатуры и кнопки мыши.  
  
-   Если пользователь перемещает указатель мыши за пределы окна, происходит событие <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Если указатель мыши перемещается на другой элемент управления, для этого элемента вызывается событие <xref:System.Windows.Forms.Control.DragEnter>.  
  
-   При перемещении мыши в пределах одного элемента управления возникает событие <xref:System.Windows.Forms.Control.DragOver>.  
  
 При изменении состояния клавиатуры или кнопки мыши возникает событие <xref:System.Windows.Forms.Control.QueryContinueDrag> и определяет, следует ли продолжить перетаскивание, для удаления данных или отмены операции на основе значения свойства <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> события <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Continue`, возникает событие <xref:System.Windows.Forms.Control.DragOver> для продолжения операции, а событие <xref:System.Windows.Forms.Control.GiveFeedback> вызывается с новым действием, чтобы можно было установить соответствующую визуальную обратную связь. Список допустимых эффектов сброса см. в перечислении <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  События <xref:System.Windows.Forms.Control.DragOver> и <xref:System.Windows.Forms.Control.GiveFeedback> сопряжены таким образом, что при перемещении мыши по направлению перетаскивания пользователь получает наиболее актуальную информацию о положении мыши.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Drop`, то значение результата перетаскивания возвращается в источник, поэтому исходное приложение может выполнить соответствующую операцию с исходными данными. Например, если операция была перемещена, вырежьте данные.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Cancel`, возникает событие <xref:System.Windows.Forms.Control.DragLeave>.  
  
    > [!NOTE]
    >  Свойства <xref:System.Windows.Forms.DragEventArgs.X%2A> и <xref:System.Windows.Forms.DragEventArgs.Y%2A> <xref:System.Windows.Forms.DragEventArgs> находятся в экранных координатах, а не на клиентских координатах. Следующая строка C# кода преобразует свойства в клиент <xref:System.Drawing.Point>:  
    >   
    >  Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется операция перетаскивания между двумя элементами управления <xref:System.Windows.Forms.ListBox>. В примере вызывается метод <xref:System.Windows.Forms.Control.DoDragDrop%2A>, когда начинается действие перетаскивания. Действие перетаскивания начинается, если мышь переместила больше <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> из положения мыши во время события <xref:System.Windows.Forms.Control.MouseDown>. Метод <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> используется для определения индекса элемента, перетаскиваемого во время события `MouseDown`.  
  
 В примере также демонстрируется использование пользовательских курсоров для операции перетаскивания. Для этого примера требуются два файла курсора (`3dwarro.cur` и `3dwno.cur`) в каталоге приложения для настраиваемых курсоров перетаскивания и без перетаскивания соответственно. Пользовательские курсоры будут использоваться, если установлен флажок `UseCustomCursorsCheck` @ no__t-1. Пользовательские курсоры задаются в обработчике событий <xref:System.Windows.Forms.Control.GiveFeedback>.  
  
 Состояние клавиатуры вычисляется в обработчике событий <xref:System.Windows.Forms.Control.DragOver> справа `ListBox`, чтобы определить, какая операция перетаскивания будет основываться на состоянии клавиш SHIFT, CTRL, ALT или CTRL + ALT. Расположение в `ListBox`, где происходит удаление, также определяется во время события `DragOver`. Если данные для удаления не являются `String`, <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> устанавливается в значение `None` в <xref:System.Windows.Forms.DragDropEffects>. Наконец, состояние удаления отображается в `DropLocationLabel` @ no__t-1.  
  
 Данные, которые нужно удалить справа `ListBox`, определяются в обработчике событий <xref:System.Windows.Forms.Control.DragDrop>, а значение `String` добавляется в соответствующее место `ListBox`. Если операция перетаскивания выходит за границы формы, операция перетаскивания отменяется в обработчике событий <xref:System.Windows.Forms.Control.QueryContinueDrag>.  
  
 Этот фрагмент кода демонстрирует использование события <xref:System.Windows.Forms.Control.DragOver>. Полный пример кода см. в описании метода <xref:System.Windows.Forms.Control.DoDragDrop%2A>.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#4)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#4)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawToBitmap(System::Drawing::Bitmap ^ bitmap, System::Drawing::Rectangle targetBounds);" />
      <MemberSignature Language="F#" Value="member this.DrawToBitmap : System.Drawing.Bitmap * System.Drawing.Rectangle -&gt; unit" Usage="control.DrawToBitmap (bitmap, targetBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="bitmap">Точечный рисунок, который требуется нарисовать.</param>
        <param name="targetBounds">Границы, в которых выполняется отрисовка элемента управления.</param>
        <summary>Поддерживает отрисовку в указанном точечном рисунке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Forms.Control.DrawToBitmap%2A> не поддерживается для элементов управления ActiveX. Можно переопределить событие <xref:System.Windows.Forms.Control.OnPrint%2A> и при необходимости предоставить настраиваемую логику печати.  
  
 Метод <xref:System.Windows.Forms.Control.DrawToBitmap%2A> имеет следующие ограничения.  
  
-   Для больших точечных рисунков может быть создано <xref:System.ArgumentException>. Максимально допустимый размер зависит от компьютера.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> не поддерживает элементы управления `Ink` для операционной системы Windows XP Tablet PC Edition 2005.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> не рисует дочерний <xref:System.Windows.Forms.TextBox>, если для свойства <xref:System.Windows.Forms.Control.Visible%2A> объекта <xref:System.Windows.Forms.TextBox> задано значение `false`.  
  
-   Элементы управления внутри контейнеров подготавливаются к просмотру в обратном порядке.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> не полностью функционирует для <xref:System.Windows.Forms.RichTextBox>; рисуется только граница точечного рисунка.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.Control.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-514)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, может ли элемент управления отвечать на действия пользователя.</summary>
        <value>Значение <see langword="true" />, если элемент управления может отвечать на действия пользователя; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.Enabled%2A> позволяет включать или отключать элементы управления во время выполнения. Например, можно отключить элементы управления, которые не применяются к текущему состоянию приложения. Можно также отключить элемент управления, чтобы ограничить его использование. Например, кнопка может быть отключена, чтобы пользователь не мог ее щелкнуть. Если элемент управления отключен, он не может быть выбран.  
  
> [!IMPORTANT]
>  Если задать для свойства <xref:System.Windows.Forms.Control.Enabled%2A> значение `false`, окно управления приложения не будет отключено или окно приложения не сможет получать фокус.  
  
 Если свойство Enabled элемента управления контейнера имеет значение `false`, все содержащиеся в нем элементы управления также отключаются. Например, если пользователь щелкнет какие-либо элементы управления, содержащиеся в отключенном элементе управления <xref:System.Windows.Forms.GroupBox>, события не создаются.  
  
> [!NOTE]
>  Если прокручиваемый элемент управления отключен, полосы прокрутки также отключаются. Например, отключенное многострочное текстовое поле не может прокручиваться для отображения всех строк текста.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.GroupBox> и задаются некоторые общие свойства. В примере создается <xref:System.Windows.Forms.TextBox> и задается его <xref:System.Windows.Forms.Control.Location%2A> в поле группы. Затем задается свойство <xref:System.Windows.Forms.Control.Text%2A> поля группы и закрепляет поле группы в верхней части формы. Наконец, он отключает поле группы, присвоив свойству <xref:System.Windows.Forms.Control.Enabled%2A> значение `false`, что приводит к отключению всех элементов управления, содержащихся в поле группы.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ScrollableControl" />
      </Docs>
    </Member>
    <Member MemberName="EnabledChanged">
      <MemberSignature Language="C#" Value="public event EventHandler EnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.EnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EnabledChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ EnabledChanged;" />
      <MemberSignature Language="F#" Value="member this.EnabledChanged : EventHandler " Usage="member this.EnabledChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, если значение свойства <see cref="P:System.Windows.Forms.Control.Enabled" /> было изменено.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.Enabled%2A> изменено программным изменением или взаимодействием с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода используются два элемента управления <xref:System.Windows.Forms.RadioButton> для демонстрации события <xref:System.Windows.Forms.Control.EnabledChanged>. Нажатие одной кнопки изменяет значение свойства <xref:System.Windows.Forms.Control.Enabled%2A> другой кнопки на `false` и отображает <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-csharp[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="EndInvoke">
      <MemberSignature Language="C#" Value="public object EndInvoke (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object EndInvoke(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndInvoke (asyncResult As IAsyncResult) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ EndInvoke(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndInvoke : IAsyncResult -&gt; obj&#xA;override this.EndInvoke : IAsyncResult -&gt; obj" Usage="control.EndInvoke asyncResult" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISynchronizeInvoke.EndInvoke(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, представляющий конкретную асинхронную операцию вызова, возвращаемую при вызове <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />.</param>
        <summary>Получает возвращаемое значение асинхронной операции, представленное переданным объектом <see cref="T:System.IAsyncResult" />.</summary>
        <returns>Объект <see cref="T:System.Object" />, созданный асинхронной операцией.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если асинхронная операция не была завершена, эта функция будет заблокирована до тех пор, пока результат не станет доступен.  
  
> [!NOTE]
>  В дополнение к свойству <xref:System.Windows.Forms.Control.InvokeRequired%2A> существуют четыре метода в элементе управления, которые являются потокобезопасными: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> и <xref:System.Windows.Forms.Control.CreateGraphics%2A>, если уже был создан маркер для элемента управления. Вызов <xref:System.Windows.Forms.Control.CreateGraphics%2A> перед созданием маркера элемента управления в фоновом потоке может привести к недопустимым перекрестным вызовам потоков. Для всех остальных вызовов методов следует использовать один из методов Invoke для маршалирования вызова в поток элемента управления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="asyncResult" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Объект <paramref name="asyncResult" /> не был создан предыдущим вызовом метода <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" /> из того же элемента управления.</exception>
        <altmember cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public event EventHandler Enter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Enter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Enter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Enter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Enter;" />
      <MemberSignature Language="F#" Value="member this.Enter : EventHandler " Usage="member this.Enter : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при входе в элемент управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При изменении фокуса с помощью клавиатуры (TAB, SHIFT + TAB и т. д.), вызывая методы <xref:System.Windows.Forms.Control.Select%2A> или <xref:System.Windows.Forms.Control.SelectNextControl%2A> или устанавливая свойство <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> в текущую форму, события фокуса происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 При изменении фокуса с помощью мыши или при вызове метода <xref:System.Windows.Forms.Control.Focus%2A> события фокуса происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Если свойство <xref:System.Windows.Forms.Control.CausesValidation%2A> имеет значение `false`, события <xref:System.Windows.Forms.Control.Validating> и <xref:System.Windows.Forms.Control.Validated> подавляются.  
  
> [!NOTE]
>  События <xref:System.Windows.Forms.Control.Enter> и <xref:System.Windows.Forms.Control.Leave> подавляются классом <xref:System.Windows.Forms.Form>. Эквивалентными событиями в классе <xref:System.Windows.Forms.Form> являются события <xref:System.Windows.Forms.Form.Activated> и <xref:System.Windows.Forms.Form.Deactivate>. События <xref:System.Windows.Forms.Control.Enter> и <xref:System.Windows.Forms.Control.Leave> являются иерархическими и будут каскадными и вниз по родительской цепочке до тех пор, пока не будет достигнут соответствующий элемент управления. Например, предположим, что имеется <xref:System.Windows.Forms.Form> с двумя элементами управления <xref:System.Windows.Forms.GroupBox>, и каждый элемент управления <xref:System.Windows.Forms.GroupBox> имеет один элемент управления <xref:System.Windows.Forms.TextBox>. Когда курсор перемещается из одного <xref:System.Windows.Forms.TextBox> в другой, возникает событие <xref:System.Windows.Forms.Control.Leave> для <xref:System.Windows.Forms.TextBox> и <xref:System.Windows.Forms.GroupBox>, а для других <xref:System.Windows.Forms.GroupBox> и <xref:System.Windows.Forms.TextBox> возникает событие <xref:System.Windows.Forms.Control.Enter>.  
  
> [!CAUTION]
>  Не пытайтесь установить фокус с помощью обработчиков событий <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating> или <xref:System.Windows.Forms.Control.Validated>. Это может привести к тому, что ваше приложение или операционная система перестанут отвечать. Дополнительные сведения см. в разделе `WM_KILLFOCUS` в разделе "Справочник по входным данным на клавиатуре" и в разделе "взаимоблокировки сообщений" статьи [о сообщениях и очередях сообщений](https://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx) .  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода событие <xref:System.Windows.Forms.Control.Enter> используется для изменения цвета переднего плана и фона <xref:System.Windows.Forms.TextBox> при определенных условиях.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="FindForm">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form FindForm ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Form FindForm() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FindForm" />
      <MemberSignature Language="VB.NET" Value="Public Function FindForm () As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Form ^ FindForm();" />
      <MemberSignature Language="F#" Value="member this.FindForm : unit -&gt; System.Windows.Forms.Form" Usage="control.FindForm " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает форму, в которой находится элемент управления.</summary>
        <returns>Форма <see cref="T:System.Windows.Forms.Form" />, в которой находится элемент управления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение свойства <xref:System.Windows.Forms.Control.Parent%2A> элемента управления может отличаться от <xref:System.Windows.Forms.Form>, возвращаемого методом <xref:System.Windows.Forms.Control.FindForm%2A>. Например, если элемент управления <xref:System.Windows.Forms.RadioButton> содержится в элементе управления <xref:System.Windows.Forms.GroupBox>, а <xref:System.Windows.Forms.GroupBox> — в <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.RadioButton> элемента управления <xref:System.Windows.Forms.Control.Parent%2A> — это <xref:System.Windows.Forms.GroupBox>, а <xref:System.Windows.Forms.Control.Parent%2A> элемента управления <xref:System.Windows.Forms.GroupBox> — <xref:System.Windows.Forms.Form>.  
  
   
  
## Examples  
 В следующем примере кода выполняется поиск формы, содержащей указанную кнопку.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон, вызывающих этот метод. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.GetTopLevel" />
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; bool" Usage="control.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Устанавливает фокус ввода на элемент управления.</summary>
        <returns>Значение <see langword="true" />, если запрос фокуса ввода был успешным; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Forms.Control.Focus%2A> возвращает `true`, если элемент управления успешно получил фокус ввода. Элемент управления может иметь фокус ввода, не отображая никаких визуальных подсказок в фокусе. Это поведение в основном наблюдалось для невыбираемых элементов управления, перечисленных ниже, или любых элементов управления, производных от них.  
  
 Элемент управления может быть выбран и получать фокус ввода, если выполняются следующие условия: значение `Selectable` <xref:System.Windows.Forms.ControlStyles> равно `true`, оно содержится в другом элементе управления, и все его родительские элементы управления видимы и включены.  
  
 Элементы управления Windows Forms в следующем списке недоступны для выбора. Элементы управления, производные от этих элементов управления, также не могут быть выбраны.  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel> (если в элементе управления отсутствует ссылка)  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Focus%2A> — это метод низкого уровня, предназначенный в основном для авторов пользовательских элементов управления. Вместо этого программисты приложений должны использовать метод <xref:System.Windows.Forms.Control.Select%2A> или свойство <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> для дочерних элементов управления или метод <xref:System.Windows.Forms.Form.Activate%2A> для форм.  
  
   
  
## Examples  
 В следующем примере кода фокус устанавливается на указанный <xref:System.Windows.Forms.Control>, если он может получить фокус.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон, вызывающих этот метод. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="P:System.Windows.Forms.Control.ContainsFocus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.ActiveControl" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public virtual bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Focused" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Focused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Focused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Focused : bool" Usage="System.Windows.Forms.Control.Focused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, имеется ли на элементе управления фокус ввода.</summary>
        <value>Значение <see langword="true" />, если фокус находится на элементе управления; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода отключается <xref:System.Windows.Forms.MenuItem>, если <xref:System.Windows.Forms.TextBox> не имеет фокуса. В этом примере требуется наличие <xref:System.Windows.Forms.Form> с <xref:System.Windows.Forms.TextBox> с именем @no__t 2 и двумя объектами <xref:System.Windows.Forms.MenuItem> с именами `menuItemEdit` и `menuItemEditInsertCustomerInfo`.  
  
 [!code-cpp[Windows.FOrms.Control Members2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#4)]
 [!code-csharp[Windows.FOrms.Control Members2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#4)]
 [!code-vb[Windows.FOrms.Control Members2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.Focused" /> в производном классе используйте свойство базового класса <see cref="P:System.Windows.Forms.Control.Focused" /> для расширения базовой реализации. В противном случае необходимо предоставить всю реализацию.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
        <altmember cref="P:System.Windows.Forms.Control.ContainsFocus" />
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Font : System.Drawing.Font with get, set" Usage="System.Windows.Forms.Control.Font" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-512)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает шрифт текста, отображаемого элементом управления.</summary>
        <value>Шрифт <see cref="T:System.Drawing.Font" />, применяемый к тексту, отображаемому элементом управления. Значением по умолчанию является значение свойства <see cref="P:System.Windows.Forms.Control.DefaultFont" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.Font%2A> является внешним свойством. Внешнее свойство — это свойство элемента управления, которое, если оно не задано, извлекается из родительского элемента управления. Например, <xref:System.Windows.Forms.Button> будет иметь то же <xref:System.Windows.Forms.Control.BackColor%2A>, что и родительский <xref:System.Windows.Forms.Form> по умолчанию. Дополнительные сведения о внешних свойствах см. в описании класса <xref:System.Windows.Forms.AmbientProperties> или в обзоре класса <xref:System.Windows.Forms.Control>.  
  
 Поскольку <xref:System.Drawing.Font> является неизменяемым (то есть вы не можете изменить его свойства), можно назначить свойству <xref:System.Windows.Forms.Control.Font%2A> новое <xref:System.Drawing.Font>. Однако можно создать новый шрифт на основе существующего шрифта.  
  
 [Visual Basic, C#]  
  
 Ниже приведен пример того, как изменить существующий шрифт, сделав его полужирным:  
  
```csharp  
myControl.Font = new Font(myControl.Font,   
    myControl.Font.Style | FontStyle.Bold);  
```  
  
```vb  
MyControl.Font = New Font(MyControl.Font, _   
    MyControl.Font.Style Or FontStyle.Bold)  
```  
  
   
  
## Examples  
 В следующем примере кода отображается <xref:System.Windows.Forms.FontDialog> для пользователя и изменяется <xref:System.Drawing.Font> элемента управления <xref:System.Windows.Forms.DateTimePicker>. В этом примере требуется наличие <xref:System.Windows.Forms.Form> с <xref:System.Windows.Forms.Button> и <xref:System.Windows.Forms.DateTimePicker>.  
  
 [!code-cpp[Control_Font#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Font/CPP/control_font.cpp#1)]
 [!code-csharp[Control_Font#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Font/CS/control_font.cs#1)]
 [!code-vb[Control_Font#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Font/VB/control_font.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.Font" /> в производном классе используйте свойство базового класса <see cref="P:System.Windows.Forms.Control.Font" /> для расширения базовой реализации. В противном случае необходимо предоставить всю реализацию. Не требуется переопределять методы доступа <see langword="get" /> и <see langword="set" /> свойства <see cref="P:System.Windows.Forms.Control.Font" />; При необходимости можно переопределить только один из них.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="FontChanged">
      <MemberSignature Language="C#" Value="public event EventHandler FontChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler FontChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.FontChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FontChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ FontChanged;" />
      <MemberSignature Language="F#" Value="member this.FontChanged : EventHandler " Usage="member this.FontChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.Font" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.Font%2A> изменено с помощью программного изменения или взаимодействия.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано событие <xref:System.Windows.Forms.Control.FontChanged>.  
  
 [!code-csharp[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="FontHeight">
      <MemberSignature Language="C#" Value="protected int FontHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FontHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.FontHeight" />
      <MemberSignature Language="VB.NET" Value="Protected Property FontHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int FontHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.FontHeight : int with get, set" Usage="System.Windows.Forms.Control.FontHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает высоту шрифта элемента управления.</summary>
        <value>Высота объекта <see cref="T:System.Drawing.Font" /> элемента управления (в пикселях).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Для свойства <xref:System.Windows.Forms.Control.FontHeight%2A> не должно быть задано значение, отличное от значения <xref:System.Drawing.Font.Height%2A?displayProperty=nameWithType> элемента управления, или-1. Установка <xref:System.Windows.Forms.Control.FontHeight%2A> в значение-1 оказывает удаление значения кэшированной высоты, а значение вычисляется повторно при следующем обращении к свойству.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Font.Height" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.Control.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-513)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает цвет элемента управления.</summary>
        <value>Цвет <see cref="T:System.Drawing.Color" /> переднего плана для элемента управления. Значением по умолчанию является значение свойства <see cref="P:System.Windows.Forms.Control.DefaultForeColor" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.ForeColor%2A> является внешним свойством. Внешнее свойство — это свойство элемента управления, которое, если оно не задано, извлекается из родительского элемента управления. Например, <xref:System.Windows.Forms.Button> будет иметь то же <xref:System.Windows.Forms.Control.BackColor%2A>, что и родительский <xref:System.Windows.Forms.Form> по умолчанию. Дополнительные сведения о внешних свойствах см. в описании класса <xref:System.Windows.Forms.AmbientProperties> или в обзоре класса <xref:System.Windows.Forms.Control>.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Windows.Forms.Control.BackColor%2A> и <xref:System.Windows.Forms.Control.ForeColor%2A> для элементов управления устанавливаются в системные цвета по умолчанию. Код рекурсивно вызывает себя, если у элемента управления есть дочерние элементы управления. Этот пример кода требует наличия <xref:System.Windows.Forms.Form> с по крайней мере одним дочерним элементом управления. Однако элемент управления дочерним контейнером, например <xref:System.Windows.Forms.Panel> или <xref:System.Windows.Forms.GroupBox> с собственными дочерними элементами управления, лучше продемонстрировать рекурсию.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.ForeColor" /> в производном классе используйте свойство базового класса <see cref="P:System.Windows.Forms.Control.ForeColor" /> для расширения базовой реализации. В противном случае необходимо предоставить всю реализацию. Не требуется переопределять методы доступа <see langword="get" /> и <see langword="set" /> свойства <see cref="P:System.Windows.Forms.Control.ForeColor" />; При необходимости можно переопределить только один из них.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="ForeColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ForeColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ForeColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ForeColorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ForeColorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ForeColorChanged;" />
      <MemberSignature Language="F#" Value="member this.ForeColorChanged : EventHandler " Usage="member this.ForeColorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.ForeColor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.ForeColor%2A> изменено с помощью программного изменения или взаимодействия.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Следующий пример кода является обработчиком событий, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени *PropertyName*`Changed`, которые вызываются при изменении соответствующего значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> с отображением денежных данных. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере требуется <xref:System.Windows.Forms.Form>, содержащий <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ForeColor" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="FromChildHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromChildHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromChildHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromChildHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromChildHandle (handle As IntPtr) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::Control ^ FromChildHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="static member FromChildHandle : nativeint -&gt; System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.FromChildHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Дескриптор окна (<see langword="HWND" />), который требуется найти.</param>
        <summary>Возвращает элемент управления, содержащий указанный дескриптор.</summary>
        <returns>Объект <see cref="T:System.Windows.Forms.Control" /> представляет элемент управления, сопоставленный с указанным дескриптором; возвращает значение <see langword="null" />, если элемент управления с указанным дескриптором не обнаружен.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск по родительской цепочке Window Handle, пока не найдет маркер, связанный с элементом управления. Этот метод более надежен, чем метод <xref:System.Windows.Forms.Control.FromHandle%2A>, так как он правильно возвращает элементы управления, владеющие более чем одним маркером.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон, вызывающих этот метод. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As IntPtr) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::Control ^ FromHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="static member FromHandle : nativeint -&gt; System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.FromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Дескриптор окна (<see langword="HWND" />), который требуется найти.</param>
        <summary>Возвращает элемент управления, связанный в настоящий момент с указанным дескриптором.</summary>
        <returns>Объект <see cref="T:System.Windows.Forms.Control" /> представляет элемент управления, сопоставленный с указанным дескриптором; возвращает значение <see langword="null" />, если элемент управления с указанным дескриптором не обнаружен.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод <xref:System.Windows.Forms.Control.FromChildHandle%2A>, если необходимо вернуть элементы управления, владеющие более чем одним маркером.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон, вызывающих этот метод. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetAccessibilityObjectById">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject GetAccessibilityObjectById (int objectId);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject GetAccessibilityObjectById(int32 objectId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAccessibilityObjectById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetAccessibilityObjectById (objectId As Integer) As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::AccessibleObject ^ GetAccessibilityObjectById(int objectId);" />
      <MemberSignature Language="F#" Value="abstract member GetAccessibilityObjectById : int -&gt; System.Windows.Forms.AccessibleObject&#xA;override this.GetAccessibilityObjectById : int -&gt; System.Windows.Forms.AccessibleObject" Usage="control.GetAccessibilityObjectById objectId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="objectId"><see langword="Int32" />, указывающий получаемый объект <see cref="T:System.Windows.Forms.AccessibleObject" />.</param>
        <summary>Получает указанный объект <see cref="T:System.Windows.Forms.AccessibleObject" />.</summary>
        <returns>Указанный <see cref="T:System.Windows.Forms.AccessibleObject" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="GetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.AutoSizeMode GetAutoSizeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.AutoSizeMode GetAutoSizeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAutoSizeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetAutoSizeMode () As AutoSizeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::AutoSizeMode GetAutoSizeMode();" />
      <MemberSignature Language="F#" Value="member this.GetAutoSizeMode : unit -&gt; System.Windows.Forms.AutoSizeMode" Usage="control.GetAutoSizeMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает значение, указывающее, как будет вести себя элемент управления, когда его свойство <see cref="P:System.Windows.Forms.Control.AutoSize" /> включено.</summary>
        <returns>Одно из значений перечисления <see cref="T:System.Windows.Forms.AutoSizeMode" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChildAtPoint">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает дочерний элемент управления в указанном расположении.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildAtPoint (pt As Point) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetChildAtPoint(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="member this.GetChildAtPoint : System.Drawing.Point -&gt; System.Windows.Forms.Control" Usage="control.GetChildAtPoint pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">Объект <see cref="T:System.Drawing.Point" />, содержащий координаты, по которым будет проходить поиск элемента управления. Координаты заданы относительно левого верхнего угла клиентской области элемента управления.</param>
        <summary>Возвращает дочерний элемент управления, имеющий указанные координаты.</summary>
        <returns>Объект <see cref="T:System.Windows.Forms.Control" /> представляет элемент управления, расположенный в указанном месте.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если в указанной точке нет дочернего элемента управления, метод <xref:System.Windows.Forms.Control.GetChildAtPoint%2A> возвращает `null`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон, вызывающих этот метод, если возвращаемый элемент управления не является дочерним элементом элемента управления. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt, System.Windows.Forms.GetChildAtPointSkip skipValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt, valuetype System.Windows.Forms.GetChildAtPointSkip skipValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point,System.Windows.Forms.GetChildAtPointSkip)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildAtPoint (pt As Point, skipValue As GetChildAtPointSkip) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetChildAtPoint(System::Drawing::Point pt, System::Windows::Forms::GetChildAtPointSkip skipValue);" />
      <MemberSignature Language="F#" Value="member this.GetChildAtPoint : System.Drawing.Point * System.Windows.Forms.GetChildAtPointSkip -&gt; System.Windows.Forms.Control" Usage="control.GetChildAtPoint (pt, skipValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="skipValue" Type="System.Windows.Forms.GetChildAtPointSkip" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="pt">Объект <see cref="T:System.Drawing.Point" />, содержащий координаты, по которым будет проходить поиск элемента управления. Координаты заданы относительно левого верхнего угла клиентской области элемента управления.</param>
        <param name="skipValue">Одно из значений объекта <see cref="T:System.Windows.Forms.GetChildAtPointSkip" />, определяющее, следует ли игнорировать дочерние элементы управления конкретного типа.</param>
        <summary>Возвращает дочерний элемент управления, расположенный по указанным координатам, определяя, следует ли игнорировать дочерние элементы управления конкретного типа.</summary>
        <returns>Дочерний объект <see cref="T:System.Windows.Forms.Control" />, расположенный по указанным координатам.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainerControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IContainerControl GetContainerControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.IContainerControl GetContainerControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetContainerControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContainerControl () As IContainerControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::IContainerControl ^ GetContainerControl();" />
      <MemberSignature Language="F#" Value="member this.GetContainerControl : unit -&gt; System.Windows.Forms.IContainerControl" Usage="control.GetContainerControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IContainerControl</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает следующий объект <see cref="T:System.Windows.Forms.ContainerControl" /> в цепочке родительских элементов управления данного элемента.</summary>
        <returns>Объект <see cref="T:System.Windows.Forms.IContainerControl" />, представляющий родительский элемент объекта <see cref="T:System.Windows.Forms.Control" />.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон, вызывающих этот метод. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="T:System.Windows.Forms.IContainerControl" />
      </Docs>
    </Member>
    <Member MemberName="GetNextControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetNextControl (System.Windows.Forms.Control ctl, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetNextControl(class System.Windows.Forms.Control ctl, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetNextControl(System.Windows.Forms.Control,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextControl (ctl As Control, forward As Boolean) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetNextControl(System::Windows::Forms::Control ^ ctl, bool forward);" />
      <MemberSignature Language="F#" Value="member this.GetNextControl : System.Windows.Forms.Control * bool -&gt; System.Windows.Forms.Control" Usage="control.GetNextControl (ctl, forward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">Объект <see cref="T:System.Windows.Forms.Control" />, с которого следует начать поиск.</param>
        <param name="forward">Значение <see langword="true" /> для поиска в прямом направлении в последовательности табуляции; значение <see langword="false" /> для поиска в обратном направлении.</param>
        <summary>Возвращает следующий или предыдущий элемент среди дочерних элементов управления в последовательности клавиши TAB.</summary>
        <returns>Следующий объект <see cref="T:System.Windows.Forms.Control" /> в последовательности табуляции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Forms.Control.GetNextControl%2A> зависит от порядка табуляции. Для перебора всех элементов управления формы, включая вложенные элементы управления, используйте свойство <xref:System.Windows.Forms.Control.Controls%2A>. Чтобы получить или задать активный элемент управления контейнера, используйте свойство <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="GetPreferredSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size GetPreferredSize (System.Drawing.Size proposedSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.Size GetPreferredSize(valuetype System.Drawing.Size proposedSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreferredSize (proposedSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Drawing::Size GetPreferredSize(System::Drawing::Size proposedSize);" />
      <MemberSignature Language="F#" Value="abstract member GetPreferredSize : System.Drawing.Size -&gt; System.Drawing.Size&#xA;override this.GetPreferredSize : System.Drawing.Size -&gt; System.Drawing.Size" Usage="control.GetPreferredSize proposedSize" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.Layout.IArrangedElement.GetPreferredSize(System.Drawing.Size)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proposedSize" Type="System.Drawing.Size" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="proposedSize">Область пользовательского размера для элемента управления.</param>
        <summary>Вычисляет размер прямоугольной области, в которую помещается элемент управления.</summary>
        <returns>Упорядоченная пара типа <see cref="T:System.Drawing.Size" />, представляющая ширину и высоту прямоугольника.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поведение <xref:System.Windows.Forms.Control.GetPreferredSize%2A> отличается от Control. @No__t-0 не может присвоить возвращаемый размер элементу управления. Можно вернуть размер, превышающий ограничения, указанные в параметре `proposedSize`, но `proposedSize` должно уменьшиться по мере уменьшения ограничения. Например, `GetPreferredSize(new Size(100, 0))` не должен быть шире `GetPreferredSize(new Size(200, 0))`. Исключением является `proposedSize` из 0 или `Size.Empty`, которые определены как неограниченные.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetScaledBounds (bounds As Rectangle, factor As SizeF, specified As BoundsSpecified) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Rectangle GetScaledBounds(System::Drawing::Rectangle bounds, System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member GetScaledBounds : System.Drawing.Rectangle * System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; System.Drawing.Rectangle&#xA;override this.GetScaledBounds : System.Drawing.Rectangle * System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; System.Drawing.Rectangle" Usage="control.GetScaledBounds (bounds, factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="bounds">Объект <see cref="T:System.Drawing.Rectangle" />, определяющий область, для которой возвращаются границы области отображения.</param>
        <param name="factor">Высота и ширина границ элемента управления.</param>
        <param name="specified">Одно из значений объекта <see cref="T:System.Windows.Forms.BoundsSpecified" />, задающее границы элемента управления, используемые для определения его размеров и положения.</param>
        <summary>Возвращает границы, внутри которых масштабируется элемент управления.</summary>
        <returns>Объект <see cref="T:System.Drawing.Rectangle" />, представляющий границы, внутри которых масштабируется элемент управления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это вспомогательный метод, который вызывается <xref:System.Windows.Forms.Control.ScaleControl%2A> для получения границ, внутри которых масштабируется элемент управления. Этот метод можно переопределить для повторного использования логики масштабирования <xref:System.Windows.Forms.Control.ScaleControl%2A>, но необходимо предоставить собственные границы. Реализация по умолчанию возвращает масштабируемые границы, которые принимают на себя границы `specified`, является ли элемент управления верхним, является ли элемент управления фиксированной шириной или автоматическим размером, а также любыми декоративными элементами, которые может иметь элемент управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.Scale(System.Single)" />
        <altmember cref="P:System.Windows.Forms.Control.ScaleChildren" />
      </Docs>
    </Member>
    <Member MemberName="GetStyle">
      <MemberSignature Language="C#" Value="protected bool GetStyle (System.Windows.Forms.ControlStyles flag);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetStyle(valuetype System.Windows.Forms.ControlStyles flag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetStyle (flag As ControlStyles) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool GetStyle(System::Windows::Forms::ControlStyles flag);" />
      <MemberSignature Language="F#" Value="member this.GetStyle : System.Windows.Forms.ControlStyles -&gt; bool" Usage="control.GetStyle flag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
      </Parameters>
      <Docs>
        <param name="flag">Бит <see cref="T:System.Windows.Forms.ControlStyles" />, значение которого следует возвращать.</param>
        <summary>Возвращает значение указанного бита стиля элемента управления для данного элемента управления.</summary>
        <returns>Значение <see langword="true" />, если указанный бит стиля элемента управления имеет значение <see langword="true" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Битовые флаги стиля элемента управления используются для категоризации поддерживаемого поведения. Элемент управления может включить стиль, вызвав метод <xref:System.Windows.Forms.Control.SetStyle%2A> и передав соответствующий бит <xref:System.Windows.Forms.ControlStyles> и логическое значение, чтобы установить бит Равным. Чтобы определить значение, присвоенное указанному биту <xref:System.Windows.Forms.ControlStyles>, используйте метод <xref:System.Windows.Forms.Control.GetStyle%2A> и передайте для вычисления элемент <xref:System.Windows.Forms.ControlStyles>.  
  
   
  
## Examples  
 В следующем примере кода возвращаются значения битов стиля, связанных с двойной буферизацией, для <xref:System.Windows.Forms.Form>. Этот пример возвращает `true` только в том случае, если все биты стиля имеют значение `true`.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#4)]
 [!code-csharp[Windows.Forms.ControlMembers6#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#4)]
 [!code-vb[Windows.Forms.ControlMembers6#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="GetTopLevel">
      <MemberSignature Language="C#" Value="protected bool GetTopLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetTopLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetTopLevel" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetTopLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool GetTopLevel();" />
      <MemberSignature Language="F#" Value="member this.GetTopLevel : unit -&gt; bool" Usage="control.GetTopLevel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Определяет, находится ли элемент управления на верхнем уровне.</summary>
        <returns>Значение <see langword="true" />, если элемент управления является элементом верхнего уровня; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывается при выполнении операции перетаскивания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие <xref:System.Windows.Forms.Control.GiveFeedback> возникает при запуске операции перетаскивания. При событии <xref:System.Windows.Forms.Control.GiveFeedback> Источник события перетаскивания может изменить внешний вид указателя мыши, чтобы предоставить пользователю визуальную обратную связь во время операции перетаскивания.  
  
 Далее описывается, как и когда возникают события, связанные с операциями перетаскивания.  
  
 Метод <xref:System.Windows.Forms.Control.DoDragDrop%2A> определяет элемент управления под текущим местоположением курсора. Затем он проверяет, является ли элемент управления допустимым целевым объектом перетаскивания.  
  
 Если элемент управления является допустимым целевым объектом перетаскивания, то событие <xref:System.Windows.Forms.Control.GiveFeedback> вызывается с указанными действиями перетаскивания. Список эффектов перетаскивания см. в перечислении <xref:System.Windows.Forms.DragDropEffects>.  
  
 Отслеживаются изменения позиции указателя мыши, состояния клавиатуры и кнопки мыши.  
  
-   Если пользователь перемещает указатель мыши за пределы окна, происходит событие <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Если указатель мыши перемещается на другой элемент управления, для этого элемента вызывается событие <xref:System.Windows.Forms.Control.DragEnter>.  
  
-   При перемещении мыши в пределах одного элемента управления возникает событие <xref:System.Windows.Forms.Control.DragOver>.  
  
 При изменении состояния клавиатуры или кнопки мыши возникает событие <xref:System.Windows.Forms.Control.QueryContinueDrag> и определяет, следует ли продолжить перетаскивание, для удаления данных или отмены операции на основе значения свойства <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> события <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Continue`, возникает событие <xref:System.Windows.Forms.Control.DragOver> для продолжения операции, а событие <xref:System.Windows.Forms.Control.GiveFeedback> вызывается с новым действием, чтобы можно было установить соответствующую визуальную обратную связь. Список допустимых эффектов сброса см. в перечислении <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  События <xref:System.Windows.Forms.Control.DragOver> и <xref:System.Windows.Forms.Control.GiveFeedback> сопряжены таким образом, что при перемещении мыши по направлению перетаскивания пользователь получает наиболее актуальную информацию о положении мыши.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Drop`, то значение результата перетаскивания возвращается в источник, поэтому исходное приложение может выполнить соответствующую операцию с исходными данными. Например, если операция была перемещена, вырежьте данные.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Cancel`, возникает событие <xref:System.Windows.Forms.Control.DragLeave>.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется операция перетаскивания между двумя элементами управления <xref:System.Windows.Forms.ListBox>. В примере вызывается метод <xref:System.Windows.Forms.Control.DoDragDrop%2A>, когда начинается действие перетаскивания. Действие перетаскивания начинается, если мышь переместила больше <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> из положения мыши во время события <xref:System.Windows.Forms.Control.MouseDown>. Метод <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> используется для определения индекса элемента, перетаскиваемого во время события `MouseDown`.  
  
 В примере также демонстрируется использование пользовательских курсоров для операции перетаскивания. Для этого примера требуются два файла курсора (`3dwarro.cur` и `3dwno.cur`) в каталоге приложения для настраиваемых курсоров перетаскивания и без перетаскивания соответственно. Пользовательские курсоры будут использоваться, если установлен флажок `UseCustomCursorsCheck` @ no__t-1. Пользовательские курсоры задаются в обработчике событий <xref:System.Windows.Forms.Control.GiveFeedback>.  
  
 Состояние клавиатуры вычисляется в обработчике событий <xref:System.Windows.Forms.Control.DragOver> справа `ListBox`, чтобы определить, какая операция перетаскивания будет основываться на состоянии клавиш SHIFT, CTRL, ALT или CTRL + ALT. Расположение в `ListBox`, где происходит удаление, также определяется во время события `DragOver`. Если данные для удаления не являются `String`, <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> устанавливается в значение `None` в <xref:System.Windows.Forms.DragDropEffects>. Наконец, состояние удаления отображается в `DropLocationLabel` @ no__t-1.  
  
 Данные, которые нужно удалить справа `ListBox`, определяются в обработчике событий <xref:System.Windows.Forms.Control.DragDrop>, а значение `String` добавляется в соответствующее место `ListBox`. Если операция перетаскивания выходит за границы формы, операция перетаскивания отменяется в обработчике событий <xref:System.Windows.Forms.Control.QueryContinueDrag>.  
  
 Этот фрагмент кода демонстрирует использование события <xref:System.Windows.Forms.Control.GiveFeedback>. Полный пример кода см. в описании метода <xref:System.Windows.Forms.Control.DoDragDrop%2A>.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event EventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : EventHandler " Usage="member this.GotFocus : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывается при получении фокуса элементом управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При изменении фокуса с помощью клавиатуры (TAB, SHIFT + TAB и т. д.), вызывая методы <xref:System.Windows.Forms.Control.Select%2A> или <xref:System.Windows.Forms.Control.SelectNextControl%2A> или устанавливая свойство <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> в текущую форму, события фокуса происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 При изменении фокуса с помощью мыши или при вызове метода <xref:System.Windows.Forms.Control.Focus%2A> события фокуса происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Если свойство <xref:System.Windows.Forms.Control.CausesValidation%2A> имеет значение `false`, события <xref:System.Windows.Forms.Control.Validating> и <xref:System.Windows.Forms.Control.Validated> подавляются.  
  
 **Примечание** . События <xref:System.Windows.Forms.Control.GotFocus> и <xref:System.Windows.Forms.Control.LostFocus> являются событиями фокуса низкого уровня, которые привязаны к сообщениям Windows WM_KILLFOCUS и WM_SETFOCUS. Как правило, события <xref:System.Windows.Forms.Control.GotFocus> и <xref:System.Windows.Forms.Control.LostFocus> используются только при обновлении <xref:System.Windows.Forms.UICues> или при написании пользовательских элементов управления. Вместо этого события <xref:System.Windows.Forms.Control.Enter> и <xref:System.Windows.Forms.Control.Leave> должны использоваться для всех элементов управления, кроме класса <xref:System.Windows.Forms.Form>, который использует события <xref:System.Windows.Forms.Form.Activated> и <xref:System.Windows.Forms.Form.Deactivate>. Дополнительные сведения о событиях <xref:System.Windows.Forms.Control.GotFocus> и <xref:System.Windows.Forms.Control.LostFocus> см. в разделах [WM_SETFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646283\(v=vs.85\).aspx) и [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) .  
  
> [!CAUTION]
>  Не пытайтесь установить фокус с помощью обработчиков событий <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating> или <xref:System.Windows.Forms.Control.Validated>. Это может привести к тому, что ваше приложение или операционная система перестанут отвечать. Дополнительные сведения см. в разделе [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) .  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Control.GotFocus>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа, который наследует от <xref:System.Windows.Forms.Control>, например <xref:System.Windows.Forms.Button> или <xref:System.Windows.Forms.ComboBox>. Затем присвойте экземпляру имя `Control1` и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Control.GotFocus>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#47](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#47)]
 [!code-vb[System.Windows.Forms.EventExamples#47](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#47)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Windows.Forms.Control.Handle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IWin32Window.Handle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-515)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает дескриптор окна, с которым связан элемент управления.</summary>
        <value>Объект <see cref="T:System.IntPtr" />, содержащий дескриптор окна (<see langword="HWND" />) элемента управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значением свойства <xref:System.Windows.Forms.Control.Handle%2A> является Windows `HWND`. Если этот маркер еще не создан, ссылка на это свойство приведет к принудительному созданию этого обработчика.  
  
   
  
## Examples  
 В следующем примере кода показано использование свойств <xref:System.Windows.Forms.ControlPaint.DrawFocusRectangle%2A?displayProperty=nameWithType> и <xref:System.Windows.Forms.Control.Handle%2A>. Чтобы выполнить пример, вставьте следующий код в форму. Добавьте две кнопки с именами `Button1` и `Button2` в форму и убедитесь, что все события подключены к их обработчикам событий.  
  
 [!code-cpp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HandleCreated">
      <MemberSignature Language="C#" Value="public event EventHandler HandleCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleCreated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleCreated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HandleCreated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HandleCreated;" />
      <MemberSignature Language="F#" Value="member this.HandleCreated : EventHandler " Usage="member this.HandleCreated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при создании дескриптора для элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Маркер создается, когда <xref:System.Windows.Forms.Control> отображается в первый раз. Например, если создается <xref:System.Windows.Forms.Control>, где <xref:System.Windows.Forms.Control.Visible%2A> имеет значение `false`, событие <xref:System.Windows.Forms.Control.HandleCreated> не будет вызвано, пока для <xref:System.Windows.Forms.Control.Visible%2A> не установлено значение `true`.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Control.HandleCreated>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа, который наследует от <xref:System.Windows.Forms.Control>, например <xref:System.Windows.Forms.Button> или <xref:System.Windows.Forms.ComboBox>. Затем присвойте экземпляру имя `Control1` и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Control.HandleCreated>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#37](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#37)]
 [!code-vb[System.Windows.Forms.EventExamples#37](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HandleDestroyed">
      <MemberSignature Language="C#" Value="public event EventHandler HandleDestroyed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleDestroyed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleDestroyed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HandleDestroyed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HandleDestroyed;" />
      <MemberSignature Language="F#" Value="member this.HandleDestroyed : EventHandler " Usage="member this.HandleDestroyed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит в процессе удаления дескриптора элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Во время события <xref:System.Windows.Forms.Control.HandleDestroyed> элемент управления по-прежнему является допустимым элементом управления Windows, и <xref:System.Windows.Forms.Control.Handle%2A> может быть создан повторно путем вызова метода <xref:System.Windows.Forms.Control.RecreateHandle%2A>.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Control.HandleDestroyed>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа, который наследует от <xref:System.Windows.Forms.Control>, например <xref:System.Windows.Forms.Button> или <xref:System.Windows.Forms.ComboBox>. Затем присвойте экземпляру имя `Control1` и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Control.HandleDestroyed>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#38](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#38)]
 [!code-vb[System.Windows.Forms.EventExamples#38](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#38)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HasChildren">
      <MemberSignature Language="C#" Value="public bool HasChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.HasChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChildren : bool" Usage="System.Windows.Forms.Control.HasChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, содержит ли элемент управления один или несколько дочерних элементов.</summary>
        <value>Значение <see langword="true" />, если элемент управления содержит один или несколько элементов; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если коллекция <xref:System.Windows.Forms.Control.Controls%2A> имеет <xref:System.Windows.Forms.Layout.ArrangedElementCollection.Count%2A> больше нуля, свойство <xref:System.Windows.Forms.Control.HasChildren%2A> возвратит `true`. Доступ к свойству <xref:System.Windows.Forms.Control.HasChildren%2A> не приводит к принудительному созданию <xref:System.Windows.Forms.Control.ControlCollection>, если у элемента управления нет дочерних элементов, поэтому ссылка на это свойство может повысить производительность при прохождении дерева элементов управления.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Windows.Forms.Control.BackColor%2A> и <xref:System.Windows.Forms.Control.ForeColor%2A> для элементов управления устанавливаются в системные цвета по умолчанию. Код рекурсивно вызывает себя, если у элемента управления есть дочерние элементы управления. Этот пример кода требует наличия <xref:System.Windows.Forms.Form> с по крайней мере одним дочерним элементом управления. Однако элемент управления дочерним контейнером, например <xref:System.Windows.Forms.Panel> или <xref:System.Windows.Forms.GroupBox> с собственными дочерними элементами управления, лучше продемонстрировать рекурсию.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Layout.ArrangedElementCollection.Count" />
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public int Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Height { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Height : int with get, set" Usage="System.Windows.Forms.Control.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает высоту элемента управления.</summary>
        <value>Высота элемента управления в пикселях.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Изменения, внесенные в значения свойств <xref:System.Windows.Forms.Control.Height%2A> и <xref:System.Windows.Forms.Control.Top%2A>, приводят к изменению значения свойства <xref:System.Windows.Forms.Control.Bottom%2A> элемента управления.  
  
> [!NOTE]
>  Минимальная высота для производного элемента управления <xref:System.Windows.Forms.Splitter> — один пиксель. Высота по умолчанию для элемента управления <xref:System.Windows.Forms.Splitter> составляет три пикселя. Если задать для высоты элемента управления <xref:System.Windows.Forms.Splitter> значение меньше единицы, значение свойства будет сброшено до высоты по умолчанию.  
  
   
  
## Examples  
 В следующем примере кода создаются три элемента управления <xref:System.Windows.Forms.Button> в форме и задаются их размер и расположение с использованием различных свойств, связанных с размером и расположением. В этом примере требуется наличие <xref:System.Windows.Forms.Form> с шириной и высотой не менее 300 пикселей.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
        <altmember cref="P:System.Drawing.Size.Height" />
      </Docs>
    </Member>
    <Member MemberName="HelpRequested">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HelpEventHandler HelpRequested;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HelpEventHandler HelpRequested" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HelpRequested" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HelpRequested As HelpEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HelpEventHandler ^ HelpRequested;" />
      <MemberSignature Language="F#" Value="member this.HelpRequested : System.Windows.Forms.HelpEventHandler " Usage="member this.HelpRequested : System.Windows.Forms.HelpEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при запросе справки для элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие <xref:System.Windows.Forms.Control.HelpRequested> часто возникает, когда пользователь нажимает клавишу F1 или связанная с контекстной справкой Кнопка справки.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется обработка события <xref:System.Windows.Forms.Control.HelpRequested> для вывода пользовательского содержимого справки в форме, содержащей четыре поля адреса. Событие <xref:System.Windows.Forms.Control.HelpRequested> возникает либо нажатием клавиши F1 с фокусом в поле адреса, либо с помощью кнопки контекстно-зависимая справка и щелчком указателя справки в поле адреса. Свойство <xref:System.Windows.Forms.HelpEventArgs.Handled%2A> имеет значение true, чтобы указать, что событие `HelpRequested` обрабатывается. В примере также демонстрируется сохранение текста справки в свойстве <xref:System.Windows.Forms.Control.Tag%2A?displayProperty=nameWithType>.  
  
 [!code-cpp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CPP/helpevent.cpp#1)]
 [!code-csharp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CS/helpevent.cs#1)]
 [!code-vb[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/VB/helpevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
        <altmember cref="T:System.Windows.Forms.HelpProvider" />
        <altmember cref="T:System.Windows.Forms.Help" />
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="control.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Скрывает элемент управления от пользователя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Скрытие элемента управления эквивалентно присвоению свойству <xref:System.Windows.Forms.Control.Visible%2A> значения `false`. После вызова метода <xref:System.Windows.Forms.Control.Hide%2A> свойство <xref:System.Windows.Forms.Control.Visible%2A> возвращает значение `false` до тех пор, пока не будет вызван метод <xref:System.Windows.Forms.Control.Show%2A>.  
  
   
  
## Examples  
 В следующем примере кода скрывается кнопка, если нажата клавиша CTRL. В этом примере требуется, чтобы в <xref:System.Windows.Forms.Form> имелся <xref:System.Windows.Forms.Button> с именем `button1`.  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Show" />
      </Docs>
    </Member>
    <Member MemberName="ImeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ImeMode ImeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ImeMode ImeMode { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ImeMode : System.Windows.Forms.ImeMode with get, set" Usage="System.Windows.Forms.Control.ImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает режим редактора метода ввода элемента управления.</summary>
        <value>Одно из значений <see cref="T:System.Windows.Forms.ImeMode" />. Значение по умолчанию — <see cref="F:System.Windows.Forms.ImeMode.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Редактор IME — это программа, которая позволяет пользователям вводить сложные символы и символы, например японские символы кандзи, используя стандартную клавиатуру. Свойству <xref:System.Windows.Forms.Control.ImeMode%2A> обычно присваивается значение <xref:System.Windows.Forms.ImeMode.Off?displayProperty=nameWithType> для элемента управления <xref:System.Windows.Forms.TextBox>, предназначенного только для ввода числовых значений. Свойству <xref:System.Windows.Forms.Control.ImeMode%2A> присвоено значение <xref:System.Windows.Forms.ImeMode.NoControl?displayProperty=nameWithType> для класса <xref:System.Windows.Forms.Form>.  
  
 Большинство классов, которые не поддерживают напрямую редакторы методов ввода или разрешают прямой ввод из IME, присвойте этому свойству значение <xref:System.Windows.Forms.ImeMode.NoControl>.  
  
> [!IMPORTANT]
>  Пользователь может в интерактивном режиме изменить <xref:System.Windows.Forms.Control.ImeMode%2A>, если он не установлен программным образом в <xref:System.Windows.Forms.ImeMode.Disable?displayProperty=nameWithType>. В этом случае пользователь не сможет использовать IME.  
>   
>  Свойство <xref:System.Windows.Forms.Control.ImeMode%2A> не учитывается в Windows 8, если действует глобальный режим ввода. Дополнительные сведения см. в разделе [переключение ввода текста, измененное с "на поток](https://go.microsoft.com/fwlink/?LinkID=256509)" на "на пользователя".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Назначенное значение не является значением перечисления <see cref="T:System.Windows.Forms.ImeMode" />.</exception>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
        <altmember cref="P:System.Windows.Forms.Control.DefaultImeMode" />
      </Docs>
    </Member>
    <Member MemberName="ImeModeBase">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode ImeModeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeModeBase" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeModeBase" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property ImeModeBase As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode ImeModeBase { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ImeModeBase : System.Windows.Forms.ImeMode with get, set" Usage="System.Windows.Forms.Control.ImeModeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает режим IME элемента управления.</summary>
        <value>Режим IME элемента управления.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeModeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ImeModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ImeModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ImeModeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ImeModeChanged;" />
      <MemberSignature Language="F#" Value="member this.ImeModeChanged : EventHandler " Usage="member this.ImeModeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении свойства <see cref="P:System.Windows.Forms.Control.ImeMode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.ImeMode%2A> изменено с помощью программного изменения или взаимодействия.  
  
 Элементы управления, не поддерживающие диспетчеры методов ввода, никогда не будут вызывать это событие.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Следующий пример кода является обработчиком событий, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени *PropertyName*`Changed`, которые вызываются при изменении соответствующего значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> с отображением денежных данных. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере требуется <xref:System.Windows.Forms.Form>, содержащий <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
        <altmember cref="T:System.Windows.Forms.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="InitLayout">
      <MemberSignature Language="C#" Value="protected virtual void InitLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InitLayout" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitLayout ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitLayout();" />
      <MemberSignature Language="F#" Value="abstract member InitLayout : unit -&gt; unit&#xA;override this.InitLayout : unit -&gt; unit" Usage="control.InitLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывается после добавления элемента управления в другой контейнер.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Forms.Control.InitLayout%2A> вызывается сразу после добавления элемента управления в контейнер. Метод <xref:System.Windows.Forms.Control.InitLayout%2A> позволяет элементу управления инициализировать состояние макета на основе его контейнера. Например, к элементу управления в методе <xref:System.Windows.Forms.Control.InitLayout%2A> обычно применяется привязка и закрепление.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.Windows.Forms.Control.InitLayout" /> в производном классе обязательно вызовите метод <see cref="M:System.Windows.Forms.Control.InitLayout" /> базового класса, чтобы элемент управления отображался правильно.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Anchor" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invalidate">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Делает недействительной конкретную область элемента управления и вызывает отправку сообщения рисования элементу управления.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate();" />
      <MemberSignature Language="F#" Value="member this.Invalidate : unit -&gt; unit" Usage="control.Invalidate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Делает недействительной всю поверхность элемента управления и вызывает его перерисовку.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов метода <xref:System.Windows.Forms.Control.Invalidate%2A> не приводит к принудительной синхронной прорисовке; чтобы принудительно выполнить синхронную заливку, вызовите метод <xref:System.Windows.Forms.Control.Update%2A> после вызова метода <xref:System.Windows.Forms.Control.Invalidate%2A>. При вызове этого метода без параметров вся клиентская область добавляется в область обновления.  
  
   
  
## Examples  
 В следующем примере кода пользователь может перетащить изображение или файл изображения на форму и отобразить его в момент удаления. Метод <xref:System.Windows.Forms.Control.OnPaint%2A> переопределен для перерисовки изображения при каждой отрисованной форме; в противном случае изображение будет сохранено только до следующего перерисовки. Метод обработки событий <xref:System.Windows.Forms.Control.DragEnter> определяет тип данных, которые перетаскиваются в форму, и предоставляет соответствующие отзывы. Метод обработки событий <xref:System.Windows.Forms.Control.DragDrop> отображает изображение в форме, если <xref:System.Drawing.Image> может быть создан из данных. Так как значения <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> и <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> являются экранными координатами, в примере используется метод <xref:System.Windows.Forms.Control.PointToClient%2A> для преобразования их в клиентские координаты.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (invalidateChildren As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : bool -&gt; unit" Usage="control.Invalidate invalidateChildren" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidateChildren">Значение <see langword="true" />, чтобы сделать недействительными дочерние элементы управления; в противном случае — значение <see langword="false" />.</param>
        <summary>Делает недействительной конкретную область элемента управления и вызывает отправку сообщения рисования элементу управления. При необходимости объявляет недействительными назначенные элементу управления дочерние элементы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов метода <xref:System.Windows.Forms.Control.Invalidate%2A> не приводит к принудительной синхронной прорисовке; чтобы принудительно выполнить синхронную заливку, вызовите метод <xref:System.Windows.Forms.Control.Update%2A> после вызова метода <xref:System.Windows.Forms.Control.Invalidate%2A>. При вызове этого метода без параметров вся клиентская область добавляется в область обновления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (rc As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Rectangle rc);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Rectangle -&gt; unit" Usage="control.Invalidate rc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rc">Объект <see cref="T:System.Drawing.Rectangle" />, представляющий область, которую следует сделать недействительной.</param>
        <summary>Делает недействительной указанную область элемента управления (добавляет ее к области обновления элемента, которая будет перерисована при следующей операции рисования) и вызывает отправку сообщения рисования элементу управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов метода <xref:System.Windows.Forms.Control.Invalidate%2A> не приводит к принудительной синхронной прорисовке; чтобы принудительно выполнить синхронную заливку, вызовите метод <xref:System.Windows.Forms.Control.Update%2A> после вызова метода <xref:System.Windows.Forms.Control.Invalidate%2A>. При вызове этого метода без параметров вся клиентская область добавляется в область обновления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Region -&gt; unit" Usage="control.Invalidate region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">Объект <see cref="T:System.Drawing.Region" />, который делается недействительным.</param>
        <summary>Делает недействительной указанную область элемента управления (добавляет ее к области обновления элемента, которая будет перерисована при следующей операции рисования) и вызывает отправку сообщения рисования элементу управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов метода <xref:System.Windows.Forms.Control.Invalidate%2A> не приводит к принудительной синхронной прорисовке; чтобы принудительно выполнить синхронную заливку, вызовите метод <xref:System.Windows.Forms.Control.Update%2A> после вызова метода <xref:System.Windows.Forms.Control.Invalidate%2A>. При вызове этого метода без параметров вся клиентская область добавляется в область обновления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (rc As Rectangle, invalidateChildren As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Rectangle rc, bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Rectangle * bool -&gt; unit" Usage="control.Invalidate (rc, invalidateChildren)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rc">Объект <see cref="T:System.Drawing.Rectangle" />, представляющий область, которую следует сделать недействительной.</param>
        <param name="invalidateChildren">Значение <see langword="true" />, чтобы сделать недействительными дочерние элементы управления; в противном случае — значение <see langword="false" />.</param>
        <summary>Делает недействительной указанную область элемента управления (добавляет ее к области обновления элемента, которая будет перерисована при следующей операции рисования) и вызывает отправку сообщения рисования элементу управления. При необходимости объявляет недействительными назначенные элементу управления дочерние элементы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов метода <xref:System.Windows.Forms.Control.Invalidate%2A> не приводит к принудительной синхронной прорисовке; чтобы принудительно выполнить синхронную заливку, вызовите метод <xref:System.Windows.Forms.Control.Update%2A> после вызова метода <xref:System.Windows.Forms.Control.Invalidate%2A>. При вызове этого метода без параметров вся клиентская область добавляется в область обновления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Region ^ region, bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Region * bool -&gt; unit" Usage="control.Invalidate (region, invalidateChildren)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="region">Объект <see cref="T:System.Drawing.Region" />, который делается недействительным.</param>
        <param name="invalidateChildren">Значение <see langword="true" />, чтобы сделать недействительными дочерние элементы управления; в противном случае — значение <see langword="false" />.</param>
        <summary>Делает недействительной указанную область элемента управления (добавляет ее к области обновления элемента, которая будет перерисована при следующей операции рисования) и вызывает отправку сообщения рисования элементу управления. При необходимости объявляет недействительными назначенные элементу управления дочерние элементы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов метода <xref:System.Windows.Forms.Control.Invalidate%2A> не приводит к принудительной синхронной прорисовке; чтобы принудительно выполнить синхронную заливку, вызовите метод <xref:System.Windows.Forms.Control.Update%2A> после вызова метода <xref:System.Windows.Forms.Control.Invalidate%2A>. При вызове этого метода без параметров вся клиентская область добавляется в область обновления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidated">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InvalidateEventHandler Invalidated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InvalidateEventHandler Invalidated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Invalidated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Invalidated As InvalidateEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InvalidateEventHandler ^ Invalidated;" />
      <MemberSignature Language="F#" Value="member this.Invalidated : System.Windows.Forms.InvalidateEventHandler " Usage="member this.Invalidated : System.Windows.Forms.InvalidateEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InvalidateEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда для отображения элемента управления требуется перерисовка.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Control.Invalidated>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа, который наследует от <xref:System.Windows.Forms.Control>, например <xref:System.Windows.Forms.Button> или <xref:System.Windows.Forms.ComboBox>. Затем присвойте экземпляру имя `Control1` и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Control.Invalidated>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#40)]
 [!code-vb[System.Windows.Forms.EventExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#40)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет делегат в том потоке, которому принадлежит базовый дескриптор окна элемента управления.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate -&gt; obj" Usage="control.Invoke method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Делегат, содержащий метод, который требуется вызывать в контексте потока элемента управления.</param>
        <summary>Выполняет указанный делегат в том потоке, которому принадлежит базовый дескриптор окна элемента управления.</summary>
        <returns>Значение, возвращаемое вызываемым делегатом, или значение <see langword="null" />, если делегат не возвращает никакого значения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегаты похожи на указатели функций в C C++ или языках. Делегаты инкапсулируют ссылку на метод внутри объекта делегата. Затем объект делегата может быть передан в код, вызывающий упоминаемый метод, а вызываемый метод может быть неизвестным во время компиляции. В отличие от указателей на функции C++в C или делегаты являются объектно-ориентированными, строго типизированными и более безопасными.  
  
 Метод <xref:System.Windows.Forms.Control.Invoke%2A> выполняет поиск по родительской цепочке элемента управления до тех пор, пока не найдет элемент управления или форму, которые имеют обработчик окна, если его базовый маркер окна текущего элемента управления еще не существует. Если не удается найти соответствующий обработчик, метод <xref:System.Windows.Forms.Control.Invoke%2A> выдаст исключение. Исключения, возникающие во время вызова, передаются обратно вызывающему объекту.  
  
> [!NOTE]
>  В дополнение к свойству <xref:System.Windows.Forms.Control.InvokeRequired%2A> существуют четыре метода в элементе управления, которые являются потокобезопасными: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> и <xref:System.Windows.Forms.Control.CreateGraphics%2A>, если уже был создан маркер для элемента управления. Вызов <xref:System.Windows.Forms.Control.CreateGraphics%2A> перед созданием маркера элемента управления в фоновом потоке может привести к недопустимым перекрестным вызовам потоков. Для всех остальных вызовов методов следует использовать один из методов Invoke для маршалирования вызова в поток элемента управления.  
  
 Делегат может быть экземпляром <xref:System.EventHandler>. в этом случае параметр sender будет содержать этот элемент управления, а параметр события будет содержать <xref:System.EventArgs.Empty?displayProperty=nameWithType>. Делегат также может быть экземпляром <xref:System.Windows.Forms.MethodInvoker> или любым другим делегатом, принимающим список параметров void. Вызов делегата <xref:System.EventHandler> или <xref:System.Windows.Forms.MethodInvoker> будет выполняться быстрее, чем вызов другого типа делегата.  
  
> [!NOTE]
>  Исключение может быть вызвано, если поток, который должен обработать сообщение, больше не активен.  
  
   
  
## Examples  
 В следующем примере кода показаны элементы управления, которые содержат делегат. Делегат инкапсулирует метод, который добавляет элементы в список, и этот метод выполняется в потоке, владеющем базовым маркером формы. Когда пользователь нажимает кнопку, `Invoke` запускает делегат.  
  
 [!code-cpp[Control_Invoke2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke2/CPP/control_invoke2.cpp#1)]
 [!code-csharp[Control_Invoke2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke2/CS/control_invoke2.cs#1)]
 [!code-vb[Control_Invoke2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke2/VB/control_invoke2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MethodInvoker" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member Invoke : Delegate * obj[] -&gt; obj&#xA;override this.Invoke : Delegate * obj[] -&gt; obj" Usage="control.Invoke (method, args)" />
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, object[] args);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, args As Object()) As Object" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(Delegate ^ method, cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISynchronizeInvoke.Invoke(System.Delegate,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Делегат метода, принимающий параметры, количество и тип которых являются такими же, что и в параметре <paramref name="args" />.</param>
        <param name="args">Массив объектов, передаваемых в качестве аргументов указанному методу. Данный параметр может иметь значение <see langword="null" />, если метод не принимает аргументы.</param>
        <summary>Выполняет указанный делегат в том потоке, которому принадлежит основной дескриптор окна элемента управления, с указанным списком аргументов.</summary>
        <returns>Объект <see cref="T:System.Object" />, содержащий возвращаемое значение от вызываемого делегата, или значение <see langword="null" />, если делегат не имеет возвращаемого значения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Делегаты похожи на указатели функций в C C++ или языках. Делегаты инкапсулируют ссылку на метод внутри объекта делегата. Затем объект делегата может быть передан в код, вызывающий упоминаемый метод, а вызываемый метод может быть неизвестным во время компиляции. В отличие от указателей на функции C++в C или делегаты являются объектно-ориентированными, строго типизированными и более безопасными.  
  
 Если маркер элемента управления еще не существует, этот метод выполняет поиск по родительской цепочке элемента управления до тех пор, пока не обнаружит элемент управления или форму, у которых есть обработчик окна. Если не удается найти соответствующий обработчик, этот метод выдает исключение. Исключения, возникающие во время вызова, передаются обратно вызывающему объекту.  
  
> [!NOTE]
>  В дополнение к свойству <xref:System.Windows.Forms.Control.InvokeRequired%2A> существуют четыре метода в элементе управления, которые являются потокобезопасными: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> и <xref:System.Windows.Forms.Control.CreateGraphics%2A>, если уже был создан маркер для элемента управления. Вызов <xref:System.Windows.Forms.Control.CreateGraphics%2A> перед созданием маркера элемента управления в фоновом потоке может привести к недопустимым перекрестным вызовам потоков. Для всех остальных вызовов методов следует использовать один из методов Invoke для маршалирования вызова в поток элемента управления.  
  
 Делегат может быть экземпляром <xref:System.EventHandler>. в этом случае параметр sender будет содержать этот элемент управления, а параметр события будет содержать <xref:System.EventArgs.Empty?displayProperty=nameWithType>. Делегат также может быть экземпляром <xref:System.Windows.Forms.MethodInvoker> или любым другим делегатом, принимающим список параметров void. Вызов делегата <xref:System.EventHandler> или <xref:System.Windows.Forms.MethodInvoker> будет выполняться быстрее, чем вызов другого типа делегата.  
  
> [!NOTE]
>  Исключение может быть вызвано, если поток, который должен обработать сообщение, больше не активен.  
  
   
  
## Examples  
 В следующем примере кода показаны элементы управления, которые содержат делегат. Делегат инкапсулирует метод, который добавляет элементы в список, и этот метод выполняется в потоке, который владеет базовым маркером формы, используя указанные аргументы. Когда пользователь нажимает кнопку, `Invoke` запускает делегат.  
  
 [!code-cpp[Control_Invoke1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke1/CPP/control_invoke1.cpp#1)]
 [!code-csharp[Control_Invoke1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke1/CS/control_invoke1.cs#1)]
 [!code-vb[Control_Invoke1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke1/VB/control_invoke1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MethodInvoker" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="InvokeGotFocus">
      <MemberSignature Language="C#" Value="protected void InvokeGotFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeGotFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeGotFocus (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeGotFocus(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeGotFocus : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeGotFocus (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">Объект <see cref="T:System.Windows.Forms.Control" />, которому следует назначить событие.</param>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.GotFocus" /> для указанного элемента управления.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeLostFocus">
      <MemberSignature Language="C#" Value="protected void InvokeLostFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeLostFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeLostFocus (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeLostFocus(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeLostFocus : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeLostFocus (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">Объект <see cref="T:System.Windows.Forms.Control" />, которому следует назначить событие.</param>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.LostFocus" /> для указанного элемента управления.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeOnClick">
      <MemberSignature Language="C#" Value="protected void InvokeOnClick (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeOnClick(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeOnClick (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeOnClick(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeOnClick : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeOnClick (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">Объект <see cref="T:System.Windows.Forms.Control" />, которому следует назначить событие <see cref="E:System.Windows.Forms.Control.Click" />.</param>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Click" /> для указанного элемента управления.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokePaint">
      <MemberSignature Language="C#" Value="protected void InvokePaint (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaint(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokePaint (c As Control, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokePaint(System::Windows::Forms::Control ^ c, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokePaint : System.Windows.Forms.Control * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.InvokePaint (c, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c">Объект <see cref="T:System.Windows.Forms.Control" />, которому следует назначить событие <see cref="E:System.Windows.Forms.Control.Paint" />.</param>
        <param name="e">Объект класса <see cref="T:System.Windows.Forms.PaintEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Paint" /> для указанного элемента управления.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="InvokePaintBackground">
      <MemberSignature Language="C#" Value="protected void InvokePaintBackground (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaintBackground(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokePaintBackground (c As Control, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokePaintBackground(System::Windows::Forms::Control ^ c, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokePaintBackground : System.Windows.Forms.Control * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.InvokePaintBackground (c, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c">Объект <see cref="T:System.Windows.Forms.Control" />, которому следует назначить событие <see cref="E:System.Windows.Forms.Control.Paint" />.</param>
        <param name="e">Объект класса <see cref="T:System.Windows.Forms.PaintEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see langword="PaintBackground" /> для указанного элемента управления.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeRequired">
      <MemberSignature Language="C#" Value="public bool InvokeRequired { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InvokeRequired" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.InvokeRequired" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InvokeRequired As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InvokeRequired { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.InvokeRequired : bool" Usage="System.Windows.Forms.Control.InvokeRequired" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ISynchronizeInvoke.InvokeRequired</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, следует ли вызывающему оператору обращаться к методу invoke во время вызовов метода из элемента управления, так как вызывающий оператор находится не в том потоке, в котором был создан элемент управления.</summary>
        <value>Значение <see langword="true" />, если свойство <see cref="P:System.Windows.Forms.Control.Handle" /> элемента управления было создано не в вызывающем потоке, а в другом (показывает, что необходимо вызвать элемент управления через метод invoke); в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы управления в Windows Forms привязаны к определенному потоку и не являются потокобезопасными. Поэтому при вызове метода элемента управления из другого потока необходимо использовать один из методов Invoke элемента управления для маршалирования вызова в нужный поток. Это свойство можно использовать для определения необходимости вызова метода Invoke, который может быть полезен, если неизвестно, какой поток владеет элементом управления.  
  
> [!NOTE]
>  В дополнение к свойству <xref:System.Windows.Forms.Control.InvokeRequired%2A> в элементе управления, который является потокобезопасным для вызова, существуют четыре метода: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> и <xref:System.Windows.Forms.Control.CreateGraphics%2A>, если уже был создан обработчик для элемента управления. Вызов <xref:System.Windows.Forms.Control.CreateGraphics%2A> перед созданием маркера элемента управления в фоновом потоке может привести к недопустимым перекрестным вызовам потоков. Для всех остальных вызовов методов следует использовать один из этих методов Invoke при вызове из другого потока.  
  
 Если маркер элемента управления еще не существует, <xref:System.Windows.Forms.Control.InvokeRequired%2A> выполняет поиск по родительской цепочке элемента управления до тех пор, пока не обнаружит элемент управления или форму, у которых есть обработчик окна. Если не удается найти соответствующий обработчик, метод <xref:System.Windows.Forms.Control.InvokeRequired%2A> возвращает `false`.  
  
 Это означает, что <xref:System.Windows.Forms.Control.InvokeRequired%2A> может возвращать `false`, если <xref:System.Windows.Forms.Control.Invoke%2A> не требуется (вызов происходит в том же потоке) или если элемент управления был создан в другом потоке, но его обработчик еще не создан.  
  
 В случае, когда маркер элемента управления еще не был создан, не следует просто вызывать свойства, методы или события в элементе управления. Это может привести к тому, что маркер элемента управления будет создан в фоновом потоке, изолируя элемент управления в потоке без конвейера сообщений и не делая приложение нестабильным.  
  
 Для защиты в этом случае можно также проверить значение <xref:System.Windows.Forms.Control.IsHandleCreated%2A>, если <xref:System.Windows.Forms.Control.InvokeRequired%2A> возвращает `false` в фоновом потоке. Если управляющий элемент еще не создан, перед вызовом <xref:System.Windows.Forms.Control.Invoke%2A> или <xref:System.Windows.Forms.Control.BeginInvoke%2A> необходимо подождать, пока он не будет создан. Как правило, это происходит только в том случае, если фоновый поток создается в конструкторе основной формы для приложения (как в `Application.Run(new MainForm())`, перед отображением формы или при вызове `Application.Run`.  
  
 Одним из решений является ожидание создания маркера формы перед запуском фонового потока. Либо принудительное создание обработчика путем вызова свойства <xref:System.Windows.Forms.Control.Handle%2A>, либо подождите, пока событие <xref:System.Windows.Forms.Form.Load> не запустит фоновый процесс.  
  
 Еще лучшим решением является использование `SynchronizationContext`, возвращаемого <xref:System.Threading.SynchronizationContext>, а не элемента управления для маршалинга между потоками.  
  
> [!NOTE]
>  Исключение может быть вызвано, если поток, который должен обработать сообщение, больше не активен.  
  
 Дополнительные сведения о многопоточных Windows Formsных элементах управления см. в разделе [How to: Используйте фоновый поток для поиска файлов @ no__t-0 и [How в: Сделайте потокобезопасные вызовы Windows Forms элементов управления @ no__t-0.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsAccessible">
      <MemberSignature Language="C#" Value="public bool IsAccessible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAccessible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsAccessible" />
      <MemberSignature Language="VB.NET" Value="Public Property IsAccessible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAccessible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsAccessible : bool with get, set" Usage="System.Windows.Forms.Control.IsAccessible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, является ли элемент управления видимым для приложений со специальными возможностями.</summary>
        <value>Значение <see langword="true" />, если элемент управления является видимым для приложений со специальными возможностями; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Windows.Forms.Control.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, был ли удален элемент управления.</summary>
        <value>Значение <see langword="true" />, если элемент был удален; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда это свойство возвращает `true`, элемент управления удаляется и на него нельзя ссылаться как на допустимый элемент управления Windows. Хотя экземпляр элемента управления удаляется, он по-прежнему сохраняется в памяти до тех пор, пока он не будет удален из памяти с помощью сборки мусора. При удалении элемента управления нельзя вызвать его метод <xref:System.Windows.Forms.Control.RecreateHandle%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
        <altmember cref="T:System.GC" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="IsHandleCreated">
      <MemberSignature Language="C#" Value="public bool IsHandleCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHandleCreated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsHandleCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHandleCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHandleCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHandleCreated : bool" Usage="System.Windows.Forms.Control.IsHandleCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, имеется ли у элемента управления связанный с ним дескриптор.</summary>
        <value>Значение <see langword="true" />, если элементу управления был назначен дескриптор; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы определить, вызвано ли <xref:System.Windows.Forms.Control.CreateHandle%2A>, используйте свойство <xref:System.Windows.Forms.Control.IsHandleCreated%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="IsInputChar">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsInputChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsInputChar(char charCode);" />
      <MemberSignature Language="F#" Value="abstract member IsInputChar : char -&gt; bool&#xA;override this.IsInputChar : char -&gt; bool" Usage="control.IsInputChar charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Проверяемый символ.</param>
        <summary>Определяет, является ли символ входным символом, который распознается элементом управления.</summary>
        <returns>Значение <see langword="true" />, если символ должен быть отправлен непосредственно в элемент управления без предварительной обработки; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод <xref:System.Windows.Forms.Control.IsInputChar%2A>, чтобы определить, является ли символ, заданный параметром `charCode`, входным символом, который требуется элементу управления. Этот метод вызывается во время предварительной обработки сообщения окна, чтобы определить, следует ли предварительно обработать указанный входной символ или отправить его непосредственно в элемент управления. Если <xref:System.Windows.Forms.Control.IsInputChar%2A> возвращает `true`, указанный символ отправляется непосредственно в элемент управления. Если <xref:System.Windows.Forms.Control.IsInputChar%2A> возвращает `false`, то указанный символ предварительно обрабатывается и отправляется в элемент управления только в том случае, если он не занят этапом предварительной обработки. Предварительная обработка символа включает проверку того, является ли символ назначенным другим элементом управления.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон наследуемых классов для вызова этого метода. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="IsInputKey">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsInputKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsInputKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member IsInputKey : System.Windows.Forms.Keys -&gt; bool&#xA;override this.IsInputKey : System.Windows.Forms.Keys -&gt; bool" Usage="control.IsInputKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Одно из значений перечисления <see cref="T:System.Windows.Forms.Keys" />.</param>
        <summary>Определяет, является ли заданная клавиша обычной клавишей ввода или специальной клавишей, нуждающейся в предварительной обработке.</summary>
        <returns>Значение <see langword="true" />, если указанная клавиша является стандартной клавишей ввода; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод <xref:System.Windows.Forms.Control.IsInputKey%2A>, чтобы определить, является ли ключ, заданный параметром `keyData`, входным ключом, который требуется элементу управления. Этот метод вызывается во время предварительной обработки сообщения окна, чтобы определить, следует ли предварительно обработать указанный входной ключ или отправить его непосредственно в элемент управления. Если <xref:System.Windows.Forms.Control.IsInputKey%2A> возвращает `true`, указанный ключ отправляется непосредственно в элемент управления. Если <xref:System.Windows.Forms.Control.IsInputKey%2A> возвращает `false`, то указанный ключ предварительно обрабатывается и отправляется в элемент управления только в том случае, если он не занят этапом предварительной обработки. К предварительно обработанным ключам относятся TAB, RETURN, ESC и стрелка вверх, стрелка вниз, стрелка влево и клавиши со СТРЕЛКАми вправо.  
  
   
  
## Examples  
 В следующем примере кода показано, как переопределить метод <xref:System.Windows.Forms.Control.IsInputKey%2A> для элемента управления <xref:System.Windows.Forms.TextBox>. В этом примере класс `TabTextBox` обрабатывает клавишу TAB. Когда `TabTextBox` имеет фокус и пользователь нажимает клавишу TAB, в точку вставки текста добавляется четыре пробела, заменяя любой выделенный текст. По умолчанию элемент управления <xref:System.Windows.Forms.TextBox> обрабатывает клавишу TAB, перемещая фокус ввода на следующий элемент управления. В этом случае нажатие клавиши никогда не достигает переопределения метода <xref:System.Windows.Forms.Control.OnKeyDown%2A>. Чтобы предотвратить это поведение по умолчанию, переопределение метода <xref:System.Windows.Forms.Control.IsInputKey%2A> возвращает `true`, когда пользователь нажимает клавишу TAB. Для всех других нажатий клавиш переопределение метода <xref:System.Windows.Forms.Control.IsInputKey%2A> возвращает результат вызова версии базового класса метода.  
  
 [!code-csharp[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/cs/form1.cs#0)]
 [!code-vb[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/vb/form1.vb#0)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон наследуемых классов для вызова этого метода. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="T:System.Windows.Forms.Keys" />
        <altmember cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
        <altmember cref="P:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyLocked">
      <MemberSignature Language="C#" Value="public static bool IsKeyLocked (System.Windows.Forms.Keys keyVal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKeyLocked(valuetype System.Windows.Forms.Keys keyVal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsKeyLocked(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsKeyLocked (keyVal As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsKeyLocked(System::Windows::Forms::Keys keyVal);" />
      <MemberSignature Language="F#" Value="static member IsKeyLocked : System.Windows.Forms.Keys -&gt; bool" Usage="System.Windows.Forms.Control.IsKeyLocked keyVal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyVal" Type="System.Windows.Forms.Keys" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="keyVal">Элемент перечисления <see cref="T:System.Windows.Forms.Keys" />: CAPS LOCK, NUM LOCK или SCROLL LOCK.</param>
        <summary>Определяет, задействованы ли клавиши CAPS LOCK, NUM LOCK или SCROLL LOCK.</summary>
        <returns>Значение <see langword="true" />, если указанные клавиши задействованы, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте свойство <xref:System.Windows.Forms.Control.IsKeyLocked%2A>, чтобы определить, включены ли ключи CAPS LOCK, NUM LOCK или SCROLL LOCK, будь то по отдельности или в сочетании.  
  
   
  
## Examples  
 В следующем примере кода отображается окно сообщения, показывающее, действует ли указанный ключ (в данном случае это ключ Caps Lock).  
  
 [!code-cpp[ControlIsKeyLocked#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlIsKeyLocked/CPP/controliskeylocked.cpp#1)]
 [!code-csharp[ControlIsKeyLocked#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlIsKeyLocked/CS/controliskeylocked.cs#1)]
 [!code-vb[ControlIsKeyLocked#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlIsKeyLocked/VB/controliskeylocked.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Параметр <paramref name="keyVal" /> относится к клавишам, отличным от клавиш CAPS LOCK, NUM LOCK или SCROLL LOCK.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMirrored">
      <MemberSignature Language="C#" Value="public bool IsMirrored { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMirrored" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsMirrored" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMirrored As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMirrored { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMirrored : bool" Usage="System.Windows.Forms.Control.IsMirrored" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, отображается ли зеркально элемент управления.</summary>
        <value>Значение <see langword="true" />, если данный элемент управления отображается зеркально; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Зеркальный элемент управления отображает как макет, так и текст справа налево. Дополнительные сведения см. в разделе [Практическое руководство. Создайте зеркальную Windows Forms и элементы управления @ no__t-0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMnemonic">
      <MemberSignature Language="C#" Value="public static bool IsMnemonic (char charCode, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMnemonic(char charCode, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMnemonic (charCode As Char, text As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMnemonic(char charCode, System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member IsMnemonic : char * string -&gt; bool" Usage="System.Windows.Forms.Control.IsMnemonic (charCode, text)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="charCode">Проверяемый символ.</param>
        <param name="text">Строка для поиска.</param>
        <summary>Определяет, является ли указанный символ назначенным символом для элемента управления в заданной строке.</summary>
        <returns>Значение <see langword="true" />, если символ <paramref name="charCode" /> является назначенным символом для элемента управления; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Назначенный символ — это символ, непосредственно следующий за первым экземпляром "&" в <xref:System.String>.  
  
   
  
## Examples  
 В следующем примере кода показано расширение класса Button, которое переопределяет метод <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> для отображения пользовательского поведения. В примере также демонстрируется использование свойств <xref:System.Windows.Forms.Control.CanSelect%2A> и <xref:System.Windows.Forms.Control.IsMnemonic%2A>. Чтобы выполнить этот пример, вставьте следующий код после класса Form в тот же файл. Добавьте в форму кнопку типа `MnemonicButton`.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон наследуемых классов для вызова этого метода. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Forms.KeyEventHandler " Usage="member this.KeyDown : System.Windows.Forms.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при нажатии клавиши, если элемент управления имеет фокус.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ключевые события происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Чтобы обрабатывать события клавиатуры только на уровне формы и не включать другие элементы управления для получения событий клавиатуры, установите свойство <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> в форме <xref:System.Windows.Forms.Control.KeyPress> метода обработки событий в `true`. Некоторые клавиши, такие как TAB, RETURN, ESC и клавиши со стрелками, автоматически обрабатываются элементами управления. Чтобы эти ключи вызывали событие <xref:System.Windows.Forms.Control.KeyDown>, необходимо переопределить метод <xref:System.Windows.Forms.Control.IsInputKey%2A> в каждом элементе управления формы. Код переопределения <xref:System.Windows.Forms.Control.IsInputKey%2A> должен определить, нажата ли одна из специальных клавиш, и вернуть значение `true`. Вместо переопределения метода <xref:System.Windows.Forms.Control.IsInputKey%2A> можно выполнить обработку события <xref:System.Windows.Forms.Control.PreviewKeyDown> и задать для свойства <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> значение `true`. Пример кода см. в описании события <xref:System.Windows.Forms.Control.PreviewKeyDown>.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода используется событие <xref:System.Windows.Forms.Control.KeyDown> для определения типа символа, введенного в элемент управления.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
 
 
 В следующем примере кода демонстрируется порядок создания событий <xref:System.Windows.Forms.Control.KeyDown>, <xref:System.Windows.Forms.Control.KeyUp>, <xref:System.Windows.Forms.Control.KeyPress>, а также способы регистрации обработчиков событий на них.  
 
 [!code-csharp[Control.KeyDown#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form2.cs#1)]
 [!code-vb[Control.KeyDown#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/Form2.vb#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.KeyEventArgs" />
        <altmember cref="T:System.Windows.Forms.KeyEventHandler" />
        <altmember cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyPressEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyPressEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyPress As KeyPressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyPressEventHandler ^ KeyPress;" />
      <MemberSignature Language="F#" Value="member this.KeyPress : System.Windows.Forms.KeyPressEventHandler " Usage="member this.KeyPress : System.Windows.Forms.KeyPressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyPressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при нажатии клавиши с буквой, пробела или клавиши BACKSPACE, если фокус находится в элементе управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ключевые события происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Событие <xref:System.Windows.Forms.Control.KeyPress> не вызывается несимвольными ключами, отличными от пробела и Backspace; Тем не менее, несимвольные ключи вызывают события <xref:System.Windows.Forms.Control.KeyDown> и <xref:System.Windows.Forms.Control.KeyUp>.  
  
 Используйте свойство <xref:System.Windows.Forms.KeyPressEventArgs.KeyChar%2A> для выборки нажатий клавиш во время выполнения и для использования или изменения подмножества распространенных нажатий клавиш.  
  
 Чтобы обрабатывать события клавиатуры только на уровне формы и не включать другие элементы управления для получения событий клавиатуры, установите свойство <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> в форме <xref:System.Windows.Forms.Control.KeyPress> метода обработки событий в `true`.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода используется событие <xref:System.Windows.Forms.Control.KeyPress> для предотвращения ввода символов в элемент управления.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
 
 
  В следующем примере кода демонстрируется порядок возрастания событий <xref:System.Windows.Forms.Control.KeyDown>, <xref:System.Windows.Forms.Control.KeyUp> и <xref:System.Windows.Forms.Control.KeyPress>, а также способы регистрации обработчиков событий на них.  
 
 [!code-csharp[Control.KeyPress#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form2.cs#1)]
 [!code-vb[Control.KeyPress#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/Form2.vb#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.KeyPressEventArgs.KeyChar" />
        <altmember cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Forms.KeyEventHandler " Usage="member this.KeyUp : System.Windows.Forms.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда отпускается клавиша, если элемент управления имеет фокус.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ключевые события происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Чтобы обрабатывать события клавиатуры только на уровне формы и не включать другие элементы управления для получения событий клавиатуры, установите свойство <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> в форме <xref:System.Windows.Forms.Control.KeyPress> метода обработки событий в `true`. Некоторые клавиши, такие как TAB, RETURN, ESC и клавиши со стрелками, автоматически обрабатываются элементами управления. Чтобы эти ключи вызывали событие <xref:System.Windows.Forms.Control.KeyUp>, необходимо переопределить метод <xref:System.Windows.Forms.Control.IsInputKey%2A> в каждом элементе управления формы. Код переопределения <xref:System.Windows.Forms.Control.IsInputKey%2A> должен определить, нажата ли одна из специальных клавиш, и вернуть значение `true`.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода используется событие <xref:System.Windows.Forms.Control.KeyUp> с классом <xref:System.Windows.Forms.Help> для отображения справки о стиле всплывающего окна для пользователя.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
 
 
  В следующем примере кода демонстрируется порядок возрастания событий <xref:System.Windows.Forms.Control.KeyDown>, <xref:System.Windows.Forms.Control.KeyUp> и <xref:System.Windows.Forms.Control.KeyPress>, а также способы регистрации обработчиков событий на них.  
 
 [!code-csharp[Control.KeyUp#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form2.cs#1)]
 [!code-vb[Control.KeyUp#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/Form2.vb#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="Layout">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LayoutEventHandler Layout;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LayoutEventHandler Layout" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Layout" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Layout As LayoutEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::LayoutEventHandler ^ Layout;" />
      <MemberSignature Language="F#" Value="member this.Layout : System.Windows.Forms.LayoutEventHandler " Usage="member this.Layout : System.Windows.Forms.LayoutEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LayoutEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда необходимо изменить позицию дочерних элементов управления данного элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие <xref:System.Windows.Forms.Control.Layout> возникает при добавлении или удалении дочерних элементов управления, при изменении границ элемента управления и при возникновении других изменений, которые могут повлиять на макет элемента управления. Событие макета можно подавлять с помощью методов <xref:System.Windows.Forms.Control.SuspendLayout%2A> и <xref:System.Windows.Forms.Control.ResumeLayout%2A>. Приостановка макета позволяет выполнять несколько действий с элементом управления без необходимости выполнять макет для каждого изменения. Например, при изменении размера и перемещении элемента управления каждая операция вызовет событие <xref:System.Windows.Forms.Control.Layout>.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как по центру <xref:System.Windows.Forms.Form> на экране в событии <xref:System.Windows.Forms.Control.Layout>. При этом форма будет находиться в центре по мере ее изменения пользователем. Для этого примера требуется, чтобы был создан элемент управления <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
      </Docs>
    </Member>
    <Member MemberName="LayoutEngine">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Layout.LayoutEngine LayoutEngine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Layout.LayoutEngine LayoutEngine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.LayoutEngine" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LayoutEngine As LayoutEngine" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Layout::LayoutEngine ^ LayoutEngine { System::Windows::Forms::Layout::LayoutEngine ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LayoutEngine : System.Windows.Forms.Layout.LayoutEngine" Usage="System.Windows.Forms.Control.LayoutEngine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Layout.LayoutEngine</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кэшированный экземпляр механизма размещения элемента управления.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.Layout.LayoutEngine" /> для содержимого элемента управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.LayoutEngine%2A> получает обработчик макета для дочерних элементов элемента управления, а не для самого элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Layout.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public event EventHandler Leave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Leave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Leave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Leave;" />
      <MemberSignature Language="F#" Value="member this.Leave : EventHandler " Usage="member this.Leave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда фокус ввода покидает элемент управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При изменении фокуса с помощью клавиатуры (TAB, SHIFT + TAB и т. д.), вызывая методы <xref:System.Windows.Forms.Control.Select%2A> или <xref:System.Windows.Forms.Control.SelectNextControl%2A> или устанавливая свойство <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> в текущую форму, события фокуса происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 При изменении фокуса с помощью мыши или при вызове метода <xref:System.Windows.Forms.Control.Focus%2A> события фокуса происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Если свойство <xref:System.Windows.Forms.Control.CausesValidation%2A> имеет значение `false`, события <xref:System.Windows.Forms.Control.Validating> и <xref:System.Windows.Forms.Control.Validated> подавляются.  
  
> [!NOTE]
>  События <xref:System.Windows.Forms.Control.Enter> и <xref:System.Windows.Forms.Control.Leave> подавляются классом <xref:System.Windows.Forms.Form>. Эквивалентными событиями в классе <xref:System.Windows.Forms.Form> являются события <xref:System.Windows.Forms.Form.Activated> и <xref:System.Windows.Forms.Form.Deactivate>. События <xref:System.Windows.Forms.Control.Enter> и <xref:System.Windows.Forms.Control.Leave> являются иерархическими и будут каскадными и вниз по родительской цепочке до тех пор, пока не будет достигнут соответствующий элемент управления. Например, предположим, что имеется <xref:System.Windows.Forms.Form> с двумя элементами управления <xref:System.Windows.Forms.GroupBox>, и каждый элемент управления <xref:System.Windows.Forms.GroupBox> имеет один элемент управления <xref:System.Windows.Forms.TextBox>. Когда курсор перемещается из одного <xref:System.Windows.Forms.TextBox> в другой, возникает событие <xref:System.Windows.Forms.Control.Leave> для <xref:System.Windows.Forms.TextBox> и <xref:System.Windows.Forms.GroupBox>, а для других <xref:System.Windows.Forms.GroupBox> и <xref:System.Windows.Forms.TextBox> возникает событие <xref:System.Windows.Forms.Control.Enter>.  
  
> [!CAUTION]
>  Не пытайтесь установить фокус с помощью обработчиков событий <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating> или <xref:System.Windows.Forms.Control.Validated>. Это может привести к тому, что ваше приложение или операционная система перестанут отвечать. Дополнительные сведения см. в разделе [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) .  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода событие <xref:System.Windows.Forms.Control.Leave> используется для сброса элемента управления до его предыдущего состояния.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public int Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Left { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Left : int with get, set" Usage="System.Windows.Forms.Control.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает расстояние в пикселях между левой границей элемента управления и левой границей клиентской области его контейнера.</summary>
        <value>Объект <see cref="T:System.Int32" />, представляющий расстояние (в пикселях) между левой границей элемента управления и левой границей клиентской области контейнера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение свойства <xref:System.Windows.Forms.Control.Left%2A> эквивалентно свойству <xref:System.Drawing.Point.X%2A?displayProperty=nameWithType> значения свойства элемента управления <xref:System.Windows.Forms.Control.Location%2A>.  
  
 Изменения, внесенные в значения свойств <xref:System.Windows.Forms.Control.Width%2A> и <xref:System.Windows.Forms.Control.Left%2A>, приводят к изменению значения свойства <xref:System.Windows.Forms.Control.Right%2A> элемента управления.  
  
   
  
## Examples  
 В следующем примере кода создаются три элемента управления <xref:System.Windows.Forms.Button> в форме и задаются их размер и расположение с использованием различных свойств, связанных с размером и расположением. В этом примере требуется наличие <xref:System.Windows.Forms.Form> с шириной и высотой не менее 300 пикселей.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Point.X" />
        <altmember cref="P:System.Windows.Forms.Control.Right" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Location" />
      <MemberSignature Language="VB.NET" Value="Public Property Location As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point Location { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.Location : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Control.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает координаты левого верхнего угла элемента управления относительно левого верхнего угла его контейнера.</summary>
        <value>Объект <see cref="T:System.Drawing.Point" />, представляющий левый верхний угол элемента управления относительно левого верхнего угла контейнера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поскольку класс <xref:System.Drawing.Point> является типом значения (`Structure` в Visual Basic, `struct` в Visual C#), он возвращается по значению, что означает, что доступ к свойству возвращает копию верхней левой точки элемента управления. Таким образом, Настройка свойств <xref:System.Drawing.Point.X%2A> или <xref:System.Drawing.Point.Y%2A> для <xref:System.Drawing.Point>, возвращаемых из этого свойства, не повлияет на значения свойств элемента управления <xref:System.Windows.Forms.Control.Left%2A>, <xref:System.Windows.Forms.Control.Right%2A>, <xref:System.Windows.Forms.Control.Top%2A> или <xref:System.Windows.Forms.Control.Bottom%2A>. Чтобы настроить эти свойства, задавайте каждое значение свойства отдельно или задайте для свойства <xref:System.Windows.Forms.Control.Location%2A> новое <xref:System.Drawing.Point>.  
  
 Если <xref:System.Windows.Forms.Control> является <xref:System.Windows.Forms.Form>, значение свойства <xref:System.Windows.Forms.Control.Location%2A> представляет верхний левый угол <xref:System.Windows.Forms.Form> в координатах экрана.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.GroupBox> и задаются некоторые общие свойства. В примере создается <xref:System.Windows.Forms.TextBox> и задается его <xref:System.Windows.Forms.Control.Location%2A> в поле группы. Затем задается свойство <xref:System.Windows.Forms.Control.Text%2A> поля группы и закрепляет поле группы в верхней части формы. Наконец, он отключает поле группы, присвоив свойству <xref:System.Windows.Forms.Control.Enabled%2A> значение `false`, что приводит к отключению всех элементов управления, содержащихся в поле группы.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, если значение свойства <see cref="P:System.Windows.Forms.Control.Location" /> было изменено.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.Location%2A> изменено с помощью программного изменения или взаимодействия.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Следующий пример кода вызывает событие <xref:System.Windows.Forms.Control.LocationChanged> в <xref:System.Windows.Forms.StatusStrip> при изменении размера формы.  
  
 [!code-csharp[System.Windows.Forms.LocationChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.LocationChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="LogicalToDeviceUnits">
      <MemberSignature Language="C#" Value="public System.Drawing.Size LogicalToDeviceUnits (System.Drawing.Size value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Size LogicalToDeviceUnits(valuetype System.Drawing.Size value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.LogicalToDeviceUnits(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogicalToDeviceUnits (value As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Size LogicalToDeviceUnits(System::Drawing::Size value);" />
      <MemberSignature Language="F#" Value="member this.LogicalToDeviceUnits : System.Drawing.Size -&gt; System.Drawing.Size" Usage="control.LogicalToDeviceUnits value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Drawing.Size" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Размер для масштабирования.</param>
        <summary>Преобразует размер из логических единиц в единицы устройства путем его масштабирования к текущему DPI и округлением вниз до ближайшего целого значения ширины и высоты.</summary>
        <returns>Масштабированное значение размера.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalToDeviceUnits">
      <MemberSignature Language="C#" Value="public int LogicalToDeviceUnits (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LogicalToDeviceUnits(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.LogicalToDeviceUnits(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogicalToDeviceUnits (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LogicalToDeviceUnits(int value);" />
      <MemberSignature Language="F#" Value="member this.LogicalToDeviceUnits : int -&gt; int" Usage="control.LogicalToDeviceUnits value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Логическое значение для преобразования.</param>
        <summary>Преобразует логическое значение DPI в эквивалентное значение DPI DeviceUnit.</summary>
        <returns>Получившееся значение DeviceUnit.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event EventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : EventHandler " Usage="member this.LostFocus : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при потере фокуса элементом управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При изменении фокуса с помощью клавиатуры (TAB, SHIFT + TAB и т. д.), вызывая методы <xref:System.Windows.Forms.Control.Select%2A> или <xref:System.Windows.Forms.Control.SelectNextControl%2A> или устанавливая свойство <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> в текущую форму, события фокуса происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 При изменении фокуса с помощью мыши или при вызове метода <xref:System.Windows.Forms.Control.Focus%2A> события фокуса происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Если свойство <xref:System.Windows.Forms.Control.CausesValidation%2A> имеет значение `false`, события <xref:System.Windows.Forms.Control.Validating> и <xref:System.Windows.Forms.Control.Validated> подавляются.  
  
 Если свойство <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> <xref:System.ComponentModel.CancelEventArgs> имеет значение `true` в делегате события <xref:System.Windows.Forms.Control.Validating>, все события, которые обычно происходят после события <xref:System.Windows.Forms.Control.Validating>, подавляются.  
  
> [!NOTE]
>  События <xref:System.Windows.Forms.Control.GotFocus> и <xref:System.Windows.Forms.Control.LostFocus> являются событиями фокуса низкого уровня, которые привязаны к сообщениям Windows WM_KILLFOCUS и WM_SETFOCUS. Как правило, события <xref:System.Windows.Forms.Control.GotFocus> и <xref:System.Windows.Forms.Control.LostFocus> используются только при обновлении <xref:System.Windows.Forms.UICues> или при написании пользовательских элементов управления. Вместо этого события <xref:System.Windows.Forms.Control.Enter> и <xref:System.Windows.Forms.Control.Leave> должны использоваться для всех элементов управления, кроме класса <xref:System.Windows.Forms.Form>, который использует события <xref:System.Windows.Forms.Form.Activated> и <xref:System.Windows.Forms.Form.Deactivate>. Дополнительные сведения о событиях <xref:System.Windows.Forms.Control.GotFocus> и <xref:System.Windows.Forms.Control.LostFocus> см. в разделах [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) и [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) .  
  
> [!CAUTION]
>  Не пытайтесь установить фокус с помощью обработчиков событий <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating> или <xref:System.Windows.Forms.Control.Validated>. Это может привести к тому, что ваше приложение или операционная система перестанут отвечать. Дополнительные сведения см. в разделе [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) .  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как проверить текст для TextBox1. Он также демонстрирует обработку события <xref:System.Windows.Forms.Control.LostFocus>, присвоив свойству <xref:System.Windows.Forms.FileDialog.InitialDirectory%2A?displayProperty=nameWithType> текст в TextBox1. В примере кода используется метод <xref:System.Windows.Forms.ErrorProvider.GetError%2A?displayProperty=nameWithType> для проверки ошибки перед открытием диалогового окна файл. Чтобы выполнить этот пример, вставьте следующий код в форму, содержащую <xref:System.Windows.Forms.TextBox> с именем `TextBox1`, <xref:System.Windows.Forms.OpenFileDialog> с именем `OpenFileDialog1`, a <xref:System.Windows.Forms.Button> с именем `Button1` и <xref:System.Windows.Forms.ErrorProvider> с именем `ErrorProvider1`. Убедитесь, что все события связаны с их обработчиками событий.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#2)]
 [!code-csharp[System.Windows.Forms.FileDialog#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#2)]
 [!code-vb[System.Windows.Forms.FileDialog#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
        <altmember cref="E:System.Windows.Forms.Control.Leave" />
        <altmember cref="E:System.Windows.Forms.Form.Deactivate" />
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Margin { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.Control.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает расстояние между элементами управления.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.Padding" />, представляющий пустое пространство между элементами управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы управления получают значения по умолчанию для <xref:System.Windows.Forms.Control.Margin%2A>, которые достаточно близки к рекомендациям по пользовательскому интерфейсу Windows. Некоторые настройки могут быть необходимы для определенных приложений.  
  
> [!NOTE]
>  Установка свойства <xref:System.Windows.Forms.Control.Margin%2A> для закрепленного элемента управления не влияет на расстояние элемента управления от границ контейнера.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MarginChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MarginChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MarginChanged;" />
      <MemberSignature Language="F#" Value="member this.MarginChanged : EventHandler " Usage="member this.MarginChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении поля элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Control.MarginChanged>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа, который наследует от <xref:System.Windows.Forms.Control>, например <xref:System.Windows.Forms.Button> или <xref:System.Windows.Forms.ComboBox>. Затем присвойте экземпляру имя `Control1` и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Control.MarginChanged>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#21)]
 [!code-vb[System.Windows.Forms.EventExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MaximumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.MaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.AmbientValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает размер, являющийся верхней границей, которую может указать метод <see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />.</summary>
        <value>Упорядоченная пара типа <see cref="T:System.Drawing.Size" />, представляющая ширину и высоту прямоугольника.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MinimumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MinimumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.MinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает размер, являющийся нижней границей, которую может указать метод <see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />.</summary>
        <value>Упорядоченная пара типа <see cref="T:System.Drawing.Size" />, представляющая ширину и высоту прямоугольника.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifierKeys">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Keys ModifierKeys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.Keys ModifierKeys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ModifierKeys" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ModifierKeys As Keys" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Keys ModifierKeys { System::Windows::Forms::Keys get(); };" />
      <MemberSignature Language="F#" Value="member this.ModifierKeys : System.Windows.Forms.Keys" Usage="System.Windows.Forms.Control.ModifierKeys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Keys</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, какие из специальных клавиш (SHIFT, CTRL и ALT) нажаты в данный момент.</summary>
        <value>Поразрядное сочетание значений <see cref="T:System.Windows.Forms.Keys" />. Значение по умолчанию — <see cref="F:System.Windows.Forms.Keys.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода кнопка скрывается при нажатии клавиши CTRL во время щелчка кнопки. В этом примере требуется, чтобы в <xref:System.Windows.Forms.Form> имелся <xref:System.Windows.Forms.Button> с именем `button1`.  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Keys" />
      </Docs>
    </Member>
    <Member MemberName="MouseButtons">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.MouseButtons MouseButtons { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.MouseButtons MouseButtons" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MouseButtons" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MouseButtons As MouseButtons" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::MouseButtons MouseButtons { System::Windows::Forms::MouseButtons get(); };" />
      <MemberSignature Language="F#" Value="member this.MouseButtons : System.Windows.Forms.MouseButtons" Usage="System.Windows.Forms.Control.MouseButtons" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseButtons</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, какая из кнопок мыши нажата в данный момент.</summary>
        <value>Битовая комбинация значений перечисления <see cref="T:System.Windows.Forms.MouseButtons" />. Значение по умолчанию — <see cref="F:System.Windows.Forms.MouseButtons.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано, как использовать элементы <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType> и <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType>. Чтобы выполнить пример, вставьте следующий код в форму с именем Form1, содержащую несколько элементов управления. В этом примере требуется, чтобы события <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove> и <xref:System.Windows.Forms.Control.MouseUp> были подключены к обработчикам событий, определенным в примере.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MouseButtons" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseCaptureChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MouseCaptureChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseCaptureChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseCaptureChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseCaptureChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseCaptureChanged;" />
      <MemberSignature Language="F#" Value="member this.MouseCaptureChanged : EventHandler " Usage="member this.MouseCaptureChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при потере захвата мыши элементом управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В редких случаях может потребоваться обнаружить непредвиденные входные данные. Например, рассмотрим следующие сценарии.  
  
-   Во время операции мыши пользователь открывает меню Пуск, нажимая клавишу Windows или клавиши CTRL + ESC.  
  
-   При выполнении операции мыши пользователь переключается на другую программу, нажимая клавиши ALT + TAB.  
  
-   Во время операции мыши в другой программе отображается окно или сообщение, которое переводит фокус из текущего приложения.  
  
 Операции мыши могут включать щелчок и удержание мыши в форме или элементе управления или выполнение операции перетаскивания мышью. Если необходимо определить, когда форма или элемент управления теряет захват мыши для этих и связанных непредвиденных ситуаций, можно использовать событие <xref:System.Windows.Forms.Control.MouseCaptureChanged>.  
  
   
  
## Examples  
 В следующем примере кода показано событие <xref:System.Windows.Forms.Control.MouseCaptureChanged> для элемента управления <xref:System.Windows.Forms.Button>.  
  
 [!code-csharp[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/vb/form1.vb#1)]  
  
 Чтобы протестировать этот пример, запустите его в отладчике, нажав клавишу F5. Откройте окно **вывод** в Visual Studio, чтобы видеть, когда возникают события. Щелкните <xref:System.Windows.Forms.Button> и обратите внимание на следующие выходные данные.  
  
 `button1_MouseDown`  
  
 `button1_MouseUp`  
  
 `button1_MouseCaptureChanged`  
  
 Теперь щелкните и удерживайте левую кнопку мыши на элементе управления <xref:System.Windows.Forms.Button>. Удерживая нажатой кнопку мыши, нажмите клавиши ALT + TAB, чтобы переключиться на другую программу. Обратите внимание, что событие <xref:System.Windows.Forms.Control.MouseCaptureChanged> возникает, что позволяет справиться с этим сценарием. В зависимости от ваших действий событие <xref:System.Windows.Forms.Control.MouseUp> может быть не вызвано. Вы также можете испытать этот тест с помощью клавиши Windows или клавиш CTRL + ESC.  
  
 `button1_MouseDown`  
  
 `button1_MouseCaptureChanged`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseClick;" />
      <MemberSignature Language="F#" Value="member this.MouseClick : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseClick : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывается при щелчке мышью элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нажатие кнопки мыши при наведении курсора на элемент управления обычно вызывает следующую последовательность событий из элемента управления:  
  
1.  Событие<xref:System.Windows.Forms.Control.MouseDown> .  
  
2.  Событие<xref:System.Windows.Forms.Control.Click> .  
  
3.  Событие<xref:System.Windows.Forms.Control.MouseClick> .  
  
4.  Событие<xref:System.Windows.Forms.Control.MouseUp> .  
  
 В этом случае различные события не могут быть отключены в классе элемента управления.  
  
 Два щелчка, которые происходят достаточно близко по времени, как определено параметрами мыши в операционной системе пользователя, будут создавать событие <xref:System.Windows.Forms.Control.MouseDoubleClick> вместо второго события <xref:System.Windows.Forms.Control.MouseClick>.  
  
> [!IMPORTANT]
>  события <xref:System.Windows.Forms.Control.Click> являются логическими событиями более высокого уровня элемента управления. Они часто вызываются другими действиями, например нажатием клавиши ВВОД, когда фокус находится на элементе управления.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Control.MouseClick>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа, который наследует от <xref:System.Windows.Forms.Control>, например <xref:System.Windows.Forms.Button> или <xref:System.Windows.Forms.ComboBox>. Затем присвойте экземпляру имя `Control1` и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Control.MouseClick>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#54](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#54)]
 [!code-vb[System.Windows.Forms.EventExamples#54](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDoubleClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseDoubleClick;" />
      <MemberSignature Language="F#" Value="member this.MouseDoubleClick : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseDoubleClick : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывается при двойном щелчке мышью элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие <xref:System.Windows.Forms.Control.MouseDoubleClick> возникает, когда пользователь дважды нажимает кнопку мыши в быстром случае, когда курсор находится над элементом управления. Интервал времени, разделяющий два одинарных щелчка при двойном щелчке, определяется параметрами мыши операционной системы пользователя.  
  
 Элемент управления вызывает следующую последовательность событий при выполнении такого действия пользователя:  
  
1.  Событие<xref:System.Windows.Forms.Control.MouseDown> .  
  
2.  Событие<xref:System.Windows.Forms.Control.Click> .  
  
3.  Событие<xref:System.Windows.Forms.Control.MouseClick> .  
  
4.  Событие<xref:System.Windows.Forms.Control.MouseUp> .  
  
5.  Событие<xref:System.Windows.Forms.Control.MouseDown> .  
  
6.  Событие<xref:System.Windows.Forms.Control.DoubleClick> .  
  
7.  Событие<xref:System.Windows.Forms.Control.MouseDoubleClick> .  
  
8.  Событие<xref:System.Windows.Forms.Control.MouseUp> .  
  
 В этом случае различные события не могут быть отключены в классе элемента управления.  
  
> [!IMPORTANT]
>  события <xref:System.Windows.Forms.Control.DoubleClick> являются логическими событиями более высокого уровня элемента управления. Они могут вызываться другими действиями пользователя, такими как сочетания клавиш.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Control.MouseDoubleClick>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа, который наследует от <xref:System.Windows.Forms.Control>, например <xref:System.Windows.Forms.Button> или <xref:System.Windows.Forms.ComboBox>. Затем присвойте экземпляру имя `Control1` и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Control.MouseDoubleClick>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#55](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#55)]
 [!code-vb[System.Windows.Forms.EventExamples#55](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#55)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseDown : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при нажатии кнопки мыши, если указатель мыши находится на элементе управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 События мыши происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Следующие события не вызываются для класса <xref:System.Windows.Forms.TabControl>, если в коллекции <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> не существует хотя бы один <xref:System.Windows.Forms.TabPage>: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> и 0. Если в коллекции имеется хотя бы один <xref:System.Windows.Forms.TabPage>, и пользователь взаимодействует с заголовком элемента управления вкладки (где отображаются имена <xref:System.Windows.Forms.TabPage>), <xref:System.Windows.Forms.TabControl> вызывает соответствующее событие. Однако если взаимодействие с пользователем происходит в клиентской области страницы вкладки, <xref:System.Windows.Forms.TabPage> вызывает соответствующее событие.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование различных событий мыши для рисования контура мыши на <xref:System.Windows.Forms.Panel>. Сегмент линии добавляется к <xref:System.Drawing.Drawing2D.GraphicsPath> для каждого происходящих событий <xref:System.Windows.Forms.Control.MouseMove> и <xref:System.Windows.Forms.Control.MouseDown>. Для обновления графики вызывается метод <xref:System.Windows.Forms.Control.Invalidate%2A> для <xref:System.Windows.Forms.Panel> в каждом событии `MouseDown` и `MouseUp`. Кроме того, при возникновении события <xref:System.Windows.Forms.Control.MouseWheel> графический контур прокручивается вверх или вниз. Дополнительные события мыши, например <xref:System.Windows.Forms.Control.MouseHover>, также определяются на экране. Кроме того, на экране отображаются дополнительные сведения о мыши из класса <xref:System.Windows.Forms.SystemInformation>.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event EventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : EventHandler " Usage="member this.MouseEnter : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда указатель мыши оказывается на элементе управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 События мыши происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Следующие события не вызываются для класса <xref:System.Windows.Forms.TabControl>, если в коллекции <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> не существует хотя бы один <xref:System.Windows.Forms.TabPage>: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> и 0. Если в коллекции имеется хотя бы один <xref:System.Windows.Forms.TabPage>, и пользователь взаимодействует с заголовком элемента управления вкладки (где отображаются имена <xref:System.Windows.Forms.TabPage>), <xref:System.Windows.Forms.TabControl> вызывает соответствующее событие. Однако если взаимодействие с пользователем происходит в клиентской области страницы вкладки, <xref:System.Windows.Forms.TabPage> вызывает соответствующее событие.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование различных событий мыши для рисования контура мыши на <xref:System.Windows.Forms.Panel>. Сегмент линии добавляется к <xref:System.Drawing.Drawing2D.GraphicsPath> для каждого происходящих событий <xref:System.Windows.Forms.Control.MouseMove> и <xref:System.Windows.Forms.Control.MouseDown>. Для обновления графики вызывается метод <xref:System.Windows.Forms.Control.Invalidate%2A> для <xref:System.Windows.Forms.Panel> в каждом событии `MouseDown` и `MouseUp`. Кроме того, при возникновении события <xref:System.Windows.Forms.Control.MouseWheel> графический контур прокручивается вверх или вниз. Дополнительные события мыши, например <xref:System.Windows.Forms.Control.MouseHover>, также определяются на экране. Кроме того, на экране отображаются дополнительные сведения о мыши из класса <xref:System.Windows.Forms.SystemInformation>.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.MouseLeave" />
        <altmember cref="E:System.Windows.Forms.Control.MouseHover" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseHover">
      <MemberSignature Language="C#" Value="public event EventHandler MouseHover;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseHover" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseHover" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseHover As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseHover;" />
      <MemberSignature Language="F#" Value="member this.MouseHover : EventHandler " Usage="member this.MouseHover : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда указатель мыши задерживается на элементе управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обычно <xref:System.Windows.Forms.Control.MouseHover> используется для отображения всплывающей подсказки при задержке мыши над элементом управления в заданной области вокруг элемента управления («прямоугольник наведения»). Приостановка, требуемая для возникновения этого события, указывается в миллисекундах свойством <xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A>.  
  
 Событие <xref:System.Windows.Forms.Control.MouseHover> определяется и определяется в связи со свойствами <xref:System.Windows.Forms.SystemInformation.MouseHoverSize%2A> и <xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A>.  
  
 События мыши происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Следующие события не вызываются для класса <xref:System.Windows.Forms.TabControl>, если в коллекции <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> не существует хотя бы один <xref:System.Windows.Forms.TabPage>: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> и 0. Если в коллекции имеется хотя бы один <xref:System.Windows.Forms.TabPage>, и пользователь взаимодействует с заголовком элемента управления вкладки (где отображаются имена <xref:System.Windows.Forms.TabPage>), <xref:System.Windows.Forms.TabControl> вызывает соответствующее событие. Однако если взаимодействие с пользователем происходит в клиентской области страницы вкладки, <xref:System.Windows.Forms.TabPage> вызывает соответствующее событие.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование различных событий мыши для рисования контура мыши на <xref:System.Windows.Forms.Panel>. Сегмент линии добавляется к <xref:System.Drawing.Drawing2D.GraphicsPath> для каждого происходящих событий <xref:System.Windows.Forms.Control.MouseMove> и <xref:System.Windows.Forms.Control.MouseDown>. Для обновления графики вызывается метод <xref:System.Windows.Forms.Control.Invalidate%2A> для <xref:System.Windows.Forms.Panel> в каждом событии `MouseDown` и `MouseUp`. Кроме того, при возникновении события <xref:System.Windows.Forms.Control.MouseWheel> графический контур прокручивается вверх или вниз. Дополнительные события мыши, например <xref:System.Windows.Forms.Control.MouseHover>, также определяются на экране. Кроме того, на экране отображаются дополнительные сведения о мыши из класса <xref:System.Windows.Forms.SystemInformation>.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.SystemInformation.MouseHoverTime" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event EventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : EventHandler " Usage="member this.MouseLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда указатель мыши покидает элемент управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 События мыши происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Следующие события не вызываются для класса <xref:System.Windows.Forms.TabControl>, если в коллекции <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> не существует хотя бы один <xref:System.Windows.Forms.TabPage>: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> и 0. Если в коллекции имеется хотя бы один <xref:System.Windows.Forms.TabPage>, и пользователь взаимодействует с заголовком элемента управления вкладки (где отображаются имена <xref:System.Windows.Forms.TabPage>), <xref:System.Windows.Forms.TabControl> вызывает соответствующее событие. Однако если взаимодействие с пользователем происходит в клиентской области страницы вкладки, <xref:System.Windows.Forms.TabPage> вызывает соответствующее событие.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование различных событий мыши для рисования контура мыши на <xref:System.Windows.Forms.Panel>. Сегмент линии добавляется к <xref:System.Drawing.Drawing2D.GraphicsPath> для каждого происходящих событий <xref:System.Windows.Forms.Control.MouseMove> и <xref:System.Windows.Forms.Control.MouseDown>. Для обновления графики вызывается метод <xref:System.Windows.Forms.Control.Invalidate%2A> для <xref:System.Windows.Forms.Panel> в каждом событии `MouseDown` и `MouseUp`. Кроме того, при возникновении события <xref:System.Windows.Forms.Control.MouseWheel> графический контур прокручивается вверх или вниз. Дополнительные события мыши, например <xref:System.Windows.Forms.Control.MouseHover>, также определяются на экране. Кроме того, на экране отображаются дополнительные сведения о мыши из класса <xref:System.Windows.Forms.SystemInformation>.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при перемещении указателя мыши по элементу управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Типичное использование <xref:System.Windows.Forms.Control.MouseMove> — изменение цвета элемента управления или рисование порожденного прямоугольника вокруг элемента управления.  
  
 События мыши происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Следующие события не вызываются для класса <xref:System.Windows.Forms.TabControl>, если в коллекции <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> не существует хотя бы один <xref:System.Windows.Forms.TabPage>: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> и 0. Если в коллекции имеется хотя бы один <xref:System.Windows.Forms.TabPage>, и пользователь взаимодействует с заголовком элемента управления вкладки (где отображаются имена <xref:System.Windows.Forms.TabPage>), <xref:System.Windows.Forms.TabControl> вызывает соответствующее событие. Однако если взаимодействие с пользователем происходит в клиентской области страницы вкладки, <xref:System.Windows.Forms.TabPage> вызывает соответствующее событие.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование различных событий мыши для рисования контура мыши на <xref:System.Windows.Forms.Panel>. Сегмент линии добавляется к <xref:System.Drawing.Drawing2D.GraphicsPath> для каждого происходящих событий <xref:System.Windows.Forms.Control.MouseMove> и <xref:System.Windows.Forms.Control.MouseDown>. Для обновления графики вызывается метод <xref:System.Windows.Forms.Control.Invalidate%2A> для <xref:System.Windows.Forms.Panel> в каждом событии `MouseDown` и `MouseUp`. Кроме того, при возникновении события <xref:System.Windows.Forms.Control.MouseWheel> графический контур прокручивается вверх или вниз. Дополнительные события мыши, например <xref:System.Windows.Forms.Control.MouseHover>, также определяются на экране. Кроме того, на экране отображаются дополнительные сведения о мыши из класса <xref:System.Windows.Forms.SystemInformation>.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MousePosition">
      <MemberSignature Language="C#" Value="public static System.Drawing.Point MousePosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Point MousePosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MousePosition" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MousePosition As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Point MousePosition { System::Drawing::Point get(); };" />
      <MemberSignature Language="F#" Value="member this.MousePosition : System.Drawing.Point" Usage="System.Windows.Forms.Control.MousePosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает позицию указателя мыши в экранных координатах.</summary>
        <value>Объект <see cref="T:System.Drawing.Point" /> содержит координаты указателя мыши относительно левого верхнего угла экрана.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.MousePosition%2A> возвращает <xref:System.Drawing.Point>, представляющий позицию курсора мыши во время ссылки на свойство. Координаты указывают позицию на экране, а не относительно элемента управления и возвращаются, независимо от того, наведен ли курсор на элемент управления. Координаты левого верхнего угла экрана равны 0, 0.  
  
 Свойство <xref:System.Windows.Forms.Control.MousePosition%2A> идентично свойству <xref:System.Windows.Forms.Cursor.Position%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода метка <xref:System.Windows.Forms.TreeNode> помещается в изменяемое состояние, когда пользователь нажимает ALT + E, когда указатель мыши находится над узлом дерева. После того как пользователь закончит редактирование метки, метки нельзя будет изменить, пока не будет нажата комбинация клавиш ALT + E. В этом примере требуется, чтобы на <xref:System.Windows.Forms.Form> имелся <xref:System.Windows.Forms.TreeView>. Представление в виде дерева также должно иметь по крайней мере одно <xref:System.Windows.Forms.TreeNode> в своей коллекции <xref:System.Windows.Forms.TreeView.Nodes%2A>.  
  
 [!code-cpp[Windows.Forms.Control Members4#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members4#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#3)]
 [!code-vb[Windows.Forms.Control Members4#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseUp : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при отпускании кнопки мыши, когда указатель мыши находится на элементе управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 События мыши происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Следующие события не вызываются для класса <xref:System.Windows.Forms.TabControl>, если в коллекции <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> не существует хотя бы один <xref:System.Windows.Forms.TabPage>: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseUp>, <xref:System.Windows.Forms.Control.MouseHover>, <xref:System.Windows.Forms.Control.MouseEnter>, <xref:System.Windows.Forms.Control.MouseLeave> и 0. Если в коллекции имеется хотя бы один <xref:System.Windows.Forms.TabPage>, и пользователь взаимодействует с заголовком элемента управления вкладки (где отображаются имена <xref:System.Windows.Forms.TabPage>), <xref:System.Windows.Forms.TabControl> вызывает соответствующее событие. Однако если взаимодействие с пользователем происходит в клиентской области страницы вкладки, <xref:System.Windows.Forms.TabPage> вызывает соответствующее событие.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование различных событий мыши для рисования контура мыши на <xref:System.Windows.Forms.Panel>. Сегмент линии добавляется к <xref:System.Drawing.Drawing2D.GraphicsPath> для каждого происходящих событий <xref:System.Windows.Forms.Control.MouseMove> и <xref:System.Windows.Forms.Control.MouseDown>. Для обновления графики вызывается метод <xref:System.Windows.Forms.Control.Invalidate%2A> для <xref:System.Windows.Forms.Panel> в каждом событии `MouseDown` и `MouseUp`. Кроме того, при возникновении события <xref:System.Windows.Forms.Control.MouseWheel> графический контур прокручивается вверх или вниз. Дополнительные события мыши, например <xref:System.Windows.Forms.Control.MouseHover>, также определяются на экране. Кроме того, на экране отображаются дополнительные сведения о мыши из класса <xref:System.Windows.Forms.SystemInformation>.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseWheel;" />
      <MemberSignature Language="F#" Value="member this.MouseWheel : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseWheel : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при прокручивании колеса мыши, если данный элемент управления находится в фокусе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При обработке события <xref:System.Windows.Forms.Control.MouseWheel> важно соблюдать стандарты пользовательского интерфейса, связанные с колесиком мыши. Значение свойства <xref:System.Windows.Forms.MouseEventArgs.Delta%2A?displayProperty=nameWithType> показывает величину перемещения колесика мыши. Пользовательский интерфейс должен прокручиваться, если накопленная Дельта имеет значение плюс или минус 120. Пользовательский интерфейс должен прокручивать число логических строк, возвращенных свойством <xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType> для каждого из полученных значений Дельта. Кроме того, можно прокручивать более плавную прокрутку с меньшим шагом 120 единиц, однако отношение должно оставаться постоянным, то есть <xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType> строк, прокручено на 120 Дельта-единиц перемещения колесика.  
  
 Дополнительные сведения об обработке сообщений колесика мыши см. в разделе [WM_MOUSEWHEEL](https://msdn.microsoft.com/library/windows/desktop/ms645617\(v=vs.85\).aspx) .  
  
 События мыши происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование различных событий мыши для рисования контура мыши на <xref:System.Windows.Forms.Panel>. Сегмент линии добавляется к <xref:System.Drawing.Drawing2D.GraphicsPath> для каждого происходящих событий <xref:System.Windows.Forms.Control.MouseMove> и <xref:System.Windows.Forms.Control.MouseDown>. Для обновления графики вызывается метод <xref:System.Windows.Forms.Control.Invalidate%2A> для <xref:System.Windows.Forms.Panel> в каждом событии `MouseDown` и `MouseUp`. Кроме того, при возникновении события <xref:System.Windows.Forms.Control.MouseWheel> графический контур прокручивается вверх или вниз. Дополнительные события мыши, например <xref:System.Windows.Forms.Control.MouseHover>, также определяются на экране. Кроме того, на экране отображаются дополнительные сведения о мыши из класса <xref:System.Windows.Forms.SystemInformation>.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public event EventHandler Move;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Move" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Move" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Move As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Move;" />
      <MemberSignature Language="F#" Value="member this.Move : EventHandler " Usage="member this.Move : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при перемещении элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода событие <xref:System.Windows.Forms.Control.Move> используется для отображения расположения формы в координатах экрана на панели заголовка формы.  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.Control.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя элемента управления.</summary>
        <value>Имя элемента управления. Значение по умолчанию — пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.Name%2A> можно использовать во время выполнения для вычисления объекта по имени, а не по типу и программному имени. Поскольку свойство <xref:System.Windows.Forms.Control.Name%2A> возвращает тип <xref:System.String>, его можно вычислить в инструкциях логики в стиле регистра (`Select` в Visual Basic, `switch` в Visual C# и [!INCLUDE[vcprvc](~/includes/vcprvc-md.md)]).  
  
   
  
## Examples  
 В следующем примере кода отображается <xref:System.Windows.Forms.Control.Name%2A> элемента управления в <xref:System.Windows.Forms.MessageBox> при добавлении или удалении элемента управления из формы.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.ISite.Name" />
      </Docs>
    </Member>
    <Member MemberName="NotifyInvalidate">
      <MemberSignature Language="C#" Value="protected virtual void NotifyInvalidate (System.Drawing.Rectangle invalidatedArea);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void NotifyInvalidate(valuetype System.Drawing.Rectangle invalidatedArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.NotifyInvalidate(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub NotifyInvalidate (invalidatedArea As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void NotifyInvalidate(System::Drawing::Rectangle invalidatedArea);" />
      <MemberSignature Language="F#" Value="abstract member NotifyInvalidate : System.Drawing.Rectangle -&gt; unit&#xA;override this.NotifyInvalidate : System.Drawing.Rectangle -&gt; unit" Usage="control.NotifyInvalidate invalidatedArea" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidatedArea" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="invalidatedArea">Объект <see cref="T:System.Drawing.Rectangle" />, представляющий область, которую требуется сделать недопустимой.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Invalidated" />, чтобы сделать недействительной указанную область элемента управления.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAutoSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAutoSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAutoSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAutoSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAutoSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAutoSizeChanged : EventArgs -&gt; unit&#xA;override this.OnAutoSizeChanged : EventArgs -&gt; unit" Usage="control.OnAutoSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.AutoSizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnAutoSizeChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackColorChanged : EventArgs -&gt; unit&#xA;override this.OnBackColorChanged : EventArgs -&gt; unit" Usage="control.OnBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.BackColorChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnBackColorChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackgroundImageChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackgroundImageChanged : EventArgs -&gt; unit&#xA;override this.OnBackgroundImageChanged : EventArgs -&gt; unit" Usage="control.OnBackgroundImageChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnBackgroundImageChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackgroundImageLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackgroundImageLayoutChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackgroundImageLayoutChanged : EventArgs -&gt; unit&#xA;override this.OnBackgroundImageLayoutChanged : EventArgs -&gt; unit" Usage="control.OnBackgroundImageLayoutChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBindingContextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBindingContextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBindingContextChanged : EventArgs -&gt; unit&#xA;override this.OnBindingContextChanged : EventArgs -&gt; unit" Usage="control.OnBindingContextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.BindingContextChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnBindingContextChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BindingContext" />
      </Docs>
    </Member>
    <Member MemberName="OnCausesValidationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCausesValidationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCausesValidationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCausesValidationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCausesValidationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCausesValidationChanged : EventArgs -&gt; unit&#xA;override this.OnCausesValidationChanged : EventArgs -&gt; unit" Usage="control.OnCausesValidationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.CausesValidationChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnCausesValidationChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.CausesValidationChanged" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
      </Docs>
    </Member>
    <Member MemberName="OnChangeUICues">
      <MemberSignature Language="C#" Value="protected virtual void OnChangeUICues (System.Windows.Forms.UICuesEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChangeUICues(class System.Windows.Forms.UICuesEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChangeUICues (e As UICuesEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChangeUICues(System::Windows::Forms::UICuesEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnChangeUICues : System.Windows.Forms.UICuesEventArgs -&gt; unit&#xA;override this.OnChangeUICues : System.Windows.Forms.UICuesEventArgs -&gt; unit" Usage="control.OnChangeUICues e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.UICuesEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.UICuesEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.ChangeUICues" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnChangeUICues%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
        <altmember cref="T:System.Windows.Forms.UICues" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClick : EventArgs -&gt; unit&#xA;override this.OnClick : EventArgs -&gt; unit" Usage="control.OnClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Click" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnClick%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 В следующем примере кода показано переопределение метода <xref:System.Windows.Forms.Control.OnClick%2A> в производном классе. Чтобы выполнить пример, вставьте следующий код после класса Form в тот же файл. Добавьте в форму текстовое поле типа `SingleClickTextBox`.  
  
 [!code-cpp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/VB/form1.vb#1)]  
  
 В следующем примере кода показано одно из многих применений события <xref:System.Windows.Forms.Control.Click> и обработчика событий.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Click" />
      </Docs>
    </Member>
    <Member MemberName="OnClientSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnClientSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClientSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClientSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClientSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClientSizeChanged : EventArgs -&gt; unit&#xA;override this.OnClientSizeChanged : EventArgs -&gt; unit" Usage="control.OnClientSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.ClientSizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnClientSizeChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuChanged : EventArgs -&gt; unit&#xA;override this.OnContextMenuChanged : EventArgs -&gt; unit" Usage="control.OnContextMenuChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.ContextMenuChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnContextMenuChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ContextMenuChanged" />
        <altmember cref="P:System.Windows.Forms.Control.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuStripChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuStripChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuStripChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuStripChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuStripChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuStripChanged : EventArgs -&gt; unit&#xA;override this.OnContextMenuStripChanged : EventArgs -&gt; unit" Usage="control.OnContextMenuStripChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.ContextMenuStripChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnContextMenuStripChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnControlAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnControlAdded (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlAdded(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnControlAdded (e As ControlEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnControlAdded(System::Windows::Forms::ControlEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnControlAdded : System.Windows.Forms.ControlEventArgs -&gt; unit&#xA;override this.OnControlAdded : System.Windows.Forms.ControlEventArgs -&gt; unit" Usage="control.OnControlAdded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.ControlEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.ControlAdded" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывается, когда дочерний элемент управления добавляется в элемент управления.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnControlAdded%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Windows.Forms.Control.ControlAdded> используется для добавления элемента управления в форму и отображения имени добавленного элемента управления в <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ControlAdded" />
      </Docs>
    </Member>
    <Member MemberName="OnControlRemoved">
      <MemberSignature Language="C#" Value="protected virtual void OnControlRemoved (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlRemoved(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnControlRemoved (e As ControlEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnControlRemoved(System::Windows::Forms::ControlEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnControlRemoved : System.Windows.Forms.ControlEventArgs -&gt; unit&#xA;override this.OnControlRemoved : System.Windows.Forms.ControlEventArgs -&gt; unit" Usage="control.OnControlRemoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.ControlEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.ControlRemoved" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывается, когда дочерний элемент управления удаляется из элемента управления.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnControlRemoved%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Windows.Forms.Control.ControlRemoved> используется для удаления элемента управления из формы и отображения имени удаленного элемента управления в <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ControlRemoved" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected virtual void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCreateControl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCreateControl();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateControl : unit -&gt; unit&#xA;override this.OnCreateControl : unit -&gt; unit" Usage="control.OnCreateControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает метод <see cref="M:System.Windows.Forms.Control.CreateControl" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Forms.Control.OnCreateControl%2A> вызывается при первом создании элемента управления.  
  
 Метод <xref:System.Windows.Forms.Control.OnCreateControl%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnCreateControl" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnCreateControl" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
      </Docs>
    </Member>
    <Member MemberName="OnCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCursorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCursorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCursorChanged : EventArgs -&gt; unit&#xA;override this.OnCursorChanged : EventArgs -&gt; unit" Usage="control.OnCursorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.CursorChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnCursorChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.CursorChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="OnDockChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDockChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDockChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDockChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDockChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDockChanged : EventArgs -&gt; unit&#xA;override this.OnDockChanged : EventArgs -&gt; unit" Usage="control.OnDockChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.DockChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnDockChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DockChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
      </Docs>
    </Member>
    <Member MemberName="OnDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnDoubleClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoubleClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDoubleClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDoubleClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDoubleClick : EventArgs -&gt; unit&#xA;override this.OnDoubleClick : EventArgs -&gt; unit" Usage="control.OnDoubleClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.DoubleClick" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnDoubleClick%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 В следующем примере кода используется событие <xref:System.Windows.Forms.Control.DoubleClick> <xref:System.Windows.Forms.ListBox> для загрузки текстовых файлов, перечисленных в <xref:System.Windows.Forms.ListBox>, в элемент управления <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedAfterParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedAfterParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedAfterParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedAfterParent(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChangedAfterParent (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChangedAfterParent(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChangedAfterParent : EventArgs -&gt; unit&#xA;override this.OnDpiChangedAfterParent : EventArgs -&gt; unit" Usage="control.OnDpiChangedAfterParent e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.DpiChangedAfterParent" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedBeforeParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedBeforeParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedBeforeParent(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChangedBeforeParent (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChangedBeforeParent(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChangedBeforeParent : EventArgs -&gt; unit&#xA;override this.OnDpiChangedBeforeParent : EventArgs -&gt; unit" Usage="control.OnDpiChangedBeforeParent e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.DpiChangedBeforeParent" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDragDrop (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragDrop(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragDrop (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragDrop(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragDrop : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragDrop : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragDrop drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragDrop(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Объект <see cref="T:System.Windows.Forms.DragEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.DragDrop" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnDragDrop%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragEnter (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragEnter(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragEnter : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragEnter : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragEnter drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragEnter(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Объект <see cref="T:System.Windows.Forms.DragEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.DragEnter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnDragEnter%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragLeave : EventArgs -&gt; unit&#xA;override this.OnDragLeave : EventArgs -&gt; unit" Usage="control.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragLeave(System.EventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.DragLeave" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnDragLeave%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragOver(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragOver (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragOver(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragOver : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragOver : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragOver drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragOver(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">Объект <see cref="T:System.Windows.Forms.DragEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.DragOver" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnDragOver%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEnabledChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEnabledChanged : EventArgs -&gt; unit&#xA;override this.OnEnabledChanged : EventArgs -&gt; unit" Usage="control.OnEnabledChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.EnabledChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnEnabledChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.EnabledChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEnter(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEnter : EventArgs -&gt; unit&#xA;override this.OnEnter : EventArgs -&gt; unit" Usage="control.OnEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Enter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnEnter%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 В следующем примере кода событие <xref:System.Windows.Forms.Control.Enter> используется для изменения цвета переднего плана и фона <xref:System.Windows.Forms.TextBox> при определенных условиях.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFontChanged : EventArgs -&gt; unit&#xA;override this.OnFontChanged : EventArgs -&gt; unit" Usage="control.OnFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.FontChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnFontChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnForeColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnForeColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnForeColorChanged : EventArgs -&gt; unit&#xA;override this.OnForeColorChanged : EventArgs -&gt; unit" Usage="control.OnForeColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.ForeColorChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnForeColorChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.Forms.GiveFeedbackEventArgs gfbevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.Forms.GiveFeedbackEventArgs gfbevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGiveFeedback (gfbevent As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGiveFeedback(System::Windows::Forms::GiveFeedbackEventArgs ^ gfbevent);" />
      <MemberSignature Language="F#" Value="abstract member OnGiveFeedback : System.Windows.Forms.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnGiveFeedback : System.Windows.Forms.GiveFeedbackEventArgs -&gt; unit" Usage="control.OnGiveFeedback gfbevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gfbevent" Type="System.Windows.Forms.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="gfbevent">Объект <see cref="T:System.Windows.Forms.GiveFeedbackEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.GiveFeedback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnGiveFeedback%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotFocus : EventArgs -&gt; unit&#xA;override this.OnGotFocus : EventArgs -&gt; unit" Usage="control.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.GotFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnGotFocus%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHandleCreated : EventArgs -&gt; unit&#xA;override this.OnHandleCreated : EventArgs -&gt; unit" Usage="control.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.HandleCreated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnHandleCreated%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.HandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHandleDestroyed : EventArgs -&gt; unit&#xA;override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="control.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.HandleDestroyed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnHandleDestroyed%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.HandleDestroyed" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnHelpRequested">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpRequested (System.Windows.Forms.HelpEventArgs hevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpRequested(class System.Windows.Forms.HelpEventArgs hevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHelpRequested (hevent As HelpEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHelpRequested(System::Windows::Forms::HelpEventArgs ^ hevent);" />
      <MemberSignature Language="F#" Value="abstract member OnHelpRequested : System.Windows.Forms.HelpEventArgs -&gt; unit&#xA;override this.OnHelpRequested : System.Windows.Forms.HelpEventArgs -&gt; unit" Usage="control.OnHelpRequested hevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hevent" Type="System.Windows.Forms.HelpEventArgs" />
      </Parameters>
      <Docs>
        <param name="hevent">Объект <see cref="T:System.Windows.Forms.HelpEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.HelpRequested" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnHelpRequested%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.HelpRequested" />
      </Docs>
    </Member>
    <Member MemberName="OnImeModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnImeModeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeModeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnImeModeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnImeModeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnImeModeChanged : EventArgs -&gt; unit&#xA;override this.OnImeModeChanged : EventArgs -&gt; unit" Usage="control.OnImeModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.ImeModeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnImeModeChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ImeModeChanged" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="OnInvalidated">
      <MemberSignature Language="C#" Value="protected virtual void OnInvalidated (System.Windows.Forms.InvalidateEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInvalidated(class System.Windows.Forms.InvalidateEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInvalidated (e As InvalidateEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInvalidated(System::Windows::Forms::InvalidateEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInvalidated : System.Windows.Forms.InvalidateEventArgs -&gt; unit&#xA;override this.OnInvalidated : System.Windows.Forms.InvalidateEventArgs -&gt; unit" Usage="control.OnInvalidated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InvalidateEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.Forms.InvalidateEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Invalidated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnInvalidated%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Invalidated" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyDown(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyDown : System.Windows.Forms.KeyEventArgs -&gt; unit&#xA;override this.OnKeyDown : System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.KeyEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.KeyDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnKeyDown%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 В следующем примере кода используется событие <xref:System.Windows.Forms.Control.KeyDown> для определения типа символа, введенного в элемент управления.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyPress">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyPress (System.Windows.Forms.KeyPressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyPress(class System.Windows.Forms.KeyPressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyPress (e As KeyPressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyPress(System::Windows::Forms::KeyPressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyPress : System.Windows.Forms.KeyPressEventArgs -&gt; unit&#xA;override this.OnKeyPress : System.Windows.Forms.KeyPressEventArgs -&gt; unit" Usage="control.OnKeyPress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyPressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.KeyPressEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.KeyPress" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnKeyPress%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 В следующем примере кода используется событие <xref:System.Windows.Forms.Control.KeyPress> для предотвращения ввода символов в элемент управления.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyUp(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyUp : System.Windows.Forms.KeyEventArgs -&gt; unit&#xA;override this.OnKeyUp : System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.KeyEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.KeyUp" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnKeyUp%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 В следующем примере кода используется событие <xref:System.Windows.Forms.Control.KeyUp> с классом <xref:System.Windows.Forms.Help> для отображения справки о стиле всплывающего окна для пользователя.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected virtual void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLayout (levent As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLayout(System::Windows::Forms::LayoutEventArgs ^ levent);" />
      <MemberSignature Language="F#" Value="abstract member OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit&#xA;override this.OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit" Usage="control.OnLayout levent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">Объект <see cref="T:System.Windows.Forms.LayoutEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Layout" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnLayout%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> в производном классе обязательно вызывайте метод <see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получали событие, а также для работы стандартных функций закрепления и привязки. Производные классы должны переопределять этот метод, чтобы реализовать любую пользовательскую логику макета.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="OnLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLeave : EventArgs -&gt; unit&#xA;override this.OnLeave : EventArgs -&gt; unit" Usage="control.OnLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Leave" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnLeave%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 В следующем примере кода событие <xref:System.Windows.Forms.Control.Leave> используется для сброса элемента управления до его предыдущего состояния.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Leave" />
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="control.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.LocationChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnLocationChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName* `Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.LocationChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostFocus : EventArgs -&gt; unit&#xA;override this.OnLostFocus : EventArgs -&gt; unit" Usage="control.OnLostFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.LostFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnLostFocus%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnMarginChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMarginChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMarginChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMarginChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMarginChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMarginChanged : EventArgs -&gt; unit&#xA;override this.OnMarginChanged : EventArgs -&gt; unit" Usage="control.OnMarginChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.MarginChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnMarginChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseCaptureChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseCaptureChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseCaptureChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseCaptureChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseCaptureChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseCaptureChanged : EventArgs -&gt; unit&#xA;override this.OnMouseCaptureChanged : EventArgs -&gt; unit" Usage="control.OnMouseCaptureChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.MouseCaptureChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnMouseCaptureChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseClick (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseClick(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseClick : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseClick : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.Forms.MouseEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.MouseClick" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnMouseClick%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDoubleClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDoubleClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDoubleClick (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDoubleClick(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDoubleClick : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseDoubleClick : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseDoubleClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.Forms.MouseEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.MouseDoubleClick" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnMouseDoubleClick%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDown (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDown(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDown : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseDown : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.MouseEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.MouseDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnMouseDown%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseEnter(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseEnter : EventArgs -&gt; unit&#xA;override this.OnMouseEnter : EventArgs -&gt; unit" Usage="control.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.MouseEnter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnMouseEnter%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseEnter" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseHover">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseHover (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseHover(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseHover (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseHover(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseHover : EventArgs -&gt; unit&#xA;override this.OnMouseHover : EventArgs -&gt; unit" Usage="control.OnMouseHover e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.MouseHover" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnMouseHover%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 В следующем примере кода показано, как переопределить методы <xref:System.Windows.Forms.Control.OnMouseHover%2A> и <xref:System.Windows.Forms.Control.OnMouseMove%2A> в производном классе. Чтобы выполнить пример, вставьте следующий код в новую форму и вставьте этот класс, формируя тот же файл после формы. Добавьте в форму кнопку типа `FunButton`.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseHover" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeave : EventArgs -&gt; unit&#xA;override this.OnMouseLeave : EventArgs -&gt; unit" Usage="control.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.MouseLeave" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnMouseLeave%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseLeave" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseMove(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseMove : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseMove : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.MouseEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.MouseMove" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnMouseMove%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 В следующем примере кода показано, как переопределить методы <xref:System.Windows.Forms.Control.OnMouseHover%2A> и <xref:System.Windows.Forms.Control.OnMouseMove%2A> в производном классе. Чтобы выполнить пример, вставьте следующий код в новую форму и вставьте этот класс, формируя тот же файл после формы. Добавьте в форму кнопку типа `FunButton`.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseMove" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseUp (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseUp(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.MouseEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.MouseUp" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnMouseUp%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseWheel (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseWheel(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseWheel : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseWheel : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.MouseEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.MouseWheel" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnMouseWheel%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseWheel" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMove (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMove(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMove (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMove(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMove : EventArgs -&gt; unit&#xA;override this.OnMove : EventArgs -&gt; unit" Usage="control.OnMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Move" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnMove%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 В следующем примере кода событие <xref:System.Windows.Forms.Control.Move> используется для отображения расположения формы в координатах экрана на панели заголовка формы.  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Move" />
      </Docs>
    </Member>
    <Member MemberName="OnNotifyMessage">
      <MemberSignature Language="C#" Value="protected virtual void OnNotifyMessage (System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNotifyMessage(valuetype System.Windows.Forms.Message m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNotifyMessage (m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNotifyMessage(System::Windows::Forms::Message m);" />
      <MemberSignature Language="F#" Value="abstract member OnNotifyMessage : System.Windows.Forms.Message -&gt; unit&#xA;override this.OnNotifyMessage : System.Windows.Forms.Message -&gt; unit" Usage="control.OnNotifyMessage m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" />
      </Parameters>
      <Docs>
        <param name="m">Объект <see cref="T:System.Windows.Forms.Message" />, представляющий сообщение Windows.</param>
        <summary>Уведомляет элемент управления о сообщениях Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Forms.Control.OnNotifyMessage%2A> вызывается, если бит стиля `EnableNotifyMessage` элемента управления задан в <xref:System.Windows.Forms.ControlStyles>. Стиль `EnableNotifyMessage` в <xref:System.Windows.Forms.ControlStyles> позволяет получать уведомления об элементе управления, когда метод <xref:System.Windows.Forms.Control.WndProc%2A> получает сообщение Windows. С помощью этого метода элементы управления с частичным доверием могут прослушивать сообщения Windows, не позволяя им изменять сообщение.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" /> в производном классе вызов метода <see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" /> базового класса не требуется, так как отсутствует исходная реализация.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPaddingChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPaddingChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaddingChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaddingChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaddingChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPaddingChanged : EventArgs -&gt; unit&#xA;override this.OnPaddingChanged : EventArgs -&gt; unit" Usage="control.OnPaddingChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.PaddingChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnPaddingChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected virtual void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPaint e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.PaintEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Paint" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnPaint%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 В следующем примере кода пользователь может перетащить изображение или файл изображения на форму и отобразить его в той точке, где он был удален. Метод <xref:System.Windows.Forms.Control.OnPaint%2A> переопределен для перерисовки изображения при каждой отрисованной форме; в противном случае изображение будет сохранено только до следующего перерисовки. Метод обработки событий <xref:System.Windows.Forms.Control.DragEnter> определяет тип данных, которые перетаскиваются в форму, и предоставляет соответствующие отзывы. Метод обработки событий <xref:System.Windows.Forms.Control.DragDrop> отображает изображение в форме, если <xref:System.Drawing.Image> может быть создан из данных. Так как значения <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> и <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> являются экранными координатами, в примере используется метод <xref:System.Windows.Forms.Control.PointToClient%2A> для преобразования их в клиентские координаты.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="OnPaintBackground">
      <MemberSignature Language="C#" Value="protected virtual void OnPaintBackground (System.Windows.Forms.PaintEventArgs pevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaintBackground(class System.Windows.Forms.PaintEventArgs pevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaintBackground (pevent As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaintBackground(System::Windows::Forms::PaintEventArgs ^ pevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPaintBackground : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPaintBackground : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPaintBackground pevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pevent" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="pevent"><see cref="T:System.Windows.Forms.PaintEventArgs" />, содержащий сведения об элементе управления, который следует закрасить.</param>
        <summary>Рисует фон элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Forms.Control.OnPaintBackground%2A> позволяет производным классам обрабатывали запросы на очистку фона Windows.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Наследующие классы должны переопределять этот метод для выполнения запроса на удаление в фоновом режиме из Windows. При переопределении <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" /> в производном классе нет необходимости вызывать <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" /> базового класса.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBackColorChanged : EventArgs -&gt; unit&#xA;override this.OnParentBackColorChanged : EventArgs -&gt; unit" Usage="control.OnParentBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.BackColorChanged" /> при изменении значения свойства <see cref="P:System.Windows.Forms.Control.BackColor" /> контейнера элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnParentBackColorChanged%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBackgroundImageChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBackgroundImageChanged : EventArgs -&gt; unit&#xA;override this.OnParentBackgroundImageChanged : EventArgs -&gt; unit" Usage="control.OnParentBackgroundImageChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" /> при изменении значения свойства <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> контейнера элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnParentBackgroundImageChanged%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBindingContextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBindingContextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBindingContextChanged : EventArgs -&gt; unit&#xA;override this.OnParentBindingContextChanged : EventArgs -&gt; unit" Usage="control.OnParentBindingContextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.BindingContextChanged" /> при изменении значения свойства <see cref="P:System.Windows.Forms.Control.BindingContext" /> контейнера элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnParentBindingContextChanged%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentChanged : EventArgs -&gt; unit&#xA;override this.OnParentChanged : EventArgs -&gt; unit" Usage="control.OnParentChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.ParentChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnParentChanged%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ParentChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentCursorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentCursorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentCursorChanged : EventArgs -&gt; unit&#xA;override this.OnParentCursorChanged : EventArgs -&gt; unit" Usage="control.OnParentCursorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.CursorChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnParentCursorChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnParentEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentEnabledChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentEnabledChanged : EventArgs -&gt; unit&#xA;override this.OnParentEnabledChanged : EventArgs -&gt; unit" Usage="control.OnParentEnabledChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.EnabledChanged" /> при изменении значения свойства <see cref="P:System.Windows.Forms.Control.Enabled" /> контейнера элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnParentEnabledChanged%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.EnabledChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentFontChanged : EventArgs -&gt; unit&#xA;override this.OnParentFontChanged : EventArgs -&gt; unit" Usage="control.OnParentFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.FontChanged" /> при изменении значения свойства <see cref="P:System.Windows.Forms.Control.Font" /> контейнера элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnParentFontChanged%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentForeColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentForeColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentForeColorChanged : EventArgs -&gt; unit&#xA;override this.OnParentForeColorChanged : EventArgs -&gt; unit" Usage="control.OnParentForeColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.ForeColorChanged" /> при изменении значения свойства <see cref="P:System.Windows.Forms.Control.ForeColor" /> контейнера элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnParentForeColorChanged%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentRightToLeftChanged : EventArgs -&gt; unit&#xA;override this.OnParentRightToLeftChanged : EventArgs -&gt; unit" Usage="control.OnParentRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" /> при изменении значения свойства <see cref="P:System.Windows.Forms.Control.RightToLeft" /> контейнера элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnParentRightToLeftChanged%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.RightToLeftChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentVisibleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentVisibleChanged : EventArgs -&gt; unit&#xA;override this.OnParentVisibleChanged : EventArgs -&gt; unit" Usage="control.OnParentVisibleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.VisibleChanged" /> при изменении значения свойства <see cref="P:System.Windows.Forms.Control.Visible" /> контейнера элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnParentVisibleChanged%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Forms.PreviewKeyDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Forms.PreviewKeyDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewKeyDown (e As PreviewKeyDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewKeyDown(System::Windows::Forms::PreviewKeyDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventArgs -&gt; unit&#xA;override this.OnPreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventArgs -&gt; unit" Usage="control.OnPreviewKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PreviewKeyDownEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.PreviewKeyDownEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.PreviewKeyDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnPreviewKeyDown%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPrint">
      <MemberSignature Language="C#" Value="protected virtual void OnPrint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPrint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPrint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPrint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPrint : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPrint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPrint e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.PaintEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Paint" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если установлен бит `UserPaint` <xref:System.Windows.Forms.ControlStyles>, можно переопределить <xref:System.Windows.Forms.Control.OnPrint%2A> для выполнения многоуровневой прорисовки. Дополнительные сведения см. в разделе <xref:System.Windows.Forms.Control.SetStyle%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="e" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.Forms.QueryContinueDragEventArgs qcdevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.Forms.QueryContinueDragEventArgs qcdevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnQueryContinueDrag (qcdevent As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnQueryContinueDrag(System::Windows::Forms::QueryContinueDragEventArgs ^ qcdevent);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryContinueDrag : System.Windows.Forms.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnQueryContinueDrag : System.Windows.Forms.QueryContinueDragEventArgs -&gt; unit" Usage="control.OnQueryContinueDrag qcdevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qcdevent" Type="System.Windows.Forms.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="qcdevent">Объект <see cref="T:System.Windows.Forms.QueryContinueDragEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.QueryContinueDrag" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После начала перетаскивания этот метод вызывается повторно [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] до тех пор, пока операция перетаскивания не будет отменена или завершена.  
  
> [!NOTE]
>  Переопределите этот метод, если нужно изменить точку, в которой перетаскивание отменяется или когда происходит перетаскивание.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnQueryContinueDrag%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnRegionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRegionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRegionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRegionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRegionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRegionChanged : EventArgs -&gt; unit&#xA;override this.OnRegionChanged : EventArgs -&gt; unit" Usage="control.OnRegionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.RegionChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnRegionChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected virtual void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResize (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResize(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResize : EventArgs -&gt; unit&#xA;override this.OnResize : EventArgs -&gt; unit" Usage="control.OnResize e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Resize" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnResize%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие. Метод <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> можно вызвать во время построения, поэтому при переопределении <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> его можно вызвать до вызова конструктора элемента управления.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRightToLeftChanged : EventArgs -&gt; unit&#xA;override this.OnRightToLeftChanged : EventArgs -&gt; unit" Usage="control.OnRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnRightToLeftChanged%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.RightToLeftChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSizeChanged : EventArgs -&gt; unit&#xA;override this.OnSizeChanged : EventArgs -&gt; unit" Usage="control.OnSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.SizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnSizeChanged%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStyleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : EventArgs -&gt; unit&#xA;override this.OnStyleChanged : EventArgs -&gt; unit" Usage="control.OnStyleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.StyleChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnStyleChanged%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.StyleChanged" />
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnSystemColorsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSystemColorsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSystemColorsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSystemColorsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSystemColorsChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSystemColorsChanged : EventArgs -&gt; unit&#xA;override this.OnSystemColorsChanged : EventArgs -&gt; unit" Usage="control.OnSystemColorsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.SystemColorsChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnSystemColorsChanged%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.SystemColorsChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTabIndexChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabIndexChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabIndexChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTabIndexChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTabIndexChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTabIndexChanged : EventArgs -&gt; unit&#xA;override this.OnTabIndexChanged : EventArgs -&gt; unit" Usage="control.OnTabIndexChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.TabIndexChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnTabIndexChanged%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.TabIndexChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTabStopChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabStopChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabStopChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTabStopChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTabStopChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTabStopChanged : EventArgs -&gt; unit&#xA;override this.OnTabStopChanged : EventArgs -&gt; unit" Usage="control.OnTabStopChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.TabStopChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnTabStopChanged%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.TabStopChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextChanged : EventArgs -&gt; unit&#xA;override this.OnTextChanged : EventArgs -&gt; unit" Usage="control.OnTextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.TextChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnTextChanged%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.TextChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnValidated">
      <MemberSignature Language="C#" Value="protected virtual void OnValidated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnValidated : EventArgs -&gt; unit&#xA;override this.OnValidated : EventArgs -&gt; unit" Usage="control.OnValidated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Validated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnValidated%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="OnValidating">
      <MemberSignature Language="C#" Value="protected virtual void OnValidating (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidating(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidating (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidating(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnValidating : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnValidating : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="control.OnValidating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.ComponentModel.CancelEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Validating" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnValidating%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnVisibleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnVisibleChanged : EventArgs -&gt; unit&#xA;override this.OnVisibleChanged : EventArgs -&gt; unit" Usage="control.OnVisibleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.VisibleChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Control.OnVisibleChanged%2A> также позволяет производным классам выполнять обработку события без присоединения делегата. Это предпочтительная методика обработки событий в производном классе.  
  
   
  
## Examples  
 Следующий пример кода является методом, вызывающим событие, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени `On`*PropertyName*`Changed`, которые вызывают соответствующее событие *PropertyName*`Changed` при изменении значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> производного класса <xref:System.Windows.Forms.TextBox>, отображающего данные валюты. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере предполагается, что у вас есть класс, производный от класса <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Show" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Padding { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Padding : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.Control.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает заполнение в элементе управления.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.Padding" />, представляющий параметры внутренних зазоров элемента управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для контейнеров, таких как <xref:System.Windows.Forms.GroupBox> и <xref:System.Windows.Forms.TabControl>, свойство <xref:System.Windows.Forms.Control.Padding%2A> получает или задает соответствующие свойства <xref:System.Windows.Forms.Control.DisplayRectangle%2A>. Свойство <xref:System.Windows.Forms.ScrollableControl.DockPadding%2A?displayProperty=nameWithType> равно свойству <xref:System.Windows.Forms.Control.Padding%2A?displayProperty=nameWithType>.  
  
 Элементы управления получают значения по умолчанию для <xref:System.Windows.Forms.Control.Padding%2A>, которые достаточно близки к рекомендациям по пользовательскому интерфейсу Windows. Некоторые настройки могут быть необходимы для определенных приложений.  
  
 Все элементы управления, которые реализуют <xref:System.Windows.Forms.Control.GetPreferredSize%2A>, увеличены на величину в <xref:System.Windows.Forms.Control.Padding%2A>, если <xref:System.Windows.Forms.Control.AutoSize%2A> — `true`.  
  
 Следующие элементы управления не используют <xref:System.Windows.Forms.Control.Padding%2A>:  
  
-   Элементы управления, которые не реализуют <xref:System.Windows.Forms.Control.AutoSize%2A> до <xref:System.Windows.Forms.Control.GetPreferredSize%2A>  
  
-   Пользовательские элементы управления, непосредственно наследуемые от <xref:System.Windows.Forms.Control>  
  
-   <xref:System.Windows.Forms.AxHost>  
  
-   <xref:System.Windows.Forms.ComboBox>  
  
-   <xref:System.Windows.Forms.DataGridView>  
  
-   <xref:System.Windows.Forms.DateTimePicker>  
  
-   <xref:System.Windows.Forms.HScrollBar>  
  
-   <xref:System.Windows.Forms.ListView>  
  
-   <xref:System.Windows.Forms.MaskedTextBox>  
  
-   <xref:System.Windows.Forms.MonthCalendar>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.PropertyGrid>  
  
-   <xref:System.Windows.Forms.RichTextBox>  
  
-   <xref:System.Windows.Forms.SplitContainer>  
  
-   <xref:System.Windows.Forms.TextBox>  
  
-   <xref:System.Windows.Forms.TextBoxBase>  
  
-   <xref:System.Windows.Forms.TreeView>  
  
-   <xref:System.Windows.Forms.VScrollBar>  
  
-   <xref:System.Windows.Forms.WebBrowser>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PaddingChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaddingChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PaddingChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PaddingChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PaddingChanged;" />
      <MemberSignature Language="F#" Value="member this.PaddingChanged : EventHandler " Usage="member this.PaddingChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Генерируется при изменении заполнения элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Control.PaddingChanged>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа, который наследует от <xref:System.Windows.Forms.Control>, например <xref:System.Windows.Forms.Button> или <xref:System.Windows.Forms.ComboBox>. Затем присвойте экземпляру имя `Control1` и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Control.PaddingChanged>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#41](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#41)]
 [!code-vb[System.Windows.Forms.EventExamples#41](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#41)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PaintEventHandler Paint;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PaintEventHandler Paint" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Paint" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Paint As PaintEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PaintEventHandler ^ Paint;" />
      <MemberSignature Language="F#" Value="member this.Paint : System.Windows.Forms.PaintEventHandler " Usage="member this.Paint : System.Windows.Forms.PaintEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PaintEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при перерисовке элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие <xref:System.Windows.Forms.Control.Paint> возникает при перерисовке элемента управления. Он передает экземпляр <xref:System.Windows.Forms.PaintEventArgs> методу, обрабатывающему событие <xref:System.Windows.Forms.Control.Paint>.  
  
 При создании нового пользовательского элемента управления или наследуемого элемента управления с другим визуальным представлением необходимо предоставить код для отрисовки элемента управления путем переопределения метода <xref:System.Windows.Forms.Control.OnPaint%2A>. Дополнительные сведения см. [в разделе переопределение метода onpain](~/docs/framework/winforms/controls/overriding-the-onpaint-method.md) и [прорисовка и отрисовки пользовательского элемента управления](~/docs/framework/winforms/controls/custom-control-painting-and-rendering.md).  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода создается элемент управления <xref:System.Windows.Forms.PictureBox> в форме и для его отрисовки используется событие <xref:System.Windows.Forms.Control.Paint>.  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control Parent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Property Parent As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ Parent { System::Windows::Forms::Control ^ get(); void set(System::Windows::Forms::Control ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.Control with get, set" Usage="System.Windows.Forms.Control.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает родительский контейнер элемента управления.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.Control" />, представляющий родительский элемент управления или контейнерный элемент управления элемента управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если задать для свойства <xref:System.Windows.Forms.Control.Parent%2A> значение `null`, элемент управления удаляется из <xref:System.Windows.Forms.Control.ControlCollection> текущего родительского элемента управления.  
  
   
  
## Examples  
 В следующем примере кода используется свойство <xref:System.Windows.Forms.Control.Parent%2A> и метод <xref:System.Windows.Forms.Control.FindForm%2A> для задания свойств родительского элемента управления кнопки и ее формы.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон, чтобы получить значение этого свойства. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ParentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ParentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ParentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ParentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ParentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ParentChanged;" />
      <MemberSignature Language="F#" Value="member this.ParentChanged : EventHandler " Usage="member this.ParentChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.Parent" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.Parent%2A> изменено программным изменением или взаимодействием с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PerformLayout">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вызывает в элементе управления принудительное применение логики макета к дочерним элементам управления.</summary>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </MemberGroup>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformLayout();" />
      <MemberSignature Language="F#" Value="member this.PerformLayout : unit -&gt; unit" Usage="control.PerformLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает в элементе управления принудительное применение логики макета ко всем его дочерним элементам управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если метод <xref:System.Windows.Forms.Control.SuspendLayout%2A> был вызван до вызова метода <xref:System.Windows.Forms.Control.PerformLayout%2A>, событие <xref:System.Windows.Forms.Control.Layout> подавляется.  
  
 Свойства <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A> и <xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A> для класса <xref:System.Windows.Forms.LayoutEventArgs>, которые были созданы, имеют значение `null`, если при вызове метода @no__t 4 не были предоставлены значения.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.Windows.Forms.Control.PerformLayout%2A>. В нем также демонстрируются способы возникновения события <xref:System.Windows.Forms.Control.Layout>. В этом примере обработчик событий `Click` для `Button1` явно вызывает <xref:System.Windows.Forms.Control.PerformLayout%2A>. Обработчик событий `Click` для `Button2` неявно вызывает <xref:System.Windows.Forms.Control.PerformLayout%2A>. <xref:System.Windows.Forms.Control.PerformLayout%2A> также вызывается при загрузке формы. `Button3` возвращает элемент управления в состояние, в котором он находился при загрузке. В каждом случае возникает событие <xref:System.Windows.Forms.Control.Layout>.  
  
 Это полный пример. Чтобы выполнить пример, вставьте следующий код в пустую форму.  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout (System.Windows.Forms.Control affectedControl, string affectedProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout(class System.Windows.Forms.Control affectedControl, string affectedProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout(System.Windows.Forms.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformLayout (affectedControl As Control, affectedProperty As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformLayout(System::Windows::Forms::Control ^ affectedControl, System::String ^ affectedProperty);" />
      <MemberSignature Language="F#" Value="member this.PerformLayout : System.Windows.Forms.Control * string -&gt; unit" Usage="control.PerformLayout (affectedControl, affectedProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="affectedControl" Type="System.Windows.Forms.Control" />
        <Parameter Name="affectedProperty" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="affectedControl">Объект <see cref="T:System.Windows.Forms.Control" />, представляющий последний измененный элемент управления.</param>
        <param name="affectedProperty">Имя последнего измененного свойства элемента управления.</param>
        <summary>Вызывает в элементе управления принудительное применение логики макета ко всем его дочерним элементам управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если метод <xref:System.Windows.Forms.Control.SuspendLayout%2A> был вызван до вызова метода <xref:System.Windows.Forms.Control.PerformLayout%2A>, событие <xref:System.Windows.Forms.Control.Layout> подавляется.  
  
 Для параметров `affectedControl` и `affectedProperty` можно задать значение `null`. Это приводит к тому, что свойства <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A> и <xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A> для <xref:System.Windows.Forms.LayoutEventArgs>, созданные для, устанавливаются в `null`.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.Windows.Forms.Control.PerformLayout%2A>. В нем также демонстрируются способы возникновения события <xref:System.Windows.Forms.Control.Layout>. В этом примере обработчик событий `Click` для `Button1` явно вызывает <xref:System.Windows.Forms.Control.PerformLayout%2A>. Обработчик событий `Click` для `Button2` неявно вызывает <xref:System.Windows.Forms.Control.PerformLayout%2A>. <xref:System.Windows.Forms.Control.PerformLayout%2A> также вызывается при загрузке формы. `Button3` возвращает элемент управления в состояние, в котором он находился при загрузке. В каждом случае возникает событие <xref:System.Windows.Forms.Control.Layout>.  
  
 Это полный пример. Чтобы выполнить пример, вставьте следующий код в пустую форму.  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="PointToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToClient (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToClient(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function PointToClient (p As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point PointToClient(System::Drawing::Point p);" />
      <MemberSignature Language="F#" Value="member this.PointToClient : System.Drawing.Point -&gt; System.Drawing.Point" Usage="control.PointToClient p" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">Преобразуемый элемент <see cref="T:System.Drawing.Point" /> экранных координат.</param>
        <summary>Вычисляет местоположение указанной точки экрана в клиентских координатах.</summary>
        <returns>Объект <see cref="T:System.Drawing.Point" />, представляющий преобразованный объект <see cref="T:System.Drawing.Point" />, <paramref name="p" />, в клиентских координатах.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода пользователь может перетащить изображение или файл изображения на форму и отобразить его в момент удаления. Метод <xref:System.Windows.Forms.Control.OnPaint%2A> переопределен для перерисовки изображения при каждой отрисованной форме; в противном случае изображение будет сохранено только до следующего перерисовки. Метод обработки событий <xref:System.Windows.Forms.Control.DragEnter> определяет тип данных, которые перетаскиваются в форму, и предоставляет соответствующие отзывы. Метод обработки событий <xref:System.Windows.Forms.Control.DragDrop> отображает изображение в форме, если <xref:System.Drawing.Image> может быть создан из данных. Так как значения <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType> и <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> являются экранными координатами, в примере используется метод <xref:System.Windows.Forms.Control.PointToClient%2A> для преобразования их в клиентские координаты.  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="PointToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToScreen (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToScreen(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function PointToScreen (p As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point PointToScreen(System::Drawing::Point p);" />
      <MemberSignature Language="F#" Value="member this.PointToScreen : System.Drawing.Point -&gt; System.Drawing.Point" Usage="control.PointToScreen p" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">Преобразуемый объект <see cref="T:System.Drawing.Point" /> клиентских координат.</param>
        <summary>Вычисляет местоположение указанной точки клиента в экранных координатах.</summary>
        <returns>Объект <see cref="T:System.Drawing.Point" />, представляющий преобразованный объект <see cref="T:System.Drawing.Point" />, <paramref name="p" />, в экранных координатах.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано, как использовать элементы <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType> и <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType>. Чтобы выполнить пример, вставьте следующий код в форму с именем Form1, содержащую несколько элементов управления. В этом примере требуется, чтобы события <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove> и <xref:System.Windows.Forms.Control.MouseUp> были подключены к обработчикам событий, определенным в примере.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="PreferredSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size PreferredSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size PreferredSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PreferredSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size PreferredSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.PreferredSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает размер прямоугольной области, в которую может поместиться элемент управления.</summary>
        <value>Объект <see cref="T:System.Drawing.Size" />, содержащий значения высоты и ширины в пикселях.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessControlMessage">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.PreProcessControlState PreProcessControlMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.PreProcessControlState PreProcessControlMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessControlMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function PreProcessControlMessage (ByRef msg As Message) As PreProcessControlState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::PreProcessControlState PreProcessControlMessage(System::Windows::Forms::Message % msg);" />
      <MemberSignature Language="F#" Value="member this.PreProcessControlMessage : Message -&gt; System.Windows.Forms.PreProcessControlState" Usage="control.PreProcessControlMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreProcessControlState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="msg">Объект <see cref="T:System.Windows.Forms.Message" />, представляющий сообщение, которое требуется обработать.</param>
        <summary>Выполняет предварительную обработку клавиатурных или входящих сообщений в цикле обработки сообщений перед их отправкой.</summary>
        <returns>Одно из значений <see cref="T:System.Windows.Forms.PreProcessControlState" />, зависящее от того, какое значение имеет метод <see cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" /> — <see langword="true" /> или <see langword="false" />, а также какое значение имеет метод <see cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" /> или <see cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" /> — <see langword="true" /> или <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessMessage">
      <MemberSignature Language="C#" Value="public virtual bool PreProcessMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PreProcessMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PreProcessMessage (ByRef msg As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PreProcessMessage(System::Windows::Forms::Message % msg);" />
      <MemberSignature Language="F#" Value="abstract member PreProcessMessage : Message -&gt; bool&#xA;override this.PreProcessMessage : Message -&gt; bool" Usage="control.PreProcessMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="msg">Переданный по ссылке объект <see cref="T:System.Windows.Forms.Message" />, представляющий обрабатываемое сообщение. Возможными значениями являются WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR и WM_SYSCHAR.</param>
        <summary>Выполняет предварительную обработку клавиатурных или входящих сообщений в цикле обработки сообщений перед их отправкой.</summary>
        <returns>Значение <see langword="true" />, если сообщение было обработано элементом управления; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.PreProcessMessage%2A> вызывается циклом обработки сообщений приложения для предварительной обработки входных сообщений до их отправки. Для параметра `msg` допустимы значения WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR и WM_SYSCHAR.  
  
 При переопределении <xref:System.Windows.Forms.Control.PreProcessMessage%2A> элемент управления должен вернуть `true`, чтобы указать, что он обработал сообщение. Для сообщений, которые не обрабатываются элементом управления, должен возвращаться результат `base.PreProcessMessage`. Как правило, элементы управления переопределяют один из более специализированных методов, таких как <xref:System.Windows.Forms.Control.IsInputChar%2A>, <xref:System.Windows.Forms.Control.IsInputKey%2A>, <xref:System.Windows.Forms.Control.ProcessCmdKey%2A>, <xref:System.Windows.Forms.Control.ProcessDialogChar%2A> или <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> вместо переопределения <xref:System.Windows.Forms.Control.PreProcessMessage%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон непосредственных вызывающих объектов для вызова этого метода. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As PreviewKeyDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PreviewKeyDownEventHandler ^ PreviewKeyDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventHandler " Usage="member this.PreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreviewKeyDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Генерируется перед событием <see cref="E:System.Windows.Forms.Control.KeyDown" /> при нажатии клавиши, когда элемент управления имеет фокус.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые нажатия клавиш, такие как TAB, RETURN, ESC и клавиши со стрелками, обычно игнорируются некоторыми элементами управления, так как они не считаются нажатиями клавиш ввода. Например, по умолчанию элемент управления <xref:System.Windows.Controls.Button> игнорирует клавиши со стрелками. Нажатие клавиш со стрелками обычно приводит к перемещению фокуса на предыдущий или следующий элемент управления. Клавиши со стрелками считаются клавишами навигации, и нажатие этих клавиш обычно не вызывает событие <xref:System.Windows.Forms.Control.KeyDown> для <xref:System.Windows.Controls.Button>. Однако нажатие клавиш со стрелками для <xref:System.Windows.Controls.Button> вызывает событие <xref:System.Windows.Forms.Control.PreviewKeyDown>. Обрабатывая событие <xref:System.Windows.Forms.Control.PreviewKeyDown> для <xref:System.Windows.Controls.Button> и устанавливая для свойства <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> значение `true`, можно вызвать событие <xref:System.Windows.Forms.Control.KeyDown> при нажатии клавиш со стрелками. Однако если вы обрабатываете клавиши со стрелками, фокус перестанет перемещаться к предыдущему или следующему элементу управления.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется <xref:System.Windows.Forms.Button>, включающий <xref:System.Windows.Forms.ContextMenuStrip>. Когда <xref:System.Windows.Forms.Button> находится в фокусе и вы нажимаете клавиши со стрелками вверх или вниз, отображается <xref:System.Windows.Forms.ContextMenuStrip>. Обработчик событий <xref:System.Windows.Forms.Control.PreviewKeyDown> обнаруживает, что нажаты клавиши со стрелками вверх или вниз, и устанавливает для свойства <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> значение `true`. Это вызовет событие <xref:System.Windows.Forms.Control.KeyDown>, чтобы можно было отобразить <xref:System.Windows.Forms.ContextMenuStrip>. Не следует помещайте логику в обработчик событий <xref:System.Windows.Forms.Control.PreviewKeyDown>, Кроме установки свойства <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A>. Вместо этого необходимо разместить логику в обработчике событий <xref:System.Windows.Forms.Control.KeyDown>.  
  
 [!code-csharp[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/vb/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member ProcessCmdKey : Message * System.Windows.Forms.Keys -&gt; bool&#xA;override this.ProcessCmdKey : Message * System.Windows.Forms.Keys -&gt; bool" Usage="control.ProcessCmdKey (msg, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">Передаваемый по ссылке объект <see cref="T:System.Windows.Forms.Message" />, который представляет сообщение окна для обработки.</param>
        <param name="keyData">Одно из значений <see cref="T:System.Windows.Forms.Keys" />, представляющее обрабатываемую клавишу.</param>
        <summary>Обрабатывает клавишу для команд.</summary>
        <returns>Значение <see langword="true" />, если знак был обработан элементом управления; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается во время предварительной обработки сообщения для обработки ключей команд. Ключи команд — это ключи, которые всегда имеют приоритет над обычными входными ключами. Примеры клавиш команд: сочетания клавиш и ярлыки меню. Метод должен возвращать `true`, чтобы указать, что он обработал клавишу Command, или `false`, чтобы указать, что ключ не является клавишей команды. Этот метод вызывается только при размещении элемента управления в Windows Forms приложении или в качестве элемента управления ActiveX.  
  
 Метод <xref:System.Windows.Forms.Control.ProcessCmdKey%2A> сначала определяет, имеет ли элемент управления <xref:System.Windows.Forms.ContextMenu>, и, если это так, включает <xref:System.Windows.Forms.ContextMenu> для обработки ключа команды. Если клавиша Command не является ярлыком меню и у элемента управления есть родительский элемент, ключ передается в родительский метод <xref:System.Windows.Forms.Control.ProcessCmdKey%2A>. В результате используются клавиши команд «пузырьковая» в иерархии элементов управления. В дополнение к нажатию клавиши пользователем, ключевые данные также указывают, какие клавиши модификатора были нажаты в то же время, что и ключ. К клавишам модификатора относятся клавиши SHIFT, CTRL и ALT.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для немедленного вызывающего объекта и наследования классов для вызова этого метода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" /> в производном классе элемент управления должен возвращать значение <see langword="true" />, чтобы указать, что он обработал ключ. Для ключей, которые не обрабатываются элементом управления, должен возвращаться результат вызова метода <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" /> базового класса. При необходимости элементы управления будут переопределять этот метод.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessDialogChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessDialogChar(char charCode);" />
      <MemberSignature Language="F#" Value="abstract member ProcessDialogChar : char -&gt; bool&#xA;override this.ProcessDialogChar : char -&gt; bool" Usage="control.ProcessDialogChar charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Символ, подлежащий обработке.</param>
        <summary>Обрабатывает символ диалогового окна.</summary>
        <returns>Значение <see langword="true" />, если знак был обработан элементом управления; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается во время предварительной обработки сообщения для обработки символов диалогового окна, таких как управляющие клавиши. Этот метод вызывается только в том случае, если метод <xref:System.Windows.Forms.Control.IsInputChar%2A> указывает, что элемент управления не обрабатывает символ. Метод <xref:System.Windows.Forms.Control.ProcessDialogChar%2A> просто отправляет символ в родительский метод <xref:System.Windows.Forms.Control.ProcessDialogChar%2A> или возвращает `false`, если у элемента управления нет родителя. Класс <xref:System.Windows.Forms.Form> переопределяет этот метод для выполнения фактической обработки диалоговых символов. Этот метод вызывается только при размещении элемента управления в Windows Forms приложении или в качестве элемента управления ActiveX.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон наследуемых классов для вызова этого метода. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> в производном классе элемент управления должен возвращать значение <see langword="true" />, чтобы указать, что он обработал символ. Для символов, которые не обрабатываются элементом управления, должен возвращаться результат вызова метода <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> базового класса. При необходимости элементы управления будут переопределять этот метод.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool&#xA;override this.ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool" Usage="control.ProcessDialogKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Одно из значений <see cref="T:System.Windows.Forms.Keys" />, представляющее обрабатываемую клавишу.</param>
        <summary>Обрабатывает клавишу диалогового окна.</summary>
        <returns>Значение <see langword="true" />, если клавиша была обработана элементом управления; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается во время предварительной обработки сообщения для обработки символов диалогового окна, таких как TAB, RETURN, ESC и клавиши со стрелками. Этот метод вызывается только в том случае, если метод <xref:System.Windows.Forms.Control.IsInputKey%2A> указывает, что элемент управления не обрабатывает ключ. @No__t-0 просто отправляет символ в родительский метод <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> или возвращает `false`, если у элемента управления нет родителя. Класс <xref:System.Windows.Forms.Form> переопределяет этот метод для выполнения фактической обработки клавиш диалогового окна. Этот метод вызывается только при размещении элемента управления в Windows Forms приложении или в качестве элемента управления ActiveX.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон наследуемых классов для вызова этого метода. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" /> в производном классе элемент управления должен возвращать значение <see langword="true" />, чтобы указать, что он обработал ключ. Для ключей, которые не обрабатываются элементом управления, должен возвращаться результат вызова метода <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> базового класса. При необходимости элементы управления будут переопределять этот метод.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyEventArgs">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyEventArgs (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyEventArgs(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessKeyEventArgs (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessKeyEventArgs(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyEventArgs : Message -&gt; bool&#xA;override this.ProcessKeyEventArgs : Message -&gt; bool" Usage="control.ProcessKeyEventArgs m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Передаваемый по ссылке объект <see cref="T:System.Windows.Forms.Message" />, который представляет сообщение окна для обработки.</param>
        <summary>Обрабатывает сообщение о нажатии клавиши и создает соответствующие события элемента управления.</summary>
        <returns>Значение <see langword="true" />, если сообщение было обработано элементом управления; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается, когда элемент управления получает сообщение клавиатуры. Метод отвечает за создание соответствующих ключевых событий для сообщения путем вызова методов <xref:System.Windows.Forms.Control.OnKeyPress%2A>, <xref:System.Windows.Forms.Control.OnKeyDown%2A> или <xref:System.Windows.Forms.Control.OnKeyUp%2A>. Параметр `m` содержит сообщение окна, которое необходимо обработать. Возможные значения для свойства <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>: WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP, WM_SYSKEYUP и WM_IME_CHAR.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон наследуемых классов для вызова этого метода. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для непосредственного вызывающего объекта, чтобы вызвать неуправляемый код. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> в производном классе элемент управления должен возвращать значение <see langword="true" />, чтобы указать, что он обработал ключ. Для ключей, которые не обрабатываются элементом управления, должен возвращаться результат вызова метода <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> базового класса. При необходимости элементы управления будут переопределять этот метод.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyMessage">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessKeyMessage (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessKeyMessage(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessKeyMessage (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessKeyMessage(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyMessage : Message -&gt; bool&#xA;override this.ProcessKeyMessage : Message -&gt; bool" Usage="control.ProcessKeyMessage m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Передаваемый по ссылке объект <see cref="T:System.Windows.Forms.Message" />, который представляет сообщение окна для обработки.</param>
        <summary>Обрабатывает сообщение клавиатуры.</summary>
        <returns>Значение <see langword="true" />, если сообщение было обработано элементом управления; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается, когда элемент управления получает сообщение клавиатуры. Метод сначала определяет, имеет ли элемент управления родительский объект. Если это так, то вызывается метод <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> родительского объекта. Если метод <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> родительского объекта не обрабатывает сообщение, вызывается метод <xref:System.Windows.Forms.Control.ProcessKeyEventArgs%2A> для создания соответствующих событий клавиатуры. Параметр `m` содержит сообщение окна, которое необходимо обработать. Возможные значения для свойства <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>: WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP и WM_SYSKEYUP.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон наследуемых классов для вызова этого метода. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" /> элемент управления должен возвращать значение <see langword="true" />, чтобы указать, что он обработал ключ. Для ключей, которые не обрабатываются элементом управления, должен возвращаться результат <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> базового класса. При необходимости элементы управления будут переопределять этот метод.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessKeyPreview (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessKeyPreview(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyPreview : Message -&gt; bool&#xA;override this.ProcessKeyPreview : Message -&gt; bool" Usage="control.ProcessKeyPreview m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Передаваемый по ссылке объект <see cref="T:System.Windows.Forms.Message" />, который представляет сообщение окна для обработки.</param>
        <summary>Выполняет предварительный просмотр сообщения клавиатуры.</summary>
        <returns>Значение <see langword="true" />, если сообщение было обработано элементом управления; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается дочерним элементом управления, когда дочерний элемент управления получает сообщение клавиатуры. Дочерний элемент управления вызывает этот метод перед созданием каких бы то ни было событий клавиатуры для сообщения. Если этот метод возвращает `true`, дочерний элемент управления считает сообщение обработанным и не создает никаких событий клавиатуры. Параметр `m` содержит окно сообщения для предварительного просмотра. Возможные значения для свойства <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>: WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP и WM_SYSKEYUP. Метод <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> просто отправляет символ в родительский метод <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> или возвращает `false`, если у элемента управления нет родителя. Класс <xref:System.Windows.Forms.Form> переопределяет этот метод для выполнения фактической обработки клавиш диалогового окна.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон наследуемых классов для вызова этого метода. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для непосредственного вызывающего объекта, чтобы вызвать неуправляемый код. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>При переопределении метода <see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" /> в производном классе элемент управления должен возвращать значение <see langword="true" />, чтобы указать, что он обработал ключ. Для ключей, которые не обрабатываются элементом управления, должен возвращаться результат вызова метода <see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" /> базового класса.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessMnemonic (char charCode);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessMnemonic(char charCode) cil managed" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessMnemonic (charCode As Char) As Boolean" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessMnemonic(char charCode);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member ProcessMnemonic : char -&gt; bool&#xA;override this.ProcessMnemonic : char -&gt; bool" Usage="control.ProcessMnemonic charCode" />
      <MemberSignature Language="C#" Value="protected virtual bool ProcessMnemonic (char charCode);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessMnemonic(char charCode) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessMnemonic (charCode As Char) As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessMnemonic(char charCode);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Символ, подлежащий обработке.</param>
        <summary>Обрабатывает назначенный символ.</summary>
        <returns>Значение <see langword="true" />, если символ был обработан элементом управления как назначенный; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается для предоставления элементу управления возможности обрабатывать назначенный символ. Метод должен определить, находится ли элемент управления в состоянии для обработки назначенных символов, и указывает, представляет ли заданный символ назначенную клавишу. Если это так, метод должен выполнить действие, связанное с назначенной клавишей, и вернуть `true`. В противном случае метод должен вернуть значение `false`. Реализации этого метода часто используют метод <xref:System.Windows.Forms.Control.IsMnemonic%2A>, чтобы определить, соответствует ли заданный символ назначенному в тексте элемента управления.  
  
 Например:  
  
```csharp  
if (CanSelect && IsMnemonic(charCode, MyControl.Text) {  
      // Perform action associated with mnemonic.  
       }  
```  
  
 Эта реализация по умолчанию для метода <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> просто возвращает `false`, чтобы указать, что у элемента управления нет назначенных клавиш.  
  
   
  
## Examples  
 В следующем примере кода показано расширение класса Button, которое переопределяет метод <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> для отображения пользовательского поведения. В примере также демонстрируется использование свойств <xref:System.Windows.Forms.Control.CanSelect%2A> и <xref:System.Windows.Forms.Control.IsMnemonic%2A>. Чтобы выполнить этот пример, вставьте следующий код после класса Form в тот же файл. Добавьте в форму кнопку типа `MnemonicButton`.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон наследуемых классов для вызова этого метода. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
        <altmember cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Control.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя продукта сборки, содержащей элемент управления.</summary>
        <value>Имя продукта сборки, содержащей элемент управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.ProductName%2A> является свойством только для чтения. Чтобы изменить значение этого свойства, задайте значение свойства <xref:System.Reflection.AssemblyProductAttribute.Product%2A> для <xref:System.Reflection.AssemblyProductAttribute>. В следующей строке C# кода задается свойство <xref:System.Windows.Forms.Control.ProductName%2A>.  
  
```  
[assembly: AssemblyProduct("MyApplication")]  
```  
  
> [!NOTE]
>  Настоятельно рекомендуется указать название компании, название продукта и версию продукта. Предоставление этих сведений позволяет использовать Windows Forms функции, такие как <xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType>, которые упрощают написание приложений, соответствующих программе "сертифицировано для Windows". Дополнительные сведения о программе сертификации для Windows см. в разделе http://msdn.microsoft.com/certification.  
  
   
  
## Examples  
 В следующем примере кода отображаются сведения о приложении в <xref:System.Windows.Forms.Label>, содержащемся в <xref:System.Windows.Forms.Form>. Для этого примера требуется, чтобы были заданы <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> и <xref:System.Windows.Forms.Control.ProductVersion%2A>.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyProductAttribute.Product" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Control.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает версию сборки, содержащую элемент управления.</summary>
        <value>Версия файла сборки, содержащая элемент управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.ProductVersion%2A> является свойством только для чтения. Чтобы изменить значение этого свойства, задайте значение свойства <xref:System.Reflection.AssemblyVersionAttribute.Version%2A> для <xref:System.Reflection.AssemblyVersionAttribute>. В следующей строке C# кода задается свойство <xref:System.Windows.Forms.Control.ProductVersion%2A>.  
  
```  
[assembly: AssemblyVersion("1.0.1")]  
```  
  
> [!NOTE]
>  Настоятельно рекомендуется указать название компании, название продукта и версию продукта. Предоставление этих сведений позволяет использовать Windows Forms функции, такие как <xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType>, которые упрощают написание приложений, соответствующих программе "сертифицировано для Windows". Дополнительные сведения о программе сертификации для Windows см. в разделе http://msdn.microsoft.com/certification.  
  
   
  
## Examples  
 В следующем примере кода отображаются сведения о приложении в <xref:System.Windows.Forms.Label>, содержащемся в <xref:System.Windows.Forms.Form>. Для этого примера требуется, чтобы были заданы <xref:System.Windows.Forms.Control.CompanyName%2A>, <xref:System.Windows.Forms.Control.ProductName%2A> и <xref:System.Windows.Forms.Control.ProductVersion%2A>.  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyVersionAttribute.Version" />
      </Docs>
    </Member>
    <Member MemberName="PropagatingImeMode">
      <MemberSignature Language="C#" Value="protected static System.Windows.Forms.ImeMode PropagatingImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.ImeMode PropagatingImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PropagatingImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly Property PropagatingImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static property System::Windows::Forms::ImeMode PropagatingImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberSignature Language="F#" Value="member this.PropagatingImeMode : System.Windows.Forms.ImeMode" Usage="System.Windows.Forms.Control.PropagatingImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект, представляющий режим IME распространения.</summary>
        <value>Объект, представляющий режим IME распространения.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAccessibilityHelp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryAccessibilityHelp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryAccessibilityHelp As QueryAccessibilityHelpEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryAccessibilityHelpEventHandler ^ QueryAccessibilityHelp;" />
      <MemberSignature Language="F#" Value="member this.QueryAccessibilityHelp : System.Windows.Forms.QueryAccessibilityHelpEventHandler " Usage="member this.QueryAccessibilityHelp : System.Windows.Forms.QueryAccessibilityHelpEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryAccessibilityHelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда объект <see cref="T:System.Windows.Forms.AccessibleObject" /> предоставляет справку для приложений со специальными возможностями.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте класс <xref:System.Windows.Forms.HelpProvider>, чтобы пользователи могли вызывать справку для доступного объекта, нажав клавишу F1. Использование <xref:System.Windows.Forms.HelpProvider> предоставляет полные сведения в <xref:System.Windows.Forms.QueryAccessibilityHelpEventArgs>. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано создание элемента управления диаграммы с поддержкой специальных возможностей с помощью классов <xref:System.Windows.Forms.AccessibleObject> и <xref:System.Windows.Forms.Control.ControlAccessibleObject> для предоставления доступной информации. Элемент управления отображает две кривые вместе с условными обозначениями. Класс `ChartControlAccessibleObject`, который является производным от `ControlAccessibleObject`, используется в методе <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> для предоставления настраиваемой информации, доступной для элемента управления диаграммы. Поскольку условные обозначения диаграммы не являются фактическим элементом управления на основе <xref:System.Windows.Forms.Control>, а нарисованы элементом управления диаграммы, он не содержит встроенных доступных сведений. В связи с этим класс `ChartControlAccessibleObject` переопределяет метод <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> для возврата `CurveLegendAccessibleObject`, который представляет доступную информацию для каждой части условных обозначений. Если приложение, поддерживающее доступ, использует этот элемент управления, элемент управления может предоставить необходимые сведения о специальных возможностях.  
  
 Этот фрагмент кода демонстрирует обработку события <xref:System.Windows.Forms.Control.QueryAccessibilityHelp>. Полный пример кода см. в обзоре класса <xref:System.Windows.Forms.AccessibleObject>.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#3)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#3)]
 [!code-vb[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.AccessibleObject.GetHelpTopic(System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит во время операции перетаскивания и позволяет источнику перетаскивания определить, следует ли отменить эту операцию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие <xref:System.Windows.Forms.Control.QueryContinueDrag> возникает при изменении состояния клавиатуры или кнопки мыши во время операции перетаскивания. Событие <xref:System.Windows.Forms.Control.QueryContinueDrag> позволяет источнику перетаскивания определить, следует ли отменить операцию перетаскивания.  
  
 Далее описывается, как и когда возникают события, связанные с операциями перетаскивания.  
  
 Метод <xref:System.Windows.Forms.Control.DoDragDrop%2A> определяет элемент управления под текущим местоположением курсора. Затем он проверяет, является ли элемент управления допустимым целевым объектом перетаскивания.  
  
 Если элемент управления является допустимым целевым объектом перетаскивания, то событие <xref:System.Windows.Forms.Control.GiveFeedback> вызывается с указанными действиями перетаскивания. Список эффектов перетаскивания см. в перечислении <xref:System.Windows.Forms.DragDropEffects>.  
  
 Отслеживаются изменения позиции указателя мыши, состояния клавиатуры и кнопки мыши.  
  
-   Если пользователь перемещает указатель мыши за пределы окна, происходит событие <xref:System.Windows.Forms.Control.DragLeave>.  
  
-   Если указатель мыши перемещается на другой элемент управления, для этого элемента вызывается событие <xref:System.Windows.Forms.Control.DragEnter>.  
  
-   При перемещении мыши в пределах одного элемента управления возникает событие <xref:System.Windows.Forms.Control.DragOver>.  
  
 При изменении состояния клавиатуры или кнопки мыши возникает событие <xref:System.Windows.Forms.Control.QueryContinueDrag> и определяет, следует ли продолжить перетаскивание, для удаления данных или отмены операции на основе значения свойства <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> события <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Continue`, возникает событие <xref:System.Windows.Forms.Control.DragOver> для продолжения операции, а событие <xref:System.Windows.Forms.Control.GiveFeedback> вызывается с новым действием, чтобы можно было установить соответствующую визуальную обратную связь. Список допустимых эффектов сброса см. в перечислении <xref:System.Windows.Forms.DragDropEffects>.  
  
    > [!NOTE]
    >  События <xref:System.Windows.Forms.Control.DragOver> и <xref:System.Windows.Forms.Control.GiveFeedback> сопряжены таким образом, что при перемещении мыши по направлению перетаскивания пользователь получает наиболее актуальную информацию о положении мыши.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Drop`, то значение результата перетаскивания возвращается в источник, поэтому исходное приложение может выполнить соответствующую операцию с исходными данными. Например, если операция была перемещена, вырежьте данные.  
  
-   Если значение <xref:System.Windows.Forms.DragAction> равно `Cancel`, возникает событие <xref:System.Windows.Forms.Control.DragLeave>.  
  
 По умолчанию событие <xref:System.Windows.Forms.Control.QueryContinueDrag> задает <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> для `Cancel` в <xref:System.Windows.Forms.DragAction>, если нажата клавиша ESC, и задает для <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> значение `Drop` в <xref:System.Windows.Forms.DragAction> при нажатии левой, средней или правой кнопки мыши.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Этот фрагмент кода демонстрирует использование события <xref:System.Windows.Forms.Control.QueryContinueDrag> для отмены операции перетаскивания, если операция перетаскивания выходит за границы формы. Полный пример кода см. в описании метода <xref:System.Windows.Forms.Control.DoDragDrop%2A>.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseDragEvent">
      <MemberSignature Language="C#" Value="protected void RaiseDragEvent (object key, System.Windows.Forms.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseDragEvent(object key, class System.Windows.Forms.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseDragEvent (key As Object, e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseDragEvent(System::Object ^ key, System::Windows::Forms::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseDragEvent : obj * System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.RaiseDragEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Вызываемое событие.</param>
        <param name="e">Объект <see cref="T:System.Windows.Forms.DragEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает соответствующее событие перетаскивания.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseKeyEvent">
      <MemberSignature Language="C#" Value="protected void RaiseKeyEvent (object key, System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseKeyEvent(object key, class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseKeyEvent (key As Object, e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseKeyEvent(System::Object ^ key, System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseKeyEvent : obj * System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.RaiseKeyEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Вызываемое событие.</param>
        <param name="e">Объект <see cref="T:System.Windows.Forms.KeyEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает соответствующее событие клавиши.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseMouseEvent">
      <MemberSignature Language="C#" Value="protected void RaiseMouseEvent (object key, System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseMouseEvent(object key, class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseMouseEvent (key As Object, e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseMouseEvent(System::Object ^ key, System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseMouseEvent : obj * System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.RaiseMouseEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Вызываемое событие.</param>
        <param name="e">Объект <see cref="T:System.Windows.Forms.MouseEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает соответствующее событие мыши.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaisePaintEvent">
      <MemberSignature Language="C#" Value="protected void RaisePaintEvent (object key, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaisePaintEvent(object key, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaisePaintEvent (key As Object, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaisePaintEvent(System::Object ^ key, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaisePaintEvent : obj * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.RaisePaintEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Вызываемое событие.</param>
        <param name="e">Объект <see cref="T:System.Windows.Forms.PaintEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает соответствующее событие рисования.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RecreateHandle">
      <MemberSignature Language="C#" Value="protected void RecreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RecreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RecreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RecreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RecreateHandle();" />
      <MemberSignature Language="F#" Value="member this.RecreateHandle : unit -&gt; unit" Usage="control.RecreateHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает повторное создание дескриптора элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Forms.Control.RecreateHandle%2A> вызывается каждый раз, когда для нового элемента управления требуются параметры, но использование вызова из <xref:System.Windows.Forms.Control.UpdateStyles%2A> в <xref:System.Windows.Forms.Control.CreateParams%2A> недостаточно. Этот метод также вызывает <xref:System.Windows.Forms.Control.DestroyHandle%2A> и <xref:System.Windows.Forms.Control.CreateHandle%2A> и устанавливает <xref:System.Windows.Forms.Control.RecreatingHandle%2A> в `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="RecreatingHandle">
      <MemberSignature Language="C#" Value="public bool RecreatingHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RecreatingHandle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RecreatingHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecreatingHandle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RecreatingHandle { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RecreatingHandle : bool" Usage="System.Windows.Forms.Control.RecreatingHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, осуществляет ли в настоящий момент элемент управления повторное создание дескриптора.</summary>
        <value>Значение <see langword="true" />, если в данный момент осуществляется повторное создание дескриптора элементом управления; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.RecreatingHandle%2A> возвращает `true`, если метод <xref:System.Windows.Forms.Control.RecreateHandle%2A> по-прежнему выполняется в элементе управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="RectangleToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToClient (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToClient(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function RectangleToClient (r As Rectangle) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle RectangleToClient(System::Drawing::Rectangle r);" />
      <MemberSignature Language="F#" Value="member this.RectangleToClient : System.Drawing.Rectangle -&gt; System.Drawing.Rectangle" Usage="control.RectangleToClient r" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">Преобразуемый элемент <see cref="T:System.Drawing.Rectangle" /> экранных координат.</param>
        <summary>Вычисляет размер и местоположение указанной прямоугольной области экрана в клиентских координатах.</summary>
        <returns>Объект <see cref="T:System.Drawing.Rectangle" />, представляющий преобразованный объект <see cref="T:System.Drawing.Rectangle" />, <paramref name="r" />, в клиентских координатах.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="RectangleToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToScreen (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToScreen(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function RectangleToScreen (r As Rectangle) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle RectangleToScreen(System::Drawing::Rectangle r);" />
      <MemberSignature Language="F#" Value="member this.RectangleToScreen : System.Drawing.Rectangle -&gt; System.Drawing.Rectangle" Usage="control.RectangleToScreen r" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">Преобразуемый объект <see cref="T:System.Drawing.Rectangle" /> клиентских координат.</param>
        <summary>Вычисляет размер и местоположение указанной клиентской области (в виде прямоугольника) в экранных координатах.</summary>
        <returns>Объект <see cref="T:System.Drawing.Rectangle" />, представляющий преобразованный объект <see cref="T:System.Drawing.Rectangle" />, <paramref name="p" />, в экранных координатах.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано, как использовать элементы <xref:System.Windows.Forms.Control.BackColor%2A>, <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, <xref:System.Windows.Forms.Control.PointToScreen%2A>, <xref:System.Windows.Forms.Control.MouseButtons%2A>, <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType> и <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType>. Чтобы выполнить пример, вставьте следующий код в форму с именем **Form1** , содержащую несколько элементов управления. В этом примере требуется, чтобы события <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove> и <xref:System.Windows.Forms.Control.MouseUp> были подключены к обработчикам событий, определенным в примере.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="ReflectMessage">
      <MemberSignature Language="C#" Value="protected static bool ReflectMessage (IntPtr hWnd, ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool ReflectMessage(native int hWnd, valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ReflectMessage(System.IntPtr,System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function ReflectMessage (hWnd As IntPtr, ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool ReflectMessage(IntPtr hWnd, System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="static member ReflectMessage : nativeint * Message -&gt; bool" Usage="System.Windows.Forms.Control.ReflectMessage (hWnd, m)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hWnd" Type="System.IntPtr" />
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="hWnd">Объект <see cref="T:System.IntPtr" />, представляющий дескриптор элемента управления, которому следует переслать сообщение.</param>
        <param name="m">Объект <see cref="T:System.Windows.Forms.Message" />, предоставляющий пересылаемое сообщение Windows.</param>
        <summary>Пересылает указанное сообщение элементу управления, связанному с заданным дескриптором.</summary>
        <returns>Значение <see langword="true" />, если сообщение было переслано; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Forms.Control.ReflectMessage%2A> является методом инфраструктуры, и обычно его не следует вызывать из кода.  
  
 Если параметр `hWnd` не представляет допустимый элемент управления, метод <xref:System.Windows.Forms.Control.ReflectMessage%2A> возвращает `false`.  
  
 Так как сообщения Windows возвращаются в окно верхнего уровня, метод <xref:System.Windows.Forms.Control.ReflectMessage%2A> используется для передачи возвращаемого сообщения в элемент управления, который отправил сообщение.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон, вызывающих этот метод. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public virtual void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Refresh();" />
      <MemberSignature Language="F#" Value="abstract member Refresh : unit -&gt; unit&#xA;override this.Refresh : unit -&gt; unit" Usage="control.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Принудительно создает условия, при которых элемент управления делает недоступной свою клиентскую область и немедленно перерисовывает себя и все дочерние элементы.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.Windows.Forms.Control.Refresh" /> в производном классе обязательно вызывайте метод <see cref="M:System.Windows.Forms.Control.Refresh" /> базового класса, чтобы элемент управления и его дочерние элементы управления стали недействительными и перерисованы.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.Update" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <Member MemberName="Region">
      <MemberSignature Language="C#" Value="public System.Drawing.Region Region { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Region Region" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Region" />
      <MemberSignature Language="VB.NET" Value="Public Property Region As Region" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Region ^ Region { System::Drawing::Region ^ get(); void set(System::Drawing::Region ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Region : System.Drawing.Region with get, set" Usage="System.Windows.Forms.Control.Region" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Region</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает область окна, связанную с элементом управления.</summary>
        <value>Объект <see cref="T:System.Drawing.Region" /> окна, сопоставленный с элементом управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Область окна представляет собой коллекцию пикселей в окне, в которой операционная система разрешает рисование. Операционная система не отображает ни одной части окна, которая находится за пределами области окна. Координаты области элемента управления задаются относительно левого верхнего угла элемента управления, а не клиентской области элемента управления.  
  
> [!NOTE]
>  Коллекция пикселей, содержащаяся в области, может быть не непрерывной.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать свойство <xref:System.Windows.Forms.Control.Region%2A> путем создания круглой кнопки. Чтобы выполнить пример, вставьте следующий код в форму, содержащую кнопку с именем `roundButton`. В этом примере требуется, чтобы событие <xref:System.Windows.Forms.Control.Paint> было подключено к обработчику событий, определенному в примере.  
  
 [!code-cpp[System.Windows.Forms.Control.Region#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.Region#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.Region#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">значение этого свойства для всех окон. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="RegionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RegionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RegionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RegionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RegionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RegionChanged;" />
      <MemberSignature Language="F#" Value="member this.RegionChanged : EventHandler " Usage="member this.RegionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Control.RegionChanged>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа, который наследует от <xref:System.Windows.Forms.Control>, например <xref:System.Windows.Forms.Button> или <xref:System.Windows.Forms.ComboBox>. Затем присвойте экземпляру имя `Control1` и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Control.RegionChanged>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#22)]
 [!code-vb[System.Windows.Forms.EventExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderRightToLeft">
      <MemberSignature Language="C#" Value="protected internal bool RenderRightToLeft { get; }" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RenderRightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RenderRightToLeft" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property RenderRightToLeft As Boolean" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool RenderRightToLeft { bool get(); };" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.RenderRightToLeft : bool" Usage="System.Windows.Forms.Control.RenderRightToLeft" />
      <MemberSignature Language="C#" Value="protected bool RenderRightToLeft { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property RenderRightToLeft As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool RenderRightToLeft { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated. Please use RightToLeft instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Это свойство устарело.</summary>
        <value>Значение <see langword="true" />, если элемент управления прорисовывается справа налево; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RescaleConstantsForDpi">
      <MemberSignature Language="C#" Value="protected virtual void RescaleConstantsForDpi (int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RescaleConstantsForDpi(int32 deviceDpiOld, int32 deviceDpiNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RescaleConstantsForDpi(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RescaleConstantsForDpi (deviceDpiOld As Integer, deviceDpiNew As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RescaleConstantsForDpi(int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="F#" Value="abstract member RescaleConstantsForDpi : int * int -&gt; unit&#xA;override this.RescaleConstantsForDpi : int * int -&gt; unit" Usage="control.RescaleConstantsForDpi (deviceDpiOld, deviceDpiNew)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">Значение DPI до внесения изменения.</param>
        <param name="deviceDpiNew">Значение DPI после внесения изменения.</param>
        <summary>Предоставляет константы для изменения масштаба элемента управления при изменении DPI.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBackColor">
      <MemberSignature Language="C#" Value="public virtual void ResetBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetBackColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetBackColor();" />
      <MemberSignature Language="F#" Value="abstract member ResetBackColor : unit -&gt; unit&#xA;override this.ResetBackColor : unit -&gt; unit" Usage="control.ResetBackColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Восстанавливает значение по умолчанию свойства <see cref="P:System.Windows.Forms.Control.BackColor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный метод не применим к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBindings">
      <MemberSignature Language="C#" Value="public void ResetBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBindings" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetBindings ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetBindings();" />
      <MemberSignature Language="F#" Value="member this.ResetBindings : unit -&gt; unit" Usage="control.ResetBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает в элементе управления, привязанном к компоненту <see cref="T:System.Windows.Forms.BindingSource" />, повторное считывание всех элементов списка и обновление их отображаемых значений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный метод не применим к этому классу.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.DataBindings" />
      </Docs>
    </Member>
    <Member MemberName="ResetCursor">
      <MemberSignature Language="C#" Value="public virtual void ResetCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetCursor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetCursor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetCursor();" />
      <MemberSignature Language="F#" Value="abstract member ResetCursor : unit -&gt; unit&#xA;override this.ResetCursor : unit -&gt; unit" Usage="control.ResetCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Восстанавливает значение по умолчанию свойства <see cref="P:System.Windows.Forms.Control.Cursor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный метод не применим к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetFont">
      <MemberSignature Language="C#" Value="public virtual void ResetFont ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetFont() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetFont" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetFont ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetFont();" />
      <MemberSignature Language="F#" Value="abstract member ResetFont : unit -&gt; unit&#xA;override this.ResetFont : unit -&gt; unit" Usage="control.ResetFont " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Восстанавливает значение по умолчанию свойства <see cref="P:System.Windows.Forms.Control.Font" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный метод не применим к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetForeColor">
      <MemberSignature Language="C#" Value="public virtual void ResetForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetForeColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetForeColor();" />
      <MemberSignature Language="F#" Value="abstract member ResetForeColor : unit -&gt; unit&#xA;override this.ResetForeColor : unit -&gt; unit" Usage="control.ResetForeColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Восстанавливает значение по умолчанию свойства <see cref="P:System.Windows.Forms.Control.ForeColor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный метод не применим к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetImeMode">
      <MemberSignature Language="C#" Value="public void ResetImeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetImeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetImeMode" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetImeMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetImeMode();" />
      <MemberSignature Language="F#" Value="member this.ResetImeMode : unit -&gt; unit" Usage="control.ResetImeMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Восстанавливает значение по умолчанию свойства <see cref="P:System.Windows.Forms.Control.ImeMode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный метод не применим к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetMouseEventArgs">
      <MemberSignature Language="C#" Value="protected void ResetMouseEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ResetMouseEventArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetMouseEventArgs" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ResetMouseEventArgs ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ResetMouseEventArgs();" />
      <MemberSignature Language="F#" Value="member this.ResetMouseEventArgs : unit -&gt; unit" Usage="control.ResetMouseEventArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сбрасывает элемент управления в дескриптор события <see cref="E:System.Windows.Forms.Control.MouseLeave" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetRightToLeft">
      <MemberSignature Language="C#" Value="public virtual void ResetRightToLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetRightToLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetRightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetRightToLeft ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetRightToLeft();" />
      <MemberSignature Language="F#" Value="abstract member ResetRightToLeft : unit -&gt; unit&#xA;override this.ResetRightToLeft : unit -&gt; unit" Usage="control.ResetRightToLeft " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Восстанавливает значение по умолчанию свойства <see cref="P:System.Windows.Forms.Control.RightToLeft" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный метод не применим к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetText">
      <MemberSignature Language="C#" Value="public virtual void ResetText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetText" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetText ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetText();" />
      <MemberSignature Language="F#" Value="abstract member ResetText : unit -&gt; unit&#xA;override this.ResetText : unit -&gt; unit" Usage="control.ResetText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Восстанавливает значение по умолчанию свойства <see cref="P:System.Windows.Forms.Control.Text" /> (<see cref="F:System.String.Empty" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод обычно используется при создании конструктора для <xref:System.Windows.Forms.Control> или при создании собственного элемента управления, включающего <xref:System.Windows.Forms.Control>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="Resize">
      <MemberSignature Language="C#" Value="public event EventHandler Resize;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Resize" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Resize" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resize As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Resize;" />
      <MemberSignature Language="F#" Value="member this.Resize : EventHandler " Usage="member this.Resize : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении размеров элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы определить <xref:System.Windows.Forms.Control.Size%2A> элемента управления с измененным размером, можно привести параметр `sender` для зарегистрированного метода <xref:System.Windows.Forms.ControlEventHandler> к <xref:System.Windows.Forms.Control> и получить его свойство <xref:System.Windows.Forms.Control.Size%2A> (или свойства <xref:System.Windows.Forms.Control.Height%2A> и <xref:System.Windows.Forms.Control.Width%2A> по отдельности).  
  
 Для управления пользовательскими макетами используйте событие <xref:System.Windows.Forms.Control.Layout> вместо события изменения размера. Событие <xref:System.Windows.Forms.Control.Layout> возникает в ответ на событие <xref:System.Windows.Forms.Control.Resize>, но также в ответ на другие изменения, влияющие на макет элемента управления.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода обрабатывается событие <xref:System.Windows.Forms.Control.Resize> <xref:System.Windows.Forms.Form>. При изменении размера формы обработчик событий гарантирует, что форма остается квадратной (ее <xref:System.Windows.Forms.Control.Height%2A> и <xref:System.Windows.Forms.Control.Width%2A> остаются равными). Чтобы выполнить этот пример, убедитесь и свяжите этот метод обработки событий с событием <xref:System.Windows.Forms.Control.Resize> формы.  
  
 [!code-cpp[WinForms.Control.Resize#1](~/samples/snippets/cpp/VS_Snippets_Winforms/WinForms.Control.Resize/CPP/form1.cpp#1)]
 [!code-csharp[WinForms.Control.Resize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/WinForms.Control.Resize/CS/form1.cs#1)]
 [!code-vb[WinForms.Control.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/WinForms.Control.Resize/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="ResizeRedraw">
      <MemberSignature Language="C#" Value="protected bool ResizeRedraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResizeRedraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ResizeRedraw" />
      <MemberSignature Language="VB.NET" Value="Protected Property ResizeRedraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ResizeRedraw { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeRedraw : bool with get, set" Usage="System.Windows.Forms.Control.ResizeRedraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, перерисовывается ли элемент управления при изменении размеров.</summary>
        <value>Значение <see langword="true" />, если элемент управления перерисовывается при изменении размеров; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение свойства <xref:System.Windows.Forms.Control.ResizeRedraw%2A> эквивалентно возвращаемому значению метода <xref:System.Windows.Forms.Control.GetStyle%2A> при передаче значения <xref:System.Windows.Forms.ControlStyles.ResizeRedraw?displayProperty=nameWithType> в качестве параметра.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.ResizeRedraw" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ResumeLayout">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возобновляет обычную логику макета.</summary>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeLayout();" />
      <MemberSignature Language="F#" Value="member this.ResumeLayout : unit -&gt; unit" Usage="control.ResumeLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возобновляет обычную логику макета.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов метода <xref:System.Windows.Forms.Control.ResumeLayout%2A> приводит к немедленному разметке при наличии ожидающих запросов макета.  
  
 Методы <xref:System.Windows.Forms.Control.SuspendLayout%2A> и <xref:System.Windows.Forms.Control.ResumeLayout%2A> используются совместно, чтобы подавлять несколько событий <xref:System.Windows.Forms.Control.Layout> при изменении нескольких атрибутов элемента управления. Например, обычно вызывается метод <xref:System.Windows.Forms.Control.SuspendLayout%2A>, затем устанавливаются свойства элемента управления <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A> или <xref:System.Windows.Forms.Control.Dock%2A>, а затем вызывается метод <xref:System.Windows.Forms.Control.ResumeLayout%2A>, чтобы изменения вступили в силу.  
  
 Для успешного вызова <xref:System.Windows.Forms.Control.ResumeLayout%2A> не должно быть незавершенных вызовов <xref:System.Windows.Forms.Control.SuspendLayout%2A>.  
  
   
  
## Examples  
 В следующем примере кода две кнопки добавляются в форму. В примере транзакции Добавление кнопок осуществляется с помощью методов <xref:System.Windows.Forms.Control.SuspendLayout%2A> и <xref:System.Windows.Forms.Control.ResumeLayout%2A>.  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout (bool performLayout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout(bool performLayout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeLayout (performLayout As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeLayout(bool performLayout);" />
      <MemberSignature Language="F#" Value="member this.ResumeLayout : bool -&gt; unit" Usage="control.ResumeLayout performLayout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="performLayout" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="performLayout">Значение <see langword="true" />, чтобы выполнить отложенные запросы макета; в противном случае — значение <see langword="false" />.</param>
        <summary>Возобновляет обычную логику макета, дополнительно осуществляя немедленное отображение отложенных запросов макета.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов метода <xref:System.Windows.Forms.Control.ResumeLayout%2A> приводит к немедленному разметке при наличии ожидающих запросов макета. Если для параметра `performLayout` задано значение `true`, то при наличии запросов макета, ожидающих обработки, происходит немедленное размещение.  
  
 Методы <xref:System.Windows.Forms.Control.SuspendLayout%2A> и <xref:System.Windows.Forms.Control.ResumeLayout%2A> используются совместно, чтобы подавлять несколько событий <xref:System.Windows.Forms.Control.Layout> при изменении нескольких атрибутов элемента управления. Например, обычно вызывается метод <xref:System.Windows.Forms.Control.SuspendLayout%2A>, затем устанавливаются свойства элемента управления <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A> или <xref:System.Windows.Forms.Control.Dock%2A>, а затем вызывается метод <xref:System.Windows.Forms.Control.ResumeLayout%2A>, чтобы изменения вступили в силу.  
  
 Для успешного вызова <xref:System.Windows.Forms.Control.ResumeLayout%2A> не должно быть незавершенных вызовов <xref:System.Windows.Forms.Control.SuspendLayout%2A>.  
  
> [!NOTE]
>  При добавлении нескольких элементов управления в родительский элемент управления рекомендуется вызвать метод <xref:System.Windows.Forms.Control.SuspendLayout%2A> перед инициализацией добавляемых элементов управления. После добавления элементов управления в родительский элемент управления вызовите метод <xref:System.Windows.Forms.Control.ResumeLayout%2A>. Это увеличит производительность приложений с большим количеством элементов управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="Right">
      <MemberSignature Language="C#" Value="public int Right { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Right" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Right" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Right As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Right { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Right : int" Usage="System.Windows.Forms.Control.Right" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает расстояние в пикселях между правой границей элемента управления и левой границей клиентской области его контейнера.</summary>
        <value>Объект <see cref="T:System.Int32" />, представляющий расстояние (в пикселях) между правой границей элемента управления и левой границей клиентской области контейнера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение свойства <xref:System.Windows.Forms.Control.Right%2A> равно сумме значения свойства <xref:System.Windows.Forms.Control.Left%2A> и значения свойства <xref:System.Windows.Forms.Control.Width%2A>.  
  
 Свойство <xref:System.Windows.Forms.Control.Right%2A> доступно только для чтения. Это значение свойства можно изменить косвенно, изменив значения свойств <xref:System.Windows.Forms.Control.Left%2A> или <xref:System.Windows.Forms.Control.Width%2A> или вызвав методы <xref:System.Windows.Forms.Control.SetBounds%2A>, <xref:System.Windows.Forms.Control.SetBoundsCore%2A>, <xref:System.Windows.Forms.Control.UpdateBounds%2A> или <xref:System.Windows.Forms.Control.SetClientSizeCore%2A>.  
  
   
  
## Examples  
 В следующем примере кода создаются три элемента управления <xref:System.Windows.Forms.Button> в форме и задаются их размер и расположение с использованием различных свойств, связанных с размером и расположением. В этом примере требуется наличие <xref:System.Windows.Forms.Form> с шириной и высотой не менее 300 пикселей.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Right" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.RightToLeft RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RightToLeft RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RightToLeft As RightToLeft" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::RightToLeft RightToLeft { System::Windows::Forms::RightToLeft get(); void set(System::Windows::Forms::RightToLeft value); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : System.Windows.Forms.RightToLeft with get, set" Usage="System.Windows.Forms.Control.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RightToLeft</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, выровнены ли компоненты элемента управления для поддержки языков, использующих шрифты с написанием справа налево.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Windows.Forms.RightToLeft" />. Значение по умолчанию — <see cref="F:System.Windows.Forms.RightToLeft.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.RightToLeft%2A> является внешним свойством. Внешнее свойство — это свойство элемента управления, которое, если оно не задано, извлекается из родительского элемента управления. Например, <xref:System.Windows.Forms.Button> будет иметь то же <xref:System.Windows.Forms.Control.BackColor%2A>, что и родительский <xref:System.Windows.Forms.Form> по умолчанию. Дополнительные сведения о внешних свойствах см. в описании класса <xref:System.Windows.Forms.AmbientProperties> или в обзоре класса <xref:System.Windows.Forms.Control>.  
  
 Свойство <xref:System.Windows.Forms.Control.RightToLeft%2A> используется для международных приложений, в которых язык написан справа налево, например иврит или арабский. Если это свойство имеет значение <xref:System.Windows.Forms.RightToLeft.Yes?displayProperty=nameWithType>, элементы управления, содержащие текст, отображаются справа налево.  
  
> [!NOTE]
>  Если значение свойства <xref:System.Windows.Forms.Control.RightToLeft%2A> изменяется во время выполнения, сохраняется только необработанный текст без форматирования.  
  
 Ниже приведено несколько примеров того, как на элементы управления влияет значение свойства <xref:System.Windows.Forms.Control.RightToLeft%2A> <xref:System.Windows.Forms.RightToLeft.Yes?displayProperty=nameWithType>.  
  
-   Вертикальные полосы прокрутки отображаются с левой стороны, а не с правой стороны прокручиваемых элементов управления (например, <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.Panel>, Multiline <xref:System.Windows.Forms.TextBox> и <xref:System.Windows.Forms.RichTextBox>).  
  
-   Горизонтальные полосы прокрутки начинаются с полосы прокрутки (бегунка), расположенной по правому краю.  
  
-   Элемент флажка, управляемый свойством `CheckAlign`, обращается к элементам управления <xref:System.Windows.Forms.CheckBox> и <xref:System.Windows.Forms.RadioButton>.  
  
-   Элементы в списке, поле со списком и элементы управления "вверх-вниз" выводятся по правому краю.  
  
-   Кнопки вверх и вниз выводятся по левому краю для элементов управления <xref:System.Windows.Forms.NumericUpDown> и <xref:System.Windows.Forms.DomainUpDown>.  
  
-   Меню (<xref:System.Windows.Forms.MainMenu>, <xref:System.Windows.Forms.MenuItem> и <xref:System.Windows.Forms.ContextMenu>) отображаются по правому краю.  
  
-   Свойство <xref:System.Windows.Forms.Control.RightToLeft%2A> не зависит от выравнивания кнопок панели инструментов в элементе управления <xref:System.Windows.Forms.ToolBar> или выравнивания текста на <xref:System.Windows.Forms.ToolBarButton>.  
  
-   <xref:System.Windows.Forms.AxHost> поддерживает выравнивание справа налево; Однако воздействие на элемент управления ActiveX зависит от степени, в которой автор элемента управления реализовал поддержку вывода справа налево.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Присваиваемое значение не относится к значениям <see cref="T:System.Windows.Forms.RightToLeft" />.</exception>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.RightToLeft" /> в производном классе используйте свойство базового класса <see cref="P:System.Windows.Forms.Control.RightToLeft" /> для расширения базовой реализации. В противном случае необходимо предоставить всю реализацию. Не требуется переопределять методы доступа <see langword="get" /> и <see langword="set" /> свойства <see cref="P:System.Windows.Forms.Control.RightToLeft" />; При необходимости можно переопределить только один из них.</para></block>
        <altmember cref="T:System.Windows.Forms.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeftChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RightToLeftChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RightToLeftChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RightToLeftChanged;" />
      <MemberSignature Language="F#" Value="member this.RightToLeftChanged : EventHandler " Usage="member this.RightToLeftChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.RightToLeft" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.RightToLeft%2A> изменено программным изменением или взаимодействием с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Следующий пример кода является обработчиком событий, который выполняется при изменении значения свойства <xref:System.Windows.Forms.Control.Text%2A>. Класс <xref:System.Windows.Forms.Control> имеет несколько методов с шаблоном имени *PropertyName*`Changed`, которые вызываются при изменении соответствующего значения *PropertyName* (*PropertyName* представляет имя соответствующего свойства).  
  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> с отображением денежных данных. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере требуется <xref:System.Windows.Forms.Form>, содержащий <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RtlTranslateAlignment">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует текущее выравнивание в соответствующее выравнивание, обеспечивающее поддержку текста, читаемого справа налево.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Drawing.ContentAlignment RtlTranslateAlignment (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateAlignment(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Drawing.ContentAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As ContentAlignment) As ContentAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Drawing::ContentAlignment RtlTranslateAlignment(System::Drawing::ContentAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Drawing.ContentAlignment -&gt; System.Drawing.ContentAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Одно из значений <see cref="T:System.Drawing.ContentAlignment" />.</param>
        <summary>Преобразует указанный объект <see cref="T:System.Drawing.ContentAlignment" /> в соответствующий объект <see cref="T:System.Drawing.ContentAlignment" />, чтобы обеспечить поддержку текста, читаемого справа налево.</summary>
        <returns>Одно из значений <see cref="T:System.Drawing.ContentAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойство <xref:System.Windows.Forms.Control.RightToLeft%2A> для <xref:System.Windows.Forms.RightToLeft> имеет значение `No`, то возвращаемое значение равно значению параметра `align`, переданному в.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Drawing.ContentAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As HorizontalAlignment) As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::HorizontalAlignment RtlTranslateAlignment(System::Windows::Forms::HorizontalAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Windows.Forms.HorizontalAlignment -&gt; System.Windows.Forms.HorizontalAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Одно из значений перечисления <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</param>
        <summary>Преобразует указанный объект <see cref="T:System.Windows.Forms.HorizontalAlignment" /> в соответствующий объект <see cref="T:System.Windows.Forms.HorizontalAlignment" />, чтобы обеспечить поддержку текста, читаемого справа налево.</summary>
        <returns>Одно из значений перечисления <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойство <xref:System.Windows.Forms.Control.RightToLeft%2A> для <xref:System.Windows.Forms.RightToLeft> имеет значение `No`, то возвращаемое значение равно значению параметра `align`, переданному в.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.LeftRightAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As LeftRightAlignment) As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::LeftRightAlignment RtlTranslateAlignment(System::Windows::Forms::LeftRightAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Windows.Forms.LeftRightAlignment -&gt; System.Windows.Forms.LeftRightAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Одно из значений перечисления <see cref="T:System.Windows.Forms.LeftRightAlignment" />.</param>
        <summary>Преобразует указанный объект <see cref="T:System.Windows.Forms.LeftRightAlignment" /> в соответствующий объект <see cref="T:System.Windows.Forms.LeftRightAlignment" />, чтобы обеспечить поддержку текста, читаемого справа налево.</summary>
        <returns>Одно из значений перечисления <see cref="T:System.Windows.Forms.LeftRightAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойство <xref:System.Windows.Forms.Control.RightToLeft%2A> для <xref:System.Windows.Forms.RightToLeft> имеет значение `No`, то возвращаемое значение равно значению параметра `align`, переданному в.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.LeftRightAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateContent">
      <MemberSignature Language="C#" Value="protected internal System.Drawing.ContentAlignment RtlTranslateContent (System.Drawing.ContentAlignment align);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateContent(valuetype System.Drawing.ContentAlignment align) cil managed" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function RtlTranslateContent (align As ContentAlignment) As ContentAlignment" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Drawing::ContentAlignment RtlTranslateContent(System::Drawing::ContentAlignment align);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateContent : System.Drawing.ContentAlignment -&gt; System.Drawing.ContentAlignment" Usage="control.RtlTranslateContent align" />
      <MemberSignature Language="C#" Value="protected System.Drawing.ContentAlignment RtlTranslateContent (System.Drawing.ContentAlignment align);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateContent(valuetype System.Drawing.ContentAlignment align) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateContent (align As ContentAlignment) As ContentAlignment" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Drawing::ContentAlignment RtlTranslateContent(System::Drawing::ContentAlignment align);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Одно из значений <see cref="T:System.Drawing.ContentAlignment" />.</param>
        <summary>Преобразует указанный объект <see cref="T:System.Drawing.ContentAlignment" /> в соответствующий объект <see cref="T:System.Drawing.ContentAlignment" />, чтобы обеспечить поддержку текста, читаемого справа налево.</summary>
        <returns>Одно из значений перечисления <see cref="T:System.Drawing.ContentAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойство <xref:System.Windows.Forms.Control.RightToLeft%2A> для <xref:System.Windows.Forms.RightToLeft> имеет значение `No`, то возвращаемое значение равно значению параметра `align`, переданному в.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Drawing.ContentAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateHorizontal">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateHorizontal (align As HorizontalAlignment) As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::HorizontalAlignment RtlTranslateHorizontal(System::Windows::Forms::HorizontalAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateHorizontal : System.Windows.Forms.HorizontalAlignment -&gt; System.Windows.Forms.HorizontalAlignment" Usage="control.RtlTranslateHorizontal align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Одно из значений перечисления <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</param>
        <summary>Преобразует указанный объект <see cref="T:System.Windows.Forms.HorizontalAlignment" /> в соответствующий объект <see cref="T:System.Windows.Forms.HorizontalAlignment" />, чтобы обеспечить поддержку текста, читаемого справа налево.</summary>
        <returns>Одно из значений перечисления <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойство <xref:System.Windows.Forms.Control.RightToLeft%2A> для <xref:System.Windows.Forms.RightToLeft> имеет значение `No`, то возвращаемое значение равно значению параметра `align`, переданному в.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateLeftRight">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateLeftRight (align As LeftRightAlignment) As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::LeftRightAlignment RtlTranslateLeftRight(System::Windows::Forms::LeftRightAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateLeftRight : System.Windows.Forms.LeftRightAlignment -&gt; System.Windows.Forms.LeftRightAlignment" Usage="control.RtlTranslateLeftRight align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Одно из значений перечисления <see cref="T:System.Windows.Forms.LeftRightAlignment" />.</param>
        <summary>Преобразует указанный объект <see cref="T:System.Windows.Forms.LeftRightAlignment" /> в соответствующий объект <see cref="T:System.Windows.Forms.LeftRightAlignment" />, чтобы обеспечить поддержку текста, читаемого справа налево.</summary>
        <returns>Одно из значений перечисления <see cref="T:System.Windows.Forms.LeftRightAlignment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойство <xref:System.Windows.Forms.Control.RightToLeft%2A> для <xref:System.Windows.Forms.RightToLeft> имеет значение `No`, то возвращаемое значение равно значению параметра `align`, переданному в.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.LeftRightAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Scale">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Масштабирует элемент управления и любые его дочерние элементы.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (System.Drawing.SizeF factor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(valuetype System.Drawing.SizeF factor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Drawing.SizeF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (factor As SizeF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(System::Drawing::SizeF factor);" />
      <MemberSignature Language="F#" Value="member this.Scale : System.Drawing.SizeF -&gt; unit" Usage="control.Scale factor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="factor">Объект <see cref="T:System.Drawing.SizeF" />, содержащий коэффициенты вертикального и горизонтального масштабирования.</param>
        <summary>Масштабирует элемент управления и любые его дочерние элементы с использованием заданного коэффициента масштабирования.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Forms.Control.Scale%2A> масштабирует элемент управления по заданному масштабу `factor`. Он также рекурсивно масштабирует все дочерние элементы управления, если свойство <xref:System.Windows.Forms.Control.ScaleChildren%2A> имеет значение `true`. На внутреннем уровне этот метод вызывает <xref:System.Windows.Forms.Control.ScaleControl%2A> для масштабирования каждого элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ScaleChildren" />
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float ratio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 ratio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (ratio As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(float ratio);" />
      <MemberSignature Language="F#" Value="member this.Scale : single -&gt; unit" Usage="control.Scale ratio" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ratio" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="ratio">Отношение, используемое для масштабирования.</param>
        <summary>Масштабирует элемент управления и любые его дочерние элементы.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(float dx, float dy);" />
      <MemberSignature Language="F#" Value="member this.Scale : single * single -&gt; unit" Usage="control.Scale (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Коэффициент горизонтального масштабирования.</param>
        <param name="dy">Коэффициент вертикального масштабирования.</param>
        <summary>Масштабирует весь элемент управления и любые его дочерние элементы.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleBitmapLogicalToDevice">
      <MemberSignature Language="C#" Value="public void ScaleBitmapLogicalToDevice (ref System.Drawing.Bitmap logicalBitmap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleBitmapLogicalToDevice(class System.Drawing.Bitmap&amp; logicalBitmap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleBitmapLogicalToDevice(System.Drawing.Bitmap@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleBitmapLogicalToDevice (ByRef logicalBitmap As Bitmap)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleBitmapLogicalToDevice(System::Drawing::Bitmap ^ % logicalBitmap);" />
      <MemberSignature Language="F#" Value="member this.ScaleBitmapLogicalToDevice : Bitmap -&gt; unit" Usage="control.ScaleBitmapLogicalToDevice logicalBitmap" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logicalBitmap" Type="System.Drawing.Bitmap" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="logicalBitmap">Масштабируемый точечный рисунок.</param>
        <summary>Масштабирует логическое значение точечного рисунка в эквивалентное значение единицы измерения устройства при изменении настройки DPI.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleChildren">
      <MemberSignature Language="C#" Value="protected virtual bool ScaleChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ScaleChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ScaleChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ScaleChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ScaleChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ScaleChildren : bool" Usage="System.Windows.Forms.Control.ScaleChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, определяющее масштабирование дочерних элементов управления.</summary>
        <value>Значение <see langword="true" />, если дочерние элементы управления будут масштабироваться при вызове метода <see cref="M:System.Windows.Forms.Control.Scale(System.Single)" /> в этом элементе управления; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойство <xref:System.Windows.Forms.Control.ScaleChildren%2A> имеет значение `true`, то метод <xref:System.Windows.Forms.Control.Scale%2A> рекурсивно вызывает метод <xref:System.Windows.Forms.Control.ScaleControl%2A> для каждого из его дочерних элементов управления.  
  
 Реализация по умолчанию <xref:System.Windows.Forms.Control.ScaleChildren%2A> всегда возвращает `true`. Производные классы могут переопределять <xref:System.Windows.Forms.Control.ScaleChildren%2A> для возврата `false`, чтобы указать, что масштабирование не должно выполняться для своих дочерних элементов.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Scale(System.Single)" />
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected virtual void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ScaleControl (factor As SizeF, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ScaleControl(System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member ScaleControl : System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; unit&#xA;override this.ScaleControl : System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.ScaleControl (factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="factor">Коэффициент масштабирования высоты и ширины элемента управления.</param>
        <param name="specified">Значение <see cref="T:System.Windows.Forms.BoundsSpecified" />, задающее границы элемента управления, используемые для определения его размеров и положения.</param>
        <summary>Выполняет масштабирование расположения, размеров, заполнения и полей элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если элемент управления является верхним, это не приведет к масштабированию расположения элемента управления. Это не масштабирует дочерние элементы или размер автоматически изменяемых элементов управления. Можно опустить масштабирование в любом направлении, изменив значение параметра `specified`.  
  
   
  
## Examples  
 <xref:System.Windows.Forms.BoundsSpecified>  
  
 <xref:System.Windows.Forms.Control.Scale%2A>  
  
 <xref:System.Windows.Forms.Control.GetScaledBounds%2A>  
  
 <xref:System.Windows.Forms.Control.SetBoundsCore%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected virtual void ScaleCore (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleCore(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleCore(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ScaleCore (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ScaleCore(float dx, float dy);" />
      <MemberSignature Language="F#" Value="abstract member ScaleCore : single * single -&gt; unit&#xA;override this.ScaleCore : single * single -&gt; unit" Usage="control.ScaleCore (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Коэффициент горизонтального масштабирования.</param>
        <param name="dy">Коэффициент вертикального масштабирования.</param>
        <summary>Данный метод не применим к этому классу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный метод не применим к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Активирует элемент управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Метод <xref:System.Windows.Forms.Control.Select%2A> активирует элемент управления, если бит стиля <xref:System.Windows.Forms.ControlStyles.Selectable?displayProperty=nameWithType> элемента управления имеет значение `true`, он содержится в другом элементе управления, и все его родительские элементы управления видимы и включены.

Элементы управления Windows Forms в следующем списке недоступны для выбора. Элементы управления, производные от элементов управления в списке, также не могут быть выбраны.
  
- <xref:System.Windows.Forms.Label>  
- <xref:System.Windows.Forms.Panel>  
- <xref:System.Windows.Forms.GroupBox>
- <xref:System.Windows.Forms.PictureBox>  
- <xref:System.Windows.Forms.ProgressBar>
- <xref:System.Windows.Forms.Splitter>
- <xref:System.Windows.Forms.LinkLabel> (если в элементе управления отсутствует ссылка)
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; unit" Usage="control.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Активирует элемент управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
  
## Examples  

В следующем примере кода выбирается указанный <xref:System.Windows.Forms.Control>, если он доступен для выбора.
  
[!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
[!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
[!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected virtual void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Select (directed As Boolean, forward As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Select(bool directed, bool forward);" />
      <MemberSignature Language="F#" Value="abstract member Select : bool * bool -&gt; unit&#xA;override this.Select : bool * bool -&gt; unit" Usage="control.Select (directed, forward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed"><see langword="true" />, чтобы указать направление элемента управления, который требуется выделить; в противном случае — <see langword="false" />.</param>
        <param name="forward"><see langword="true" /> для перемещения в прямом направлении последовательности перехода; <see langword="false" /> для перемещения в обратном направлении.</param>
        <summary>Активирует дочерний элемент управления. При необходимости указывает направление для выбора элементов управления в последовательности табуляции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры `directed` и `forward` используются элементами управления в стиле контейнера. Если для параметра `directed` задано значение `true`, то параметр `forward` оценивается так, чтобы определить, какой элемент управления следует выбрать. Если `forward` имеет значение `true`, выбирается следующий элемент управления в последовательности табуляции. Если `false`, выбирается предыдущий элемент управления в последовательности табуляции.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="M:System.Windows.Forms.Control.Select" />
      </Docs>
    </Member>
    <Member MemberName="SelectNextControl">
      <MemberSignature Language="C#" Value="public bool SelectNextControl (System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SelectNextControl(class System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectNextControl (ctl As Control, forward As Boolean, tabStopOnly As Boolean, nested As Boolean, wrap As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SelectNextControl(System::Windows::Forms::Control ^ ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberSignature Language="F#" Value="member this.SelectNextControl : System.Windows.Forms.Control * bool * bool * bool * bool -&gt; bool" Usage="control.SelectNextControl (ctl, forward, tabStopOnly, nested, wrap)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
        <Parameter Name="tabStopOnly" Type="System.Boolean" />
        <Parameter Name="nested" Type="System.Boolean" />
        <Parameter Name="wrap" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">Объект <see cref="T:System.Windows.Forms.Control" />, с которого следует начать поиск.</param>
        <param name="forward"><see langword="true" /> для перемещения в прямом направлении последовательности перехода; <see langword="false" /> для перемещения в обратном направлении.</param>
        <param name="tabStopOnly">Значение <see langword="true" />, чтобы игнорировать элементы управления, у которых для свойства <see cref="P:System.Windows.Forms.Control.TabStop" /> задано значение <see langword="false" />; в противном случае — значение <see langword="false" />.</param>
        <param name="nested">Значение <see langword="true" />, чтобы включить вложенные дочерние элементы (т. е. дочерние элементы дочерних элементов); в противном случае — значение <see langword="false" />.</param>
        <param name="wrap">Значение <see langword="true" /> для продолжения поиска с первого элемента управления в последовательности табуляции после достижения последнего элемента; в противном случае — значение <see langword="false" />.</param>
        <summary>Активирует следующий элемент управления.</summary>
        <returns>Значение <see langword="true" />, если элемент управления был активирован; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Forms.Control.SelectNextControl%2A> активирует следующий элемент управления в последовательности табуляции, если бит стиля `Selectable` элемента управления имеет значение `true` в <xref:System.Windows.Forms.ControlStyles>, он содержится в другом элементе управления, и все его родительские элементы управления видимы и включены.  
  
 Элементы управления Windows Forms в следующем списке недоступны для выбора. Элементы управления, производные от элементов управления в списке, также не могут быть выбраны.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel> (если в элементе управления отсутствует ссылка)  
  
 При изменении фокуса с помощью клавиатуры (TAB, SHIFT + TAB и т. д.), вызывая методы <xref:System.Windows.Forms.Control.Select%2A> или <xref:System.Windows.Forms.Control.SelectNextControl%2A> или устанавливая свойство <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> в текущую форму, события фокуса происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Если свойство <xref:System.Windows.Forms.Control.CausesValidation%2A> имеет значение `false`, события <xref:System.Windows.Forms.Control.Validating> и <xref:System.Windows.Forms.Control.Validated> подавляются.  
  
   
  
## Examples  
 Следующий код ексамплешовс метод <xref:System.Windows.Forms.Control.SelectNextControl%2A>, используемый в форме, которая содержит некоторые элементы управления. Каждый раз при щелчке формы активируется следующий элемент управления. Свойство <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> получает текущий активный элемент управления в контейнерном элементе управления.  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#1)]  
  
 В следующем примере кода показан метод <xref:System.Windows.Forms.Control.SelectNextControl%2A>, используемый в форме с <xref:System.Windows.Forms.Button> и некоторыми другими элементами управления. При нажатии <xref:System.Windows.Forms.Button> следующий элемент управления после <xref:System.Windows.Forms.Button> активируется. Обратите внимание, что необходимо получить родительский элемент управления <xref:System.Windows.Forms.Button>. Поскольку <xref:System.Windows.Forms.Button> не является контейнером, вызов <xref:System.Windows.Forms.Control.SelectNextControl%2A> непосредственно в <xref:System.Windows.Forms.Button> не приведет к изменению активации.  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#2)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
      </Docs>
    </Member>
    <Member MemberName="SendToBack">
      <MemberSignature Language="C#" Value="public void SendToBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendToBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SendToBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendToBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendToBack();" />
      <MemberSignature Language="F#" Value="member this.SendToBack : unit -&gt; unit" Usage="control.SendToBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отправляет элемент управления в конец z-порядка.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элемент управления перемещается в заднюю часть z-порядка. Если элемент управления является дочерним для другого элемента управления, дочерний элемент управления перемещается в конец z-порядка. Если элемент управления является элементом верхнего уровня, этот метод будет работать неправильно, если элемент управления не активен. Элемент управления верхнего уровня — это элемент управления, например <xref:System.Windows.Forms.Form>, который не является дочерним элементом другого элемента управления. Активный элемент управления — это видимый элемент управления, имеющий фокус ввода. Чтобы использовать метод <xref:System.Windows.Forms.Control.SendToBack%2A> с неактивным элементом управления верхнего уровня, сначала нужно вызвать метод <xref:System.Windows.Forms.Control.BringToFront%2A> для элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.BringToFront" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
      </Docs>
    </Member>
    <Member MemberName="SetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected void SetAutoSizeMode (System.Windows.Forms.AutoSizeMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetAutoSizeMode(valuetype System.Windows.Forms.AutoSizeMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetAutoSizeMode(System.Windows.Forms.AutoSizeMode)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetAutoSizeMode (mode As AutoSizeMode)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetAutoSizeMode(System::Windows::Forms::AutoSizeMode mode);" />
      <MemberSignature Language="F#" Value="member this.SetAutoSizeMode : System.Windows.Forms.AutoSizeMode -&gt; unit" Usage="control.SetAutoSizeMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.AutoSizeMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">Одно из значений перечисления <see cref="T:System.Windows.Forms.AutoSizeMode" />.</param>
        <summary>Задает значение, указывающее, как будет вести себя элемент управления, когда его свойство <see cref="P:System.Windows.Forms.Control.AutoSize" /> включено.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Задает границы элемента управления.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBounds(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.SetBounds : int * int * int * int -&gt; unit" Usage="control.SetBounds (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Новое значение свойства <see cref="P:System.Windows.Forms.Control.Left" /> элемента управления.</param>
        <param name="y">Новое значение свойства <see cref="P:System.Windows.Forms.Control.Top" /> элемента управления.</param>
        <param name="width">Новое значение свойства <see cref="P:System.Windows.Forms.Control.Width" /> элемента управления.</param>
        <param name="height">Новое значение свойства <see cref="P:System.Windows.Forms.Control.Height" /> элемента управления.</param>
        <summary>Задает границы элемента управления для указанного местоположения и размера.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBounds (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBounds(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="member this.SetBounds : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.SetBounds (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Новое значение свойства <see cref="P:System.Windows.Forms.Control.Left" /> элемента управления.</param>
        <param name="y">Новое значение свойства <see cref="P:System.Windows.Forms.Control.Top" /> элемента управления.</param>
        <param name="width">Новое значение свойства <see cref="P:System.Windows.Forms.Control.Width" /> элемента управления.</param>
        <param name="height">Новое значение свойства <see cref="P:System.Windows.Forms.Control.Height" /> элемента управления.</param>
        <param name="specified">Поразрядное сочетание значений <see cref="T:System.Windows.Forms.BoundsSpecified" />. Для любого неуказанного параметра будет использовано текущее значение.</param>
        <summary>Задает указанные границы элемента управления для указанного местоположения и размера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано, как по центру <xref:System.Windows.Forms.Form> на экране в событии <xref:System.Windows.Forms.Control.Layout>. При этом форма будет находиться в центре по мере ее изменения пользователем. Для этого примера требуется, чтобы был создан элемент управления <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected virtual void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit&#xA;override this.SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.SetBoundsCore (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Новое значение свойства <see cref="P:System.Windows.Forms.Control.Left" /> элемента управления.</param>
        <param name="y">Новое значение свойства <see cref="P:System.Windows.Forms.Control.Top" /> элемента управления.</param>
        <param name="width">Новое значение свойства <see cref="P:System.Windows.Forms.Control.Width" /> элемента управления.</param>
        <param name="height">Новое значение свойства <see cref="P:System.Windows.Forms.Control.Height" /> элемента управления.</param>
        <param name="specified">Поразрядное сочетание значений <see cref="T:System.Windows.Forms.BoundsSpecified" />.</param>
        <summary>Задает указанные границы данного элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как правило, параметры, соответствующие границам, не включаемым в параметр `specified`, передаются вместе с их текущими значениями. Например, свойства <xref:System.Windows.Forms.Control.Height%2A>, <xref:System.Windows.Forms.Control.Width%2A> или <xref:System.Drawing.Point.X%2A> или <xref:System.Drawing.Point.Y%2A> свойства <xref:System.Windows.Forms.Control.Location%2A> могут передаваться вместе со ссылкой на текущий экземпляр элемента управления. Однако все значения, переданные в, учитываются и применяются к элементу управления.  
  
 Параметр `boundsSpecified` представляет элементы элементов управления <xref:System.Windows.Forms.Control.Bounds%2A>, измененные приложением. Например, если изменить <xref:System.Windows.Forms.Control.Size%2A> элемента управления, параметр `boundsSpecified` будет иметь значение `Size`, равное <xref:System.Windows.Forms.BoundsSpecified>. Однако, если <xref:System.Windows.Forms.Control.Size%2A> корректируется в ответ на заданное свойство <xref:System.Windows.Forms.Control.Dock%2A>, значение параметра `boundsSpecified` равно значению `None` <xref:System.Windows.Forms.BoundsSpecified>.  
  
> [!NOTE]
>  В системах Windows Server 2003 размер <xref:System.Windows.Forms.Form> ограничен максимальным значением ширины и высотой в пикселях монитора.  
  
   
  
## Examples  
 В следующем примере кода переопределяется метод <xref:System.Windows.Forms.Control.SetBoundsCore%2A>, чтобы гарантировать, что элемент управления остается фиксированным размером. В этом примере предполагается, что у вас есть класс, который либо прямо, либо косвенно является производным от класса <xref:System.Windows.Forms.Control>.  
  
 [!code-cpp[Windows.Forms.Control_Methods#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#1)]
 [!code-csharp[Windows.Forms.Control_Methods#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#1)]
 [!code-vb[Windows.Forms.Control_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> в производном классе обязательно вызовите метод <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> базового класса, чтобы принудительно изменить границы элемента управления. Производные классы могут добавлять ограничения размера к методу <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected virtual void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetClientSizeCore (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetClientSizeCore(int x, int y);" />
      <MemberSignature Language="F#" Value="abstract member SetClientSizeCore : int * int -&gt; unit&#xA;override this.SetClientSizeCore : int * int -&gt; unit" Usage="control.SetClientSizeCore (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Ширина клиентской области в пикселях.</param>
        <param name="y">Высота клиентской области в пикселях.</param>
        <summary>Задает размер клиентской области элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиентская область начинается с точки (0, 0) и расширяется до расположения (`x`, `y`).  
  
 Как правило, не следует устанавливать <xref:System.Windows.Forms.Control.ClientSize%2A> элемента управления.  
  
   
  
## Examples  
 В следующем примере кода переопределяется метод <xref:System.Windows.Forms.Control.SetClientSizeCore%2A>, чтобы гарантировать, что элемент управления остается в квадрате. В этом примере предполагается, что у вас есть класс, который либо прямо, либо косвенно является производным от класса <xref:System.Windows.Forms.Control>.  
  
 [!code-cpp[Windows.Forms.Control_Methods#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#2)]
 [!code-csharp[Windows.Forms.Control_Methods#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#2)]
 [!code-vb[Windows.Forms.Control_Methods#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" /> в производном классе обязательно вызовите метод <see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" /> базового класса, чтобы свойство <see cref="P:System.Windows.Forms.Control.ClientSize" /> было настроено.  
  
Дополнительные сведения о рисовании элементов управления см. [в разделе Подготовка к просмотру элемента управления Windows Forms](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md).</para></block>
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
      </Docs>
    </Member>
    <Member MemberName="SetStyle">
      <MemberSignature Language="C#" Value="protected void SetStyle (System.Windows.Forms.ControlStyles flag, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetStyle(valuetype System.Windows.Forms.ControlStyles flag, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetStyle (flag As ControlStyles, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetStyle(System::Windows::Forms::ControlStyles flag, bool value);" />
      <MemberSignature Language="F#" Value="member this.SetStyle : System.Windows.Forms.ControlStyles * bool -&gt; unit" Usage="control.SetStyle (flag, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flag">Задаваемый бит <see cref="T:System.Windows.Forms.ControlStyles" />.</param>
        <param name="value">Значение <see langword="true" />, чтобы применить указанный стиль к элементу управления; в противном случае — значение <see langword="false" />.</param>
        <summary>Задает указанный флаг <see cref="T:System.Windows.Forms.ControlStyles" /> либо в значение <see langword="true" />, либо в значение <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Битовые флаги стиля элемента управления используются для категоризации поддерживаемого поведения. Элемент управления может включить стиль, вызвав метод <xref:System.Windows.Forms.Control.SetStyle%2A> и передав соответствующий бит <xref:System.Windows.Forms.ControlStyles> (или биты) и логическое значение, чтобы установить бит (или). Чтобы определить значение, присвоенное указанному биту <xref:System.Windows.Forms.ControlStyles>, используйте метод <xref:System.Windows.Forms.Control.GetStyle%2A> и передайте для вычисления элемент <xref:System.Windows.Forms.ControlStyles>.  
  
> [!CAUTION]
>  Установка битов стиля элемента управления может существенно изменить поведение элемента управления. Изучите документацию по перечислению <xref:System.Windows.Forms.ControlStyles>, чтобы понять последствия изменения битов стиля элемента управления перед вызовом метода <xref:System.Windows.Forms.Control.SetStyle%2A>.  
  
   
  
## Examples  
 Следующий пример кода включает двойную буферизацию на <xref:System.Windows.Forms.Form> и обновляет стили для отражения изменений.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="SetTopLevel">
      <MemberSignature Language="C#" Value="protected void SetTopLevel (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetTopLevel(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetTopLevel (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetTopLevel(bool value);" />
      <MemberSignature Language="F#" Value="member this.SetTopLevel : bool -&gt; unit" Usage="control.SetTopLevel value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Значение <see langword="true" />, чтобы задать элемент управления как элемент верхнего уровня; в противном случае — значение <see langword="false" />.</param>
        <summary>Определяет элемент управления как элемент верхнего уровня.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вызвать метод <xref:System.Windows.Forms.Control.SetTopLevel%2A> <xref:System.Windows.Forms.Form> и передать значение `false`, форма не будет видна до тех пор, пока вы не вызовите <xref:System.Windows.Forms.Control.SetTopLevel%2A>, передав значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Для параметра <paramref name="value" /> задано значение <see langword="true" />, а элемент управления является элементом ActiveX.</exception>
        <exception cref="T:System.Exception">Возвращаемое значение <see cref="M:System.Windows.Forms.Control.GetTopLevel" /> не равно значению параметра <paramref name="value" />, а значение свойства <see cref="P:System.Windows.Forms.Control.Parent" /> не равно значению <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">чтобы задать элемент управления как элемент управления верхнего уровня, если он имеет любой тип, кроме <see cref="T:System.Windows.Forms.Form" />. Это разрешение запрашивается только в том случае, если параметр <paramref name="value" /> имеет значение <see langword="true" />, а элемент управления не является элементом управления ActiveX. Связанное перечисление: значение <see langword="AllWindows" /> для <see cref="T:System.Security.Permissions.UIPermissionWindow" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.GetTopLevel" />
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected virtual void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetVisibleCore (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetVisibleCore(bool value);" />
      <MemberSignature Language="F#" Value="abstract member SetVisibleCore : bool -&gt; unit&#xA;override this.SetVisibleCore : bool -&gt; unit" Usage="control.SetVisibleCore value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Значение <see langword="true" />, чтобы сделать элемент управления видимым; в противном случае — значение <see langword="false" />.</param>
        <summary>Задает для элемента управления указанное видимое состояние.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обычно этот метод переопределяется для изменения режима видимости элемента управления.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" /> в производном классе обязательно вызовите метод <see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" /> базового класса, чтобы принудительно изменить видимость элемента управления.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="control.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отображает элемент управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отображение элемента управления эквивалентно присвоению свойству <xref:System.Windows.Forms.Control.Visible%2A> значения `true`. После вызова метода <xref:System.Windows.Forms.Control.Show%2A> свойство <xref:System.Windows.Forms.Control.Visible%2A> возвращает значение `true` до тех пор, пока не будет вызван метод <xref:System.Windows.Forms.Control.Hide%2A>.  
  
   
  
## Examples  
 В следующем примере кода отображается диалоговое окно "о программе", которое временно рисует синий квадрат на его поверхности. В этом примере необходимо определить класс, производный от <xref:System.Windows.Forms.Form> с именем `AboutDialog`.  
  
 [!code-cpp[Windows.Forms.Control Members2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#1)]
 [!code-vb[Windows.Forms.Control Members2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
      </Docs>
    </Member>
    <Member MemberName="ShowFocusCues">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShowFocusCues { get; }" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowFocusCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowFocusCues" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property ShowFocusCues As Boolean" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool ShowFocusCues { bool get(); };" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.ShowFocusCues : bool" Usage="System.Windows.Forms.Control.ShowFocusCues" />
      <MemberSignature Language="C#" Value="protected virtual bool ShowFocusCues { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ShowFocusCues As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ShowFocusCues { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, должен ли элемент управления отображать прямоугольники фокуса.</summary>
        <value>Значение <see langword="true" />, если элемент управления должен отображать прямоугольники фокуса; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об этой функции см. в разделах [WM_CHANGEUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx), [WM_QUERYUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx)и [WM_UPDATEUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx) .  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.ShowFocusCues" /> в производном классе используйте свойство базового класса <see cref="P:System.Windows.Forms.Control.ShowFocusCues" /> для расширения базовой реализации. В противном случае необходимо предоставить всю реализацию.</para></block>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
        <altmember cref="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      </Docs>
    </Member>
    <Member MemberName="ShowKeyboardCues">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShowKeyboardCues { get; }" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowKeyboardCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property ShowKeyboardCues As Boolean" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool ShowKeyboardCues { bool get(); };" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.ShowKeyboardCues : bool" Usage="System.Windows.Forms.Control.ShowKeyboardCues" />
      <MemberSignature Language="C#" Value="protected bool ShowKeyboardCues { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ShowKeyboardCues As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ShowKeyboardCues { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, имеет ли пользовательский интерфейс соответствующее состояние, при котором отображаются или скрываются сочетания клавиш.</summary>
        <value>Значение <see langword="true" />, если сочетания клавиш являются видимыми; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В элементах управления, созданных в конструкторе Windows Forms, сочетания клавиш отображаются по умолчанию.  
  
 Дополнительные сведения об этой функции см. в разделах [WM_CHANGEUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx), [WM_QUERYUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx)и [WM_UPDATEUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx) .  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="P:System.Windows.Forms.Control.ShowFocusCues" />
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Windows.Forms.Control.Site" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IComponent.Site</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает местонахождение элемента управления.</summary>
        <value>Объект <see cref="T:System.ComponentModel.ISite" />, сопоставленный с объектом <see cref="T:System.Windows.Forms.Control" /> (при наличии такового).</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.ISite" />
        <altmember cref="P:System.ComponentModel.IComponent.Site" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.Size : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает высоту и ширину элемента управления.</summary>
        <value>Объект <see cref="T:System.Drawing.Size" />, который представляет высоту и ширину элемента управления в пикселях.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поскольку класс <xref:System.Drawing.Size> является типом значения (`Structure` в Visual Basic, `struct` в Visual C#), он возвращается по значению, что означает, что доступ к свойству возвращает копию размера элемента управления. Таким образом, Настройка свойств <xref:System.Drawing.Size.Width%2A> или <xref:System.Drawing.Size.Height%2A> для <xref:System.Drawing.Size>, возвращаемых из этого свойства, не повлияет на <xref:System.Windows.Forms.Control.Width%2A> или <xref:System.Windows.Forms.Control.Height%2A> элемента управления. Чтобы настроить <xref:System.Windows.Forms.Control.Width%2A> или <xref:System.Windows.Forms.Control.Height%2A> элемента управления, необходимо задать свойство <xref:System.Windows.Forms.Control.Width%2A> или <xref:System.Windows.Forms.Control.Height%2A> элемента управления или задать для свойства <xref:System.Windows.Forms.Control.Size%2A> новое <xref:System.Drawing.Size>.  
  
> [!NOTE]
>  Чтобы обеспечить лучшую производительность, не устанавливайте <xref:System.Drawing.Size> элемента управления в конструкторе. Предпочтительным методом является переопределение свойства <xref:System.Windows.Forms.Control.DefaultSize%2A>.  
  
> [!NOTE]
>  В системах Windows Server 2003 размер <xref:System.Windows.Forms.Form> ограничен максимальным значением ширины и высотой в пикселях монитора.  
  
   
  
## Examples  
 В следующем примере кода в форму добавляется <xref:System.Windows.Forms.Button> и задаются некоторые общие свойства. В этом примере кнопка привязывается к нижнему правому углу формы, чтобы сохранить ее относительное расположение при изменении размера формы. Затем он устанавливает <xref:System.Windows.Forms.Control.BackgroundImage%2A> и изменяет размер кнопки на тот же размер, что и <xref:System.Drawing.Image>. Затем в примере устанавливается <xref:System.Windows.Forms.Control.TabStop%2A> в `true` и задается свойство <xref:System.Windows.Forms.Control.TabIndex%2A>. Наконец, он добавляет обработчик событий для обработки события <xref:System.Windows.Forms.Control.Click> кнопки. В этом примере требуется <xref:System.Windows.Forms.ImageList> с именем `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : EventHandler " Usage="member this.SizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.Size" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для работы с пользовательскими макетами рекомендуется использовать событие <xref:System.Windows.Forms.Control.Layout>. Событие <xref:System.Windows.Forms.Control.Layout> возникает в ответ на события <xref:System.Windows.Forms.Control.Resize>, но также и в других условиях, когда может потребоваться применить макет.  
  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.Size%2A> изменено программным изменением или взаимодействием с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано событие <xref:System.Windows.Forms.Control.SizeChanged>. Был предоставлен экземпляр элемента управления <xref:System.Windows.Forms.Button>, который можно масштабировать как по горизонтали, так и по вертикали. Экземпляр <xref:System.Windows.Forms.NumericUpDown> предоставляет значение горизонтального и вертикального масштабирования. Экземпляр <xref:System.Windows.Forms.Button> с именем " **ОК** " используется для задания значений шкалы для экземпляра элемента управления <xref:System.Windows.Forms.Button>. При изменении размера элемента управления вызывается обработчик событий, связанный с событием <xref:System.Windows.Forms.Control.SizeChanged> элемента управления. Этот обработчик событий отображает окно сообщения, указывающее, что размер элемента управления изменился.  
  
 [!code-cpp[Control_Scale1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Scale1/CPP/control_scale1.cpp#2)]
 [!code-csharp[Control_Scale1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Scale1/CS/control_scale1.cs#2)]
 [!code-vb[Control_Scale1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Scale1/VB/control_scale1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="SizeFromClientSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size SizeFromClientSize (System.Drawing.Size clientSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Size SizeFromClientSize(valuetype System.Drawing.Size clientSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SizeFromClientSize(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SizeFromClientSize (clientSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Size SizeFromClientSize(System::Drawing::Size clientSize);" />
      <MemberSignature Language="F#" Value="abstract member SizeFromClientSize : System.Drawing.Size -&gt; System.Drawing.Size&#xA;override this.SizeFromClientSize : System.Drawing.Size -&gt; System.Drawing.Size" Usage="control.SizeFromClientSize clientSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientSize" Type="System.Drawing.Size" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="clientSize">Значение <see cref="T:System.Drawing.Size" />, представляющее высоту и ширину клиентской области элемента управления.</param>
        <summary>Определяет размер всего элемента управления по высоте и ширине его клиентской области.</summary>
        <returns>Значение <see cref="T:System.Drawing.Size" />, представляющее высоту и ширину всего элемента управления.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StyleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StyleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.StyleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StyleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StyleChanged;" />
      <MemberSignature Language="F#" Value="member this.StyleChanged : EventHandler " Usage="member this.StyleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении стиля элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие <xref:System.Windows.Forms.Control.StyleChanged> возникает при добавлении или изменении флагов <xref:System.Windows.Forms.ControlStyles>.  
  
 Это событие возникает при изменении стиля элемента управления с помощью программного изменения или взаимодействия с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Control.StyleChanged>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа, который наследует от <xref:System.Windows.Forms.Control>, например <xref:System.Windows.Forms.Button> или <xref:System.Windows.Forms.ComboBox>. Затем присвойте экземпляру имя `Control1` и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Control.StyleChanged>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#68](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#68)]
 [!code-vb[System.Windows.Forms.EventExamples#68](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#68)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="SuspendLayout">
      <MemberSignature Language="C#" Value="public void SuspendLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SuspendLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SuspendLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub SuspendLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SuspendLayout();" />
      <MemberSignature Language="F#" Value="member this.SuspendLayout : unit -&gt; unit" Usage="control.SuspendLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Временно приостанавливает логику макета для элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Логика макета элемента управления приостанавливается до тех пор, пока не будет вызван метод <xref:System.Windows.Forms.Control.ResumeLayout%2A>.  
  
 Методы <xref:System.Windows.Forms.Control.SuspendLayout%2A> и <xref:System.Windows.Forms.Control.ResumeLayout%2A> используются совместно, чтобы подавлять несколько событий <xref:System.Windows.Forms.Control.Layout> при изменении нескольких атрибутов элемента управления. Например, обычно вызывается метод <xref:System.Windows.Forms.Control.SuspendLayout%2A>, затем устанавливаются свойства элемента управления <xref:System.Windows.Forms.Control.Size%2A>, <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A> или <xref:System.Windows.Forms.Control.Dock%2A>, а затем вызывается метод <xref:System.Windows.Forms.Control.ResumeLayout%2A>, чтобы изменения вступили в силу.  
  
 Для успешного вызова <xref:System.Windows.Forms.Control.ResumeLayout%2A> не должно быть незавершенных вызовов <xref:System.Windows.Forms.Control.SuspendLayout%2A>.  
  
> [!NOTE]
>  При добавлении нескольких элементов управления в родительский элемент управления рекомендуется вызвать метод <xref:System.Windows.Forms.Control.SuspendLayout%2A> перед инициализацией добавляемых элементов управления. После добавления элементов управления в родительский элемент управления вызовите метод <xref:System.Windows.Forms.Control.ResumeLayout%2A>. Это увеличит производительность приложений с большим количеством элементов управления.  
  
   
  
## Examples  
 В следующем примере кода две кнопки добавляются в форму. В примере транзакции Добавление кнопок осуществляется с помощью методов <xref:System.Windows.Forms.Control.SuspendLayout%2A> и <xref:System.Windows.Forms.Control.ResumeLayout%2A>.  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragDrop">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragDrop (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragDrop(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragDrop (drgEvent As DragEventArgs) Implements IDropTarget.OnDragDrop" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragDrop(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragDrop;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragDrop(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Объект <see cref="T:System.Windows.Forms.DragEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.DragDrop" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragEnter">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragEnter (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragEnter(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragEnter (drgEvent As DragEventArgs) Implements IDropTarget.OnDragEnter" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragEnter(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragEnter;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragEnter(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Объект <see cref="T:System.Windows.Forms.DragEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.DragEnter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragLeave">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragLeave (e As EventArgs) Implements IDropTarget.OnDragLeave" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragLeave(EventArgs ^ e) = System::Windows::Forms::IDropTarget::OnDragLeave;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragLeave(System.EventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.DragLeave" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragOver">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragOver (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragOver(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragOver (drgEvent As DragEventArgs) Implements IDropTarget.OnDragOver" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragOver(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragOver;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragOver(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="drgEvent">Объект <see cref="T:System.Windows.Forms.DragEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.DragOver" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemColorsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SystemColorsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SystemColorsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SystemColorsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SystemColorsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SystemColorsChanged;" />
      <MemberSignature Language="F#" Value="member this.SystemColorsChanged : EventHandler " Usage="member this.SystemColorsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении системных цветов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если <xref:System.Drawing.SystemColors> изменено программным изменением или взаимодействием с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Control.SystemColorsChanged>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа, который наследует от <xref:System.Windows.Forms.Control>, например <xref:System.Windows.Forms.Button> или <xref:System.Windows.Forms.ComboBox>. Затем присвойте экземпляру имя `Control1` и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Control.SystemColorsChanged>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#69](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#69)]
 [!code-vb[System.Windows.Forms.EventExamples#69](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#69)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TabIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TabIndex : int with get, set" Usage="System.Windows.Forms.Control.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает последовательность перехода по клавише TAB между элементами управления внутри контейнера.</summary>
        <value>Значение индекса элемента управления из набора элементов управления в его контейнере. Элементы управления в контейнере включены в последовательность табуляции.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Индекс вкладки может состоять из любого допустимого целого числа, которое больше или равно нулю, меньшее число предшествует последовательности табуляции. Если один и тот же родительский элемент управления имеет один и тот же индекс табуляции, то в z-порядке элементов управления определяется порядок циклического прохода по элементам управления.  
  
 Чтобы элемент управления включался в последовательность табуляции, его свойство <xref:System.Windows.Forms.Control.TabStop%2A> должно иметь значение `true`.  
  
   
  
## Examples  
 В следующем примере кода в форму добавляется <xref:System.Windows.Forms.Button> и задаются некоторые общие свойства. В этом примере кнопка привязывается к нижнему правому углу формы, чтобы сохранить ее относительное расположение при изменении размера формы. Затем он устанавливает <xref:System.Windows.Forms.Control.BackgroundImage%2A> и изменяет размер кнопки на тот же размер, что и <xref:System.Drawing.Image>. Затем в примере устанавливается <xref:System.Windows.Forms.Control.TabStop%2A> в `true` и задается свойство <xref:System.Windows.Forms.Control.TabIndex%2A>. Наконец, он добавляет обработчик событий для обработки события <xref:System.Windows.Forms.Control.Click> кнопки. В этом примере требуется <xref:System.Windows.Forms.ImageList> с именем `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabIndexChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabIndexChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabIndexChanged;" />
      <MemberSignature Language="F#" Value="member this.TabIndexChanged : EventHandler " Usage="member this.TabIndexChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.TabIndex" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.TabIndex%2A> изменено программным изменением или взаимодействием с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Control.TabIndexChanged>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа, который наследует от <xref:System.Windows.Forms.Control>, например <xref:System.Windows.Forms.Button> или <xref:System.Windows.Forms.ComboBox>. Затем присвойте экземпляру имя `Control1` и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Control.TabIndexChanged>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#25)]
 [!code-vb[System.Windows.Forms.EventExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#25)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabStop" />
      <MemberSignature Language="VB.NET" Value="Public Property TabStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TabStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TabStop : bool with get, set" Usage="System.Windows.Forms.Control.TabStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, может ли пользователь перевести фокус на данный элемент управления при помощи клавиши TAB.</summary>
        <value>Значение <see langword="true" />, если с помощью клавиши TAB можно перевести фокус на элемент управления; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.  
  
 <block subset="none" type="note"><para>  
 Это свойство будет всегда возвращать значение <see langword="true" /> для экземпляра класса <see cref="T:System.Windows.Forms.Form" />.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда пользователь нажимает клавишу TAB, фокус ввода устанавливается на следующий элемент управления в последовательности табуляции. Элементы управления со значением свойства <xref:System.Windows.Forms.Control.TabStop%2A>, равным `false`, не включаются в коллекцию элементов управления в последовательности табуляции. Порядок табуляции можно изменить, задав значение свойства <xref:System.Windows.Forms.Control.TabIndex%2A> элемента управления.  
  
   
  
## Examples  
 В следующем примере кода в форму добавляется <xref:System.Windows.Forms.Button> и задаются некоторые общие свойства. В этом примере кнопка привязывается к нижнему правому углу формы, чтобы сохранить ее относительное расположение при изменении размера формы. Затем он устанавливает <xref:System.Windows.Forms.Control.BackgroundImage%2A> и изменяет размер кнопки на тот же размер, что и <xref:System.Drawing.Image>. Затем в примере устанавливается <xref:System.Windows.Forms.Control.TabStop%2A> в `true` и задается свойство <xref:System.Windows.Forms.Control.TabIndex%2A>. Наконец, он добавляет обработчик событий для обработки события <xref:System.Windows.Forms.Control.Click> кнопки. В этом примере требуется <xref:System.Windows.Forms.ImageList> с именем `imageList1`.  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabStopChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabStopChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabStopChanged;" />
      <MemberSignature Language="F#" Value="member this.TabStopChanged : EventHandler " Usage="member this.TabStopChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.TabStop" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.TabStop%2A> изменено программным изменением или взаимодействием с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В этом примере обработчик событий сообщает о возникновении события <xref:System.Windows.Forms.Control.TabStopChanged>. Этот отчет поможет вам узнать, когда происходит событие и может помочь при отладке. Чтобы сообщить о нескольких событиях или о событиях, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> на <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или Добавление сообщения в многострочный <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы выполнить пример кода, вставьте его в проект, содержащий экземпляр типа, который наследует от <xref:System.Windows.Forms.Control>, например <xref:System.Windows.Forms.Button> или <xref:System.Windows.Forms.ComboBox>. Затем присвойте экземпляру имя `Control1` и убедитесь, что обработчик событий связан с событием <xref:System.Windows.Forms.Control.TabStopChanged>.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#26)]
 [!code-vb[System.Windows.Forms.EventExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.Forms.Control.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект, содержащий данные об элементе управления.</summary>
        <value>Объект <see cref="T:System.Object" />, содержащий данные элемента управления. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этому свойству может быть назначен любой тип, производный от класса <xref:System.Object>. Если свойство <xref:System.Windows.Forms.Control.Tag%2A> задано с помощью конструктора Windows Forms, может быть назначен только текст.  
  
 Обычно свойство <xref:System.Windows.Forms.Control.Tag%2A> используется для хранения данных, тесно связанных с элементом управления. Например, если имеется элемент управления, отображающий сведения о клиенте, можно сохранить <xref:System.Data.DataSet>, который содержит историю заказа клиента в свойстве <xref:System.Windows.Forms.Control.Tag%2A> этого элемента управления, чтобы обеспечить быстрый доступ к данным.  
  
   
  
## Examples  
 В следующем примере кода отображается форма и в свойстве <xref:System.Windows.Forms.Control.Tag%2A> хранится `Customer`. В этом примере необходимо определить класс, производный от <xref:System.Windows.Forms.Form> с именем `CustomerForm`, и определить `Customer`.  
  
 [!code-cpp[Windows.Forms.Control Members2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#3)]
 [!code-vb[Windows.Forms.Control Members2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public virtual string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.Control.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-517)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает текст, связанный с этим элементом управления.</summary>
        <value>Текст, связанный с этим элементом управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Forms.Control.Text%2A> элемента управления используется различными производными классами. Например, свойство <xref:System.Windows.Forms.Control.Text%2A> <xref:System.Windows.Forms.Form> отображается в строке заголовка в верхней части формы, является небольшим в поле число символов и обычно отображает имя приложения или документа. Однако свойство <xref:System.Windows.Forms.Control.Text%2A> <xref:System.Windows.Forms.RichTextBox> может быть большим и может включать многочисленные невизуальные символы, используемые для форматирования текста. Например, текст, отображаемый в <xref:System.Windows.Forms.RichTextBox>, можно отформатировать, изменив свойства <xref:System.Drawing.Font>, или добавить пробелы или символы табуляции для выровняйте текст.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.GroupBox> и задаются некоторые общие свойства. В примере создается <xref:System.Windows.Forms.TextBox> и задается его <xref:System.Windows.Forms.Control.Location%2A> в поле группы. Затем задается свойство <xref:System.Windows.Forms.Control.Text%2A> поля группы и закрепляет поле группы в верхней части формы. Наконец, он отключает поле группы, присвоив свойству <xref:System.Windows.Forms.Control.Enabled%2A> значение `false`, что приводит к отключению всех элементов управления, содержащихся в поле группы.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении свойства <see cref="P:System.Windows.Forms.Control.Text" /> в производном классе используйте свойство базового класса <see cref="P:System.Windows.Forms.Control.Text" /> для расширения базовой реализации. В противном случае необходимо предоставить всю реализацию. Не требуется переопределять методы доступа <see langword="get" /> и <see langword="set" /> свойства <see cref="P:System.Windows.Forms.Control.Text" />; При необходимости можно переопределить только один из них.</para></block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.TextLength" />
      </Docs>
    </Member>
    <Member MemberName="TextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TextChanged;" />
      <MemberSignature Language="F#" Value="member this.TextChanged : EventHandler " Usage="member this.TextChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.Text" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.Text%2A> изменено программным изменением или взаимодействием с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> с отображением денежных данных. В примере текст преобразуется в десятичное число и изменяется <xref:System.Windows.Forms.Control.ForeColor%2A> в <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>, если число отрицательное, а значение <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>, если число положительное. В этом примере требуется <xref:System.Windows.Forms.Form>, содержащий <xref:System.Windows.Forms.TextBox>.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public int Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Top { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Top : int with get, set" Usage="System.Windows.Forms.Control.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает расстояние в пикселях между верхней границей элемента управления и верхней границей клиентской области его контейнера.</summary>
        <value>Объект <see cref="T:System.Int32" />, представляющий расстояние (в пикселях) между нижней границей элемента управления и верхней границей клиентской области контейнера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение свойства <xref:System.Windows.Forms.Control.Top%2A> эквивалентно свойству <xref:System.Drawing.Point.Y%2A?displayProperty=nameWithType> значения свойства элемента управления <xref:System.Windows.Forms.Control.Location%2A>.  
  
 Изменения, внесенные в значения свойств <xref:System.Windows.Forms.Control.Height%2A> и <xref:System.Windows.Forms.Control.Top%2A>, приводят к изменению значения свойства <xref:System.Windows.Forms.Control.Bottom%2A> элемента управления.  
  
   
  
## Examples  
 В следующем примере кода создаются три элемента управления <xref:System.Windows.Forms.Button> в форме и задаются их размер и расположение с использованием различных свойств, связанных с размером и расположением. В этом примере требуется наличие <xref:System.Windows.Forms.Form> с шириной и высотой не менее 300 пикселей.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Point.Y" />
        <altmember cref="P:System.Windows.Forms.Control.Bottom" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="TopLevelControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control TopLevelControl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control TopLevelControl" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TopLevelControl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TopLevelControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ TopLevelControl { System::Windows::Forms::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TopLevelControl : System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.TopLevelControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает родительский элемент управления, не имеющий другого родительского элемента управления Windows Forms. Как правило, им является внешний объект <see cref="T:System.Windows.Forms.Form" />, в котором содержится элемент управления.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.Control" /> представляет элемент управления верхнего уровня, содержащий текущий элемент управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элемент управления верхнего уровня определяется как родительский элемент управления, не являющийся родительским для другого элемента управления Windows Forms. Как правило, им является внешний объект <xref:System.Windows.Forms.Form>, в котором содержится элемент управления. Например, если элемент управления содержится в дочернем элементе MDI <xref:System.Windows.Forms.Form>, то элемент управления верхнего уровня является родительским элементом интерфейса MDI <xref:System.Windows.Forms.Form>. Если элемент управления не является родительским для <xref:System.Windows.Forms.Form>, это свойство будет возвращать значение `null`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон, чтобы получить значение этого свойства. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public void Update ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Update() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Update" />
      <MemberSignature Language="VB.NET" Value="Public Sub Update ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Update();" />
      <MemberSignature Language="F#" Value="member this.Update : unit -&gt; unit" Usage="control.Update " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает перерисовку элементом управления недопустимых областей клиентской области.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Выполняет все ожидающие запросы на рисование.  
  
 Существует два способа перерисовки формы и ее содержимого:  
  
-   Можно использовать одну из перегрузок метода <xref:System.Windows.Forms.Control.Invalidate%2A> с методом <xref:System.Windows.Forms.Control.Update%2A>.  
  
-   Можно вызвать метод <xref:System.Windows.Forms.Control.Refresh%2A>, который заставляет элемент управления перерисовывать себя и все его дочерние элементы. Это эквивалентно присвоению методу <xref:System.Windows.Forms.Control.Invalidate%2A> значения `true` и его использования в <xref:System.Windows.Forms.Control.Update%2A>.  
  
 Метод <xref:System.Windows.Forms.Control.Invalidate%2A> управляет нарисованной или перерисовкой. Метод <xref:System.Windows.Forms.Control.Update%2A> управляет назначением прорисовки или перерисовки. Если вы используете методы <xref:System.Windows.Forms.Control.Invalidate%2A> и <xref:System.Windows.Forms.Control.Update%2A> вместе, а не вызываете <xref:System.Windows.Forms.Control.Refresh%2A>, что перерисовывается, зависит от того, какая перегрузка используется в <xref:System.Windows.Forms.Control.Invalidate%2A>. Метод <xref:System.Windows.Forms.Control.Update%2A> просто заставляет элемент управления закрашен немедленно, но метод <xref:System.Windows.Forms.Control.Invalidate%2A> управляет тем, что рисуется при вызове метода <xref:System.Windows.Forms.Control.Update%2A>.  
  
 Дополнительные сведения см. в разделе [WM_PAINT](https://msdn.microsoft.com/library/dd145213\(v=vs.85\).aspx) .  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Обновляет границы элемента управления.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected internal void UpdateBounds ();" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void UpdateBounds() cil managed" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub UpdateBounds ()" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void UpdateBounds();" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : unit -&gt; unit" Usage="control.UpdateBounds " />
      <MemberSignature Language="C#" Value="protected void UpdateBounds ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds() cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds ()" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds();" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обновляет границы элемента управления с учетом текущего размера и местоположения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если новый <xref:System.Windows.Forms.Control.Size%2A> элемента управления отличается от предыдущего <xref:System.Drawing.Size>, возникает событие <xref:System.Windows.Forms.Control.SizeChanged>. Аналогичным образом, при изменении <xref:System.Windows.Forms.Control.Location%2A> элемента управления возникает событие <xref:System.Windows.Forms.Control.LocationChanged>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : int * int * int * int -&gt; unit" Usage="control.UpdateBounds (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Координата <see cref="P:System.Drawing.Point.X" /> элемента управления.</param>
        <param name="y">Координата <see cref="P:System.Drawing.Point.Y" /> элемента управления.</param>
        <param name="width">Тип <see cref="P:System.Drawing.Size.Width" /> элемента управления.</param>
        <param name="height">Тип <see cref="P:System.Drawing.Size.Height" /> элемента управления.</param>
        <summary>Обновляет границы элемента управления с учетом указанного размера и местоположения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если новый <xref:System.Windows.Forms.Control.Size%2A> элемента управления, если он отличается от предыдущего <xref:System.Drawing.Size>, возникает событие <xref:System.Windows.Forms.Control.SizeChanged>. Аналогично, является <xref:System.Windows.Forms.Control.Location%2A> элемента управления, возникает событие <xref:System.Windows.Forms.Control.LocationChanged>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height, int32 clientWidth, int32 clientHeight) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds (x As Integer, y As Integer, width As Integer, height As Integer, clientWidth As Integer, clientHeight As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds(int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : int * int * int * int * int * int -&gt; unit" Usage="control.UpdateBounds (x, y, width, height, clientWidth, clientHeight)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="clientWidth" Type="System.Int32" />
        <Parameter Name="clientHeight" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Координата <see cref="P:System.Drawing.Point.X" /> элемента управления.</param>
        <param name="y">Координата <see cref="P:System.Drawing.Point.Y" /> элемента управления.</param>
        <param name="width">Тип <see cref="P:System.Drawing.Size.Width" /> элемента управления.</param>
        <param name="height">Тип <see cref="P:System.Drawing.Size.Height" /> элемента управления.</param>
        <param name="clientWidth">Клиентское свойство <see cref="P:System.Drawing.Size.Width" /> элемента управления.</param>
        <param name="clientHeight">Клиентское свойство <see cref="P:System.Drawing.Size.Height" /> элемента управления.</param>
        <summary>Обновляет границы элемента управления с учетом указанного размера, местоположения и клиентского размера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если новый <xref:System.Windows.Forms.Control.Size%2A> элемента управления отличается от предыдущего <xref:System.Drawing.Size>, возникает событие <xref:System.Windows.Forms.Control.SizeChanged>. Аналогичным образом, при изменении <xref:System.Windows.Forms.Control.Location%2A> элемента управления возникает событие <xref:System.Windows.Forms.Control.LocationChanged>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
      </Docs>
    </Member>
    <Member MemberName="UpdateStyles">
      <MemberSignature Language="C#" Value="protected void UpdateStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateStyles" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateStyles ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateStyles();" />
      <MemberSignature Language="F#" Value="member this.UpdateStyles : unit -&gt; unit" Usage="control.UpdateStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает принудительное повторное применение назначенных стилей к элементу управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает метод <xref:System.Windows.Forms.Control.CreateParams%2A>, чтобы получить применяемые стили. Повторно применяются стили, присвоенные свойствам <xref:System.Windows.Forms.CreateParams.Style%2A> и <xref:System.Windows.Forms.CreateParams.ExStyle%2A> класса <xref:System.Windows.Forms.CreateParams>, назначенного свойству <xref:System.Windows.Forms.Control.CreateParams%2A> элемента управления. Элемент управления перерисовывается для отражения изменений стиля, если это необходимо.  
  
 Метод <xref:System.Windows.Forms.Control.UpdateStyles%2A> не действует, если значение свойства <xref:System.Windows.Forms.Control.IsHandleCreated%2A> равно `false`.  
  
   
  
## Examples  
 Следующий пример кода включает двойную буферизацию на <xref:System.Windows.Forms.Form> и обновляет стили для отражения изменений.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="UpdateZOrder">
      <MemberSignature Language="C#" Value="protected void UpdateZOrder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateZOrder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateZOrder" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateZOrder ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateZOrder();" />
      <MemberSignature Language="F#" Value="member this.UpdateZOrder : unit -&gt; unit" Usage="control.UpdateZOrder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обновляет элемент управления в z-порядке его родительского элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Forms.Control.UpdateZOrder%2A> обновляет расположение элемента управления в z-порядке его родительского элемента управления. Например, если этот элемент управления является только что созданным элементом управления, добавленным в <xref:System.Windows.Forms.Control.ControlCollection>, то z-порядок обновляется новым элементом управления, добавленным в конец.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Control.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, следует ли использовать курсор ожидания для текущего элемента управления и всех дочерних элементов управления.</summary>
        <value>Значение <see langword="true" />, чтобы использовать курсор ожидания для текущего элемента управления и всех дочерних элементов управления; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте курсор ожидания при выполнении операции, которая занимает значительное время. Однако обратите внимание, что операции, блокирующие поток пользовательского интерфейса, также блокируют изменение курсора. Поэтому это свойство следует использовать только при выполнении операций, требующих много времени в другом потоке. Для глобального и немедленного изменения курсора см. свойство <xref:System.Windows.Forms.Cursor.Current%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validated">
      <MemberSignature Language="C#" Value="public event EventHandler Validated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Validated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Validated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Validated;" />
      <MemberSignature Language="F#" Value="member this.Validated : EventHandler " Usage="member this.Validated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит по завершении проверки элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При изменении фокуса с помощью клавиатуры (TAB, SHIFT + TAB и т. д.), вызывая методы <xref:System.Windows.Forms.Control.Select%2A> или <xref:System.Windows.Forms.Control.SelectNextControl%2A> или устанавливая свойство <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> в текущую форму, события фокуса происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 При изменении фокуса с помощью мыши или при вызове метода <xref:System.Windows.Forms.Control.Focus%2A> события фокуса происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Если свойство <xref:System.Windows.Forms.Control.CausesValidation%2A> имеет значение `false`, события <xref:System.Windows.Forms.Control.Validating> и <xref:System.Windows.Forms.Control.Validated> подавляются.  
  
 Если свойство <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> <xref:System.ComponentModel.CancelEventArgs> имеет значение `true` в делегате события <xref:System.Windows.Forms.Control.Validating>, все события, которые обычно происходят после события <xref:System.Windows.Forms.Control.Validating>, подавляются.  
  
> [!CAUTION]
>  Не пытайтесь установить фокус с помощью обработчиков событий <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating> или <xref:System.Windows.Forms.Control.Validated>. Это может привести к тому, что ваше приложение или операционная система перестанут отвечать. Дополнительные сведения см. в разделе [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx) и в разделе "взаимоблокировки сообщений" статьи [о сообщениях и очередях сообщений](https://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx) .  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода используется производный класс <xref:System.Windows.Forms.TextBox> и проверяется адрес электронной почты, который вводит пользователь. Если адрес электронной почты имеет формат, отличный от стандартного (содержащий "@" and "."), проверка завершается неудачно, отображается значок <xref:System.Windows.Forms.ErrorProvider>, и событие отменяется. В этом примере требуется, чтобы на форме создавался элемент управления <xref:System.Windows.Forms.TextBox> и <xref:System.Windows.Forms.ErrorProvider>.  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
      </Docs>
    </Member>
    <Member MemberName="Validating">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Validating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Validating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Validating As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Validating;" />
      <MemberSignature Language="F#" Value="member this.Validating : System.ComponentModel.CancelEventHandler " Usage="member this.Validating : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает при проверке действительности элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При изменении фокуса с помощью клавиатуры (TAB, SHIFT + TAB и т. д.), вызывая методы <xref:System.Windows.Forms.Control.Select%2A> или <xref:System.Windows.Forms.Control.SelectNextControl%2A> или устанавливая свойство <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> в текущую форму, события фокуса происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 При изменении фокуса с помощью мыши или при вызове метода <xref:System.Windows.Forms.Control.Focus%2A> события фокуса происходят в следующем порядке:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Если свойство <xref:System.Windows.Forms.Control.CausesValidation%2A> имеет значение `false`, события <xref:System.Windows.Forms.Control.Validating> и <xref:System.Windows.Forms.Control.Validated> подавляются.  
  
 Если свойство <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> <xref:System.ComponentModel.CancelEventArgs> имеет значение `true` в делегате события <xref:System.Windows.Forms.Control.Validating>, все события, которые обычно происходят после события <xref:System.Windows.Forms.Control.Validating>, подавляются.  
  
> [!CAUTION]
>  Не пытайтесь установить фокус с помощью обработчиков событий <xref:System.Windows.Forms.Control.Enter>, <xref:System.Windows.Forms.Control.GotFocus>, <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus>, <xref:System.Windows.Forms.Control.Validating> или <xref:System.Windows.Forms.Control.Validated>. Это может привести к тому, что ваше приложение или операционная система перестанут отвечать. Дополнительные сведения см. в разделе `WM_KILLFOCUS` в разделе "Справка по вводу с клавиатуры" и в разделе "взаимоблокировки сообщений" статьи "о сообщениях и очередях сообщений" в библиотеке MSDN по адресу http://msdn.microsoft.com/library.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода используется производный класс <xref:System.Windows.Forms.TextBox> и проверяется адрес электронной почты, который вводит пользователь. Если адрес электронной почты имеет формат, отличный от стандартного (содержащий "@" and "."), проверка завершается неудачно, отображается значок <xref:System.Windows.Forms.ErrorProvider>, и событие отменяется. В этом примере требуется, чтобы на форме создавался элемент управления <xref:System.Windows.Forms.TextBox> и <xref:System.Windows.Forms.ErrorProvider>.  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Windows.Forms.Control.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, отображаются ли элемент управления и все его дочерние элементы управления.</summary>
        <value>Значение <see langword="true" />, если элемент управления и все его дочерние элементы управления отображаются; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что даже если `Visible` имеет значение `true`, элемент управления может быть невидимым для пользователя, если он скрыт позади других элементов управления.  
  
   
  
## Examples  
 В следующем примере кода используются производные классы <xref:System.Windows.Forms.VScrollBar> и <xref:System.Windows.Forms.HScrollBar> и устанавливаются значения свойств <xref:System.Windows.Forms.Control.Visible%2A> в зависимости от размера <xref:System.Drawing.Image>, отображаемого в элементе управления <xref:System.Windows.Forms.PictureBox>. В этом примере требуется, чтобы в форме был создан <xref:System.Windows.Forms.PictureBox>, и что в <xref:System.Windows.Forms.PictureBox> были созданы элементы управления <xref:System.Windows.Forms.HScrollBar> и <xref:System.Windows.Forms.VScrollBar>. Этот код должен вызываться при загрузке изображения в поле изображения и при событии <xref:System.Windows.Forms.Control.Resize> формы.  
  
 [!code-cpp[Classic Control.Visible Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.Visible Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.Visible Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.Visible Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Visible Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.Visible Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="VisibleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler VisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.VisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VisibleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ VisibleChanged;" />
      <MemberSignature Language="F#" Value="member this.VisibleChanged : EventHandler " Usage="member this.VisibleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Control.Visible" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает, если свойство <xref:System.Windows.Forms.Control.Visible%2A> изменено программным изменением или взаимодействием с пользователем.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода возникает событие <xref:System.Windows.Forms.Control.VisibleChanged> при изменении значения свойства <xref:System.Windows.Forms.Control.Visible%2A> элемента управления <xref:System.Windows.Forms.Label>.  
  
 [!code-cpp[Control_VisibleChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_VisibleChanged/CPP/control_visiblechanged.cpp#1)]
 [!code-csharp[Control_VisibleChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_VisibleChanged/CS/control_visiblechanged.cs#1)]
 [!code-vb[Control_VisibleChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_VisibleChanged/VB/control_visiblechanged.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public int Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Width { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Width : int with get, set" Usage="System.Windows.Forms.Control.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ширину элемента управления.</summary>
        <value>Ширина элемента управления в пикселях.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Изменения, внесенные в значения свойств <xref:System.Windows.Forms.Control.Width%2A> и <xref:System.Windows.Forms.Control.Left%2A>, приводят к изменению значения свойства <xref:System.Windows.Forms.Control.Right%2A> элемента управления.  
  
   
  
## Examples  
 В следующем примере кода создаются три элемента управления <xref:System.Windows.Forms.Button> в форме и задаются их размер и расположение с использованием различных свойств, связанных с размером и расположением. В этом примере требуется наличие <xref:System.Windows.Forms.Form> с шириной и высотой не менее 300 пикселей.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Drawing.Size.Width" />
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WindowTarget">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IWindowTarget WindowTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IWindowTarget WindowTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.WindowTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowTarget As IWindowTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IWindowTarget ^ WindowTarget { System::Windows::Forms::IWindowTarget ^ get(); void set(System::Windows::Forms::IWindowTarget ^ value); };" />
      <MemberSignature Language="F#" Value="member this.WindowTarget : System.Windows.Forms.IWindowTarget with get, set" Usage="System.Windows.Forms.Control.WindowTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IWindowTarget</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Данное свойство не применимо к этому классу.</summary>
        <value>NativeWindow в элементе управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данное свойство не применимо к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected virtual void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member WndProc : Message -&gt; unit&#xA;override this.WndProc : Message -&gt; unit" Usage="control.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Сообщение <see cref="T:System.Windows.Forms.Message" /> Windows для обработки.</param>
        <summary>Обрабатывает сообщения Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все сообщения отправляются в метод <xref:System.Windows.Forms.Control.WndProc%2A> после фильтрации с помощью метода <xref:System.Windows.Forms.Control.PreProcessMessage%2A>.  
  
 Метод <xref:System.Windows.Forms.Control.WndProc%2A> точно соответствует функции `WindowProc` Windows. Дополнительные сведения об обработке сообщений Windows см. в разделе [функция WindowProc](https://go.microsoft.com/fwlink/?LinkId=181565).  
  
   
  
## Examples  
 В следующем примере кода показано переопределение метода <xref:System.Windows.Forms.Control.WndProc%2A> для работы с сообщениями операционной системы, определенными в структуре <xref:System.Windows.Forms.Message>. Сообщение операционной системы [WM_ACTIVATEAPP](https://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx) обрабатывается в этом примере, чтобы выяснить, когда становится активным другое приложение. Сведения о доступных значениях <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.Message.LParam%2A?displayProperty=nameWithType> и <xref:System.Windows.Forms.Message.WParam%2A?displayProperty=nameWithType> см. в следующих разделах. Фактические значения констант можно найти в файле заголовка Windows. h.  
  
 [!code-cpp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для непосредственного вызывающего объекта, чтобы вызвать неуправляемый код. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides"><para>Наследуемые элементы управления должны вызывать метод <see cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" /> базового класса для обработки любых сообщений, которые не обрабатываются.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
  </Members>
</Type>
