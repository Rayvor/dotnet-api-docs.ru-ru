<Type Name="MsmqBindingElementBase" FullName="System.ServiceModel.Configuration.MsmqBindingElementBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b98fbeb8fd666e61ab7e3170976ac162ce58871b" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69105093" /></Metadata><TypeSignature Language="C#" Value="public abstract class MsmqBindingElementBase : System.ServiceModel.Configuration.StandardBindingElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit MsmqBindingElementBase extends System.ServiceModel.Configuration.StandardBindingElement" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Configuration.MsmqBindingElementBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MsmqBindingElementBase&#xA;Inherits StandardBindingElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class MsmqBindingElementBase abstract : System::ServiceModel::Configuration::StandardBindingElement" />
  <TypeSignature Language="F#" Value="type MsmqBindingElementBase = class&#xA;    inherit StandardBindingElement" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Configuration.StandardBindingElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет базовый класс, члены которого являются общими для классов <see cref="T:System.ServiceModel.Configuration.NetMsmqBindingElement" /> и <see cref="T:System.ServiceModel.Configuration.MsmqIntegrationBindingElement" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс содержит параметры, необходимые для настройки привязки на основе очереди сообщений (MSMQ).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.Configuration.MsmqBindingElementBase" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MsmqBindingElementBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Configuration.MsmqBindingElementBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MsmqBindingElementBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.Configuration.MsmqBindingElementBase" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MsmqBindingElementBase (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Configuration.MsmqBindingElementBase.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MsmqBindingElementBase(System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Configuration.MsmqBindingElementBase : string -&gt; System.ServiceModel.Configuration.MsmqBindingElementBase" Usage="new System.ServiceModel.Configuration.MsmqBindingElementBase name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя конфигурации привязки. Это значение должно быть уникальным, поскольку оно используется для идентификации конкретной привязки.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.Configuration.MsmqBindingElementBase" /> с использованием указанного имени.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomDeadLetterQueue">
      <MemberSignature Language="C#" Value="public Uri CustomDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri CustomDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.CustomDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property CustomDeadLetterQueue As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ CustomDeadLetterQueue { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CustomDeadLetterQueue : Uri with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.CustomDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("customDeadLetterQueue", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает универсальный код ресурса <see cref="T:System.Uri" />, идентифицирующий пользовательскую очередь недоставленных сообщений, в которую отправляются просроченные сообщения и сообщения, которые не удалось доставить.</summary>
        <value>Экземпляр класса <see cref="T:System.Uri" />, содержащий универсальный код ресурса (URI) настраиваемой очереди недоставленных сообщений.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Очередь* недоставленных сообщений — это очередь, управляемая диспетчером очереди отправляющего приложения, в которой хранятся сообщения, которые не были доставлены или истек срок их действия. Свойство `CustomDeadLetterQueue` позволяет указать настраиваемую очередь недоставленных сообщений вместо системной очереди недоставленных сообщений.  
  
 Универсальный код ресурса (URI), определяемый свойством <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.CustomDeadLetterQueue%2A>, должен использовать схему net.msmq.  
  
 Если свойству <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.DeadLetterQueue%2A> присвоено значение <xref:System.ServiceModel.DeadLetterQueue.None> или <xref:System.ServiceModel.DeadLetterQueue.System>, свойству <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.CustomDeadLetterQueue%2A> необходимо присвоить значение `null`. Если значение свойства <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.CustomDeadLetterQueue%2A> отличается от значения `null`, свойству <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.DeadLetterQueue%2A> необходимо присвоить значение <xref:System.ServiceModel.DeadLetterQueue.Custom>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeadLetterQueue">
      <MemberSignature Language="C#" Value="public System.ServiceModel.DeadLetterQueue DeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.DeadLetterQueue DeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.DeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property DeadLetterQueue As DeadLetterQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::DeadLetterQueue DeadLetterQueue { System::ServiceModel::DeadLetterQueue get(); void set(System::ServiceModel::DeadLetterQueue value); };" />
      <MemberSignature Language="F#" Value="member this.DeadLetterQueue : System.ServiceModel.DeadLetterQueue with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.DeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("deadLetterQueue", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.DeadLetterQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение параметра <see cref="T:System.ServiceModel.DeadLetterQueue" /> для данной привязки.</summary>
        <value>Значение <see cref="T:System.ServiceModel.DeadLetterQueue" />, задающее, какой тип очереди недоставленных сообщений следует использовать, и использовать ли вообще.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Очередь* недоставленных сообщений — это очередь, управляемая диспетчером очереди отправляющего приложения, в которой хранятся сообщения, которые не удалось доставить или которых истек срок действия. Ниже перечислены возможные причины, по которым сообщение может не дойти до принимающего приложения.  
  
-   Транзакционное сообщение отправлено в нетранзакционную очередь.  
  
-   Нетранзакционное сообщение отправлено в транзакционную очередь.  
  
-   В очередь, принимающую только сообщения, которые прошли проверку подлинности, отправлено сообщение, не прошедшее проверку подлинности.  
  
-   В очередь, принимающую только зашифрованные сообщения, отправлено незашифрованное сообщение.  
  
-   Срок действия сообщения истек до того, как оно было доставлено получателю.  
  
-   При получении сообщения была превышена квота хранилища сообщений на конечном компьютере или квота хранилища очереди назначения, либо не хватило пространства памяти на конечном компьютере.  
  
-   У отправителя нет [прав доступа](https://go.microsoft.com/fwlink/?LinkID=96167) , необходимых для размещения сообщения в очереди назначения.  
  
-   Цифровая сигнатура сообщения недействительна.  
  
-   Диспетчеру очереди назначения не удалось расшифровать зашифрованное сообщение.  
  
-   Очередь назначения была очищена или удалена до извлечения сообщения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Durable">
      <MemberSignature Language="C#" Value="public bool Durable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Durable" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.Durable" />
      <MemberSignature Language="VB.NET" Value="Public Property Durable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Durable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Durable : bool with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.Durable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("durable", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, являются ли сообщения, отправляемые этой привязкой, устойчивыми или переменными.</summary>
        <value>Значение <see langword="true" />, если сообщения, обрабатываемые этой привязкой, являются устойчивыми; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этому свойству присвоено значение `true`, сообщения являются устойчивыми; в противном случае сообщения являются переменными. Устойчивые сообщения не теряются в случае сбоя диспетчера очередей. Значение по умолчанию для этого свойства — `true`. Если необходимо обеспечить для сообщений гарантию в точности однократной доставки (свойству <xref:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce%2A> присвоено значение `true`), этому свойству необходимо присвоить значение `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExactlyOnce">
      <MemberSignature Language="C#" Value="public bool ExactlyOnce { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExactlyOnce" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.ExactlyOnce" />
      <MemberSignature Language="VB.NET" Value="Public Property ExactlyOnce As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExactlyOnce { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExactlyOnce : bool with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.ExactlyOnce" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("exactlyOnce", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, задана ли для сообщений, отправляемых этой привязкой, гарантия в точности однократной доставки.</summary>
        <value>Значение <see langword="true" />, если гарантирована однократная доставка сообщений, отправляемых этой привязкой; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce%2A>значение `true`указывает, что очередь сообщений (также называемая MSMQ) гарантирует, что отправленное сообщение будет доставлено в очередь принимающих сообщений один раз и только один раз. В случае сбоя доставки сообщение отправляется в очередь недоставленных сообщений в зависимости от `DeadLetterQueue` значения свойства. Если свойству <xref:System.ServiceModel.Channels.MsmqBindingElementBase.ExactlyOnce%2A> присвоено значение `true`, используемая очередь должна быть очередью транзакционных сообщений.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeFrom">
      <MemberSignature Language="C#" Value="protected internal override void InitializeFrom (System.ServiceModel.Channels.Binding binding);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void InitializeFrom(class System.ServiceModel.Channels.Binding binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Configuration.MsmqBindingElementBase.InitializeFrom(System.ServiceModel.Channels.Binding)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void InitializeFrom(System::ServiceModel::Channels::Binding ^ binding);" />
      <MemberSignature Language="F#" Value="override this.InitializeFrom : System.ServiceModel.Channels.Binding -&gt; unit" Usage="msmqBindingElementBase.InitializeFrom binding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
      </Parameters>
      <Docs>
        <param name="binding">Привязка с параметрами, которые будут использоваться для инициализации данной привязки.</param>
        <summary>Инициализирует данную привязку содержимым указанной привязки.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxReceivedMessageSize">
      <MemberSignature Language="C#" Value="public long MaxReceivedMessageSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxReceivedMessageSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.MaxReceivedMessageSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxReceivedMessageSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxReceivedMessageSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxReceivedMessageSize : int64 with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.MaxReceivedMessageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("maxReceivedMessageSize", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Configuration.LongValidator(MinValue=0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, в котором указывается максимально допустимый размер сообщения (в байтах).</summary>
        <value>Максимально допустимый размер сообщения, отправляемого или принимаемого данной привязкой.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если размер входящего сообщения превышает значение <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.MaxReceivedMessageSize%2A>, такое сообщение отбрасывается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxRetryCycles">
      <MemberSignature Language="C#" Value="public int MaxRetryCycles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxRetryCycles" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.MaxRetryCycles" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxRetryCycles As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxRetryCycles { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxRetryCycles : int with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.MaxRetryCycles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("maxRetryCycles", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Configuration.IntegerValidator(MinValue=0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное число циклов повторных попыток доставки сообщений принимающему приложению.</summary>
        <value>Максимально количество циклов повторных попыток, предпринимаемых перед тем, как поместить сообщение в очередь недоставленных сообщений.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Цикл повторных попыток* заключается в том, что сообщение передается из очереди повтора в очередь приложения для попыток доставки в приложение. Сообщения помещаются в очередь повторных попыток после сбоя нескольких немедленных повторных попыток, как задано свойством <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveRetryCount%2A>. <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.MaxRetryCycles%2A> задает число циклов повторных попыток и не включает первоначальную попытку отправки сообщения. Максимальное количество попыток отправки сообщения составляет (1 + MaxRetryCycles) * (ReceiveRetryCount + 1) раз. Например, если ReceiveRetryCount = 0, а MaxRetryCycles = 1, будет предпринято максимум две попытки доставить сообщение. Это свойство доступно в операционных системах Windows, начиная с [!INCLUDE[wv](~/includes/wv-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyConfiguration">
      <MemberSignature Language="C#" Value="protected override void OnApplyConfiguration (System.ServiceModel.Channels.Binding binding);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApplyConfiguration(class System.ServiceModel.Channels.Binding binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Configuration.MsmqBindingElementBase.OnApplyConfiguration(System.ServiceModel.Channels.Binding)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApplyConfiguration(System::ServiceModel::Channels::Binding ^ binding);" />
      <MemberSignature Language="F#" Value="override this.OnApplyConfiguration : System.ServiceModel.Channels.Binding -&gt; unit" Usage="msmqBindingElementBase.OnApplyConfiguration binding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
      </Parameters>
      <Docs>
        <param name="binding">Привязка, содержащая параметры, которые необходимо применить.</param>
        <summary>Вызывается, когда содержимое данной привязки применяется к указанной привязке.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="protected override System.Configuration.ConfigurationPropertyCollection Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.ConfigurationPropertyCollection Properties" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.Properties" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property Properties As ConfigurationPropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Configuration::ConfigurationPropertyCollection ^ Properties { System::Configuration::ConfigurationPropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Configuration.ConfigurationPropertyCollection" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.ConfigurationPropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает экземпляр класса <see cref="T:System.Configuration.ConfigurationPropertyCollection" />, содержащий коллекцию объектов <see cref="T:System.Configuration.ConfigurationProperty" />, которые могут быть атрибутами или объектами <see cref="T:System.Configuration.ConfigurationElement" /> данного элемента конфигурации.</summary>
        <value>Экземпляр класса <see cref="T:System.Configuration.ConfigurationPropertyCollection" />, содержащий коллекцию объектов <see cref="T:System.Configuration.ConfigurationProperty" />, которые могут быть атрибутами или объектами <see cref="T:System.Configuration.ConfigurationElement" /> данного элемента конфигурации привязки.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveContextEnabled">
      <MemberSignature Language="C#" Value="public bool ReceiveContextEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReceiveContextEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveContextEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveContextEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReceiveContextEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveContextEnabled : bool with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveContextEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Configuration.ConfigurationProperty("receiveContextEnabled", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, включен ли контекст получения для обработки сообщений в очередях.</summary>
        <value>Значение <see langword="true" />, если включен контекст получения для обработки сообщений в очередях; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот параметр включен, служба может "Просмотреть" сообщение в очереди, чтобы начать его обработку, и, если что-то пойдет не так и исключение будет создано, оно останется в очереди. Службы также могут "блокировать" сообщения для повторной обработки в более поздний момент времени. Объект ReceiveContext предоставляет механизм для «завершения» сообщения после обработки, чтобы его можно было удалить из очереди. Сообщения больше не считываются и не переписываются в очереди по сети, а отдельные сообщения не переносятся между разными экземплярами службы во время обработки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveErrorHandling">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ReceiveErrorHandling ReceiveErrorHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.ReceiveErrorHandling ReceiveErrorHandling" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveErrorHandling As ReceiveErrorHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ReceiveErrorHandling ReceiveErrorHandling { System::ServiceModel::ReceiveErrorHandling get(); void set(System::ServiceModel::ReceiveErrorHandling value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveErrorHandling : System.ServiceModel.ReceiveErrorHandling with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("receiveErrorHandling", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ReceiveErrorHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение перечисления, указывающее, каким образом будут обрабатываться подозрительные сообщения и сообщения, которые не удалось доставить.</summary>
        <value>Значение <see cref="T:System.ServiceModel.ReceiveErrorHandling" />, указывающее, каким образом будут обрабатываться подозрительные сообщения и сообщения, которые не удалось доставить.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этому свойству присвоить значение <xref:System.ServiceModel.ReceiveErrorHandling.Fault>, это приведет к сбою прослушивателя и вызову исключения <xref:System.ServiceModel.ProtocolException> (являющегося оболочкой для класса <xref:System.ServiceModel.MsmqPoisonMessageException>) с трассировкой. Сообщение останется в очереди; его необходимо удалить вручную. Класс <xref:System.ServiceModel.MsmqPoisonMessageException> содержит свойство <xref:System.ServiceModel.MsmqPoisonMessageException.MessageLookupId%2A>, с помощью которого можно выявлять и вручную удалять такие сообщения из очереди подозрительных сообщений.  
  
 Если этому свойству присвоено значение <xref:System.ServiceModel.ReceiveErrorHandling.Drop>, сообщение, которое привело к вызову исключения, просто отбрасывается.  
  
 Если этому свойству присвоено значение <xref:System.ServiceModel.ReceiveErrorHandling.Reject>, клиенту отправляется уведомление о недоставке, а сообщение удаляется из очереди подозрительных сообщений. Этот параметр доступен только в очереди сообщений (MSMQ) 4.0.  
  
 Если этому свойству присвоено значение <xref:System.ServiceModel.ReceiveErrorHandling.Move>, сообщение перемещается во вложенную очередь для окончательного хранения подозрительных сообщений. Этот параметр доступен только в очереди сообщений (также известной как MSMQ) 4.0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveRetryCount">
      <MemberSignature Language="C#" Value="public int ReceiveRetryCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveRetryCount" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveRetryCount" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveRetryCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveRetryCount { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveRetryCount : int with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveRetryCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("receiveRetryCount", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Configuration.IntegerValidator(MinValue=0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное число немедленных повторных попыток, которые должен выполнить диспетчер очереди, если не удается передать сообщение из очереди приложения самому приложению.</summary>
        <value>Максимальное число попыток отправки сообщения диспетчером очереди, после которого сообщение помещается в очередь повторного выполнения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если выполнено максимальное количество попыток доставки, а приложение не имеет доступа к сообщению, сообщение помещается в очередь повторного выполнения для повторной доставки через некоторое время. Время до повторного помещения сообщения в очередь отправки указывается в свойстве <xref:System.ServiceModel.Channels.MsmqBindingElementBase.RetryCycleDelay%2A>. Если число повторных попыток достигает значения <xref:System.ServiceModel.Channels.MsmqBindingElementBase.MaxRetryCycles%2A>, то сообщение отправляется в очередь подозрительных сообщений или отправителю отсылается уведомление о том, что сообщение не может быть доставлено.  
  
 Дополнительные сведения см. в разделах <xref:System.ServiceModel.Channels.MsmqBindingElementBase.MaxRetryCycles%2A> и <xref:System.ServiceModel.Channels.MsmqBindingElementBase.RetryCycleDelay%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RetryCycleDelay">
      <MemberSignature Language="C#" Value="public TimeSpan RetryCycleDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan RetryCycleDelay" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.RetryCycleDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryCycleDelay As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan RetryCycleDelay { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.RetryCycleDelay : TimeSpan with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.RetryCycleDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("retryCycleDelay", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceModel.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Runtime.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, задающее время ожидания между циклами повторных попыток доставки сообщения, которое не удалось доставить.</summary>
        <value>Значение <see cref="T:System.TimeSpan" />, задающее промежуток времени ожидания до начала следующего цикла попыток доставки сообщения принимающему приложению. Значение по умолчанию — 30 (минут).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый цикл повторных попыток предпринимает попытки доставить сообщение принимающему приложению (задается свойством <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.MaxRetryCycles%2A>). Если ни одна из попыток не увенчается успехом, сообщение будет помещено обратно в очередь повторного выполнения. Это свойство задает срок нахождения сообщения в очереди повторных попыток, по истечении которого сообщение будет передано в очередь приложения для следующего цикла повторных попыток. Это свойство доступно в операционных системах Windows, начиная с [!INCLUDE[wv](~/includes/wv-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeToLive">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToLive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToLive" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.TimeToLive" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToLive As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToLive { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToLive : TimeSpan with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.TimeToLive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("timeToLive", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceModel.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Runtime.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, задающее срок действия сообщений. По истечении этого срока сообщение помещается в очередь недоставленных сообщений (если такая очередь существует).</summary>
        <value>Значение <see cref="T:System.TimeSpan" />, задающее срок действия сообщений. Значение по умолчанию — 24 часа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поставленные в очередь приложения работают по замыслу разработчиков асинхронно, то есть отправляющее и принимающее приложения могут быть запущены в разное время. Следовательно, возможна ситуация, при которой сообщение от отправляющего приложения может быть обработано принимающим приложением не сразу. Некоторые сообщения содержат сведения, действительные только в течение определенного промежутка времени. Если сообщение не будет доставлено в течение этого промежутка времени, содержащиеся в нем сведения потеряют свою актуальность, и поэтому такое сообщение следует удалить. Это свойство позволяет указать предельное время, в течение которого сообщение будет храниться перед доставкой в очередь приложения. Если это время истечет до помещения сообщения в очередь приложения, сообщение будет помещено в очередь недоставленных сообщений, если таковая существует (указывается в свойстве <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.DeadLetterQueue%2A>); в противном случае, если очереди недоставленных сообщений не существует, сообщение удаляется.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseMsmqTracing">
      <MemberSignature Language="C#" Value="public bool UseMsmqTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseMsmqTracing" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.UseMsmqTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseMsmqTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseMsmqTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseMsmqTracing : bool with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.UseMsmqTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("useMsmqTracing", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, используется ли функция отслеживания сообщений, встроенная в очередь сообщений (MSMQ).</summary>
        <value>Значение <see langword="true" />, если используется встроенная трассировка сообщений очереди сообщений (MSMQ); в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойству <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.UseMsmqTracing%2A> задано значение `true`, поставленный в очередь канал использует встроенную функцию трассировки сообщений очереди сообщений. При включенной трассировке каждый раз, когда сообщение принимается и отправляется диспетчером очередей, в указанную очередь отчетов помещается сообщение с отчетом.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseSourceJournal">
      <MemberSignature Language="C#" Value="public bool UseSourceJournal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSourceJournal" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.UseSourceJournal" />
      <MemberSignature Language="VB.NET" Value="Public Property UseSourceJournal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSourceJournal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseSourceJournal : bool with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.UseSourceJournal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Configuration.ConfigurationProperty("useSourceJournal", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, должны ли сохраняться в очереди журнала источника копии сообщений, обрабатываемых этой привязкой.</summary>
        <value>Значение <see langword="true" />, если сообщения, обрабатываемые данной привязкой, копируются в очередь журнала источника; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложения в очереди, которым необходимо вести учет сообщений, покинувших очередь исходящих сообщений на исходном компьютере, могут копировать сообщения в очередь журнала. После того как сообщение покидает очередь исходящих сообщений и появляется подтверждение, что сообщение было принято конечным компьютером, в очереди системного журнала отправляющего компьютера сохраняется копия этого сообщения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidityDuration">
      <MemberSignature Language="C#" Value="public TimeSpan ValidityDuration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan ValidityDuration" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.MsmqBindingElementBase.ValidityDuration" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidityDuration As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan ValidityDuration { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.ValidityDuration : TimeSpan with get, set" Usage="System.ServiceModel.Configuration.MsmqBindingElementBase.ValidityDuration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceModel.Configuration.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Configuration.ConfigurationProperty("validityDuration", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Runtime.TimeSpanOrInfiniteConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее время ожидания соединения при работе с каналами, поставленными в очередь.</summary>
        <value>Время ожидания соединения при использовании с каналами в очереди.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Если в ходе транзакции для сообщения истекает срок <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ValidityDuration%2A>, то любая транзакция, используемая для его обработки, будет прервана вместе с экземпляром рабочего процесса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
