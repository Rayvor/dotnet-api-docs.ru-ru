<Type Name="GrammarBuilder" FullName="System.Speech.Recognition.GrammarBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e0d9bfa62675c9e59e6fa12e0bf36c839258e976" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69231353" /></Metadata><TypeSignature Language="C#" Value="public class GrammarBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GrammarBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.GrammarBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class GrammarBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class GrammarBuilder" />
  <TypeSignature Language="F#" Value="type GrammarBuilder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{DebugSummary}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет механизм для программного создания ограничений для грамматики распознавания речи.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Грамматики распознавания речи обычно создаются в формате XML, определенном в [спецификации грамматики распознавания речи (SRGS) версии 1,0](https://go.microsoft.com/fwlink/?LinkId=201761). Если вы знакомы с SRGS, но хотите создать грамматики программно, можно использовать <xref:System.Speech.Recognition.SrgsGrammar> пространство имен, члены которого близко соответствуют элементам и атрибутам, определенным в SRGS. Если вы не знакомы с SRGS или хотите использовать упрощенный, программный подход к созданию грамматик, с помощью которых можно эффективно выполнять многие распространенные сценарии; можно использовать <xref:System.Speech.Recognition.GrammarBuilder> классы и <xref:System.Speech.Recognition.Choices> .  
  
 Используйте <xref:System.Speech.Recognition.GrammarBuilder> объекты для создания иерархического дерева, состоящего из <xref:System.Speech.Recognition.Choices> объектов, содержащих альтернативные фразы, в том числе с помощью выражений преамбулы и POST-преамбул на каждом узле, а также начальных значений, которые передаются обратно в приклад.  
  
 <xref:System.Speech.Recognition.GrammarBuilder> Чтобы<xref:System.Speech.Recognition.Grammar> создать объект с помощью, выполните следующие действия.  
  
1.  Создание объекта <xref:System.Speech.Recognition.GrammarBuilder>.  
  
2.  Добавление ограничений <xref:System.Speech.Recognition.GrammarBuilder>к, таким как <xref:System.Speech.Recognition.Choices> <xref:System.String> <xref:System.Speech.Recognition.GrammarBuilder> объекты, <xref:System.Speech.Recognition.SemanticResultKey> <xref:System.Speech.Recognition.SemanticResultValue>, ,,идругиеобъекты,определяющиеограниченияграмматики.<xref:System.Speech.Recognition.DictationGrammar>  
  
3.  Используйте один из <xref:System.Speech.Recognition.Grammar.%23ctor%2A> конструкторов для <xref:System.Speech.Recognition.Grammar> создания объекта из завершенной <xref:System.Speech.Recognition.GrammarBuilder> грамматики.  
  
 Разработка с <xref:System.Speech.Recognition.GrammarBuilder> помощью лучше всего подходит для грамматики с одним правилом, содержащим списки, или, возможно, списки. Чтобы программно создать грамматики с несколькими правилами или ссылки на внутренние правила, используйте классы <xref:System.Speech.Recognition.SrgsGrammar> пространства имен.  
  
 Экземпляры также <xref:System.Speech.Recognition.GrammarBuilder> могут быть получены неявными преобразованиями из некоторых других классов или путем объединения со вторым объектом, который содержит ограничения для грамматики. <xref:System.Speech.Recognition.GrammarBuilder> Дополнительные сведения см. в <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> описании операторов <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> и <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> методов.  
  
 Чтобы добавить правила в существующую <xref:System.Speech.Recognition.GrammarBuilder>, <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>используйте методы, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>,, и <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> .  
  
> [!IMPORTANT]
>  Распознаватель речи может вызывать исключение при использовании грамматики распознавания речи, содержащей повторяющиеся семантические элементы с одинаковым именем ключа или несколькими семантическими элементами, которые могут периодически изменять значение одного и того же семантического элемента. 
  
 Чтобы упростить отладку, <xref:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases%2A> свойство возвращает текущее состояние в <xref:System.Speech.Recognition.GrammarBuilder> виде строки.  
  
 Дополнительные сведения о создании и использовании грамматик распознавания речи см. в разделе [Распознавание речи](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) и [Создание грамматик граммарбуилдер](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
   
  
## Examples  
 В следующем примере используются <xref:System.Speech.Recognition.GrammarBuilder> объекты <xref:System.Speech.Recognition.Choices> и для создания грамматики, которая может распознать любую из двух фраз: «make Background *колорчоице*» или «Set Background to *колорчоице*».  
  
 В примере используется <xref:System.Speech.Recognition.Choices> объект для создания списка допустимых значений для *колорчоице* <xref:System.String> из массива объектов. Объект является аналогом `one-of` элемента в спецификации SRGS и содержит набор альтернативных фраз, любой из которых можно распознать при разговоре. <xref:System.Speech.Recognition.Choices> В примере также используется <xref:System.Speech.Recognition.Choices> объект для группирования массива из двух <xref:System.Speech.Recognition.GrammarBuilder> объектов в пару альтернативных фраз, которые может распознать результирующая грамматика. Альтернативные слова или фразы являются компонентом большинства грамматик, а <xref:System.Speech.Recognition.Choices> объект предоставляет эту функцию для грамматик, созданных с помощью. <xref:System.Speech.Recognition.GrammarBuilder>  
  
 В примере наконец создается <xref:System.Speech.Recognition.Grammar> объект из, <xref:System.Speech.Recognition.GrammarBuilder> созданного на основе <xref:System.Speech.Recognition.Choices> объекта.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.Choices" />
    <altmember cref="T:System.Speech.Recognition.Grammar" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляры этого класса также могут быть получены неявными преобразованиями из других классов или путем <xref:System.Speech.Recognition.GrammarBuilder> объединения объекта со вторым объектом в новый. <xref:System.Speech.Recognition.GrammarBuilder> Дополнительные сведения см. в <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> описании методов и. <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>  
  
 Чтобы добавить ограничения к существующему <xref:System.Speech.Recognition.GrammarBuilder>, <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>используйте <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A> методы<xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> , <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>,, и, а также <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> оператор.  
  
> [!IMPORTANT]
>  Распознаватель речи может вызывать исключение при использовании грамматики распознавания речи, содержащей повторяющиеся семантические элементы с одинаковым именем ключа или несколькими семантическими элементами, которые могут периодически изменять значение одного и того же семантического элемента.
  
 Дополнительные сведения о создании и использовании грамматик распознавания речи см. в разделе [Распознавание речи](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) и [Создание грамматик граммарбуилдер](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый пустой экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы добавить правила в существующий <xref:System.Speech.Recognition.GrammarBuilder> объект, <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>используйте <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A> методы<xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> ,,, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>и, а также <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> оператор.  
  
> [!IMPORTANT]
>  Распознаватель речи может вызывать исключение при использовании грамматики распознавания речи, содержащей повторяющиеся семантические элементы с одинаковым именем ключа или несколькими семантическими элементами, которые могут периодически изменять значение одного и того же семантического элемента.
  
   
  
## Examples  
 В следующем примере используются <xref:System.Speech.Recognition.GrammarBuilder> объекты <xref:System.Speech.Recognition.Choices> и для создания грамматики, которая может распознать любую из двух фраз: «make Background *колорчоице*» или «Set Background to *колорчоице*».  
  
 В примере используется <xref:System.Speech.Recognition.Choices> объект для создания списка допустимых значений для *колорчоице* <xref:System.String> из массива объектов. Объект является аналогом `one-of` элемента в спецификации SRGS и содержит набор альтернативных фраз, любой из которых можно распознать при разговоре. <xref:System.Speech.Recognition.Choices> В примере также используется <xref:System.Speech.Recognition.Choices> объект для группирования массива из двух <xref:System.Speech.Recognition.GrammarBuilder> объектов в пару альтернативных фраз, которые может распознать результирующая грамматика. Альтернативные слова или фразы являются компонентом большинства грамматик, а <xref:System.Speech.Recognition.Choices> объект предоставляет эту функцию для грамматик, созданных с помощью. <xref:System.Speech.Recognition.GrammarBuilder>  
  
 В примере наконец создается <xref:System.Speech.Recognition.Grammar> объект из, <xref:System.Speech.Recognition.GrammarBuilder> созданного на основе <xref:System.Speech.Recognition.Choices> объекта.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  GrammarBuilder bothPhrases = new GrammarBuilder();  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  bothPhrases.Append(bothChoices);  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder alternateChoices" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">Набор вариантов.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" /> из набора объектов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о создании грамматики распознавания речи, содержащей альтернативные варианты, см. в разделе [Использование вариантов для создания грамматики граммарбуилдер](https://msdn.microsoft.com/library/5b18db18-a5f6-46a3-aa77-6d3141544efd).  
  
   
  
## Examples  
 В следующем примере используются <xref:System.Speech.Recognition.GrammarBuilder> объекты <xref:System.Speech.Recognition.Choices> и для создания грамматики, которая может распознать любую из двух фраз: «make Background *колорчоице*» или «Set Background to *колорчоице*».  
  
 В примере используется <xref:System.Speech.Recognition.Choices> объект для создания списка допустимых значений для *колорчоице* <xref:System.String> из массива объектов. Объект является аналогом `one-of` элемента в спецификации SRGS и содержит набор альтернативных фраз, любой из которых можно распознать при разговоре. <xref:System.Speech.Recognition.Choices> В примере также используется <xref:System.Speech.Recognition.Choices> объект для группирования массива из двух <xref:System.Speech.Recognition.GrammarBuilder> объектов в пару альтернативных фраз, которые может распознать результирующая грамматика. Альтернативные слова или фразы являются компонентом большинства грамматик, а <xref:System.Speech.Recognition.Choices> объект предоставляет эту функцию для грамматик, созданных с помощью. <xref:System.Speech.Recognition.GrammarBuilder>  
  
 В примере наконец создается <xref:System.Speech.Recognition.Grammar> объект из, <xref:System.Speech.Recognition.GrammarBuilder> созданного на основе <xref:System.Speech.Recognition.Choices> объекта.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder key" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">Семантический ключ.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" /> из семантического ключа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При создании <xref:System.Speech.Recognition.GrammarBuilder> экземпляра <xref:System.Speech.Recognition.SemanticResultValue> из объекта в грамматику добавляются семантические сведения, которые могут быть возвращены в результате распознавания. Вы можете получить доступ к семантическим сведениям в результатах распознавания <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> , используя <xref:System.Speech.Recognition.RecognizedPhrase>свойство объекта, которое доступно `SpeechRecognized` в обработчике события. Если объект <xref:System.Speech.Recognition.GrammarBuilder> <xref:System.Speech.Recognition.SemanticResultKey>определяет, он может использоваться для получения семантической информации в результате распознавания, связанного с ключом. См. пример для <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>, а также см <xref:System.Speech.Recognition.SemanticResultValue> . <xref:System.Speech.Recognition.SemanticResultKey>раздел и.  
  
> [!IMPORTANT]
>  При создании <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> экземпляры или <xref:System.Speech.Recognition.SemanticResultKey> , убедитесь, что вы не создаете повторяющиеся семантические элементы с одинаковым именем ключа или <xref:System.Speech.Recognition.SemanticValue.Value%2A> несколькими семантическими элементами, которые могут периодически изменять <xref:System.Speech.Recognition.SemanticValue> свойство объекта. Распознаватель речи может вызвать исключение, если в них возникают такие обстоятельства. 
  
   
  
## Examples  
 В следующем примере создается Грамматика распознавания речи, которая может распознать две фразы: «make Background *колорчоице*» и «Set Background to *колорчоице*», где *колорчоице* выбирается из набора цветов. Грамматика позволяет пользователю поговорить с любым из нескольких имен цветов и Возвращает семантическую информацию о распознанном имени цвета для приложения.  
  
 В примере используется один <xref:System.Speech.Recognition.SemanticResultKey> объект, с помощью которого можно получить объект <xref:System.Speech.Recognition.SemanticValue> , связанный с цветом, произнесенным пользователем. Например, если вход содержит фразу «установить фон в красный цвет», результат распознавания будет содержать семантическое значение «#FF0000», которое можно получить с помощью обработчика для `SpeechRecognized` события.  
  
 В примере используются <xref:System.String> <xref:System.Speech.Recognition.Choices> <xref:System.Speech.Recognition.GrammarBuilder> объекты, <xref:System.Speech.Recognition.SemanticResultKey> ,<xref:System.Speech.Recognition.SemanticResultValue>, и <xref:System.Speech.Recognition.GrammarBuilder> для построения ограничений, содержащихся в последнем объекте. `bothPhrases` Наконец, в примере создается <xref:System.Speech.Recognition.Grammar> объект из завершенного. <xref:System.Speech.Recognition.GrammarBuilder>  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices object for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the Grammar object from the GrammarBuilder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">Семантическое значение или пара имя-значение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" /> из семантического значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При создании <xref:System.Speech.Recognition.GrammarBuilder> экземпляра <xref:System.Speech.Recognition.SemanticResultValue> из объекта в грамматику добавляются семантические сведения, которые могут быть возвращены в результате распознавания. Вы можете получить доступ к семантическим сведениям в результатах распознавания <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> , используя <xref:System.Speech.Recognition.RecognizedPhrase>свойство объекта, которое доступно `SpeechRecognized` в обработчике события. Если объект <xref:System.Speech.Recognition.GrammarBuilder> <xref:System.Speech.Recognition.SemanticResultKey>определяет, он может использоваться для получения семантической информации в результате распознавания, связанного с ключом. См. пример для <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>, а также см <xref:System.Speech.Recognition.SemanticResultValue> . <xref:System.Speech.Recognition.SemanticResultKey>раздел и.  
  
> [!IMPORTANT]
>  При создании <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> экземпляры или <xref:System.Speech.Recognition.SemanticResultKey> , убедитесь, что вы не создаете повторяющиеся семантические элементы с одинаковым именем ключа или <xref:System.Speech.Recognition.SemanticValue.Value%2A> несколькими семантическими элементами, которые могут периодически изменять <xref:System.Speech.Recognition.SemanticValue> свойство объекта. Распознаватель речи может вызвать исключение, если в них возникают такие обстоятельства. 
  
   
  
## Examples  
 В следующем примере создается Грамматика распознавания речи, которая может распознать две фразы: «make Background *колорчоице*» и «Set Background to *колорчоице*», где *колорчоице* выбирается из набора цветов. Грамматика позволяет пользователю поговорить с любым из нескольких имен цветов и Возвращает семантическую информацию о распознанном имени цвета для приложения.  
  
 В примере используется один <xref:System.Speech.Recognition.SemanticResultKey> объект, с помощью которого можно получить объект <xref:System.Speech.Recognition.SemanticValue> , связанный с цветом, произнесенным пользователем. Например, если вход содержит фразу «установить фон в красный цвет», результат распознавания будет содержать семантическое значение «#FF0000», которое можно получить с помощью обработчика для `SpeechRecognized` события.  
  
 В примере используются <xref:System.String> <xref:System.Speech.Recognition.Choices> <xref:System.Speech.Recognition.GrammarBuilder> объекты, <xref:System.Speech.Recognition.SemanticResultKey> ,<xref:System.Speech.Recognition.SemanticResultValue>, и <xref:System.Speech.Recognition.GrammarBuilder> для построения ограничений, содержащихся в последнем объекте. `bothPhrases` Наконец, в примере создается <xref:System.Speech.Recognition.Grammar> объект из завершенного. <xref:System.Speech.Recognition.GrammarBuilder>  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the grammar from the grammar builder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder phrase" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Последовательность слов.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" /> из последовательности слов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фраза представляет собой точную голосовую фразу, которую может распознать Грамматика распознавания речи. Дополнительные сведения о создании грамматики распознавания речи, содержащей строки, см. [в разделе Использование строк для создания грамматики граммарбуилдер](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 В следующем примере используются <xref:System.Speech.Recognition.GrammarBuilder> объекты <xref:System.Speech.Recognition.Choices> и для создания грамматики, которая может распознать любую из двух фраз: «make Background *колорчоице*» или «Set Background to *колорчоице*».  
  
 После создания списка допустимых значений для *колорчоице* с <xref:System.Speech.Recognition.Choices> помощью объекта в примере инициализируются два <xref:System.Speech.Recognition.GrammarBuilder> объекта, `makePhrase` а `setPhrase`в качестве аргумента используется строка.  
  
 В примере наконец создается <xref:System.Speech.Recognition.Grammar> объект <xref:System.Speech.Recognition.Choices> из объекта, приведенного к <xref:System.Speech.Recognition.GrammarBuilder> объекту.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * System.Speech.Recognition.SubsetMatchingMode -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, subsetMatchingCriteria)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">Последовательность слов.</param>
        <param name="subsetMatchingCriteria">Соответствующий режим, используемый грамматикой распознавания речи для распознавания фразы.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для подмножества последовательности слов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase` Параметр представляет фразу, которую может распознать Грамматика распознавания речи. `subsetMatchingMode` Параметр указывает подмножество фразы, с помощью которых можно получить успешное распознавание всей фразы. С помощью этого параметра можно создать грамматику со списком записей с длинными именами, не требуя от пользователя говорить о полном имени в соответствии с элементом.  
  
 Дополнительные сведения о режимах сопоставления см. в <xref:System.Speech.Recognition.SubsetMatchingMode>разделе. Дополнительные сведения о создании грамматики распознавания речи, содержащей строки, см. [в разделе Использование строк для создания грамматики граммарбуилдер](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 В следующем примере создается Грамматика распознавания речи для каждого <xref:System.Speech.Recognition.SubsetMatchingMode> значения и грамматики для выбора между грамматикой режима сопоставления. Если значение `phrase` равно "1 2 3 4 5 6 7", то грамматика подпоследовательности распознает входные данные "2 3 4", но не входные данные "1 3 5". Однако грамматика упорядоченного подмножества распознает оба этих входа.  
  
```csharp  
  
private static IEnumerable<Grammar>  
  CreateMatchingModeGrammars(string phrase)  
{  
  List<Grammar> grammars = new List<Grammar>(5);  
  
  Choices modeChoice = new Choices();  
  Type enumType = typeof(SubsetMatchingMode);  
  foreach (SubsetMatchingMode mode in Enum.GetValues(enumType))  
  {  
    string modeName = Enum.GetName(enumType, mode);  
    modeName = BreakAtCaps(modeName);  
  
    GrammarBuilder builder = new GrammarBuilder(phrase, mode);  
    Grammar modeGrammar = new Grammar(builder);  
    modeGrammar.Name = modeName;  
    modeGrammar.Enabled = false;  
    grammars.Add(modeGrammar);  
  
    modeChoice.Add(modeName);  
  }  
  
  Grammar choiceGrammar = new Grammar(modeChoice);  
  choiceGrammar.Name = "choice";  
  grammars.Add(choiceGrammar);  
  
  return grammars;  
}  
  
// Insert spaces preceding each uppercase letter in a string.   
private static string BreakAtCaps(string item)  
{  
  if (item == null || item.Length == 0)  
  {  
    return item;  
  }  
  
  StringBuilder sb = new StringBuilder(item[0].ToString());  
  for (int i = 1; i < item.Length; i++)  
  {  
    char c = item[i];  
    if (char.IsUpper(c))  
    {  
      sb.Append(" ");  
    }  
    sb.Append(c);  
  }  
  
  return sb.ToString();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.SubsetMatchingMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.GrammarBuilder * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (builder, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">Повторяющийся элемент.</param>
        <param name="minRepeat">Минимальное количество сопоставлений входных данных элементу, определенному в <paramref name="builder" />, при котором засчитывается совпадение.</param>
        <param name="maxRepeat">Максимальное количество сопоставлений входных данных элементу, определенному в <paramref name="builder" />, при котором засчитывается совпадение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" /> из повторяющегося элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение `minRepeat` равно 0, то New <xref:System.Speech.Recognition.GrammarBuilder> представляет необязательный элемент.  
  
 Значение `minRepeat` должно быть больше или равно 0 и меньше или равно `maxRepeat`значению.  
  
> [!IMPORTANT]
>  При указании REPEAT для <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> экземпляры или <xref:System.Speech.Recognition.SemanticResultKey> , следует избегать создания повторяющихся семантических элементов с одинаковым именем ключа или несколькими семантическими элементами, которые могут периодически изменять <xref:System.Speech.Recognition.SemanticValue.Value%2A> свойство объекта.<xref:System.Speech.Recognition.SemanticValue> Распознаватель речи может вызвать исключение, если в них возникают такие обстоятельства. 
  
   
  
## Examples  
 В следующем примере создается Грамматика распознавания речи для упорядочивания пиццы. Он начинается с необязательной, открывающей фразы, от одной до четырех наследов и закрывается словом «пицца».  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object from a string array of alternative toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">Повторяющаяся последовательность слов.</param>
        <param name="minRepeat">Минимальное количество сопоставлений входной фразы, при котором засчитывается совпадение.</param>
        <param name="maxRepeat">Максимальное количество сопоставлений входной фразы, при котором засчитывается совпадение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Speech.Recognition.GrammarBuilder" /> из последовательности слов в <see cref="T:System.String" /> и определяет, сколько раз можно повторить <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение `minRepeat` равно 0, то New <xref:System.Speech.Recognition.GrammarBuilder> представляет необязательный элемент.  
  
 Значение `minRepeat` должно быть больше или равно 0 и меньше или равно `maxRepeat`значению. Дополнительные сведения о создании грамматики распознавания речи, содержащей строки, см. [в разделе Использование строк для создания грамматики граммарбуилдер](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 В следующем примере создается Грамматика распознавания речи для упорядочивания пиццы. Он начинается с необязательной, открывающей фразы, от одной до четырех наследов и закрывается словом «пицца».  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий последовательность из двух элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статические <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> методы предоставляют еще один механизм, с помощью которого можно комбинировать различные типы для создания разнородности и гибкости в <xref:System.Speech.Recognition.GrammarBuilder>грамматиках, построенных с помощью. Эти методы соответствуют статическим <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> методам, которые также определены <xref:System.Speech.Recognition.GrammarBuilder> в классе. Порядок параметров определяет порядок элементов в новом <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 <xref:System.Speech.Recognition.Choices> <xref:System.Speech.Recognition.SemanticResultKey> [](https://go.microsoft.com/fwlink/?LinkId=159733) Можно также получить из строковых объектов,, <xref:System.Speech.Recognition.SemanticResultValue>и. <xref:System.Speech.Recognition.GrammarBuilder> Дополнительные сведения см. в <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> разделе операторы и. <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>  
  
> [!IMPORTANT]
>  Распознаватель речи может вызывать исключение при использовании грамматики распознавания речи, содержащей повторяющиеся семантические элементы с одинаковым именем ключа или несколькими семантическими элементами, которые могут периодически изменять значение одного и того же семантического элемента. 
  
 Дополнительные сведения о создании и использовании грамматик распознавания речи см. в разделе [Распознавание речи](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) и [Создание грамматик граммарбуилдер](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (choices, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">Первый элемент grammar, представляющий набор альтернатив.</param>
        <param name="builder">Второй элемент grammar.</param>
        <summary>Создает элемент <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий объект <see cref="T:System.Speech.Recognition.Choices" />, за которым следует объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Объект <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности элементов <paramref name="choices" />, за которой следует элемент <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>поддерживает неявные преобразования из следующих классов:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает перечисленные выше объекты для `builder` параметра.  
  
 Дополнительные сведения см. в <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> разделе операторы и. <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>  
  
> [!IMPORTANT]
>  При объединении <xref:System.Speech.Recognition.Choices> объектов <xref:System.Speech.Recognition.GrammarBuilder> и, содержащих <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> , следует избегать создания повторяющихся семантических элементов с одинаковым именем ключа или несколькими семантическими элементами, которые могут периодически изменять <xref:System.Speech.Recognition.SemanticValue.Value%2A> свойство объекта.<xref:System.Speech.Recognition.SemanticValue> Распознаватель речи может вызвать исключение, если в них возникают такие обстоятельства. Дополнительные сведения о создании грамматики распознавания речи, содержащей семантическую информацию, см. в разделе [Добавление семантики в грамматику граммарбуилдер](https://msdn.microsoft.com/library/hh361581.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, choices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">Первый элемент грамматики.</param>
        <param name="choices">Второй элемент грамматики, который представляет набор вариантов.</param>
        <summary>Создает элемент <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, за которым следует объект <see cref="T:System.Speech.Recognition.Choices" />.</summary>
        <returns>Объект <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности элементов <paramref name="builder" />, за которой следует элемент <paramref name="choices" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>поддерживает неявные преобразования из следующих классов:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает перечисленные выше объекты для `builder` параметра.  
  
 Дополнительные сведения см. в <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> разделе операторы и. <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>  
  
> [!IMPORTANT]
>  При объединении <xref:System.Speech.Recognition.Choices> объектов <xref:System.Speech.Recognition.GrammarBuilder> и, содержащих <xref:System.Speech.Recognition.SemanticResultValue> экземпляры <xref:System.Speech.Recognition.SemanticResultKey> или с другими элементами грамматики, следует избегать создания повторяющихся семантических элементов с одинаковым именем ключа или несколькими семантическими элементами, которые может периодически изменять <xref:System.Speech.Recognition.SemanticValue.Value%2A> свойство <xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может вызвать исключение, если в них возникают такие обстоятельства. 
  
   
  
## Examples  
 В следующем примере создается Грамматика распознавания речи, которая может распознать две фразы: «создать *Цвет*фона» и «задать фон до *цвета*», где *Цвет* выбирается из набора цветов. Для создания окончательной грамматики, например [строк](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>и <xref:System.Speech.Recognition.GrammarBuilder> объектов, используются различные типы. Операторы явного приведения в вызовах <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> методов являются необязательными.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder1, builder2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">Первый элемент грамматики.</param>
        <param name="builder2">Второй элемент grammar.</param>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий последовательность из двух объектов <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Объект <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности элементов <paramref name="builder1" />, за которой следует элемент <paramref name="builder2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>поддерживает неявные преобразования из следующих классов:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает перечисленные выше объекты для `builder1` параметра или. `builder2`  
  
 Дополнительные сведения см. в <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> разделе операторы и. <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>  
  
> [!IMPORTANT]
>  При объединении <xref:System.Speech.Recognition.Choices> объектов <xref:System.Speech.Recognition.GrammarBuilder> и, содержащих <xref:System.Speech.Recognition.SemanticResultValue> экземпляры <xref:System.Speech.Recognition.SemanticResultKey> или с другими элементами грамматики, следует избегать создания повторяющихся семантических элементов с одинаковым именем ключа или несколькими семантическими элементами, которые может периодически изменять <xref:System.Speech.Recognition.SemanticValue.Value%2A> свойство <xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может вызвать исключение, если в них возникают такие обстоятельства. 
  
   
  
## Examples  
 В следующем примере создается Грамматика распознавания речи, которая может распознать две фразы: «создать *Цвет*фона» и «задать фон до *цвета*», где *Цвет* выбирается из набора цветов. Для создания окончательной грамматики, например [строк](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>и <xref:System.Speech.Recognition.GrammarBuilder> объектов, используются различные типы. Операторы явного приведения в вызовах <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> методов являются необязательными.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, phrase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">Первый элемент грамматики.</param>
        <param name="phrase">Второй элемент грамматики, который представляет последовательность слов.</param>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, после которого следует фраза.</summary>
        <returns>Объект <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности элементов <paramref name="builder" />, за которой следует элемент <paramref name="phrase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>поддерживает неявные преобразования из следующих классов:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает перечисленные выше объекты для `builder` параметра.  
  
 Дополнительные сведения см. в <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> разделе операторы и. <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>  
  
   
  
## Examples  
 В следующем примере создается Грамматика распознавания речи, которая может распознать две фразы: «создать *Цвет*фона» и «задать фон до *цвета*», где *Цвет* выбирается из набора цветов. Для создания окончательной грамматики, например [строк](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>и <xref:System.Speech.Recognition.GrammarBuilder> объектов, используются различные типы. Операторы явного приведения в вызовах <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> методов являются необязательными.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (phrase, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">Первый элемент грамматики, который представляет последовательность слов.</param>
        <param name="builder">Второй элемент grammar.</param>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий фразу, после которой следует объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Объект <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности элементов <paramref name="phrase" />, за которой следует элемент <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>поддерживает неявные преобразования из следующих классов:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает перечисленные выше объекты для `builder` параметра.  
  
 Дополнительные сведения см. в <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> разделе операторы и. <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A>  
  
   
  
## Examples  
 В следующем примере создается Грамматика распознавания речи, которая может распознать две фразы: «создать *Цвет*фона» и «задать фон до *цвета*», где *Цвет* выбирается из набора цветов. Для создания окончательной грамматики, например [строк](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>и <xref:System.Speech.Recognition.GrammarBuilder> объектов, используются различные типы. Операторы явного приведения в вызовах <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> методов являются необязательными.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет элемент грамматики к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эти методы, чтобы присоединить элементы грамматики <xref:System.Speech.Recognition.GrammarBuilder>к существующему. При создании элементов грамматики их можно добавить к существующему построителю, чтобы поочередно разрабатывать ограничения для грамматики распознавания речи. Каждый элемент добавляется в конец текущей последовательности элементов.  
  
 <xref:System.Speech.Recognition.GrammarBuilder>Этот метод имеет перегрузки для добавления объектов <xref:System.Speech.Recognition.Choices>, <xref:System.String> <xref:System.Speech.Recognition.SemanticResultKey>,, и <xref:System.Speech.Recognition.SemanticResultValue> .  
  
> [!IMPORTANT]
>  Распознаватель речи может вызывать исключение при использовании грамматики распознавания речи, содержащей повторяющиеся семантические элементы с одинаковым именем ключа или несколькими семантическими элементами, которые могут периодически изменять значение одного и того же семантического элемента. 
  
 Дополнительные сведения о создании и использовании грамматик распознавания речи см. в разделе [Распознавание речи](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) и [Создание грамматик граммарбуилдер](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.Choices -&gt; unit" Usage="grammarBuilder.Append alternateChoices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">Набор вариантов для добавления.</param>
        <summary>Добавляет набор альтернатив к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `alternateChoices`добавляется в конец текущей последовательности элементов.  
  
> [!IMPORTANT]
>  При добавлении <xref:System.Speech.Recognition.Choices> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> экземпляры или <xref:System.Speech.Recognition.SemanticResultKey> , в <xref:System.Speech.Recognition.GrammarBuilder> объект следует избегать создания повторяющихся семантических элементов с одинаковым именем ключа или несколькими семантическими элементами, которые могут повторяться. <xref:System.Speech.Recognition.SemanticValue.Value%2A> измените свойство<xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может вызвать исключение, если в них возникают такие обстоятельства.
  
   
  
## Examples  
 В следующем примере создается Грамматика распознавания речи для таких фраз, как "позвонить в Джеймс at" и "вызвать Anne на своем сотовом телефоне", где слово "Phone" является необязательным. В примере демонстрируется использование <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> метода.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder -&gt; unit" Usage="grammarBuilder.Append builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">Элемент грамматики для добавления.</param>
        <summary>Добавляет элемент грамматики к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `builder`добавляется в конец текущей последовательности элементов грамматики.  
  
> [!NOTE]
>  При добавлении <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> экземпляры или <xref:System.Speech.Recognition.SemanticResultKey> , в <xref:System.Speech.Recognition.GrammarBuilder> объект следует избегать создания повторяющихся семантических элементов с одинаковым именем ключа или несколькими семантическими элементами, которые могут повторяться. <xref:System.Speech.Recognition.SemanticValue.Value%2A> измените свойство<xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может вызвать исключение, если в них возникают такие обстоятельства. 
  
   
  
## Examples  
 В следующем примере создается Грамматика распознавания речи для таких фраз, как "позвонить в Джеймс at" и "вызвать Anne на своем сотовом телефоне", где слово "Phone" является необязательным. <xref:System.Speech.Recognition.GrammarBuilder>объекты <xref:System.Speech.Recognition.Choices> и используются для создания грамматики. В примере демонстрируется использование <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> метода.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultKey -&gt; unit" Usage="grammarBuilder.Append key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">Семантический ключ для добавления.</param>
        <summary>Добавляет семантический ключ к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `key`добавляется в конец текущей последовательности элементов.  
  
> [!IMPORTANT]
>  При добавлении <xref:System.Speech.Recognition.SemanticResultValue> <xref:System.Speech.Recognition.GrammarBuilder> объектов или <xref:System.Speech.Recognition.SemanticResultKey> к объекту следует избегать создания повторяющихся семантических элементов с одинаковым именем ключа или <xref:System.Speech.Recognition.SemanticValue.Value%2A> несколькими семантическими элементами, которые могут периодически изменять свойство элемента <xref:System.Speech.Recognition.SemanticValue> объект. Распознаватель речи может вызвать исключение, если в них возникают такие обстоятельства.
  
   
  
## Examples  
 Следующий пример является частью консольного приложения для выбора исходных и целевых городов для рейса. Приложение распознает такие фразы, как «я хочу полета из Майами в Чикаго». Обработчик <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> события <xref:System.Speech.Recognition.SemanticResultValue> использует для извлечения кода аэропорта, указанного в, для исходных и целевых городов. <xref:System.Speech.Recognition.SemanticResultKey>  
  
```csharp  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create a Choices object and add  cities and airport codes  
        // using SemanticResultValue objects.  
        Choices cities = new Choices();  
        cities.Add(new SemanticResultValue("Chicago", "ORD"));  
        cities.Add(new SemanticResultValue("Boston", "BOS"));  
        cities.Add(new SemanticResultValue("Miami", "MIA"));  
        cities.Add(new SemanticResultValue("Dallas", "DFW"));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultValue -&gt; unit" Usage="grammarBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">Прибавляемое семантическое значение.</param>
        <summary>Добавляет семантическое значение к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`добавляется в конец текущей последовательности элементов.  
  
> [!IMPORTANT]
>  При добавлении <xref:System.Speech.Recognition.SemanticResultValue> <xref:System.Speech.Recognition.GrammarBuilder> объектов или <xref:System.Speech.Recognition.SemanticResultKey> к объекту следует избегать создания повторяющихся семантических элементов с одинаковым именем ключа или <xref:System.Speech.Recognition.SemanticValue.Value%2A> несколькими семантическими элементами, которые могут периодически изменять свойство элемента <xref:System.Speech.Recognition.SemanticValue> объект. Распознаватель речи может вызвать исключение, если в них возникают такие обстоятельства.
  
   
  
## Examples  
 Следующий пример является частью консольного приложения для выбора исходных и целевых городов для рейса. Приложение распознает такие фразы, как «я хочу полета из Майами в Чикаго». Обработчик <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> события <xref:System.Speech.Recognition.SemanticResultValue> использует для извлечения кода аэропорта, указанного в, для исходных и целевых городов. <xref:System.Speech.Recognition.SemanticResultKey>  
  
```csharp  
  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create GrammarBuilder objects and append SemanticResultValue objects   
        // that contain cities and airport codes.  
  
        GrammarBuilder chicago = new GrammarBuilder();  
        chicago.Append(new SemanticResultValue("Chicago", "ORD"));  
  
        GrammarBuilder boston = new GrammarBuilder();  
        boston.Append(new SemanticResultValue("Boston", "BOS"));  
  
        GrammarBuilder miami = new GrammarBuilder();  
        miami.Append(new SemanticResultValue("Miami", "MIA"));  
  
        GrammarBuilder dallas = new GrammarBuilder();  
        dallas.Append(new SemanticResultValue("Dallas", "DFW"));  
  
        // Create a Choices object and add the cities using implicit conversion from   
        // SemanticResultValue to GrammarBuilder.  
        Choices cities = new Choices();  
        cities.Add(new Choices(new GrammarBuilder[] { chicago, boston, miami, dallas }));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; unit" Usage="grammarBuilder.Append phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Последовательность слов для добавления.</param>
        <summary>Добавляет фразу к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase`добавляется в конец текущей последовательности элементов.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="member this.Append : string * System.Speech.Recognition.SubsetMatchingMode -&gt; unit" Usage="grammarBuilder.Append (phrase, subsetMatchingCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">Последовательность слов для добавления.</param>
        <param name="subsetMatchingCriteria">Соответствующий режим, используемый грамматикой для распознавания фразы.</param>
        <summary>Добавляет элемент для подмножества фразы к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элемент подмножества добавляется в конец текущей последовательности элементов. Дополнительные сведения о создании грамматики распознавания речи с помощью строк см. [в разделе Использование строк для создания грамматики граммарбуилдер](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
 Подробные сведения об использовании режимов сопоставления подмножеств см. в разделе <xref:System.Speech.Recognition.SubsetMatchingMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере создается Грамматика распознавания речи для каждого <xref:System.Speech.Recognition.SubsetMatchingMode> значения. Например, созданная грамматика `OrderedSubset` распознает фразы «3 4 5» и «1 3 5», и грамматика `Subsequence` распознает фразу «3 4 5», но не фразу «1 3 5».  
  
```csharp  
  
private Grammar[] CreateSubsetMatchTest()  
{  
  List<Grammar> grammars = new List<Grammar>(4);  
  
  string phrase = "one two three four five six";  
  foreach (SubsetMatchingMode mode in  
    Enum.GetValues(typeof(SubsetMatchingMode)))  
  {  
    GrammarBuilder gb = new GrammarBuilder();  
    gb.Append(phrase, mode);  
  
    Grammar grammar = new Grammar(gb);  
    grammar.Name = mode.ToString();  
    grammars.Add(grammar);  
  }  
  
  return grammars.ToArray();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder * int * int -&gt; unit" Usage="grammarBuilder.Append (builder, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">Повторяющийся элемент грамматики для добавления.</param>
        <param name="minRepeat">Минимальное количество сопоставлений входных данных элементу, определенному в <paramref name="builder" />, при котором засчитывается совпадение.</param>
        <param name="maxRepeat">Максимальное количество сопоставлений входных данных элементу, определенному в <paramref name="builder" />, при котором засчитывается совпадение.</param>
        <summary>Добавляет повторный элемент грамматики к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение `minRepeat` должно быть больше или равно 0 и меньше или равно `maxRepeat`значению.  
  
> [!IMPORTANT]
>  При добавлении <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> экземпляры или <xref:System.Speech.Recognition.SemanticResultKey> , в <xref:System.Speech.Recognition.GrammarBuilder> объект следует избегать создания повторяющихся семантических элементов с одинаковым именем ключа или несколькими семантическими элементами, которые могут повторяться. <xref:System.Speech.Recognition.SemanticValue.Value%2A> измените свойство<xref:System.Speech.Recognition.SemanticValue> объекта. Распознаватель речи может вызвать исключение, если в них возникают такие обстоятельства.
  
   
  
## Examples  
 В следующем примере создается Грамматика распознавания речи для таких фраз, как "позвонить в Джеймс at" и "вызвать Anne на своем сотовом телефоне", где слово "Phone" является необязательным. <xref:System.Speech.Recognition.GrammarBuilder>объекты <xref:System.Speech.Recognition.Choices> и используются для создания грамматики. В примере демонстрируется использование <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> метода.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; unit" Usage="grammarBuilder.Append (phrase, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">Повторяющаяся последовательность слов для добавления.</param>
        <param name="minRepeat">Минимальное количество сопоставлений входных данных <paramref name="phrase" />, при котором засчитывается совпадение.</param>
        <param name="maxRepeat">Максимальное количество сопоставлений входных данных <paramref name="phrase" />, при котором засчитывается совпадение.</param>
        <summary>Добавляет повторную фразу к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение `minRepeat` должно быть больше или равно 0 и меньше или равно `maxRepeat`значению.  
  
   
  
## Examples  
 В следующем примере создается Грамматика распознавания речи для таких фраз, как "позвонить в Джеймс at" и "вызвать Anne на своем сотовом телефоне", где слово "Phone" является необязательным. <xref:System.Speech.Recognition.GrammarBuilder>объекты <xref:System.Speech.Recognition.Choices> и используются для создания грамматики. В примере демонстрируется использование <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> метода.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendDictation">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет грамматику диктовки к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы позволяют добавлять грамматику диктовки в качестве правила <xref:System.Speech.Recognition.GrammarBuilder>в. <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>  
  
 Дополнительные сведения о грамматиках диктовки см. в <xref:System.Speech.Recognition.DictationGrammar>разделе.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation();" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : unit -&gt; unit" Usage="grammarBuilder.AppendDictation " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Добавляет грамматику диктовки по умолчанию к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о грамматиках диктовки см. в <xref:System.Speech.Recognition.DictationGrammar>разделе.  
  
   
  
## Examples  
 В следующем примере создается Грамматика распознавания речи, включающая диктовку.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation();  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation (string category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation(string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation (category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation(System::String ^ category);" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : string -&gt; unit" Usage="grammarBuilder.AppendDictation category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="category">Категория грамматики диктовки для добавления.</param>
        <summary>Добавляет указанную грамматику диктовки к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы использовать грамматику диктовки, присвойте `category` параметру значение `spelling`.  
  
 Дополнительные сведения о грамматиках диктовки см. в <xref:System.Speech.Recognition.DictationGrammar>разделе.  
  
   
  
## Examples  
 В следующем примере создается Грамматика распознавания речи, которая включает грамматические правила диктовки орфографии.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation("spelling");  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendRuleReference">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет файл грамматики или правило грамматики к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> Методы могут добавлять файл грамматики или грамматическое правило из файла. Эти методы позволяют приложениям использовать предварительно развернутые или общедоступные грамматические правила. Приложение должно иметь доступ на чтение к расположению указанных файлов грамматики.  
  
 Эти методы могут читать грамматику распознавания речи в следующих форматах.  
  
-   XML-файлы форматирования, соответствующие [спецификации грамматики распознавания речи W3C (SRGS), версия 1,0](https://go.microsoft.com/fwlink/?LinkId=201761)  
  
-   Двоичные файлы, соответствующие грамматике в двоичном формате для распознавания речи Майкрософт (расширение файла. cfg)  
  
 Компиляция файла грамматики XML-формата в двоичный файл грамматики с расширением CFG может сократить время, затраченное на поиск совпадения, особенно если для грамматики требуется распознавание большого количества слов и фраз. Дополнительные сведения о компиляции грамматики SRGS в двоичный формат CFG см. в <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler>разделе.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string -&gt; unit" Usage="grammarBuilder.AppendRuleReference path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь или универсальный идентификатор ресурса (URI) файла, который описывает грамматику распознавания речи в поддерживаемом формате.</param>
        <summary>Добавляет файл определения грамматики к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URI, предоставленный `path` аргументом, может быть локальным или удаленным. Приложение должно иметь доступ на чтение к расположению указанных файлов грамматики.  
  
 Представление спецификации грамматики распознавания речи W3C (SRGS) может определять корневое правило. Этот метод добавляет грамматику, начиная с ее корневого правила, к текущей последовательности элементов грамматики. Чтобы добавить определенное грамматическое правило, используйте <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> метод.  
  
   
  
## Examples  
 В следующем C# примере создается Грамматика распознавания речи, которая использует правило с `Cities` именем в локальном файле SRGS, городах. грксмл. Содержимое файла городов. грксмл отображается под примером C# кода.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar1()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.AppendRuleReference("file://c:/temp/cities.grxml");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 1";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-16" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path, string rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path, string rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String, rule As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path, System::String ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string * string -&gt; unit" Usage="grammarBuilder.AppendRuleReference (path, rule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rule" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь к файлу или универсальный идентификатор ресурса (URI) файла, который описывает грамматику распознавания речи в поддерживаемом формате.</param>
        <param name="rule">Идентификатор добавляемого правила или значение <see langword="null" />, чтобы добавить корневое правило файла грамматики по умолчанию.</param>
        <summary>Добавляет указанное правило файла определения грамматики к текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URI, предоставленный `path` аргументом, может быть локальным или удаленным. Приложение должно иметь доступ на чтение к расположению указанных файлов грамматики.  
  
 С помощью <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> метода можно добавить файл грамматики, начиная с его корневого правила.  
  
   
  
## Examples  
 В следующем C# примере создается Грамматика распознавания речи, которая использует правило с `Cities` именем в локальном файле SRGS, городах. грксмл. Содержимое файла городов. грксмл отображается под примером C# кода.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar2()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.Append("Does");  
  builder.AppendRuleReference(@"c:\temp\cities.grxml", "Cities");  
  builder.Append("have a shuttle");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 2";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendWildcard">
      <MemberSignature Language="C#" Value="public void AppendWildcard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendWildcard() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendWildcard ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendWildcard();" />
      <MemberSignature Language="F#" Value="member this.AppendWildcard : unit -&gt; unit" Usage="grammarBuilder.AppendWildcard " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Добавляет элемент грамматики распознавания, соответствующий любой входной информации для текущей последовательности элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элемент-шаблон добавляется в конец текущей последовательности элементов.  
  
 Подстановочный элемент соответствует любому произнесенному слову. Он не соответствует фоновым шумам или тишине.  
  
   
  
## Examples  
 В следующем примере создается грамматика, которая принимает ввод пароля в качестве подстановочного знака. В этом примере обработчик <xref:System.Speech.Recognition.Grammar.SpeechRecognized?displayProperty=nameWithType> событий присоединяется к грамматике, которая проверяет ввод пароля.  
  
```csharp  
private Grammar CreatePasswordGrammar()  
{  
  GrammarBuilder wildcardBuilder = new GrammarBuilder();  
  wildcardBuilder.AppendWildcard();  
  SemanticResultKey passwordKey =  
    new SemanticResultKey("Password", wildcardBuilder);  
  
  GrammarBuilder passwordBuilder =  
    new GrammarBuilder("My Password is");  
  passwordBuilder.Append(passwordKey);  
  
  Grammar passwordGrammar = new Grammar(passwordBuilder);  
  passwordGrammar.Name = "Password input";  
  
  passwordGrammar.SpeechRecognized +=  
    new EventHandler<SpeechRecognizedEventArgs>(  
      PasswordInputHandler);  
  
  return passwordGrammar;  
}  
  
// Handle the SpeechRecognized event for the password grammar.  
private void PasswordInputHandler(object sender, SpeechRecognizedEventArgs e)  
{  
  if (e.Result == null) return;  
  
  RecognitionResult result = e.Result;  
  SemanticValue semantics = e.Result.Semantics;  
  
  if (semantics.ContainsKey("Password"))  
  {  
    RecognizedAudio passwordAudio =  
      result.GetAudioForWordRange(  
        result.Words[3], result.Words[result.Words.Count - 1]);  
  
    if (IsValidPassword(passwordAudio))  
    {  
      Console.WriteLine("Password accepted.");  
  
      // Add code to handle a valid password here.  
    }  
    else  
    {  
      Console.WriteLine("Invalid password.");  
  
      // Add code to handle an invalid password here.  
    }  
  }  
}  
  
// Validate the password input.   
private bool IsValidPassword(RecognizedAudio passwordAudio)  
{  
  Console.WriteLine("Validating password.");  
  
  // Add password validation code here.  
  
  return false;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Culture : System.Globalization.CultureInfo with get, set" Usage="System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает язык и региональные параметры грамматики распознавания речи.</summary>
        <value>Язык и региональные параметры <see cref="T:System.Speech.Recognition.GrammarBuilder" />. По умолчанию — свойство <see cref="P:System.Threading.Thread.CurrentUICulture" /> выполняющего потока.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> Конструктор<xref:System.Speech.Recognition.Grammar> создает объект, который может использоваться распознавателем речи соответствующего языка и региональных параметров. <xref:System.Speech.Recognition.GrammarBuilder.Culture%2A> Только свойство<xref:System.Speech.Recognition.GrammarBuilder> объекта, предоставленное в качестве параметра для конструктора грамматики, используется для задания языка и региональных параметров в результирующей грамматике распознавания речи.  
  
 Microsoft Windows и API System. Speech принимают все допустимые коды языковых стран. Чтобы выполнить распознавание речи с использованием языка, указанного `Culture` в свойстве, необходимо установить модуль распознавания речи, поддерживающий этот код языка и страны. Модули распознавания речи, поставляемые вместе с Microsoft Windows 7, работают со следующими кодами языковых стран.  
  
-   EN-GB. Английский (Великобритания)  
  
-   EN-US. Английский (США)  
  
-   de-DE. Немецкий (Германия)  
  
-   ES-ES. Испанский (Испания)  
  
-   fr-FR. Французский (Франция)  
  
-   ja-JP. Японский (Япония)  
  
-   zh-CN. Китайский (Китай)  
  
-   zh-TW. Китайский (Тайвань)  
  
 Также разрешены двухбуквенный код языка, например "en", "fr" или "ES".  
  
   
  
## Examples  
 В следующем примере создается Грамматика распознавания речи для упорядочивания пиццы до четырех. В частности, <xref:System.Speech.Recognition.GrammarBuilder> язык и региональные параметры объекта задаются как английский (США).  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.RecognizerInfo" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
      </Docs>
    </Member>
    <Member MemberName="DebugShowPhrases">
      <MemberSignature Language="C#" Value="public string DebugShowPhrases { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DebugShowPhrases" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DebugShowPhrases As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DebugShowPhrases { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DebugShowPhrases : string" Usage="System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает строку, которая отображает содержимое и структуру грамматики, содержащейся в <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <value>Текущее содержимое и структура <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается Грамматика распознавания речи для упорядочивания пиццы до четырех. Перед созданием грамматики она <xref:System.Speech.Recognition.GrammarBuilder> записывает состояние в консоль. Этот метод создает следующие выходные данные:  
  
-   `GrammarBuilder status: I would like a [cheese,mushroom,tomato,onion,anchovy,chic ken,pepperoni] and [cheese,mushroom,tomato,onion,anchovy,chicken,pepperoni] pizza`  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Write the contents and structure of the GrammarBuilder to the console.  
  Console.WriteLine("Grammar content and structure: {0}", gb.DebugShowPhrases);  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361640(v%3doffice.14)">Создание грамматик с помощью Граммарбуилдер</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Addition">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, соответствующий последовательности из двух элементов грамматики.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Порядок операндов определяет порядок элементов в новом <xref:System.Speech.Recognition.GrammarBuilder>.  
  
> [!IMPORTANT]
>  При объединении <xref:System.Speech.Recognition.Choices> объектов или <xref:System.Speech.Recognition.GrammarBuilder> , содержащих <xref:System.Speech.Recognition.SemanticResultValue> экземпляры или <xref:System.Speech.Recognition.SemanticResultKey> с другими элементами грамматики, рекомендуется соблюдать осторожность. Распознаватель речи может вызывать исключение при использовании грамматики распознавания речи, содержащей повторяющиеся семантические элементы с одинаковым именем ключа или несколькими семантическими элементами, которые могут периодически изменять значение одного и того же семантического элемента. 
  
 Дополнительные сведения о создании и использовании грамматик распознавания речи см. в разделе [Распознавание речи](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) и [Создание грамматик граммарбуилдер](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="choices + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">Первый элемент grammar, представляющий набор альтернатив.</param>
        <param name="builder">Второй элемент grammar.</param>
        <summary>Создает элемент <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий объект <see cref="T:System.Speech.Recognition.Choices" />, за которым следует объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Возвращает <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности параметра <paramref name="choices" />, а затем параметр <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>поддерживает преобразования из следующих классов.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает перечисленные выше объекты для `builder` параметра. Дополнительные сведения см. в <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> разделе операторы.  
  
> [!IMPORTANT]
>  При объединении <xref:System.Speech.Recognition.Choices> объектов <xref:System.Speech.Recognition.GrammarBuilder> и, содержащих <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> , следует избегать создания повторяющихся семантических элементов с одинаковым именем ключа или несколькими семантическими элементами, которые могут периодически изменять <xref:System.Speech.Recognition.SemanticValue.Value%2A> свойство объекта.<xref:System.Speech.Recognition.SemanticValue> Распознаватель речи может вызвать исключение, если в них возникают такие обстоятельства.
  
 Эквивалентным методом для этого оператора является<xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.Choices%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">Первый элемент грамматики.</param>
        <param name="choices">Второй элемент грамматики, который представляет набор альтернативных вариантов.</param>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, после которого следует <see cref="T:System.Speech.Recognition.Choices" />.</summary>
        <returns>Возвращает <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности параметра <paramref name="builder" />, а затем параметр <paramref name="choices" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>поддерживает преобразования из следующих классов:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает перечисленные выше объекты для `builder` параметра. Дополнительные сведения см. в <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> разделе операторы.  
  
> [!IMPORTANT]
>  При объединении <xref:System.Speech.Recognition.Choices> объектов <xref:System.Speech.Recognition.GrammarBuilder> и, содержащих <xref:System.Speech.Recognition.SemanticResultValue> или <xref:System.Speech.Recognition.SemanticResultKey> , следует избегать создания повторяющихся семантических элементов с одинаковым именем ключа или несколькими семантическими элементами, которые могут периодически изменять <xref:System.Speech.Recognition.SemanticValue.Value%2A> свойство объекта.<xref:System.Speech.Recognition.SemanticValue> Распознаватель речи может вызвать исключение, если в них возникают такие обстоятельства.
  
 Эквивалентным методом для этого оператора является<xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 В следующем примере создается Грамматика распознавания речи, которая может распознать две фразы: «создать *Цвет*фона» и «задать фон до *цвета*», где *Цвет* выбирается из набора цветов. Для создания окончательной грамматики, например [строк](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>и <xref:System.Speech.Recognition.GrammarBuilder> объектов, используются различные типы.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder1 + builder2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">Первый элемент грамматики.</param>
        <param name="builder2">Второй элемент grammar.</param>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий последовательность из двух объектов <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Возвращает <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности параметра <paramref name="builder1" />, а затем параметр <paramref name="builder2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>поддерживает преобразования из следующих классов.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает перечисленные выше объекты для `builder1` параметров и. `builder2` Дополнительные сведения см. в <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> разделе операторы.  
  
> [!IMPORTANT]
>  При объединении <xref:System.Speech.Recognition.GrammarBuilder> объектов, содержащих <xref:System.Speech.Recognition.SemanticResultValue> экземпляры <xref:System.Speech.Recognition.SemanticResultKey> или, следует избегать создания повторяющихся семантических элементов с одинаковым именем ключа или <xref:System.Speech.Recognition.SemanticValue.Value%2A> несколькими семантическими элементами, которые могут периодически изменять <xref:System.Speech.Recognition.SemanticValue> свойство объекта. Распознаватель речи может вызвать исключение, если в них возникают такие обстоятельства.
  
 Эквивалентным методом для этого оператора является<xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">Первый элемент грамматики.</param>
        <param name="phrase">Второй элемент грамматики, который представляет последовательность слов.</param>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, после которой следует фраза.</summary>
        <returns>Возвращает <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности параметра <paramref name="builder" />, а затем параметр <paramref name="phrase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>поддерживает преобразования из следующих классов.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает перечисленные выше объекты для `builder` параметра. Дополнительные сведения см. в <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> разделе операторы.  
  
 Эквивалентным методом для этого оператора является<xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.String%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="phrase + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">Первый элемент грамматики, который представляет последовательность слов.</param>
        <param name="builder">Второй элемент grammar.</param>
        <summary>Создает новый объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />, содержащий фразу, после которой следует объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Возвращает <see cref="T:System.Speech.Recognition.GrammarBuilder" /> для последовательности параметра <paramref name="phrase" />, а затем параметр <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>поддерживает преобразования из следующих классов.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Этот метод принимает перечисленные выше объекты для `builder` параметра. Дополнительные сведения см. в <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> разделе операторы.  
  
 Эквивалентным методом для этого оператора является<xref:System.Speech.Recognition.GrammarBuilder.Add%28System.String%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>  
  
## Examples  
 В следующем примере создается Грамматика распознавания речи, которая может распознать две фразы: «создать *Цвет*фона» и «задать фон до *цвета*», где *Цвет* выбирается из набора цветов. Для создания окончательной грамматики, например [строк](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>и <xref:System.Speech.Recognition.GrammarBuilder> объектов, используются различные типы.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует другой тип в <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неявное преобразование создает новый экземпляр <xref:System.Speech.Recognition.GrammarBuilder>. Каждый из следующих классов можно привести к <xref:System.Speech.Recognition.GrammarBuilder>типу.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Каждое неявное приведение эквивалентно вызову конструктора.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="choices">Набор вариантов для преобразования.</param>
        <summary>Преобразует объект <see cref="T:System.Speech.Recognition.Choices" /> в объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Преобразованный объект <see cref="T:System.Speech.Recognition.Choices" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неявное преобразование создает новый экземпляр <xref:System.Speech.Recognition.GrammarBuilder>. Этот оператор преобразования эквивалентен вызову <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> и указанию `choices` для `alternateChoices`.  
  
 Эквивалентным методом для этого оператора является<xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 В следующем примере создается Грамматика распознавания речи, которая может распознать ответ на вопрос "Да" или "нет". Оператор неявного преобразования используется в построении <xref:System.Speech.Recognition.SemanticResultValue> объекта <xref:System.Speech.Recognition.Choices> из объекта, <xref:System.Speech.Recognition.Choices> в построении объекта из двух <xref:System.Speech.Recognition.SemanticResultValue> объектов и в построении <xref:System.Speech.Recognition.Grammar> объекта из <xref:System.Speech.Recognition.SemanticResultKey> объект.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultKey semanticKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultKey semanticKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultKey)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticKey As SemanticResultKey) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultKey ^ semanticKey);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticKey" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="semanticKey">Семантический ключ для преобразования.</param>
        <summary>Преобразует объект <see cref="T:System.Speech.Recognition.SemanticResultKey" /> в объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Преобразованный объект <see cref="T:System.Speech.Recognition.SemanticResultKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неявное преобразование создает новый экземпляр <xref:System.Speech.Recognition.GrammarBuilder>. Этот оператор преобразования эквивалентен вызову <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> и указанию `semanticKey` для `key`.  
  
 Эквивалентным методом для этого оператора является<xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultKey%29?displayProperty=nameWithType>  
  
## Examples  
 В следующем примере создается Грамматика распознавания речи, которая может распознать ответ на вопрос "Да" или "нет". Оператор неявного преобразования используется в построении <xref:System.Speech.Recognition.SemanticResultValue> объекта <xref:System.Speech.Recognition.Choices> из объекта, <xref:System.Speech.Recognition.Choices> в построении объекта из двух <xref:System.Speech.Recognition.SemanticResultValue> объектов и в построении <xref:System.Speech.Recognition.Grammar> объекта из <xref:System.Speech.Recognition.SemanticResultKey> объект.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultValue semanticValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultValue semanticValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultValue)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticValue As SemanticResultValue) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultValue ^ semanticValue);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticValue" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="semanticValue">Преобразуемый объект <see cref="T:System.Speech.Recognition.SemanticResultValue" />.</param>
        <summary>Преобразует объект <see cref="T:System.Speech.Recognition.SemanticResultValue" /> в объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Преобразованный объект <see cref="T:System.Speech.Recognition.SemanticResultValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неявное преобразование создает новый экземпляр <xref:System.Speech.Recognition.GrammarBuilder>. Этот оператор преобразования эквивалентен вызову <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> и указанию `semanticValue` для `value`.  
  
 Эквивалентным методом для этого оператора является<xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultValue%29?displayProperty=nameWithType>  
  
## Examples  
 В следующем примере создается Грамматика распознавания речи, которая может распознать ответ на вопрос "Да" или "нет". Оператор неявного преобразования используется в построении <xref:System.Speech.Recognition.SemanticResultValue> объекта <xref:System.Speech.Recognition.Choices>из объекта, <xref:System.Speech.Recognition.Choices> в построении объекта из двух <xref:System.Speech.Recognition.SemanticResultValue> объектов и в построении <xref:System.Speech.Recognition.Grammar> объекта из <xref:System.Speech.Recognition.SemanticResultKey> объект.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.String)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Преобразуемая строка.</param>
        <summary>Преобразует строку в объект <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Преобразованная строка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неявное преобразование создает новый экземпляр <xref:System.Speech.Recognition.GrammarBuilder>. Этот оператор преобразования эквивалентен вызову <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> и указанию того `phrase`же самого.  
  
 Эквивалентным методом для этого оператора является<xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.String%29?displayProperty=nameWithType>  
  
## Examples  
 В следующем примере используются <xref:System.Speech.Recognition.GrammarBuilder> объекты <xref:System.Speech.Recognition.Choices> и для создания грамматики, которая может распознать любую из двух фраз: «make Background *колорчоице*» или «Set Background to *колорчоице*».  
  
 После создания списка допустимых значений для *колорчоице* с <xref:System.Speech.Recognition.Choices> помощью объекта в примере инициализируются два <xref:System.Speech.Recognition.GrammarBuilder> объекта `makePhrase` и `setPhrase`используется неявное преобразование из строковых объектов.  
  
 В примере наконец создается <xref:System.Speech.Recognition.Grammar> объект <xref:System.Speech.Recognition.Choices> из объекта, приведенного к <xref:System.Speech.Recognition.GrammarBuilder> объекту.  
  
```csharp  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
  </Members>
</Type>
