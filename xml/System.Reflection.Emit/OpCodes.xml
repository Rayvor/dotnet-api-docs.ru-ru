<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="76cf31c35ad94a83719988c90e476ffdd459c191" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75169337" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Содержит поля, предоставляющие инструкции языка MSIL для выпуска элементами класса <see cref="T:System.Reflection.Emit.ILGenerator" /> (например, <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подробное описание кодов операций для элементов см. в документации по Common Language Infrastructure (CLI), особенно в разделе III: набор инструкций CIL и "Секция II: определение метаданных и семантика". Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.  
  
   
  
## Examples  
 В следующем примере демонстрируется создание динамического метода с помощью <xref:System.Reflection.Emit.ILGenerator> для выдачи `OpCodes` в <xref:System.Reflection.Emit.MethodBuilder>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Складывает два значения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|58|add|Складывает два числовых значения, возвращая новое числовое значение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` добавляется в `value2`.  
  
4.  Результат помещается в стек.  
  
 Переполнение не обнаружено для целочисленных операций (для правильной обработки переполнения см. раздел <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).  
  
 Сложение целых чисел, а не насыщенность. Например, при использовании 8-разрядных целых чисел, где `value1` имеет значение 255, а `value2` имеет значение 1, то упакованный результат равен 0, а не 256.  
  
 Переполнение с плавающей точкой возвращает `+inf` (`PositiveInfinity`) или `-inf` (`NegativeInfinity`).  
  
 Допустимые типы операндов и соответствующий тип данных результата перечислены в таблице ниже. Если нет записи для определенного сочетания типа (например, `int32` и `float`; `int32` и `int64`), это недопустимый MSIL-код, который выдает ошибку.  
  
|операнд|Тип value1|Тип value2|Тип результата|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `add`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Складывает два целых числа, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D6|Добавить. ovf|Добавляет два целочисленных значения со знаком с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` добавляется в `value2` с помощью проверки переполнения.  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException> создается, если результат не представлен типом результата.  
  
 Эту операцию можно выполнить с целыми числами со знаком. Для значений с плавающей запятой используйте <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Допустимые типы операндов и соответствующий тип данных результата перечислены в таблице ниже. Если нет записи для определенного сочетания типа (например, `int32` и `float`; `int32` и `int64`), это недопустимая инструкция промежуточного языка MSIL и выдает ошибку.  
  
|операнд|Тип value1|Тип value2|Тип результата|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `add.ovf`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Складывает два целочисленных значения без знака, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D7|Добавить. ovf. un|Добавляет два целочисленных значения без знака с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` добавляется в `value2` с помощью проверки переполнения.  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException> создается, если результат не представлен типом результата.  
  
 Эту операцию можно выполнить с целыми числами со знаком. Для значений с плавающей запятой используйте <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Допустимые типы операндов и соответствующий тип данных результата перечислены в таблице ниже. Если нет записи для определенного сочетания типа (например, `int32` и `float`; `int32` и `int64`), это недопустимая инструкция промежуточного языка MSIL и выдает ошибку.  
  
|операнд|Тип value1|Тип value2|Тип результата|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `add.ovf.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое И двух значений и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Инструкция|Описание|  
|------------|-----------------|-----------------|  
|5F|and|Определяет побитовое и для двух целочисленных значений.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value1` и `value2` извлекаются из стека; Побитовое и для двух значений является вычисленным.  
  
4.  Результат помещается в стек.  
  
 Инструкция `and` рассчитывает побитовое и для двух верхних значений в стеке и оставляет результат в стеке.  
  
 `And` — это операция, относящаяся к целому числу.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `and`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает неуправляемый указатель на список аргументов текущего метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 00|arglist|Возвращает маркер списка аргументов для текущего метода.|  
  
 Эта операция не выполняет поведений стека вычислений.  
  
 Инструкция `arglist` возвращает непрозрачный маркер (неуправляемый указатель типа `native int`), представляющий список аргументов текущего метода. Этот маркер действителен только в течение времени существования текущего метода. Однако можно передать этот обработчик другим методам, если текущий метод находится в потоке управления. Инструкцию `arglist` можно выполнить только в методе, принимающем переменное число аргументов.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `arglist`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если два значения равны.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3B < `int32` >|Бек `target`|Выполняет переход к целевой инструкции со смещением `target`, если два значения равны.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` равен `value2`, выполняется операция ветвления.  
  
 Инструкция `beq` передает управление указанной конечной инструкции, если `value1` равен `value2`. Результат аналогичен выполнению инструкции `ceq`, за которой следует `brtrue`ая ветвь к конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Допустимые типы операндов инкапсулированы ниже:  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.  
  
 Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может быть выполнено этой инструкцией (такие передачи являются строго ограниченными и должны использовать инструкцию <xref:System.Reflection.Emit.OpCodes.Leave>).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `beq`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если два значения равны.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|`int8`< 2E  >|`target` Бек. s|Переход к целевой инструкции со смещением `target` если равно, краткая форма|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` равен `value2`, выполняется операция ветвления.  
  
 Инструкция `beq.s` передает управление указанной конечной инструкции, если `value1` равен `value2`. Результат аналогичен выполнению инструкции `ceq`, за которой следует `brtrue`ая ветвь к конкретной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Допустимые типы операндов инкапсулированы ниже:  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.  
  
 Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может быть выполнено этой инструкцией (такие передачи являются строго ограниченными и должны использовать инструкцию <xref:System.Reflection.Emit.OpCodes.Leave>).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `beq.s`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3C `<int32>`|бже `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго или равно ему.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` больше или равно `value2`, выполняется операция ветвления.  
  
 Инструкция `bge` передает управление в указанную целевую инструкцию, если `value1` больше или равна `value2`. Этот результат идентичен выполнению инструкции `clt.un`, за которой следует `brfalse`ая ветвь к конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bge`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2F `<int8>`|`target` бже. s|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго или равно ему (краткая форма).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` больше или равно `value2`, выполняется операция ветвления.  
  
 Инструкция `bge.s` передает управление в указанную целевую инструкцию, если `value1` больше или равна `value2`. Этот результат идентичен выполнению инструкции `clt.un`, за которой следует `brfalse`ая ветвь к конкретной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bge.s`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|41 `<int32>`|бже. un `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше или равно второму значению (значения без знака).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` больше или равно `value2`, выполняется операция ветвления.  
  
 Инструкция `bge.un` передает управление указанной конечной инструкции, если `value1` больше или равно `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `clt`, за которой следует `brfalse`ая ветвь к конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bge.un`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|34 < `int8` >|`target` бже. un. s|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше или равно второму (значения без знака), короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` больше или равно `value2`, выполняется операция ветвления.  
  
 Инструкция `bge.un.s` передает управление указанной конечной инструкции, если `value1` больше или равно `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `clt`, за которой следует `brfalse`ая ветвь к конкретной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bge.un.s`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|Трехмерная < `int32` >|БГТ `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` больше `value2`, выполняется операция ветвления.  
  
 Инструкция `bgt` передает управление указанной конечной инструкции, если `value1` больше `value2`. Этот результат идентичен выполнению инструкции `cgt`, за которой следует `brtrue`ая ветвь к конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bgt`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|30 < `int8` >|`target` БГТ. s|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго (краткая форма).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` больше `value2`, выполняется операция ветвления.  
  
 Инструкция `bgt.s` передает управление указанной конечной инструкции, если `value1` больше `value2`. Этот результат идентичен выполнению инструкции `cgt`, за которой следует `brtrue`ая ветвь к конкретной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bgt.s`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|42 < `int32` >|БГТ. un `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго (значения без знака).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` больше `value2`, выполняется операция ветвления.  
  
 Инструкция `bgt.un` передает управление указанной конечной инструкции, если `value1` больше, чем `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `cgt.un`, за которой следует `brtrue`ая ветвь к конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bgt.un`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|35 < `int8` >|`target` БГТ. un. s|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго (значения без знака), короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` больше `value2`, выполняется операция ветвления.  
  
 Инструкция `bgt.un.s` передает управление указанной конечной инструкции, если `value1` больше, чем `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `cgt.un`, за которой следует `brtrue`ая ветвь к конкретной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bgt.un.s`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго значения или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3E `<int32>`|BLE `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго или равно ему.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` меньше или равно `value2`, выполняется операция ветвления.  
  
 Инструкция `ble` передает управление в указанную целевую инструкцию, если `value1` меньше или равно `value2`. Этот результат идентичен выполнению инструкции `cgt` (`cgt.un` для операций с плавающей запятой), за которой следует `brfalse`ая ветвь к конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ble`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|31 `<int8>`|`target` BLE. s|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго или равно ему (короткая форма).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` меньше или равно `value2`, выполняется операция ветвления.  
  
 Инструкция `ble.s` передает управление в указанную целевую инструкцию, если `value1` меньше или равно `value2`. Этот результат идентичен выполнению инструкции `cgt` инструкции (`cgt.un` for float), за которой следует`brfalse`ная ветвь к конкретной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ble.s`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго или равно ему (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|43 `<int32>`|BLE. un `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше или равно второму значению (значения без знака).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` меньше или равно `value2`, выполняется операция ветвления.  
  
 Инструкция `ble.un` передает управление в указанную целевую инструкцию, если `value1` меньше или равно `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `cgt.un` (`cgt` для операций с плавающей запятой), за которой следует `brfalse`ая ветвь к конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ble.un`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго или равно ему (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|36 `<int8>`|`target` BLE. un. s|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше или равно второму (значения без знака), короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` меньше или равно `value2`, выполняется операция ветвления.  
  
 Инструкция `ble.un.s` передает управление в указанную целевую инструкцию, если `value1` меньше или равно `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `cgt.un` (`cgt` для операций с плавающей запятой), за которой следует `brfalse`ая ветвь к конкретной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ble.un.s`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3F < `int32` >|БЛТ `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` меньше `value2`, выполняется операция ветвления.  
  
 Инструкция `blt` передает управление в указанную целевую инструкцию, если `value1` меньше или равно `value2`. Этот результат идентичен выполнению инструкции `clt`, за которой следует `brtrue`ая ветвь к конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `blt`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|32 < `int8` >|`target` БЛТ. s|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго (краткая форма).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` меньше `value2`, выполняется операция ветвления.  
  
 Инструкция `blt.s` передает управление указанной конечной инструкции, если `value1` меньше `value2`. Этот результат идентичен выполнению инструкции `clt`, за которой следует `brtrue`ая ветвь к конкретной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `blt.s`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|44 < `int32` >|БЛТ. un `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго (значения без знака).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` меньше `value2`, выполняется операция ветвления.  
  
 Инструкция `blt.un` передает управление указанной конечной инструкции, если `value1` меньше, чем `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `clt.un`, за которой следует `brtrue`ая ветвь к конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `blt.un`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|37 < `int8` >|`target` БЛТ. un. s|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго (значения без знака), короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` меньше `value2`, выполняется операция ветвления.  
  
 Инструкция `blt.un` передает управление указанной конечной инструкции, если `value1` меньше, чем `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `clt.un`, за которой следует `brtrue`ая ветвь к конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `blt.un.s`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции в случае неравенства двух целочисленных значений без знака или двух неупорядоченных значений с плавающей запятой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|40 < `int32` >|бне. un `target`|Выполняет переход к целевой инструкции с указанным смещением, если два целочисленных значения без знака не равны (значения без знака).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` не равно `value2`, выполняется операция ветвления.  
  
 Инструкция `bne.un` передает управление указанной конечной инструкции, если `value1` не равно `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `ceq`, за которой следует `brfalse`ая ветвь к конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bne.un`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма) в случае неравенства двух целочисленных значений без знака или двух неупорядоченных значений с плавающей запятой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|33 < `int8` >|`target` бне. un. s|Выполняет переход к целевой инструкции с указанным смещением, если два целочисленных значения без знака не равны (значения без знака), краткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` не равно `value2`, выполняется операция ветвления.  
  
 Инструкция `bne.un` передает управление указанной конечной инструкции, если `value1` не равно `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `ceq`, за которой следует `brfalse`ая ветвь к конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bne.un.s`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует тип значения в ссылку на объект (тип <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8В < `T` >|Box `valTypeToken`|Преобразование типа значения (типа, указанного в `valTypeToken`) в фактическую ссылку на объект.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Тип значения помещается в стек.  
  
2.  Тип значения извлекается из стека; выполняется операция `box`.  
  
3.  Ссылка на объект, получивший "упакованный" тип значения, помещается в стек.  
  
 Тип значения имеет два отдельных представления в Common Language Infrastructure (CLI):  
  
-   Необработанная форма, используемая при внедрении типа значения в другой объект или в стек.  
  
-   "Упакованная" форма, в которой данные в типе значения упаковываются (упаковываются) в объект, поэтому он может существовать как независимая сущность.  
  
 Инструкция `box` преобразует тип значения "RAW" (распакованного) в ссылку на объект (тип `O`). Это достигается путем создания нового объекта и копирования данных из типа значения в новый выделенный объект. `valTypeToken` является маркером метаданных, указывающим тип значения в стеке.  
  
 <xref:System.OutOfMemoryException> возникает, если недостаточно памяти для удовлетворения запроса.  
  
 Если класс не найден, выдается <xref:System.TypeLoadException>. Обычно это обнаруживается при преобразовании MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `box`.  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Обеспечивает безусловную передачу управления конечной инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|Выполняет переход к целевой инструкции по указанному смещению.|  
  
 Эта операция не выполняет поведений стека вычислений.  
  
 Инструкция `br` безусловно передает управление целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `br`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Обеспечивает безусловную передачу управления конечной инструкции (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br. s `target`|Выполняет переход к целевой инструкции по указанному смещению (краткая форма).|  
  
 Эта операция не выполняет поведений стека вычислений.  
  
 Инструкция `br.s` безусловно передает управление целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `br.s`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сообщает инфраструктуре CLI, что необходимо оповестить отладчик о достижении точки останова.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|01|break|Сообщите отладчику о достижении точки останова.|  
  
 Эта операция не выполняет поведений стека вычислений.  
  
 Инструкция `break` предназначена для поддержки отладки. Он сигнализирует интерфейсу командной строки сообщить отладчику о том, что точка останова была остановлена. Он не влияет на состояние интерпретатора.  
  
 Инструкция `break` имеет наименьший возможный размер инструкции, позволяющий выполнять исправление кода с точкой останова и создавать минимальный беспорядки вокруг окружающего кода.  
  
 Инструкция `break` может выполнять треппинг в отладчике, не выполнять никаких действий или вызывать исключение безопасности. Точное поведение определяется реализацией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `break`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если значением <paramref name="value" /> является <see langword="false" />, пустая ссылка (<see langword="Nothing" /> в Visual Basic) или ноль.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|39 < `int32` >|брфалсе `target`<br /><br /> брнулл `target`<br /><br /> брзеро `target`|Выполняет переход к целевой инструкции с указанным смещением, если `false`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек с помощью предыдущей операции.  
  
2.  `value` извлекается из стека; Если `value` `false`, ветвь устанавливается в `target`.  
  
 Инструкция `brfalse` (и ее псевдонимы `brnull` и `brzero`) передает управление указанной конечной инструкции, если `value` (тип `int32`, `int64`, ссылка на объект `O`, управляемый указатель `&`, временный указатель `*`, `native int`) равен нулю (`false`). Если `value` не равно нулю (`true`), продолжение выполнения выполняется в следующей инструкции.  
  
 Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `brfalse`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если значением <paramref name="value" /> является <see langword="false" />, пустая ссылка или ноль.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2C <`int8` >|`target` брфалсе. s<br /><br /> `target` брнулл. s<br /><br /> `target` брзеро. s|Выполняет переход к целевой инструкции с указанным смещением, если `false`короткий формат.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек с помощью предыдущей операции.  
  
2.  `value` извлекается из стека; Если `value` `false`, ветвь устанавливается в `target`.  
  
 Инструкция `brfalse.s` (и ее псевдонимы `brnull` и `brzero`) передает управление указанной конечной инструкции, если `value` (тип `int32`, `int64`, ссылка на объект `O`, управляемый указатель `&`, временный указатель `*`, `native int`) равен нулю (`false`). Если `value` не равно нулю (`true`), продолжение выполнения выполняется в следующей инструкции.  
  
 Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `brfalse.s`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если значение <paramref name="value" /> равно <see langword="true" />, либо отличается от null и от нуля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< 3A `int32` >|требовалась brtrue `target`<br /><br /> бринст `target`|Выполняет переход к целевой инструкции с указанным смещением, если не равен нулю (`true`).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек с помощью предыдущей операции.  
  
2.  `value` извлекается из стека; Если `value` `true`, ветвь устанавливается в `target`.  
  
 Инструкция `brtrue` передает управление указанной конечной инструкции, если `value` (тип `native int`) не равен нулю (`true`). Если `value` равен нулю (`false`), продолжение выполнения выполняется в следующей инструкции.  
  
 Если `value` является ссылкой на объект (тип `O`), то `brinst` (псевдоним для `brtrue`) передает управление, если он представляет экземпляр объекта (например, если он не является ссылкой на объект null; см. <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `brtrue`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если значение <paramref name="value" /> равно <see langword="true" /> либо отличается от null и от нуля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|`int8`2D-<  >|`target` требовалась brtrue. s<br /><br /> `target` бринст. s|Переход к целевой инструкции с указанным смещением, если ненулевое значение (`true`), краткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек с помощью предыдущей операции.  
  
2.  `value` извлекается из стека; Если `value` `true`, ветвь устанавливается в `target`.  
  
 Инструкция `brtrue.s` передает управление указанной конечной инструкции, если `value` (тип `native int`) не равен нулю (`true`). Если `value` равен нулю (`false`), продолжение выполнения выполняется в следующей инструкции.  
  
 Если `value` является ссылкой на объект (тип `O`), то `brinst` (псевдоним для `brtrue`) передает управление, если он представляет экземпляр объекта (например, если он не является ссылкой на объект null; см. <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `brtrue.s`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывает метод, на который ссылается переданный дескриптор метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|28 < `T` >|вызов `methodDesc`|Вызовите метод, описанный `methodDesc`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Аргументы метода, `arg1` с помощью `argN`, помещаются в стек.  
  
2.  Аргументы метода, `arg1` с помощью `argN`, извлекаются из стека; вызов метода выполняется с этими аргументами, и управление передается методу, на который ссылается дескриптор метода. По завершении возвращаемое значение создается вызываемым методом и отправляется вызывающему объекту.  
  
3.  Возвращаемое значение помещается в стек.  
  
 Инструкция `call` вызывает метод, указанный дескриптором метода, передаваемым с помощью инструкции. Дескриптор метода — это маркер метаданных, указывающий вызываемый метод и число, тип и порядок аргументов, которые были помещены в стек для передачи в этот метод, а также соглашение о вызовах для использования. Инструкции `call` может предшествовать префикс `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>), чтобы указать, что текущее состояние метода должно быть освобождено перед передачей управления. Если вызов передает управление методу более высокого уровня доверия, чем метод источника, кадр стека не освобождается. Вместо этого выполнение продолжится автоматически, как если бы `tail` не было предоставлено. Маркер метаданных содержит достаточную информацию для определения того, относится ли вызов к статическому методу, методу экземпляра, виртуальному методу или глобальной функции. Во всех этих случаях адрес назначения определяется исключительно из дескриптора метода (Сравните это с инструкцией <xref:System.Reflection.Emit.OpCodes.Callvirt> для вызова виртуальных методов, где адрес назначения также зависит от типа среды выполнения ссылки на экземпляр, помещаемой перед <xref:System.Reflection.Emit.OpCodes.Callvirt>).  
  
 Аргументы помещаются в стек в порядке слева направо. То есть первый аргумент выводится и помещается в стек, затем второй аргумент — третий, пока все необходимые аргументы не помещаются в стек в убывающем порядке. Существует три важных случая.  
  
 1. Вызовы метода экземпляра (или виртуального) должны отправить ссылку на этот экземпляр перед любыми видимыми пользователем аргументами. Ссылка на экземпляр не должна быть пустой ссылкой. Подпись, переданная в метаданных, не содержит записи в списке параметров для `this` указателя; Вместо этого используется бит, указывающий, требует ли метод передачи указателя `this`.  
  
 2. Допускается вызов виртуального метода с помощью `call` (а не `callvirt`); Это означает, что метод должен быть разрешен с помощью класса, заданного методом, а не как указано динамически в вызываемом объекте.  
  
 3. Обратите внимание, что метод `Invoke` делегата можно вызвать с помощью инструкции `call` или `callvirt`.  
  
 <xref:System.Security.SecurityException> могут возникать, если система безопасности не предоставляет вызывающему объекту доступ к вызываемому методу. Проверка безопасности может происходить, когда инструкции MSIL преобразуются в машинный код, а не во время выполнения.  
  
> [!NOTE]
>  При вызове методов типа System. Object для типов значений рекомендуется использовать префикс `constrained` с инструкцией `callvirt`, а не выдавать инструкцию `call`. Это избавляет от необходимости создавать разные IL в зависимости от того, переопределяет ли тип значения метод, избегая возможной проблемы управления версиями. Рекомендуется использовать префикс `constrained` при вызове методов интерфейса для типов значений, так как метод типа значения, реализующий метод интерфейса, можно изменить с помощью `MethodImpl`. Эти проблемы более подробно описаны в <xref:System.Reflection.Emit.OpCodes.Constrained> код операции.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузки методов могут использовать код операции `call`.  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
-   ILGenerator. Емиткалл (код операции, MethodInfo, тип [])  
  
> [!NOTE]
>  Метод <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> предоставляется для вызовов `varargs`. Используйте метод <xref:System.Reflection.Emit.ILGenerator.Emit%2A> для обычных вызовов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывает метод, заданный в стеке вычислений (как указатель на точку входа), с аргументами, описанными в соглашении о вызовах.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|29 < `T` >|calli `callSiteDescr`|Вызывает метод, указываемый с аргументами, описанными в соглашении о вызовах.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Аргументы метода, `arg1` с помощью `argN`, помещаются в стек.  
  
2.  Указатель на запись метода помещается в стек.  
  
3.  Аргументы метода `arg1`ся через `argN` и указатель входа метода извлекается из стека; выполняется вызов метода. По завершении возвращаемое значение создается вызываемым методом и отправляется вызывающему объекту.  
  
4.  Возвращаемое значение помещается в стек.  
  
 Инструкция `calli` вызывает указатель входа метода с аргументами, `arg1` с помощью `argN`. Типы этих аргументов описаны конкретным соглашением о вызовах (`callSiteDesc`). Инструкции `calli` может предшествовать префикс `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>), чтобы указать, что текущее состояние метода должно быть освобождено перед передачей управления. Если вызов передает управление методу с более высоким уровнем доверия, чем метод источника, кадр стека не будет освобожден; Вместо этого выполнение продолжится без уведомления, как если бы `tail` не было предоставлено.  
  
 Указатель входа метода считается определенным указателем на машинный код (на целевом компьютере), который можно использовать с аргументами, описанными в соглашении о вызовах (маркер метаданных для отдельной подписи). Такой указатель может быть создан с помощью <xref:System.Reflection.Emit.OpCodes.Ldftn> или <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> инструкций или передается из машинного кода.  
  
 Соглашение о вызовах не проверяется динамически, поэтому код, использующий инструкцию `calli`, не работает правильно, если назначение фактически не использует указанное соглашение о вызовах.  
  
 Аргументы помещаются в стек в порядке слева направо. То есть первый аргумент выводится и помещается в стек, затем второй аргумент — третий, пока все необходимые аргументы не помещаются в стек в убывающем порядке. Последовательность кода для создания аргументов для экземпляра или виртуального метода должна отправить ссылку на экземпляр (которая не должна быть пустой ссылкой) перед любыми видимыми пользователем аргументами.  
  
 <xref:System.Security.SecurityException> могут возникать, если система безопасности не предоставляет вызывающему объекту доступ к вызываемому методу. Проверка безопасности может происходить, когда инструкции MSIL преобразуются в машинный код, а не во время выполнения.  
  
 Для выполнения инструкции `calli` в стеке можно использовать следующие методы <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>. Обратите внимание, что `calli` следует вызывать через приведенные ниже методы, а не использовать класс <xref:System.Reflection.Emit.ILGenerator.Emit%2A> для размещения инструкции непосредственно в стеке.  
  
-   ILGenerator. Емиткалли (opcode, Каллингконвентионс, Type, Type [], Type []) для вызовов, использующих соглашение об управляемом вызовах.  
  
-   ILGenerator. Емиткалли (opcode, CallingConvention, Type, Type []) для вызовов, использующих неуправляемое соглашение о вызовах.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывает метод объекта с поздней привязкой и помещает возвращаемое значение в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt `method`|Вызывает конкретный метод, связанный с `obj`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `obj` помещается в стек.  
  
2.  Аргументы метода, `arg1` с помощью `argN`, помещаются в стек.  
  
3.  Аргументы метода `arg1`ся через `argN` и ссылку на объект `obj` извлекаются из стека. вызов метода выполняется с этими аргументами, и управление передается методу в `obj`, на который ссылается токен метаданных метода. По завершении возвращаемое значение создается вызываемым методом и отправляется вызывающему объекту.  
  
4.  Возвращаемое значение помещается в стек.  
  
 Инструкция `callvirt` вызывает метод с поздним связыванием для объекта. Это значит, что метод выбирается на основе типа `obj` среды выполнения, а не класса времени компиляции, видимого в указателе метода. `Callvirt` можно использовать для вызова виртуальных методов и экземпляров. Оператору `callvirt` может предшествовать префикс `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>), чтобы указать, что текущий кадр стека следует освободить перед передачей управления. Если вызов передает управление методу с более высоким уровнем доверия, чем исходный метод, кадр стека не будет освобожден.  
  
 Токен метаданных метода предоставляет имя, класс и сигнатуру вызываемого метода. Класс, связанный с `obj`, является классом, экземпляром которого является. Если класс определяет нестатический метод, соответствующий указанному имени и сигнатуре метода, вызывается этот метод. В противном случае все классы в цепочке базовых классов этого класса проверяются по порядку. Если метод не найден, возникает ошибка.  
  
 перед вызовом метода `Callvirt` извлекает объект и связанные с ним аргументы из стека вычислений. Если метод имеет возвращаемое значение, он помещается в стек после завершения метода. На стороне вызываемого метода доступ к параметру `obj` осуществляется в качестве аргумента 0, `arg1` в качестве аргумента 1 и т. д.  
  
 Аргументы помещаются в стек в порядке слева направо. То есть первый аргумент выводится и помещается в стек, затем второй аргумент — третий, пока все необходимые аргументы не помещаются в стек в убывающем порядке. Ссылка на экземпляр `obj` (всегда требуется для `callvirt`) должна быть передана перед любыми видимыми пользователем аргументами. Сигнатура (переданная в маркере метаданных) не должна содержать запись в списке параметров для этого указателя.  
  
 Обратите внимание, что виртуальный метод также можно вызвать с помощью инструкции <xref:System.Reflection.Emit.OpCodes.Call>.  
  
 <xref:System.MissingMethodException> возникает, если нестатический метод с указанным именем и подписью не удалось найти в классе, связанном с `obj`, или с любым из его базовых классов. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 <xref:System.NullReferenceException> создается, если obj имеет значение null.  
  
 <xref:System.Security.SecurityException> возникает, если система безопасности не предоставляет вызывающему объекту доступ к вызываемому методу. Проверка безопасности может произойти, когда CIL преобразуется в машинный код, а не во время выполнения.  
  
> [!NOTE]
>  При вызове методов типа System. Object для типов значений рекомендуется использовать префикс `constrained` с инструкцией `callvirt`. Это избавляет от необходимости создавать разные IL в зависимости от того, переопределяет ли тип значения метод, избегая возможной проблемы управления версиями. Рекомендуется использовать префикс `constrained` при вызове методов интерфейса для типов значений, так как метод типа значения, реализующий метод интерфейса, можно изменить с помощью `MethodImpl`. Эти проблемы более подробно описаны в <xref:System.Reflection.Emit.OpCodes.Constrained> код операции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `callvirt`.  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
-   ILGenerator. Емиткалл (код операции, MethodInfo, тип [])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Предпринимает попытку привести объект, передаваемый по ссылке, к указанному классу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|74 < `T` >|касткласс `class`|Приводит объект к новому объекту типа `class`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека; Объект, на который указывает ссылка, приводится к указанному `class`.  
  
3.  В случае успеха новая ссылка на объект помещается в стек.  
  
 Инструкция `castclass` пытается привести ссылку на объект (тип `O`) на вершине стека к указанному классу. Новый класс задается маркером метаданных, указывающим нужный класс. Если класс объекта в верхней части стека не реализует новый класс (предполагая, что новый класс является интерфейсом) и не является производным классом нового класса, создается <xref:System.InvalidCastException>. Если ссылка на объект является пустой ссылкой, `castclass` завершается и возвращает новый объект как пустую ссылку.  
  
 <xref:System.InvalidCastException> создается, если obj не может быть приведен к классу.  
  
 Если не удается найти класс, возникает исключение <xref:System.TypeLoadException>. Обычно это обнаруживается при преобразовании инструкции MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `castclass`.  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения. Если они равны, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 01|цек|Отправляет 1, если `value1` равно `value2`; в противном случае отправляет 0.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` сравнивается с `value2`.  
  
4.  Если `value1` равно `value2`, 1 помещается в стек; в противном случае в стек помещается значение 0.  
  
 Инструкция `ceq` сравнивает `value1` и `value2`. Если `value1` равен `value2`, то в стек помещается 1 (типа `int32`). В противном случае в стек помещается значение 0 (типа `int32`).  
  
 Для числа с плавающей запятой `ceq` возвращает 0, если числа не упорядочены (или оба имеют значение NaN). Бесконечные значения равны самому себе.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ceq`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения. Если первое значение больше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 02|кгт|Отправляет 1, если `value1` больше `value2`; в противном случае отправляет 0.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `cgt` проверяет, превышает ли `value1` `value2`.  
  
4.  Если `value1` больше `value2`, в стек помещается значение 1; в противном случае в стек помещается значение 0.  
  
 Инструкция `cgt` сравнивает `value1` и `value2`. Если `value1` строго больше `value2`, то в стек помещается значение `int32`, равное 1. В противном случае в стек помещается значение `int32`, равное 0.  
  
-   Для чисел с плавающей запятой `cgt` возвращает 0, если числа не упорядочены (то есть если один или оба аргумента имеют значение NaN).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `cgt`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения без знака или два неупорядоченных значения. Если первое значение больше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 03|КГТ. un|Отправляет 1, если `value1` больше `value2`; в противном случае push-уведомления 0 (неподписанные значения).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `cgt.un` проверяет, превышает ли `value1` `value2`.  
  
4.  Если `value1` больше `value2`, в стек помещается значение 1; в противном случае в стек помещается значение 0.  
  
 Значение `int32`, равное 1, помещается в стек, если какой-либо из следующих `true`:  
  
 Для чисел с плавающей запятой `value1` не упорядочивается по отношению к `value2`.  
  
 Для целочисленных значений `value1` строго больше `value2`, если они считаются неподписанными числами.  
  
 В противном случае в стек помещается значение `int32`, равное 0.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `cgt.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Создает исключение <see cref="T:System.ArithmeticException" />, если значение не является конечным числом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|C3|ккфините|Вызывайте <xref:System.ArithmeticException>, если значение не является конечным числом.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек. 
  
2.  `value` извлекается из стека и выполняется инструкция `ckfinite`.  
  
3.  `value` передается обратно в стек, если исключение не создается.  
  
 `ckfinite instruction` создает исключение <xref:System.ArithmeticException> если `value` (число с плавающей запятой) является либо значением "не число" (NaN), либо значением `+-` бесконечности. `Ckfinite` оставляет значение в стеке, если исключение не возникает. Выполнение не указано, если `value` не является числом с плавающей запятой.  
  
 <xref:System.ArithmeticException> возникает, если `value` не является нормальным числом.  
  
 Обратите внимание, что специальное исключение или производный класс <xref:System.ArithmeticException> могут быть более подходящими, передавая неверное значение обработчику исключений.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ckfinite`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения. Если первое значение меньше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 04|чилийскому|Отправляет 1, если `value1` меньше `value2`; в противном случае отправляет 0.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности: 

1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `clt` тесты, если `value1` меньше `value2`.  
  
4.  Если `value1` меньше `value2`, в стек помещается 1. в противном случае в стек помещается значение 0.  
  
 Инструкция `clt` сравнивает `value1` и `value2`. Если `value1` строго меньше `value2`, то в стек помещается `int32` значение 1. В противном случае в стек помещается значение `int32`, равное 0.  
  
-   Для чисел с плавающей запятой `clt` возвращает 0, если числа не упорядочены (то есть если один или оба аргумента имеют значение NaN).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `clt`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения без знака или два неупорядоченных значения <paramref name="value1" /> и <paramref name="value2" />. Если значение <paramref name="value1" /> меньше значения <paramref name="value2" />, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 05|средство регистрации звонков. un|Отправляет 1, если `value1` меньше `value2`; в противном случае push-уведомления 0 (неподписанные значения).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `clt.un` тесты, если `value1` меньше `value2`.  
  
4.  Если `value1` меньше `value2`, в стек помещается 1. в противном случае в стек помещается значение 0.  
  
 Инструкция `clt.un` сравнивает `value1` и `value2`. Значение `int32`, равное 1, помещается в стек, если выполняется одно из следующих условий.  
  
-   `value1` строго меньше `value2` (как для `clt`).  
  
-   Для чисел с плавающей запятой `value1` не упорядочивается по отношению к `value2`.  
  
-   Для целочисленных значений `value1` строго меньше `value2`, если они считаются неподписанными числами.  
  
 В противном случае в стек помещается значение `int32`, равное 0.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `clt.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ограничивает тип, для которого был вызван виртуальный метод.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|`T`FE 16 <  >|ограниченного. `thisType`|Вызов виртуального метода для типа, ограниченного типом `T`.|  
  
 Префикс `constrained` разрешен только в инструкции `callvirt`.  
  
 В этой точке состояние стека MSIL должно быть следующим:  
  
1.  Управляемый указатель, `ptr`, помещается в стек. Тип `ptr` должен быть управляемым указателем (`&`) для `thisType`. Обратите внимание, что это отличается от случая непрефиксной `callvirt` инструкции, которая принимает ссылку на `thisType`.  
  
2.  Аргументы метода, `arg1` с помощью `argN`, помещаются в стек, так же как и в случае с непрефиксной инструкцией `callvirt`.  
  
 Префикс `constrained` предназначен для того, чтобы `callvirt` инструкции были сделаны единообразно независимо от того, является ли `thisType` типом значения или ссылочным типом.  
  
 Если `constrained` `thisType`инструкция `callvirt` `method` имеет префикс, инструкция выполняется следующим образом:  
  
-   Если `thisType` является ссылочным типом (в отличие от типа значения), `ptr` удаляется из ссылок и передается как указатель this на `callvirt` `method`.  
  
-   Если `thisType` является типом значения и `thisType` реализует `method` то `ptr` передается в неизмененном виде как указатель this на `call` `method`, для реализации `method` с `thisType`.  
  
-   Если `thisType` является типом значения, а `thisType` не реализует `method` то `ptr` разыменованы, упаковываются и передаются как указатель this в инструкцию `callvirt` `method`.  
  
 Последний случай может возникнуть, только если `method` был определен в <xref:System.Object>, <xref:System.ValueType>или <xref:System.Enum> и не переопределен `thisType`. В этом случае упаковка создает копию исходного объекта. Однако, поскольку ни один из методов <xref:System.Object>, <xref:System.ValueType>и <xref:System.Enum> изменять состояние объекта, этот факт не может быть обнаружен.  
  
 Префикс `constrained` поддерживает генераторы IL, которые создают универсальный код. Обычно инструкция `callvirt` недопустима для типов значений. Вместо этого необходимо, чтобы компиляторы IL эффективно выполняли преобразование «this», описанное выше во время компиляции, в зависимости от типа `ptr` и вызываемого метода. Однако если `ptr` является универсальным типом, неизвестным во время компиляции, это преобразование невозможно выполнить во время компиляции.  
  
 `constrained` код операции позволяет компиляторам IL выполнять вызов виртуальной функции единообразно независимо от того, является ли `ptr` типом значения или ссылочным типом. Хотя он предназначен для случая, когда `thisType` является переменной универсального типа, префикс `constrained` также работает для неуниверсальных типов и может уменьшить сложность создания виртуальных вызовов в языках, которые скрывают различие между типами значений и ссылочными типами.  
  
 Использование префикса `constrained` также позволяет избежать возможных проблем с управлением версиями с типами значений. Если префикс `constrained` не используется, должен быть выпущен другой IL в зависимости от того, переопределяет ли тип значения метод System. Object. Например, если тип значения `V` переопределяет метод Object. ToString (), выдается `call` инструкция `V.ToString()`. в противном случае выдаются инструкция `box` и инструкция `Object.ToString()` `callvirt`. Проблема управления версиями может возникнуть в первом случае, если переопределение позже удаляется, и в последнем случае, если переопределение добавляется позже.  
  
 Префикс `constrained` также можно использовать для вызова методов интерфейса для типов значений, так как метод типа значения, реализующий метод интерфейса, можно изменить с помощью `MethodImpl`. Если префикс `constrained` не используется, компилятор принудительно выбирает, к какому из методов типа значения следует выполнить привязку во время компиляции. Использование префикса `constrained` позволяет выполнить привязку MSIL к методу, реализующему метод интерфейса во время выполнения, а не во время компиляции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `constrained`.  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D3|Кредит i|Преобразование в `native int`, принудительная отправка `native int` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.i`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результат также `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32`можно потерять точность. Если `value` слишком велико для `float32 (F)`, то возвращается положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательной). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.i`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="int8" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|67|с кредитом. i1|Преобразование в `int8`, принудительная отправка `int32` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.i1`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результат также `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32`можно потерять точность. Если `value` слишком велико для `float32 (F)`, то возвращается положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательной). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.i1`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="int16" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|68|Кредитный I2|Преобразование в `int16`, принудительная отправка `int32` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.i2`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результат также `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32`можно потерять точность. Если `value` слишком велико для `float32 (F)`, то возвращается положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательной). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.i2`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|69|с просчетом. i4|Преобразование в `int32`, принудительная отправка `int32` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.i4`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результат также `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32`можно потерять точность. Если `value` слишком велико для `float32 (F)`, то возвращается положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательной). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.i4`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6A|заменяющий i8|Преобразование в `int64`, принудительная отправка `int64` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.i8`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результат также `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32`можно потерять точность. Если `value` слишком велико для `float32 (F)`, то возвращается положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательной). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.i8`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="native int" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D4|ovf. i|Преобразуйте в `native int` (в стеке как `native int`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="native int" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8A|проovf. i. un|Преобразует значение без знака в `native int` (в стеке как `native int`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i.un`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int8" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B3|ovf. i1|Преобразуйте в `int8` (в стеке как `int32`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i1`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i1`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int8" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|82|ovf. i1. un|Преобразует значение без знака в `int8` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i1.un`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i1.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int16" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B5|ovf. i2|Преобразуйте в `int16` (в стеке как `int32`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i2`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i2`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int16" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|83|ovf. i2. un|Преобразует значение без знака в `int16` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i2.un`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i2.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int32" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B7|ovf. i4|Преобразуйте в `int32` (в стеке как `int32`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i4`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i4`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int32" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|84|ovf. i4. un|Преобразует значение без знака в `int32` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i4.un`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i4.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int64" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B9|ovf. i8|Преобразуйте в `int64` (в стеке как `int64`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i8`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i8`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int64" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|85|ovf. i8. un|Преобразует значение без знака в `int64` (в стеке как `int64`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i8.un`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i8.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned native int" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D5|ovf. u|Преобразуйте в `unsigned native int` (в стеке как `native int`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned native int" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8B|ovf. u. un|Преобразует неподписанное значение в `unsigned native int` (в стеке как `native int`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u.un`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.uvf.u.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="unsigned int8" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B4|ovf. U1|Преобразуйте в `unsigned int8` (в стеке как `int32`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u1`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u1`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int8" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|86|ovf. U1. un|Преобразует значение без знака в `unsigned int8` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u1.un`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u1.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="unsigned int16" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B6|ovf. U2|Преобразуйте в `unsigned int16` (в стеке как `int32`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u2`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u2`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int16" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|87|проovf. U2. un|Преобразует значение без знака в `unsigned int16` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u2.un`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u2.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B8|ovf. U4|Преобразуйте в `unsigned int32` (в стеке как `int32`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u4`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u4`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|88|ovf. U4. un|Преобразует значение без знака в `unsigned int32` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u4.un`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u4.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned int64" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|Бизнес|ovf. u8|Преобразуйте в `unsigned int64` (в стеке как `int64`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u8`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u8`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int64" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|89|ovf. u8. un|Преобразует значение без знака в `unsigned int64` (в стеке как `int64`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u8.un`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, тогда результат также `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u8.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразование целочисленного значения без знака на вершине стека вычислений в <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|76|Рассчет. r. un|Преобразует целое число без знака в число с плавающей запятой, отправляя `F` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.r.un`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результат также `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32`можно потерять точность. Если `value` слишком велико для `float32 (F)`, то возвращается положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательной). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемый `result` не определен. `conv.r.un` операция принимает целое число из стека, интерпретирует его как неподписанное и заменяет его на число с плавающей запятой, представляющее целое число: либо `float32`, если это достаточно, чтобы представить целое число без потери точности, или, в противном случае `float64`.  
  
 При использовании этого поля исключения никогда не возникают.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.r.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6B|с кредитом. R4|Преобразование в `float32`, принудительная отправка `F` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.r4`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результат также `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32`можно потерять точность. Если `value` слишком велико для `float32 (F)`, то возвращается положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательной). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.r4`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="float64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6C|с кредитом. R8|Преобразование в `float64`, принудительная отправка `F` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.r8`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результат также `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32`можно потерять точность. Если `value` слишком велико для `float32 (F)`, то возвращается положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательной). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.r8`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned native int" />, а затем расширяет его до <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|E0|Кредит u|Преобразование в `unsigned native int`, принудительная отправка `native int` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.u`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результат также `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32`можно потерять точность. Если `value` слишком велико для `float32 (F)`, то возвращается положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательной). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.u`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int8" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D2|с кредитом. U1|Преобразование в `int8`, принудительная отправка `int32` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.u1`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результат также `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32`можно потерять точность. Если `value` слишком велико для `float32 (F)`, то возвращается положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательной). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.u1`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int16" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D1|Кредитный. U2|Преобразование в `int16`, принудительная отправка `int32` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.u2`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результат также `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32`можно потерять точность. Если `value` слишком велико для `float32 (F)`, то возвращается положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательной). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.u2`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int32" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6D|U4|Преобразование в `unsigned int32`, принудительная отправка `int32` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.u4`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результат также `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32`можно потерять точность. Если `value` слишком велико для `float32 (F)`, то возвращается положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательной). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.u4`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int64" />, а затем расширяет его до <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6E|U8|Преобразование в `int64`, принудительная отправка `int64` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.u8`ный код операции преобразует `value` на вершине стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результат также `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32`можно потерять точность. Если `value` слишком велико для `float32 (F)`, то возвращается положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательной). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.u8`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует заданное число байт из исходного адреса в конечный.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|Копирование данных из одного блока памяти в другой.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес назначения помещается в стек.  
  
2.  Исходный адрес помещается в стек.  
  
3.  Число байтов для копирования помещается в стек.  
  
4.  Число байтов, исходный адрес и адрес назначения извлекаются из стека; указанное число байтов копируется из исходного адреса в конечный адрес.  
  
 Инструкция `cpblk` копирует число байт (тип `unsigned int32`) из исходного адреса (типа `*`, `native int`или `&`) в адрес назначения (типа `*`, `native int`или `&`). Поведение `cpblk` не указано, если области источника и назначения перекрываются.  
  
 `cpblk` предполагает, что исходные и целевые адреса выровнены по естественному размеру компьютера. Перед инструкцией `cpblk` может следовать инструкция `unaligned.<prefix>`, указывающая, что источник или назначение не совпадают.  
  
 Операция инструкции `cpblk` может быть изменена непосредственно перед инструкцией <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксом.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `cpblk`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует тип значения по адресу объекта (с типом <see langword="&amp;" />, <see langword="*" /> или <see langword="native int" />) и помещает его по адресу конечного объекта (с типом <see langword="&amp;" />, <see langword="*" /> или <see langword="native int" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|70 < `T` >|кпобж `classTok`|Копирует тип значения из исходного объекта в целевой объект.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на целевой объект помещается в стек.  
  
2.  Ссылка на исходный объект помещается в стек.  
  
3.  Две ссылки на объекты извлекаются из стека; Тип значения по адресу исходного объекта копируется на адрес целевого объекта.  
  
 Поведение `cpobj` не указано, если исходные и целевые ссылки на объекты не являются указателями на экземпляры класса, представленного маркером класса `classTok` (`typeref` или `typedef`) или если `classTok` не представляет тип значения.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `cpobj`.  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно значение на другое и помещает результат в стек вычислений как число с плавающей запятой (с типом <see langword="F" />) или как частное (с типом <see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5B|div|Делит два значения, чтобы вернуть результат частного или с плавающей точкой.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` делится на `value2`.  
  
4.  Результат помещается в стек.  
  
 `result` = `value1` div value2 удовлетворяет следующим условиям:  
  
 &#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;и:  
  
 Sign (`result`) = +, если знак (`value1`) = Sign (`value2`) или-, if знак (`value1`) ~ = Sign (`value2`)  
  
 Инструкция `div` вычислит результат и помещает его в стек.  
  
 Деление целых чисел усекается до нуля.  
  
 Деление конечного числа на ноль приводит к правильному бесконечному значению со знаком.  
  
 Деление нуля на ноль или бесконечность по бесконечности приводит к получению значения NaN (нечисловое). Любое число, деленное на бесконечность, приведет к нулевому значению.  
  
 Целочисленные операции вызывают <xref:System.ArithmeticException>, если результат не может быть представлен типом результата. Это может произойти, если `value1` является максимальным отрицательным значением, а `value2` равно-1.  
  
 Целочисленные операции создают <xref:System.DivideByZeroException>, если `value2` равен нулю.  
  
 Обратите внимание, что на платформах на базе процессоров Intel при вычислениях (minint div-1) создается <xref:System.OverflowException>. Операции с плавающей запятой никогда не создают исключение (они создают значений NaN или бесконечность).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `div`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно целочисленное значение без знака на другое и помещает результат (<see langword="int32" />) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5C|Div. un|Делит два значения без знака, возвращая частное.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` делится на `value2`.  
  
4.  Результат помещается в стек.  
  
 Инструкция `div.un` выполняет вычисление `value1` деления на `value2`, как целые числа без знака, и помещает `result` в стек.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `div.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует текущее верхнее значение в стеке вычислений и помещает копию в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|25|DUP|Дублирует значение в верхней части стека.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека для дублирования.  
  
3.  `value` помещается обратно в стек.  
  
4.  Повторяющееся значение помещается в стек.  
  
 Инструкция `dup` дублирует верхний элемент стека и оставляет два одинаковых значения на вершине.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `dup`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление из предложения <see langword="filter" /> исключения обратно в обработчик исключений CLI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 11|Команда endfilter|Завершающее предложение фильтра обработки исключений SEH.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; `endfilter` выполняется, и управление передается обработчику исключений.  
  
 в предложении фильтра возвращается `Value` (который должен иметь тип `int32` и является одним из определенного набора значений). Он должен быть одним из следующих:  
  
-   `exception_continue_search` (`value` = 0), чтобы продолжить поиск обработчика исключений  
  
-   `exception_execute_handler` (`value` = 1) для запуска второго этапа обработки исключений, в котором блоки finally выполняются до тех пор, пока не будет найден обработчик, связанный с этим предложением фильтра. После обнаружения выполняется обработчик.  
  
 Другие целочисленные значения приведут к неопределенным результатам.  
  
 Точка входа фильтра, как показано в таблице исключений метода, должна быть первой инструкцией в блоке кода фильтра. Инструкция `endfilter` должна быть последней инструкцией в блоке кода фильтра (следовательно, для одного блока фильтра может быть только один `endfilter`). После выполнения инструкции `endfilter` управление логически передается обратно механизму обработки исключений CLI.  
  
 Управление не может быть передано в блок фильтра, за исключением механизма исключения. Управление не может быть передано из блока фильтра, за исключением использования инструкции `throw` или выполнения последней инструкции `endfilter`. Нельзя внедрить блок `try` в блок `filter`. Если в блоке `filter` возникает исключение, оно перехватывается и возвращается значение 0 (`exception_continue_search`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `endfilter`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление из предложения <see langword="fault" /> или <see langword="finally" /> блока исключения обратно обработчику исключений CLI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DC|Команда endfinally<br /><br /> ендфаулт|Завершает выражение `finally` или `fault` блока исключения.|  
  
 Для этой инструкции нет поведений перехода стека.  
  
 `Endfinally` и `endfault` сигналают конец предложения `finally` или `fault`, чтобы очистка стека могла продолжаться до вызова обработчика исключений. Инструкция `endfinally` или `endfault` передает управление механизму исключения CLI. Затем механизм выполняет поиск следующего предложения `finally` в цепочке, если защищенный блок был завершен с помощью инструкции leave. Если защищенный блок завершился с исключением, интерфейс командной строки выполнит поиск следующего `finally` или `fault`или введите обработчик исключений, выбранный во время первого прохода обработки исключений.  
  
 Инструкция `endfinally` может быть только лексической в блоке `finally`. В отличие от инструкции `endfilter`, нет необходимости в конце блока с инструкцией `endfinally` и при необходимости может быть столько `endfinally` инструкций в блоке. Эти же ограничения относятся к инструкции `endfault` и блоку `fault`.  
  
 Элемент управления не может быть передан в блок `finally` (или `fault`), за исключением механизма исключения. Элемент управления не может быть передан из блока `finally` (или `fault`), за исключением использования инструкции `throw` или выполнения инструкции `endfinally` (или `endfault`). В частности, нельзя попадать в блок `finally` (или `fault`) или выполнить инструкцию <xref:System.Reflection.Emit.OpCodes.Ret> или <xref:System.Reflection.Emit.OpCodes.Leave> в блоке `finally` (или `fault`).  
  
 Обратите внимание, что инструкции `endfault` и `endfinally` являются псевдонимами, они соответствуют одному коду операции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `endfinally` (`endfault`), а также метод `ILGenerator` <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.  
  
-   ILGenerator. Emit (код операции)  
  
-   ILGenerator. Ендексцептионблокк ()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Инициализирует блок памяти с определенным адресом, присваивая его начальному значению с заданным размером.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 18|initblk|Установите для каждого расположения в блоке памяти заданное значение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Начальный адрес помещается в стек.  
  
2.  Значение инициализации помещается в стек.  
  
3.  Число байтов для инициализации помещается в стек.  
  
4.  Число байтов, значение инициализации и начальный адрес извлекаются из стека, а инициализация выполняется в соответствии с их значениями.  
  
 Инструкция `initblk` задает число (`unsigned int32`) байтов, начиная с указанного адреса (типа `native int`, `&`или `*`) и до значения инициализации (типа `unsigned int8`). `initblk` предполагает, что начальный адрес соответствует естественному размеру компьютера.  
  
 Операция `initblk` инструкции может быть изменена непосредственно перед <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксной инструкцией.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `initblk`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Инициализирует каждое поле типа значения с определенным адресом пустой ссылкой или значением 0 соответствующего простого типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|`T`< FE 15  >|`initobj` `typeTok`|Инициализирует тип значения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес типа значения для инициализации помещается в стек.  
  
2.  Адрес извлекается из стека; Тип значения по указанному адресу инициализируется как тип `typeTok`.  
  
 Инструкция `initobj` инициализирует каждое поле типа значения, заданное отправленным адресом (типа `native int`, `&`или `*`), на пустую ссылку или значение 0 соответствующего типа-примитива. После вызова этого метода экземпляр готов к вызову метода-конструктора. Если `typeTok` является ссылочным типом, эта инструкция имеет тот же результат, что и `ldnull`, за которым следует `stind.ref`.  
  
 В отличие от <xref:System.Reflection.Emit.OpCodes.Newobj>`initobj` не вызывает метод конструктора. `Initobj` предназначен для инициализации типов значений, а `newobj` используется для выделения и инициализации объектов.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `initobj`.  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Проверяет, является ли ссылка на объект (с типом <see langword="O" />) экземпляром определенного класса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|75 < `T` >|исинст `class`|Проверяет, является ли ссылка на объект экземпляром `class`, возвращая либо пустую ссылку, либо экземпляр этого класса или интерфейса.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и проверяется на наличие экземпляра класса, переданного в `class`.  
  
3.  Результат (ссылка на объект или пустая ссылка) помещается в стек.  
  
 `Class` — это маркер метаданных, указывающий нужный класс. Если класс объекта в верхней части стека реализует `class` (если `class` является интерфейсом) или является производным классом `class` (если `class` является регулярным классом), то он приводится к типу `class`, а результат передается в стек точно так же, как будто <xref:System.Reflection.Emit.OpCodes.Castclass> был вызван. В противном случае в стек помещается пустая ссылка. Если ссылка на объект является пустой ссылкой, то `isinst` также возвращает пустую ссылку.  
  
 Если не удается найти класс, возникает исключение <xref:System.TypeLoadException>. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `isinst`.  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Прекращает выполнение текущего метода и переходит к заданному методу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|27 < `T` >|Переход `method`|Завершение работы текущего метода и переход к указанному методу.|  
  
 Для этой инструкции нет поведений перехода стека.  
  
 Инструкция `jmp` (переход) передает управление методу, указанному `method`, который является маркером метаданных для ссылки на метод. Текущие аргументы передаются в целевой метод.  
  
 При выполнении этой инструкции стек вычислений должен быть пустым. Соглашение о вызовах, число и тип аргументов в адресе назначения должны соответствовать требованиям текущего метода.  
  
 Инструкция `jmp` не может использоваться для передачи управления из `try`, `filter`, `catch`или блока `finally`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `jmp`.  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент (на который ссылается указанное значение индекса) в стек.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|`unsigned int16`< FE 09  >|лдарг `index`|Загрузка аргумента с `index` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента в `index` помещается в стек.  
  
 Инструкция `ldarg` помещает аргумент, индексируемый по `index`, где аргументы индексируются от 0 до назад, в стек вычислений. Инструкцию `ldarg` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Для процедур, принимающих список аргументов переменной длины, инструкция `ldarg` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры (Дополнительные сведения см. в инструкции по <xref:System.Reflection.Emit.OpCodes.Arglist>).  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg`.  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 0 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|02|лдарг. 0|Загрузить аргумент 0 в стек|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента с индексом 0 помещается в стек.  
  
 Инструкция `ldarg.0` является эффективной кодировкой для загрузки значения аргумента по индексу 0.  
  
 Инструкция `ldarg.0` помещает аргумент с индексом 0 в стек вычислений. Инструкцию `ldarg.0` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg.0`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 1 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|03|лдарг. 1|Загрузка аргумента 1 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента с индексом 1 помещается в стек.  
  
 Инструкция `ldarg.1` является эффективной кодировкой для загрузки значения аргумента по индексу 1.  
  
 Инструкция `ldarg.1` помещает аргумент с индексом 1 в стек вычислений. Инструкцию `ldarg.1` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg.1`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 2 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|04|лдарг. 2|Загрузка аргумента 2 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента с индексом 2 помещается в стек.  
  
 Инструкция `ldarg.2` является эффективной кодировкой для загрузки значения аргумента по индексу 2.  
  
 Инструкция `ldarg.2` помещает аргумент с индексом 2 в стек вычислений. Инструкцию `ldarg.2` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg.2`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 3 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|05|лдарг. 3|Загрузка аргумента 3 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента с индексом 3 помещается в стек.  
  
 Инструкция `ldarg.3` является эффективной кодировкой для загрузки значения аргумента по индексу 3.  
  
 Инструкция `ldarg.3` помещает аргумент с индексом 3 в стек вычислений. Инструкцию `ldarg.3` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg.3`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент (на который ссылается указанное короткое значение индекса) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|`unsigned int8`0E <  >|`index` лдарг. s|Загрузка аргумента в `index` в стеке, короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента в `index` помещается в стек.  
  
 Инструкция `ldarg.s` — это эффективная кодировка для загрузки аргументов, индексируемых от 4 до 255.  
  
 Инструкция `ldarg.s` помещает аргумент, индексируемый по `index`, где аргументы индексируются от 0 до назад, в стек вычислений. Инструкцию `ldarg.s` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Для процедур, принимающих список аргументов переменной длины, инструкция `ldarg.s` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры (Дополнительные сведения см. в инструкции по <xref:System.Reflection.Emit.OpCodes.Arglist>).  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg.s`.  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает адрес аргумента в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< FE 0A `unsigned int16` >|лдарга `index`|Получение адреса аргумента, индексированного по `index`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес `addr` аргумента, индексируемого `index`, помещается в стек.  
  
 Инструкция `ldarga` извлекает адрес (типа `*`) аргумента, индексируемого по `index`, где аргументы индексируются от 0 до более поздних. Адрес `addr` всегда согласуется с естественной границей на целевом компьютере.  
  
 Для процедур, принимающих список аргументов переменной длины, инструкция `ldarga` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры.  
  
 `ldarga` используется для передачи параметров by-ref. В других случаях следует использовать <xref:System.Reflection.Emit.OpCodes.Ldarg> и <xref:System.Reflection.Emit.OpCodes.Starg>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarga`.  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает адрес аргумента (короткая форма) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` >|`index` лдарга. s|Получение адреса аргумента, индексированного по `index`краткой форме.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес `addr` аргумента, индексируемого `index`, помещается в стек.  
  
 `ldarga.s` (краткая форма `ldarga`) следует использовать для номеров аргументов от 0 до 255, и это более эффективная кодировка.  
  
 Инструкция `ldarga.s` извлекает адрес (типа`*`) аргумента, индексируемого по `index`, где аргументы индексируются от 0 до более поздних. Адрес `addr` всегда согласуется с естественной границей на целевом компьютере.  
  
 Для процедур, принимающих список аргументов переменной длины, инструкция `ldarga.s` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры.  
  
 `ldarga.s` используется для передачи параметров by-ref. В других случаях следует использовать <xref:System.Reflection.Emit.OpCodes.Ldarg_S> и <xref:System.Reflection.Emit.OpCodes.Starg_S>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarga.s`.  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="int32" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|20 < `int32` >|LDC. i4 `num`|Помещает значение `num` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение `num` помещается в стек.  
  
 Обратите внимание, что существуют специальные короткие (и, следовательно, более эффективные) кодировки для целых чисел от-128 до 127 и особенно короткие кодировки для-1 – 8. Все короткие кодировки помещают в стек 4-байтовые целые числа. Более длинные кодировки используются для 8-байтовых целых чисел, 4 и 8 байт с плавающей запятой, а также для 4 байтовых значений, которые не помещаются в короткие формы. Существует три способа отправки 8-байтовой целочисленной константы в стек.  
  
 1. Используйте <xref:System.Reflection.Emit.OpCodes.Ldc_I8>ную инструкцию для констант, которые должны быть выражены более чем на 32 бит.  
  
 2. Используйте инструкцию <xref:System.Reflection.Emit.OpCodes.Ldc_I4>, за которой следует <xref:System.Reflection.Emit.OpCodes.Conv_I8> для констант, требующих от 9 до 32 бит.  
  
 3. Используйте краткую инструкцию формы, за которой следует <xref:System.Reflection.Emit.OpCodes.Conv_I8> для констант, которые могут быть выражены в 8 или меньшем количестве битов.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4`.  
  
-   ILGenerator. Emit (код операции, int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 0 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|16|LDC. i 4.0|Помещает 0 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 0 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целого значения 0. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.0`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 1 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|17|LDC. i 4.1|Помещает 1 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 1 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целого значения 1. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.1`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 2 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|18|LDC. i 4.2|Помещает 2 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 2 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленного значения 2. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.2`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 3 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|19|LDC. i 4.3|Помещает 3 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 3 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленного значения 3. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.3`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 4 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|Sr1a|LDC. i 4.4|Передает 4 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 4 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленного значения 4. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.4`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 5 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1B|LDC. i 4.5|Передает 5 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 5 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целого значения 5. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.5`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 6 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1C|LDC. i 4.6|Помещает 6 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 6 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целого значения 6. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.6`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 7 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1D|LDC. i 4.7|Помещает 7 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 7 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленного значения 7. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.7`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 8 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1E|LDC. i 4.8|Отправляет 8 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 8 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленного значения 8. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.8`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение –1 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|15|LDC. i4. M1|Передает значение 1 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение-1 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целого значения-1. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.m1`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="int8" /> в стек вычислений как <see langword="int32" /> (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1F < `int8` >|LDC. i4. s `num`|Помещает `num` в стек как `int32`, короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение `num` помещается в стек.  
  
 `ldc.i4.s` является более эффективной кодировкой для отправки целых чисел с-128 по 127 в стек вычислений.  
  
Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузки методов могут использовать код операции `ldc.i4.s`.
  
- <xref:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Byte)?displayProperty=nameWithType>
- <xref:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.SByte)?displayProperty=nameWithType>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="int64" /> в стек вычислений как <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|21 < `int64` >|LDC. i8 `num`|Помещает `num` в стек как `int64`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение `num` помещается в стек.  
  
 Эта кодировка помещает `int64` значение в стек.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i8`.  
  
-   ILGenerator. Emit (код операции, длинный)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="float32" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|22 < `float32` >|LDC. R4 `num`|Помещает `num` в стек как `F`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение `num` помещается в стек.  
  
 Эта кодировка помещает `float32` значение в стек.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.r4`.  
  
-   ILGenerator. Emit (код операции, одиночный)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="float64" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|23 < `float64` >|LDC. R8 `num`|Помещает `num` в стек как `F`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение `num` помещается в стек.  
  
 Эта кодировка помещает `float64` значение в стек.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.r8`.  
  
-   ILGenerator. Emit (код операции, Double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент с заданным индексом массива на вершину стека вычислений в качестве типа, указанного в инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< A3 `T` >|лделем `typeTok`|Загружает элемент в `index` в верхней части стека как `typeTok`типа.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами, поэтому они представлены значением типа `O`.  
  
 Тип возвращаемого значения задается токеном `typeTok` в инструкции.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем верхняя граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem`.  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, имеющий тип <see langword="native int" />, на вершину стека вычислений как <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|97|лделем. i|Загружает элемент с типом `native int` в `index` верхней части стека как `native int`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.i` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i` — `native int`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.i`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int8" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|90|лделем. i1|Загружает элемент с типом `int8` в `index` верхней части стека как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.i1` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i1` — `int8`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.i1`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int16" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|92|лделем. i2|Загружает элемент с типом `int16` в `index` верхней части стека как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.i2` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i2` — `int16`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.i2`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int32" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|94|лделем. i4|Загружает элемент с типом `int32` в `index` верхней части стека как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.i4` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i4` — `int32`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.i4`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int64" /> с заданным индексом массива на вершину стека вычислений как <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|96|лделем. i8|Загружает элемент с типом `int64` в `index` верхней части стека как `int64`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.i8` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i8` — `int64`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.i8`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, имеющий тип <see langword="float32" />, на вершину стека вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|98|лделем. R4|Загружает элемент с типом, `float32` в `index` верхней части стека в виде `F`типа.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.r4` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.r4` — `float32`.  
  
 Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.r4`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, имеющий тип <see langword="float64" />, на вершину стека вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|99|лделем. R8|Загружает элемент с типом, `float64` `index` в верхней части стека как тип `F`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.r8` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.r8` — `float64`.  
  
 Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.r8`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, содержащий ссылку на объект, на вершину стека вычислений как <see langword="O" /> (ссылка на объект).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9A|лделем. ref|Загружает элемент со ссылкой на объект в `index` на вершину стека как `O`типа.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.ref` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.ref` имеет тип `O` (ссылка на объект).  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.ref`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="unsigned int8" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|91|лделем. U1|Загружает элемент с типом `unsigned int8` в `index` верхней части стека как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.u1` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.u1` — `int8`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.u1`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="unsigned int16" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|93|лделем. U2|Загружает элемент с типом `unsigned int16` по индексу в верхней части стека как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.u2` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.u2` — `int16`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.u2`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="unsigned int32" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|95|лделем. U4|Загружает элемент с типом `unsigned int32` по индексу в верхней части стека как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.u4` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.u4` — `int32`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> создается, если массив не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.u4`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает адрес элемента массива с заданным индексом на вершину стека вычислений как <see langword="&amp;" /> (управляемый указатель).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8F < `T` >|`class` ldelema|Загружает адрес элемента массива с `index` на вершину стека вычислений как `&` (управляемый указатель).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск адреса, хранящегося в позиции `index` в `array`.  
  
4.  Адрес помещается в стек.  
  
 `ldelema` используется для получения адреса объекта по определенному индексу в массиве объектов (типа `class`). Инструкция `ldelema` загружает адрес значения по индексу `index` (тип `native int`) в одномерном массиве с отсчетом от нуля `array` и помещает его в начало стека. Массивы являются объектами и поэтому представлены значением типа `O`. Значение должно быть типа `class` передано с инструкцией.  
  
 Возвращаемое значение для `ldelema` является управляемым указателем (тип `&`).  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelema`.  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет поиск значения поля в объекте, ссылка на который находится в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld `field`|Помещает значение поля в указанном объекте в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект (или указатель) помещается в стек.  
  
2.  Ссылка на объект (или указатель) извлекается из стека; Найдено значение указанного поля в объекте.  
  
3.  Значение, хранящееся в поле, помещается в стек.  
  
 Инструкция `ldfld` помещает значение поля, расположенного в объекте, в стек. Объект должен находиться в стеке как ссылка на объект (тип `O`), управляемый указатель (тип `&`), неуправляемый указатель (тип `native int`), временный указатель (тип `*`) или экземпляр типа значения. Использование неуправляемого указателя в проверяемом коде не допускается. Поле объекта задается маркером метаданных, который должен ссылаться на элемент поля. Тип возвращаемого значения совпадает с типом, связанным с полем. Поле может быть либо полем экземпляра (в этом случае объект не должен быть пустой ссылкой), либо статическим полем.  
  
 Оператору `ldfld` может предшествовать один или оба префикса <xref:System.Reflection.Emit.OpCodes.Unaligned> и <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.NullReferenceException> создается, если объект имеет значение NULL и поле не является статическим.  
  
 <xref:System.MissingFieldException> создается, если указанное поле не найдено в метаданных. Обычно это проверяется при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldfld`.  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ищет адрес поля в объекте, ссылка на который находится в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7C < `T` >|лдфлда `field`|Помещает адрес `field` в указанный объект в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект (или указатель) помещается в стек.  
  
2.  Ссылка на объект (или указатель) извлекается из стека; найден адрес указанного поля в объекте.  
  
3.  Адрес указанного поля помещается в стек.  
  
 Инструкция `ldflda` помещает адрес поля, расположенного в объекте, в стек. Объект должен находиться в стеке как ссылка на объект (тип `O`), управляемый указатель (тип `&`), неуправляемый указатель (тип `native int`), временный указатель (тип `*`) или экземпляр типа значения. Использование неуправляемого указателя в проверяемом коде не допускается. Поле объекта задается маркером метаданных, который должен ссылаться на элемент поля.  
  
 Значение, возвращаемое `ldflda`, является управляемым указателем (типом `&`), если объект не помещается в стек как неуправляемый указатель, в этом случае обратный адрес также является неуправляемым указателем (тип `native int`).  
  
 Оператору `ldflda` может предшествовать один или оба префикса <xref:System.Reflection.Emit.OpCodes.Unaligned> и <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.InvalidOperationException> создается, если объект не находится в домене приложения, из которого осуществляется доступ. Не удается загрузить адрес поля, не находящегося внутри доступного домена приложения.  
  
 <xref:System.NullReferenceException> создается, если объект имеет значение NULL и поле не является статическим.  
  
 <xref:System.MissingFieldException> создается, если указанное поле не найдено в метаданных. Обычно это проверяется при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldflda`.  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений неуправляемый указатель (с типом <see langword="native int" />) на машинный код, реализующий заданный метод.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|`T`< FE 06  >|ldftn `method`|Помещает указатель на метод, на который ссылается `method` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Неуправляемый указатель на конкретный метод помещается в стек.  
  
 Конкретный метод (`method`) может быть вызван с помощью инструкции <xref:System.Reflection.Emit.OpCodes.Calli>, если она ссылается на управляемый метод (или на заглушку, переход от управляемого кода к неуправляемому).  
  
 Возвращаемое значение указывает на машинный код, используя соглашение о вызовах CLR. Этот указатель метода не должен передаваться в неуправляемый машинный код в качестве подпрограммы обратного вызова.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldftn`.  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="native int" /> в стек вычислений как <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4D|ldind. i|Загружает значение `native int` по адресу `addr` в стек как `native int`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.i` косвенно загружает `native int` значение из указанного адреса (типа `native int`, `&`или *) в стек как `native int`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. инструкцию <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.i`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int8" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|46|ldind. i1|Загружает значение `int8` по адресу `addr` в стек как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек. 
  
 Инструкция `ldind.i1` косвенно загружает `int8` значение из указанного адреса (типа `native int`, `&`или *) в стек как `int32`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. инструкцию <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.i1`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int16" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|48|ldind. i2|Загружает значение `int16` по адресу `addr` в стек как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.i2` косвенно загружает `int16` значение из указанного адреса (типа `native int`, `&`или *) в стек как `int32`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. инструкцию <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.i2`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int32" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4A|ldind. i4|Загружает значение `int32` по адресу `addr` в стек как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.i4` косвенно загружает `int32` значение из указанного адреса (типа `native int`, `&`или *) в стек как `int32`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. инструкцию <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.i4`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int64" /> в стек вычислений как <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4C|ldind. i8|Загружает значение `int64` по адресу `addr` в стек как `int64`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.i8` косвенно загружает `int64` значение из указанного адреса (типа `native int`, `&`или *) в стек как `int64`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. инструкцию <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.i8`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="float32" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4E|ldind. R4|Загружает значение `float32` по адресу `addr` в стек как `F`типа.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.r4` косвенно загружает `float32` значение из указанного адреса (типа `native int`, `&`или *) в стек как `F`типа.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. инструкцию <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.r4`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="float64" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4F|ldind. R8|Загружает значение `float64` по адресу `addr` в стек как `F`типа.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.r8` косвенно загружает `float64` значение из указанного адреса (типа `native int`, `&`или *) в стек как `float64`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. инструкцию <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.r8`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку в стек вычислений ссылки на объект как <see langword="O" /> (ссылка на объект).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|50|ldind. ref|Загружает ссылку на объект по адресу `addr` в стек как тип `O`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; Ссылка на объект, расположенная по адресу, выбирается.  
  
3.  Извлеченная ссылка помещается в стек.  
  
 Инструкция `ldind.ref` косвенно загружает ссылку на объект с указанным адресом (типа `native int`, `&`или *) в стек как `O`типа.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. инструкцию <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.ref`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="unsigned int8" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|47|ldind. U1|Загружает значение `unsigned int8` по адресу `addr` в стек как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.u1` косвенно загружает `unsigned int8` значение из указанного адреса (типа`native int`, `&`или *) в стек как `int32`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. инструкцию <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.u1`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="unsigned int16" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|49|ldind. U2|Загружает значение `unsigned int16` по адресу `addr` в стек как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.u2` косвенно загружает `unsigned int16` значение из указанного адреса (типа `native int`, `&`или *) в стек как `int32`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. инструкцию <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.u2`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="unsigned int32" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4B|ldind. U4|Загружает значение `unsigned int32` по адресу `addr` в стек как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.u4` косвенно загружает `unsigned int32` значение из указанного адреса (типа `native int`, `&`или *) в стек как `int32`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти (см. инструкцию <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.u4`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений сведения о числе элементов одномерного массива с индексацией от нуля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8E|лдлен|Помещает в стек значение длины (типа `natural unsigned int`) массива.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект массива помещается в стек.  
  
2.  Ссылка на массив извлекается из стека, а длина вычислена.  
  
3.  Длина помещается в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Длина возвращается в виде `natural unsigned int`.  
  
 <xref:System.NullReferenceException> создается, если ссылка на массив является пустой ссылкой.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldlen`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с указанным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< FE 0C `unsigned int16` >|требовалась ldloc `index`|Загружает локальную переменную по индексу `index` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной по указанному индексу помещается в стек.  
  
 Инструкция `ldloc` передает содержимое номера локальной переменной по переданному индексу в стек вычислений, где локальные переменные нумеруются 0 – назад. Локальные переменные инициализируются значением 0 перед вводом метода только в том случае, если флаг инициализации метода имеет значение true. Возможны локальные переменные 65 535 (2 ^ 16-1) (0 – 65534). Индекс 65 535 является недопустимым, так как вероятные реализации будут использовать 2-байтовое целое число для записи как индекса локального объекта, так и общего числа локальных переменных для данного метода. Если индекс 65535 был сделан допустимым, для записи числа локальных переменных в таком методе потребуется более широкое целое число.  
  
 Инструкции `ldloc.0`, `ldloc.1`, `ldloc.2`и `ldloc.3` обеспечивают эффективную кодировку для доступа к первым четырем локальным переменным.  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. См. раздел I. локальные переменные размером менее 4 байт развернуты до типа `int32` при загрузке в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузки методов могут использовать код операции `ldloc`.  
  
-   ILGenerator. Emit (код операции, LocalBuilder)  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|06|требовалась ldloc. 0|Загружает в стек вычислений локальную переменную с индексом 0.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной в индексе 0 помещается в стек.  
  
 `ldloc.0` является особенно эффективным кодированием для <xref:System.Reflection.Emit.OpCodes.Ldloc>, что позволяет получить доступ к локальной переменной по индексу 0.  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. Локальные переменные, размер которых меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloc.0`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|07|требовалась ldloc. 1|Загружает в стек вычислений локальную переменную с индексом 1.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной в индексе 1 помещается в стек.  
  
 `ldloc.1` является особенно эффективным кодированием для <xref:System.Reflection.Emit.OpCodes.Ldloc>, что позволяет получить доступ к локальной переменной по индексу 1.  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. Локальные переменные, размер которых меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloc.1`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|08|требовалась ldloc. 2|Загружает в стек вычислений локальную переменную с индексом 2.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной в индексе 2 помещается в стек.  
  
 `ldloc.2` является особенно эффективным кодированием для <xref:System.Reflection.Emit.OpCodes.Ldloc>, что позволяет получить доступ к локальной переменной по индексу 2.  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. Локальные переменные, размер которых меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloc.2`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|09|требовалась ldloc. 3|Загружает в стек вычислений локальную переменную с индексом 3.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной в индексе 3 помещается в стек.  
  
 `ldloc.3` является особенно эффективным кодированием для <xref:System.Reflection.Emit.OpCodes.Ldloc>, что позволяет получить доступ к локальной переменной по индексу 3.  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. Локальные переменные, размер которых меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloc.3`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с указанным индексом (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|`index` требовалась ldloc. s|Загружает локальную переменную по индексу `index` в стек, короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной по указанному индексу помещается в стек.  
  
 Инструкция `ldloc.s` передает содержимое номера локальной переменной по переданному индексу в стек вычислений, где локальные переменные нумеруются 0 – назад. Локальные переменные инициализируются значением 0 перед входом в метод, если флаг инициализации метода имеет значение true. В краткой форме имеется 256 (2 ^ 8) локальных переменных (0-255), что является более эффективной кодировкой, чем `ldloc`.  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. См. раздел I. локальные переменные размером менее 4 байт развернуты до типа `int32` при загрузке в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузки методов могут использовать код операции `ldloc.s`.  
  
-   ILGenerator. Emit (код операции, LocalBuilder)  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений адрес локальной переменной с указанным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|`unsigned int16`< FE OD  >|лдлока `index`|Загружает адрес локальной переменной в `index` в стек вычислений.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес, хранящийся в локальной переменной по указанному индексу, помещается в стек.  
  
 Инструкция `ldloca` помещает в стек адрес локальной переменной с переданным индексом, где локальные переменные нумеруются 0 – назад. Значение, помещаемое в стек, уже правильно согласовано для использования с такими инструкциями, как <xref:System.Reflection.Emit.OpCodes.Ldind_I> и <xref:System.Reflection.Emit.OpCodes.Stind_I>. Результатом является временный указатель (тип `*`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloca`.  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений адрес локальной переменной с указанным индексом (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|`index` лдлока. s|Загружает адрес локальной переменной в `index` в стек вычислений, короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес, хранящийся в локальной переменной по указанному индексу, помещается в стек.  
  
 Инструкция `ldloca.s` помещает в стек адрес локальной переменной с переданным индексом, где локальные переменные нумеруются 0 – назад. Значение, помещаемое в стек, уже правильно согласовано для использования с такими инструкциями, как <xref:System.Reflection.Emit.OpCodes.Ldind_I> и <xref:System.Reflection.Emit.OpCodes.Stind_I>. Результатом является временный указатель (тип `*`).  
  
 Инструкция `ldloca.s` предоставляет эффективную кодировку для использования с локальными переменными от 0 до 255.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloca.s`.  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений пустую ссылку (тип <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|14|требовался ldnull|Отправка пустой ссылки на стек|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на пустой объект помещается в стек.  
  
 `ldnull` отправляет в стеке пустую ссылку (тип `O`). Используется для инициализации расположений перед заполнением данными или в случае, когда они становятся нерекомендуемыми.  
  
 `ldnull` предоставляет пустую ссылку, которая не зависит от размера.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldnull`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует объект с типом значения, размещенный по указанному адресу, на вершину стека вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|Копирование экземпляра типа значения `class` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес объекта типа значения помещается в стек.  
  
2.  Адрес извлекается из стека, и происходит поиск экземпляра по определенному адресу.  
  
3.  Значение объекта, хранящегося в этом адресе, помещается в стек.  
  
 Инструкция `ldobj` используется для передачи типа значения в качестве параметра.  
  
 Инструкция `ldobj` копирует значение, на которое указывает `addrOfValObj` (типа `&`, `*`или `native int`) в верхнюю часть стека. Количество копируемых байтов зависит от размера класса (как указано в параметре `class`). Параметр `class` — это маркер метаданных, представляющий тип значения.  
  
 Операция инструкции `ldobj` может быть изменена непосредственно перед инструкцией <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксом.  
  
 Если не удается найти класс, возникает исключение <xref:System.TypeLoadException>. Обычно это обнаруживается при преобразовании инструкции MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldobj`.  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений значение статического поля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld `field`|Отправка значения `field` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение конкретного поля помещается в стек.  
  
 Инструкция `ldsfld` помещает значение статического (общего для всех экземпляров класса) поля в стеке. Тип возвращаемого значения связан с переданным маркером метаданных `field`.  
  
 Инструкция `ldsfld` может иметь префикс <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldsfld`.  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений адрес статического поля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|`T`7F <  >|требовался ldsflda `field`|Отправка адреса `field` в стеке|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес определенного поля помещается в стек.  
  
 Инструкция `ldsflda` помещает адрес статического поля (общего для всех экземпляров класса) в стеке. Адрес может быть представлен как временный указатель (тип `*`), если маркер метаданных `field` ссылается на тип, управляемый памятью. В противном случае он соответствует неуправляемому указателю (тип `native int`). Обратите внимание, что `field` может быть статическим глобальным с назначенным относительным виртуальным адресом (смещение поля от базового адреса, в котором его содержащий PE-файл загружается в память), где память является неуправляемой.  
  
 Инструкция `ldsflda` может иметь префикс <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 Если поле не найдено в метаданных, выдается <xref:System.MissingFieldException>. Обычно это проверяется при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldsflda`.  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек ссылку на новый объект, представляющий строковой литерал, хранящийся в метаданных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|72 < `T` >|лдстр `mdToken`|Отправляет строковый объект для маркера строки метаданных `mdToken`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект String помещается в стек.  
  
 Инструкция `ldstr` помещает ссылку на объект (тип `O`) в новый строковый объект, представляющий конкретный строковый литерал, хранящийся в метаданных. Инструкция `ldstr` выделяет необходимый объем памяти и выполняет любое преобразование формата, необходимое для преобразования строкового литерала из формы, используемой в файле, в формат строки, необходимый во время выполнения.  
  
 Common Language Infrastructure (CLI) гарантирует, что результат двух инструкций `ldstr`, которые ссылаются на два токена метаданных с одинаковой последовательностью символов, возвращает один и тот же строковый объект (процесс, известный как «интернирование строк»).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldstr`.  
  
-   ILGenerator. Emit (код операции, строка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует токен метаданных в его представление времени выполнения, а затем помещает в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|`T`< D0  >|коды операций Ldtoken `token`|Преобразует маркер метаданных в представление среды выполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Переданный токен преобразуется в `RuntimeHandle` и помещается в стек.  
  
 Инструкция `ldtoken` помещает `RuntimeHandle` для указанного маркера метаданных. `RuntimeHandle` может быть `fieldref/fielddef`, `methodref/methoddef`или `typeref/typedef`.  
  
 Значение, помещаемое в стек, можно использовать в вызовах методов `Reflection` в библиотеке системных классов.  
  
 Сведения о дескрипторах среды выполнения см. в следующих классах: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>и <xref:System.RuntimeMethodHandle>.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузки методов могут использовать код операции `ldtoken`.  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений неуправляемый указатель (с типом <see langword="native int" />) на машинный код, реализующий виртуальный метод, связанный с заданным объектом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|`T`< FE 7  >|ldvirtftn `method`|Помещает указатель на виртуальный метод объекта `method` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека, а адрес точки входа в метод (как указано в маркере метаданных `method`) ищется.  
  
3.  Указатель на `method` помещается в стек.  
  
 Результирующий неуправляемый указатель, помещаемый в стек с помощью инструкции `ldvirtftn`, можно вызвать с помощью инструкции <xref:System.Reflection.Emit.OpCodes.Calli>, если она ссылается на управляемый метод (или заглушку, переход от управляемого кода к неуправляемому).  
  
 Неуправляемый указатель указывает на машинный код, используя соглашение о вызовах CLR. Этот указатель метода не должен передаваться в неуправляемый машинный код в качестве подпрограммы обратного вызова.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldvirtftn`.  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет выход из защищенной области кода с безусловной передачей управления указанной конечной инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|`int32`< DD  >|покинуть `target`|Выходит из защищенной области кода.|  
  
 Для этой инструкции не задано поведение перехода стека.  
  
 Инструкция `leave` безусловно передает управление в конкретную целевую инструкцию, представленную в виде смещения со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Инструкция `leave` похожа на инструкцию `br`, но ее можно использовать для выхода из блока `try`, `filter`или `catch`, тогда как обычные инструкции ветвления можно использовать только в блоке для передачи управления внутри него. Инструкция `leave` очищает стек вычислений и обеспечивает выполнение соответствующих блоков `finally`.  
  
 Для выхода из блока `finally` нельзя использовать инструкцию `leave`. Чтобы упростить создание кода для обработчиков исключений, оно допустимо в блоке catch, чтобы использовать инструкцию `leave`, чтобы передавать управление любой инструкции в связанном блоке `try`.  
  
 Если инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузки методов могут использовать код операции `leave`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет выход из защищенной области кода с безусловной передачей управления указанной конечной инструкции (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DE < `int8` >|покинуть. s `target`|Выйдите из защищенной области кода, короткой формы.|  
  
 Для этой инструкции не задано поведение перехода стека.  
  
 Инструкция `leave.s` безусловно передает управление в переданную целевую инструкцию, представленную как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Инструкция `leave.s` похожа на инструкцию `br`, но ее можно использовать для выхода из блока `try`, `filter`или `catch`, тогда как обычные инструкции ветвления можно использовать только в блоке для передачи управления внутри него. Инструкция `leave.s` очищает стек вычислений и обеспечивает выполнение соответствующих блоков `finally`.  
  
 Для выхода из блока `finally` нельзя использовать инструкцию `leave.s`. Чтобы упростить создание кода для обработчиков исключений, оно допустимо в блоке catch, чтобы использовать инструкцию `leave.s`, чтобы передавать управление любой инструкции в связанном блоке `try`.  
  
 Если инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `leave.s`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выделяет определенное количество байтов из пула локальной динамической памяти и помещает в стек вычислений адрес (временный указатель с типом <see langword="*" />) первого выделенного байта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|Выделение пространства из локальной кучи.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Число байтов, которое необходимо выделить, помещается в стек.  
  
2.  Число байтов извлекается из стека; объем памяти, соответствующий размеру, выделяется из локальной кучи.  
  
3.  Указатель на первый байт выделенной памяти помещается в стек.  
  
 Инструкция `localloc` выделяет байты `size` (типа `natural unsigned int`) из локального пула динамической памяти и возвращает адрес (временный указатель, тип `*`) первого выделенного байта. Возвращаемый блок памяти инициализируется значением 0 только в том случае, если флаг инициализации метода имеет значение `true`. Когда текущий метод выполняет <xref:System.Reflection.Emit.OpCodes.Ret>, пул локальной памяти становится доступным для повторного использования.  
  
 Полученный адрес будет согласовываться таким образом, чтобы любой примитивный тип данных можно было хранить в нем с помощью `stind` инструкций (например, <xref:System.Reflection.Emit.OpCodes.Stind_I4>) и загружаться с помощью инструкций `ldind` (таких как <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).  
  
 Инструкция `localloc` не может встречаться в блоке `filter`, `catch`, `finally`или `fault`.  
  
 <xref:System.StackOverflowException> возникает, если недостаточно памяти для обслуживания запроса.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `localloc`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений ссылку на экземпляр определенного типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< C6 `T` >|Mkrefany `class`|Помещает в стек типизированную ссылку типа `class`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Указатель на фрагмент данных помещается в стек.  
  
2.  Указатель извлекается и преобразуется в типизированную ссылку типа `class`.  
  
3.  Типизированная ссылка помещается в стек.  
  
 Инструкция `mkrefany` поддерживает передачу ссылок с динамическим типом. Указатель должен иметь тип `&`, `*`или `native int`и содержать допустимый адрес фрагмента данных. `Class` — это маркер класса, описывающий тип данных, на которые ссылается указатель. `Mkrefany` помещает типизированную ссылку на стек, предоставляя непрозрачный дескриптор указателя и тип `class`.  
  
 Единственной допустимой операцией, разрешенной для типизированной ссылки, является передача ее в метод, которому в качестве параметра требуется типизированная ссылка. Затем вызываемый объект может использовать инструкции <xref:System.Reflection.Emit.OpCodes.Refanytype> и <xref:System.Reflection.Emit.OpCodes.Refanyval>, чтобы получить тип (класс) и адрес соответственно.  
  
 Если `class` не удается найти, выдается <xref:System.TypeLoadException>. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `mkrefany`.  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Умножает два значения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5A|mul|Умножает два значения в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` умножается на `value2`.  
  
4.  Результат помещается в стек.  
  
 Инструкция `mul` умножает `value1` на `value2` и помещает результат в стек. Целочисленные операции автоматически усекаются верхние биты в переполнении.  
  
 См. <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> для выполнения операции умножения целого числа с помощью обработки переполнения.  
  
 Для типов с плавающей запятой 0 * Infinity = NaN.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `mul`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Умножает два целочисленных значения, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D8|mul. ovf|Умножает два целочисленных значения в стеке с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` умножается на `value2`с проверками переполнения.  
  
4.  Результат помещается в стек.  
  
 Инструкция `mul.ovf` умножает целочисленный `value1` на целочисленный `value2` и помещает результат в стек. Если результат не умещается в типе результата, выдается исключение.  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `mul.ovf`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Умножает два целочисленных значения без знака, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D9|mul. ovf. un|Умножает два значения без знака в стеке с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` умножается на `value2`с проверками переполнения.  
  
4.  Результат помещается в стек.  
  
 Инструкция `mul.ovf.un` умножает целое число без знака `value1` беззнаковое целое `value2` и помещает результат в стек. Если результат не умещается в типе результата, выдается исключение.  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `mul.ovf.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Отвергает значение и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|65|расход|Инвертирует значение, находящегося на вершине стека.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Значение извлекается из стека и инвертируется.  
  
3.  Результат помещается в стек.  
  
 Инструкция `neg` инвертирует значение и помещает результат поверх стека. Тип возвращаемого значения совпадает с типом операнда.  
  
 Отрицание целочисленных значений — это нестандартное отрицание числа единиц. В частности, при инвертировании самого отрицательного числа (которое не имеет положительного аналога) выдается наибольшее отрицательное число. Чтобы обнаружить это переполнение, используйте инструкцию <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> (то есть вычтите из 0).  
  
 Отрицание числа с плавающей запятой не может быть переполнено и отрицание NaN возвращает NaN.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `neg`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений ссылку на объект — новый одномерный массив с индексацией от нуля, состоящий из элементов заданного типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8D < `T` >|неварр `etype`|Создает новый массив с элементами типа `etype`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Число элементов в массиве помещается в стек.  
  
2.  Число элементов извлекается из стека и создается массив.  
  
3.  Ссылка на новый массив помещается в стек.  
  
 Инструкция `newarr` помещает ссылку на объект (тип `O`) в новый одномерный массив, начинающийся с нуля, элементы которого имеют тип `etype` (маркер метаданных, описывающий тип). Число элементов в новом массиве должно быть указано как `native int`. Допустимые индексы массива находятся в диапазоне от нуля до максимального числа элементов минус один.  
  
 Элементы массива могут быть любого типа, включая типы значений.  
  
 Одномерные массивы чисел с индексацией от нуля создаются с помощью маркера метаданных, ссылающегося на соответствующий тип значения (<xref:System.Int32>и т. д.). Элементы массива инициализируются значением 0 соответствующего типа.  
  
 Одномерные массивы с ненулевыми значениями и многомерные массивы создаются с помощью <xref:System.Reflection.Emit.OpCodes.Newobj>, а не `newarr`. Чаще всего они создаются с помощью методов класса <xref:System.Array> в .NET Framework.  
  
 <xref:System.OutOfMemoryException> возникает, если недостаточно памяти для удовлетворения запроса.  
  
 <xref:System.OverflowException> возникает, если `numElems` меньше 0.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `newarr`.  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Создает новый объект или новый экземпляр типа значения и помещает ссылку на объект (тип <see langword="O" />) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|Выделяет неинициализированный объект или тип значения и вызывает метод конструктора `ctor`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Аргументы, `arg1` с помощью `argn`, последовательно помещаются в стек.  
  
2.  Аргументы, `argn`ные через `arg1`, извлекаются из стека и передаются `ctor` для создания объекта.  
  
3.  Ссылка на новый объект помещается в стек.  
  
 Инструкция `newobj` создает новый объект или новый экземпляр типа значения. `Ctor` является маркером метаданных (`methodref` или `methoddef`, который должен быть помечен как конструктор), который указывает имя, класс и сигнатуру вызываемого конструктора.  
  
 Инструкция `newobj` выделяет новый экземпляр класса, связанный с `ctor`, и инициализирует все поля в новом экземпляре значением 0 (соответствующего типа) или пустыми ссылками, если это уместно. Затем он вызывает конструктор `ctor` с заданными аргументами вместе с созданным экземпляром. После вызова конструктора в стек помещается ссылка на инициализированный объект (тип `O`).  
  
 С точки зрения конструктора неинициализированный объект является аргументом 0, а остальные аргументы, передаваемые в newobj, следуют по порядку.  
  
 Все одномерные массивы, начинающиеся с нуля, создаются с помощью <xref:System.Reflection.Emit.OpCodes.Newarr>, а не `newobj`. С другой стороны, все остальные массивы (более одного измерения или одномерные, но не основанные на нуле) создаются с помощью `newobj`.  
  
 Типы значений обычно не создаются с помощью `newobj`. Обычно они выделяются как аргументы или локальные переменные с помощью `newarr` (для одномерных массивов с индексацией от нуля) или в качестве полей объектов. После выделения они инициализируются с помощью <xref:System.Reflection.Emit.OpCodes.Initobj>. Однако инструкцию `newobj` можно использовать для создания нового экземпляра типа значения в стеке, который затем может быть передан как аргумент, сохранен в локальной системе и т. д.  
  
 <xref:System.OutOfMemoryException> возникает, если недостаточно памяти для удовлетворения запроса.  
  
 <xref:System.MissingMethodException> возникает, если не удалось найти метод конструктора, `ctor` с указанным именем, классом и сигнатурой. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `newobj`.  
  
-   ILGenerator. Emit (код операции, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заполняет пространство, если коды операции содержат исправления. Никаких значимых операций не выполняется, хотя может быть пройден цикл обработки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|00|NOP|Выполняет операцию без поведения.|  
  
 Для этой инструкции не определено поведение перехода стека.  
  
 Операция `nop` не выполняет никаких действий. Он предназначен для заполнения пространства, если исправлены коды операций.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `nop`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое дополнение целочисленного значения, находящегося на вершине стека, и помещает результат в стек с тем же типом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|66|not|Вычисление побитового дополнения значения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека и вычисленное побитовое дополнение.  
  
3.  Результат помещается в стек.  
  
 Инструкция `not` вычислит побитовое дополнение целочисленного значения и помещает результат в стек. Тип возвращаемого значения совпадает с типом операнда.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `not`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое дополнение двух целочисленных значений, находящихся на вершине стека, и помещает результат в стек.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|60|or|Выполняет побитовое или для двух целочисленных значений, возвращает целое число.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека и их побитовые или вычисленные.  
  
4.  Результат помещается в стек.  
  
 Инструкция `or` выдает побитовое или двух значений, расположенных поверх стека, помещая результат в стек.  
  
 `Or` — это операция, относящаяся к целому числу.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `or`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Удаляет значение, находящееся на вершине стека.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|26|pop|Извлекает верхнее значение из стека.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Верхнее значение извлекается из стека.  
  
 Инструкция `pop` удаляет верхний элемент из стека.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `pop`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что последующая операция, связанная с адресом массива, не выполняет никаких проверок во время выполнения и возвращает управляемый указатель, изменение которого запрещено.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 1E|доступно.|Укажите, что последующие операции с адресом массива не выполняют проверку типа во время выполнения и возвращают управляемый указатель с ограниченными возможностями.|  
  
 Этот префикс может появляться непосредственно перед инструкцией `ldelema` и вызовами специального метода `Address` для массивов. Его воздействие на последующую операцию — двойная:  
  
1.  Во время выполнения операция проверки типа не выполняется. Обратите внимание, что обычно существует неявная проверка типа для `ldelema` и `stelem` инструкции при использовании массивов ссылочного типа. Для классов значений никогда не выполняется проверка типа во время выполнения, поэтому в этом случае `readonly` является отсутствием операции.  
  
2.  Средство проверки обрабатывает результат операции адреса в качестве управляемого указателя с ограниченными возможностями.  
  
 Говорят, что указатель имеет ограниченную возможность, так как определяющий тип определяет, можно ли изменить значение. Для классов значений, которые не предоставляют открытых полей или методов, которые обновляют значение на месте, указатель доступен только для чтения (следовательно, имя префикса). В частности, классы, представляющие простые типы (например, System. Int32), не предоставляют мутатора и, таким образом, доступны только для чтения.  
  
 Управляемый указатель, ограниченный таким образом, может использоваться только следующими способами:  
  
-   В качестве параметра `object` для `ldfld`, `ldflda`, `stfld`, `call`или инструкций`constrained callvirt`.  
  
-   В качестве параметра `pointer` инструкции `ldobj` или одной из `ldind` инструкций.  
  
-   В качестве параметра `source` инструкции `cpobj`.  
  
 Все другие операции запрещены, включая `stobj`, `initobj`или `mkrefany` операции, или любые инструкции `stind`.  
  
 Назначение префикса `readonly` заключается в том, чтобы избежать проверки типа при извлечении элемента из массива в универсальном коде. Например, выражение `arr[i].m()`, где тип элемента массива `arr` является универсальным типом, который был ограничен интерфейсом с помощью метода `m`, может компилироваться следующим кодом MSIL.  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 Без префикса `readonly` инструкция `ldelema` выполняет проверку типа, если! 0 является ссылочным типом. Этот тип не только неэффективен, но и семантически неверен. Проверка типа `ldelema` является точным совпадением, что является слишком строгим. Если массив удерживал подклассы типа! 0, приведенный выше код не сможет проверить тип.  
  
 Адрес элемента массива выбирается вместо самого элемента, чтобы иметь дескриптор для `arr[i]`, который работает как для типов значений, так и для ссылочных типов и поэтому может быть передан в инструкцию `constrained callvirt`.  
  
 Как правило, пропуск проверки во время выполнения может быть незащищенным, если массив удерживает элементы ссылочного типа. Чтобы быть в безопасности, необходимо убедиться, что с помощью этого указателя изменения в массиве не выполняются. Это гарантируется правилами проверки. Ограниченный управляемый указатель может передаваться как объект для вызовов метода экземпляра, поэтому он не должен строго говорить только для чтения для типов значений, но для типов значений не существует проблем безопасности типов.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `readonly`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает токен типа, внедренный в ссылку с определенным типом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 1D|рефанитипе|Помещает токен типа, хранящийся в типизированной ссылке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на тип значения помещается в стек.  
  
2.  Типизированная ссылка извлекается из стека и полученного маркера соответствующего типа.  
  
3.  Токен типа помещается в стек.  
  
 Типизированная ссылка содержит токен типа и адрес экземпляра объекта.  
  
 Инструкция `refanytype` извлекает лексему типа, внедренную в ссылку с определенным типом. Сведения о создании типизированных ссылок см. в <xref:System.Reflection.Emit.OpCodes.Mkrefany> инструкции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `refanytype`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает адрес (тип <see langword="&amp;" />), внедренный в ссылку с определенным типом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|`T`< C2  >|рефанивал `type`|Отправляет адрес, хранящийся в типизированной ссылке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на тип значения помещается в стек.  
  
2.  Типизированная ссылка извлекается из стека, и извлекается соответствующий адрес.  
  
3.  Адрес помещается в стек.  
  
 Типизированная ссылка содержит токен типа и адрес экземпляра объекта.  
  
 Инструкция `refanyval` извлекает адрес, внедренный в ссылку с определенным типом. Тип, внедренный в указанную в стеке ссылку, должен соответствовать типу, заданному `type` (маркер метаданных, `typedef` или `typeref`). См. <xref:System.Reflection.Emit.OpCodes.Mkrefany> инструкции по связанному содержимому.  
  
 <xref:System.InvalidCastException> возникает, если `type` не совпадает с типом, хранящимся в ссылке на тип (в данном случае `type` является классом, переданным в инструкцию <xref:System.Reflection.Emit.OpCodes.Mkrefany>, в которой была построена типизированная ссылка).  
  
 Если `type` не удается найти, выдается <xref:System.TypeLoadException>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `refanyval`.  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно значение на другое и помещает остаток в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5D|оставшие|Отправляет остаток от деления `value1` `value2` в стек.|  
  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека, а остаток от `value1` `div` `value2` вычислен.  
  
4.  Результат помещается в стек.  
  
 `result` = `value1` `rem` `value2` удовлетворяют следующим условиям.  
  
 `result` = `value1` - `value2` `×` (`value1` `div` `value2`) и:  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;, знак (`result`) = Sign (`value1`), где `div` является инструкцией деления, которая усекается в сторону нуля.  
  
 Если `value2` равно нулю или `value1` является бесконечной, результатом будет NaN. Если `value2` имеет бесконечное значение, результатом является `value1` (с отрицанием для `-infinity`).  
  
 Целочисленные операции создают <xref:System.DivideByZeroException>, если `value2` равен нулю.  
  
 Обратите внимание, что на платформах на базе процессоров Intel при вычислениях (minint `rem`-1) создается <xref:System.OverflowException>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `rem`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно значение без знака на другое значение без знака и помещает остаток в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5E|REM. un|Помещает остаток от деления неподписанных `value1` неподписанными `value2` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека, а остаток от `value1` `div` `value2` вычислен.  
  
4.  Результат помещается в стек.  
  
 `result` = `value1` `rem.un` `value2` удовлетворяют следующим условиям.  
  
 `result` = `value1` - `value2` x (`value1` `div.un` `value2`) и:  
  
 0 = `result` < `value2`, где `div.un` является неподписанной инструкцией деления.  
  
 Инструкция `rem.un` вычислит `result` и помещает ее в стек. `Rem.un` обрабатывает свои аргументы как целые числа без знака, а <xref:System.Reflection.Emit.OpCodes.Rem> обрабатывает их как целые числа со знаком.  
  
 `Rem.un` не задано для чисел с плавающей запятой.  
  
 Целочисленные операции создают <xref:System.DivideByZeroException>, если `value2` равен нулю.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `rem.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет возврат из текущего метода, помещая возвращаемое значение (если имеется) из стека вычислений вызываемого метода в стек вычислений вызывающего метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2A|обратно|Возвращает из метода, возможно, возвращающего значение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Возвращаемое значение извлекается из стека вычислений вызываемого метода.  
  
2.  Возвращаемое значение, полученное на шаге 1, помещается в стек вычислений вызывающего объекта.  
  
 Если возвращаемое значение отсутствует в стеке вычисления вызываемого метода, значение не возвращается (ни одно поведение перехода стека для вызываемого или вызывающего метода не используется).  
  
 Тип возвращаемого значения (если таковой имеется) текущего метода определяет тип значения, которое будет выбрано из верхней части стека и скопировано в стек метода, который вызвал текущий метод. Стек вычислений для текущего метода должен быть пустым, за исключением возвращаемого значения.  
  
 Инструкцию `ret` нельзя использовать для перемещения управления из`try`, `filter`, `catch`или блока `finally`. В `try` или `catch`используйте инструкцию <xref:System.Reflection.Emit.OpCodes.Leave> с назначением инструкции `ret`, которая находится за пределами всех охватывающих блоков исключений. Поскольку блоки `filter` и `finally` логически являются частью обработки исключений, а не метода, в котором их код внедрен, правильно сформированные инструкции языка MSIL не выполняют возврат метода из `filter` или `finally`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ret`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущее исключение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 1A|Rethrow|Повторная генерация текущего исключения|  
  
 Для этой инструкции не определено поведение перехода стека.  
  
 Инструкция `rethrow` разрешена только в теле обработчика `catch`. Он создает то же исключение, которое было перехвачено этим обработчиком.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `rethrow`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Смещает целочисленное значение влево (с заполнением нулями) на заданное число бит и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|62|шл|Сдвигает целое число влево (сдвиг в нули).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Количество битов для сдвига помещается в стек.  
  
3.  Число битов, которые необходимо сдвинуть, и значение, извлекаемое из стека; значение смещается влево на указанное число битов.  
  
4.  Результат помещается в стек.  
  
 Инструкция `shl` Сдвигает значение (тип `int32`, `int64` или `native int`) влево на указанное число битов. Число битов является значением типа `int32` или `native int`. Возвращаемое значение не указано, если число битов, которые необходимо сдвинуть, больше или равно ширине (в битах) указанного значения.  
  
 `Shl` вставляет нулевой бит в нижнюю точку при каждой смене.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `shl`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Смещает целочисленное значение вправо (с знаковым битом) на заданное число бит и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|63|SHR|Сдвигает целое число вправо (сдвиг в знак).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Количество битов для сдвига помещается в стек.  
  
3.  Число битов, которые необходимо сдвинуть, и значение, извлекаемое из стека; значение смещается вправо на указанное число битов.  
  
4.  Результат помещается в стек.  
  
 Инструкция `shr.un` Сдвигает значение (Type `int32`, `int64` или `native int`) вправо на указанное число битов. Число битов является значением типа `int32` или `native int`. Возвращаемое значение не указано, если число битов, которые необходимо сдвинуть, больше или равно ширине (в битах) указанного значения.  
  
 `Shr` реплицирует бит высокого порядка при каждой смене, сохраняя знак исходного значения в `result`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `shr`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Смещает целочисленное значение без знака вправо (с заполнением нулями) на заданное число бит и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|64|SHR. un|Сдвигает целое число вправо (с сдвигом в нули).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Количество битов для сдвига помещается в стек.  
  
3.  Число битов, которые необходимо сдвинуть, и значение, извлекаемое из стека; значение смещается вправо на указанное число битов.  
  
4.  Результат помещается в стек.  
  
 Инструкция `shr.un` Сдвигает значение (Type `int32`, `int64` или `native int`) вправо на указанное число битов. Число битов является значением типа `int32`, `int64` или `native int`. Возвращаемое значение не указано, если число битов, которые необходимо сдвинуть, больше или равно ширине (в битах) указанного значения.  
  
 `Shr.un` вставляет нулевой бит в самую верхнюю точку при каждой смене.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `shr.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений сведения о размере (в байтах) заданного типа значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|`T`< FE 1C  >|sizeof `valType`|Отправка размера (в байтах) типа значения в качестве `unsigned int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Размер (в байтах) заданного типа значения (`valType`) помещается в стек.  
  
 `valType` должен быть токеном метаданных (`typeref` или `typedef`), который указывает тип значения, ссылочный тип или параметр универсального типа.  
  
 Для ссылочного типа возвращаемый размер — это размер ссылочного значения соответствующего типа (4 байта в 32-разрядных системах), а не размер данных, хранящихся в объектах, на которые ссылается ссылочное значение. Параметр универсального типа может использоваться только в теле типа или метода, который его определяет. При создании экземпляра этого типа или метода параметр универсального типа заменяется типом значения или ссылочным типом.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `sizeof`.  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение, находящееся на вершине стека вычислений, в ячейке аргумента с заданным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< FE 0B `unsigned int16` >|СТАРГ `num`|Извлекает верхнее значение из стека и сохраняет его в ячейке аргумента `num`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение, расположенное в верхней части стека, извлекается и помещается в область аргумента `num`.  
  
 Инструкция `starg` извлекает значение из стека и помещает его в слот аргументов `num`. Тип значения должен соответствовать типу аргумента, как указано в сигнатуре текущего метода.  
  
 Для процедур, принимающих список аргументов переменных, инструкция `starg` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры.  
  
 Выполнение хранилища в аргументах, содержащих целочисленное значение менее 4 байт, усекает значение при перемещении из стека в аргумент. Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `starg`.  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение, находящееся на вершине стека вычислений, в ячейке аргумента с заданным индексом (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|`num` СТАРГ. s|Извлекает верхнее значение из стека и сохраняет его в ячейке аргумента `num`, короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение, расположенное в верхней части стека, извлекается и помещается в область аргумента `num`.  
  
 Инструкция `starg.s` извлекает значение из стека и помещает его в слот аргументов `num`. Тип значения должен соответствовать типу аргумента, как указано в сигнатуре текущего метода.  
  
 Инструкция `starg.s` предоставляет эффективную кодировку для использования с первыми аргументами 256.  
  
 Для процедур, принимающих список аргументов переменных, инструкция `starg.s` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры.  
  
 Выполнение хранилища в аргументах, содержащих целочисленное значение менее 4 байт, усекает значение при перемещении из стека в аргумент. Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `starg.s`.  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение в стеке вычислений, тип которого указан в инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|`T`< A4  >|стелем `typeTok`|Заменяет элемент массива с заданным индексом на значение типа `typeTok` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве, `array`, помещается в стек.  
  
2.  Значение индекса, `index`, в элемент в `array` помещается в стек.  
  
3.  Значение типа, указанное в инструкции, помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem` заменяет значение элемента в указанном индексе, начинающемся с нуля, в одномерном массиве `array` со значением. Значение имеет тип, заданный токеном `typeTok` в инструкции.  
  
 Массивы являются объектами, поэтому они представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem`.  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="native int" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9Б|стелем. i|Заменяет элемент массива с заданным индексом на значение `native int` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem.i` заменяет значение элемента, `index` в одномерном массиве `array` значением `native int`, помещаемым в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.i`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int8" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9C|стелем. i1|Заменяет элемент массива с заданным индексом на значение `int8` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem.i1` заменяет значение элемента, `index` в одномерном массиве `array` значением `int8`, помещаемым в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.i1`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int16" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9D|стелем. i2|Заменяет элемент массива с заданным индексом на значение `int16` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem.i2` заменяет значение элемента, `index` в одномерном массиве `array` значением `int16`, помещаемым в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.i2`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int32" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9E|стелем. i4|Заменяет элемент массива с заданным индексом на значение `int32` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem.i4` заменяет значение элемента, `index` в одномерном массиве `array` значением `int32`, помещаемым в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.i4`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int64" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9F|стелем. i8|Заменяет элемент массива с заданным индексом на значение `int64` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem.i8` заменяет значение элемента, `index` в одномерном массиве `array` значением `int64`, помещаемым в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.i8`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="float32" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A0|стелем. R4|Заменяет элемент массива с заданным индексом на значение `float32` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem.r4` заменяет значение элемента, `index` в одномерном массиве `array` значением `float32`, помещаемым в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.r4`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="float64" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A1|стелем. R8|Заменяет элемент массива с заданным индексом на значение `float64` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem.r8` заменяет значение элемента, `index` в одномерном массиве `array` значением `float64`, помещаемым в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.r8`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение object ref (тип <see langword="O" />), находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A2|стелем. ref|Заменяет элемент массива в заданном индексе значением `ref` (Type `O`) в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem.ref` заменяет значение элемента по указанному индексу в одномерном массиве `array` значением `ref` (Type `O`), помещенным в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 Обратите внимание, что `stelem.ref` неявно приводит переданное значение к типу элемента `array` перед присваиванием значения элементу массива. Это приведение может завершиться ошибкой даже для проверенного кода. Поэтому инструкция `stelem.ref` может вызывать <xref:System.InvalidCastException>. Для одномерных массивов без индексации от нуля и для многомерных массивов класс <xref:System.Array> предоставляет метод <xref:System.Array.SetValue%2A>.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` является отрицательным или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.ref`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет значение в поле объекта, по ссылке на объект или указателю, на новое значение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld `field`|Заменяет значение `field` объекта новым значением.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект или указатель помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и ссылка на объект (указатель) извлекаются из стека; значение `field` в объекте заменяется заданным значением.  
  
 Инструкция `stfld` заменяет значение поля объекта (типа `O`) или через указатель (тип `native int`, `&`или `*`) с заданным значением. `Field` — это маркер метаданных, который ссылается на ссылку на поле. Инструкция `stfld` может иметь префикс либо для <xref:System.Reflection.Emit.OpCodes.Unaligned>, либо для <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.NullReferenceException> создается, если ссылка на объект или указатель является пустой ссылкой, а поле не является статическим.  
  
 <xref:System.MissingFieldException> возникает, если `field` не найден в метаданных. Обычно это проверяется при преобразовании инструкции MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stfld`.  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="native int" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DF|stind. i|Сохраняет значение `native int` по указанному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 Инструкция `stind.i` сохраняет значение `native int` по указанному адресу (тип `native int`, `*`или `&`).  
  
 Для операции с типом "безопасно" требуется, чтобы инструкция `stind.i` была использована способом, согласованным с типом указателя. Операция инструкции `stind.i` может быть изменена непосредственно перед инструкцией <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксом.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом для типа аргумента, подразумеваемого суффиксом инструкции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.i`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int8" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|52|stind. i1|Хранит значение `int8` по заданному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 Инструкция `stind.i1` сохраняет значение `int8` по указанному адресу (тип `native int`, `*`или `&`).  
  
 Для операции с типом "безопасно" требуется, чтобы инструкция `stind.i1` была использована способом, согласованным с типом указателя. Операция инструкции `stind.i1` может быть изменена непосредственно перед инструкцией <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксом.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом для типа аргумента, подразумеваемого суффиксом инструкции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.i1`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int16" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|53|stind. i2|Хранит значение `int16` по заданному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 Инструкция `stind.i2` сохраняет значение `int16` по указанному адресу (тип `native int`, `*`или `&`).  
  
 Для операции с типом "безопасно" требуется, чтобы инструкция `stind.2i` была использована способом, согласованным с типом указателя. Операция инструкции `stind.i2` может быть изменена непосредственно перед инструкцией <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксом.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом для типа аргумента, подразумеваемого суффиксом инструкции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.i2`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int32" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|54|stind. i4|Хранит значение `int32` по заданному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 Инструкция `stind.i4` сохраняет значение `int32` по указанному адресу (тип `native int`, `*`или `&`).  
  
 Для операции с типом "безопасно" требуется, чтобы инструкция `stind.i4` была использована способом, согласованным с типом указателя. Операция инструкции `stind.i4` может быть изменена непосредственно перед инструкцией <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксом.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом для типа аргумента, подразумеваемого суффиксом инструкции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.i4`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int64" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|55|stind. i8|Хранит значение `int64` по заданному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 Инструкция `stind.i8` сохраняет значение `int64` по указанному адресу (тип `native int`, `*`или `&`).  
  
 Для операции с типом "безопасно" требуется, чтобы инструкция `stind.i8` была использована способом, согласованным с типом указателя. Операция инструкции `stind.i` может быть изменена непосредственно перед инструкцией <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксом.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом для типа аргумента, подразумеваемого суффиксом инструкции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.i8`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="float32" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|56|stind. R4|Сохраняет значение `float32` по указанному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 Инструкция `stind.r4` сохраняет значение `float32` по указанному адресу (тип `native int`, `*`или `&`).  
  
 Для операции с типом "безопасно" требуется, чтобы инструкция `stind.r4` была использована способом, согласованным с типом указателя. Операция инструкции `stind.r4` может быть изменена непосредственно перед инструкцией <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксом.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом для типа аргумента, подразумеваемого суффиксом инструкции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.r4`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="float64" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|57|stind. R8|Сохраняет значение `float64` по указанному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 Инструкция `stind.r8` сохраняет значение `float64` по указанному адресу (тип `native int`, `*`или `&`).  
  
 Для операции с типом "безопасно" требуется, чтобы инструкция `stind.r8` была использована способом, согласованным с типом указателя. Операция инструкции `stind.r8` может быть изменена непосредственно перед инструкцией <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксом.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом для типа аргумента, подразумеваемого суффиксом инструкции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.r8`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение ссылки на объект по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|51|stind. ref|Сохраняет значение ссылки на объект (тип `O`) по указанному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 Инструкция `stind.ref` сохраняет значение ссылки на объект по указанному адресу (тип `native int`, `*`или `&`).  
  
 Для операции с типом "безопасно" требуется, чтобы инструкция `stind.ref` была использована способом, согласованным с типом указателя. Операция инструкции `stind.ref` может быть изменена непосредственно перед инструкцией <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксом.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом для типа аргумента, подразумеваемого суффиксом инструкции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.ref`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с заданным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 0E < `unsigned int16` >|требовалась stloc `index`|Извлекает значение из стека и сохраняет его в локальной переменной `index`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную `index`.  
  
 Инструкция `stloc` выводит верхнее значение из стека вычислений и перемещает его в номер локальной переменной `index`, где локальные переменные нумеруются 0 и выше. Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.  
  
 Для правильных инструкций промежуточного языка MSIL требуется, чтобы `index` был допустимым локальным индексом. Для `stloc` инструкции `index` должны находиться в диапазоне от 0 до 65534 включительно (в частности, 65535 является недопустимым). Исключение 65535 является практичным: вероятные реализации будут использовать 2-байтовое целое число для трассировки как индекса локальной версии, так и общего числа локальных переменных для данного метода. Если индекс 65535 был сделан допустимым, для записи числа локальных переменных в таком методе потребуется более широкое целое число.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузки методов могут использовать код операции `stloc`.  
  
-   ILGenerator. Emit (код операции, LocalBuilder)  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0A|требовалась stloc. 0|Извлекает значение из стека в локальную переменную 0.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 0.  
  
 Инструкция `stloc.0` извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 0. Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 `stloc.0` является особенно эффективным кодированием для хранения значений в локальной переменной 0.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stloc.0`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение из стека вычислений и сохраняет его в списке локальных переменных с индексом 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0B|требовалась stloc. 1|Извлекает значение из стека в локальную переменную 1.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 1.  
  
 Инструкция `stloc.1` извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 1. Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 `stloc.1` является особенно эффективным кодированием для хранения значений в локальной переменной 1.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stloc.1`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение из стека вычислений и сохраняет его в списке локальных переменных с индексом 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0C|требовалась stloc. 2|Извлекает значение из стека в локальную переменную 2|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 2.  
  
 Инструкция `stloc.2` извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 2. Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 `stloc.2` является особенно эффективным кодированием для хранения значений в локальной переменной 2.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stloc.2`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение из стека вычислений и сохраняет его в списке локальных переменных с индексом 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0D|требовалась stloc. 3|Извлекает значение из стека в локальную переменную 3|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 3.  
  
 Инструкция `stloc.3` извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 3. Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 `stloc.3` является особенно эффективным кодированием для хранения значений в локальной переменной 3.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stloc.3`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом <paramref name="index" /> (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|`index` требовалась stloc. s|Извлекает значение из стека и сохраняет его в локальной переменной `index`краткой форме.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную `index`.  
  
 Инструкция `stloc.s` выводит верхнее значение из стека вычислений и перемещает его в номер локальной переменной `index`, где локальные переменные нумеруются 0 и выше. Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 Инструкция `stloc.s` предоставляет эффективную кодировку для локальных переменных от 0 до 255.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузки методов могут использовать код операции `stloc.s`.  
  
-   ILGenerator. Emit (код операции, LocalBuilder)  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует значение с заданным типом из стека вычислений в указанный адрес памяти.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|Сохраняет значение типа `class` из стека в память.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Объект типа значения типа `class` помещается в стек.  
  
3.  Объект и адрес извлекаются из стека; Объект типа значения хранится по адресу.  
  
 Инструкция `stobj` копирует объект типа значения в адрес, указанный в адресе (указатель типа `native int`, `*`или `&`). Число копируемых байтов зависит от размера класса, представленного `class`, маркера метаданных, представляющего тип значения.  
  
 Операция инструкции `stobj` может быть изменена непосредственно перед инструкцией <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксом.  
  
 Если не удается найти класс, возникает исключение <xref:System.TypeLoadException>. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stobj`.  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет значение статического поля на значение из стека вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|Заменяет значение в `field` на заданное значение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Значение извлекается из стека и сохраняется в `field`.  
  
 Инструкция `stsfld` заменяет значение статического поля значением из стека. `field` является маркером метаданных, который должен ссылаться на член статического поля.  
  
 Инструкция `stsfld` может иметь префикс <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 Если поле не найдено в метаданных, выдается <xref:System.MissingFieldException>. Обычно это проверяется при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stsfld`.  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычитает одно значение из другого и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|59|sub|Вычитает одно значение из другого, возвращая новое числовое значение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value2` вычитается из `value1`.  
  
4.  Результат помещается в стек.  
  
 Переполнение не обнаружено для целочисленных операций (для правильной обработки переполнения см. раздел <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).  
  
 Вычитание целых чисел заключается в переносе, а не в насыщенность. Например, если предположить 8-разрядные целые числа, где `value1` имеет значение 0, а `value2` имеет значение 1, то "упакованный" результат будет 255.  
  
 Переполнение с плавающей точкой возвращает `+inf` (`PositiveInfinity`) или `-inf` (`NegativeInfinity`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `sub`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычитает одно целочисленное значение из другого, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DA|подovf|Вычитает одно целочисленное значение из другого с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value2` вычитается из `value1` с помощью проверки переполнения.  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Эта операция выполняется над целыми числами со знаком. для значений с плавающей запятой используйте <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `sub.ovf`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычитает одно целочисленное значение без знака из другого, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DB|ovf. un|Вычитает одно целочисленное значение без знака из другого с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value2` вычитается из `value1` с помощью проверки переполнения.  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Эта операция выполняется над целыми числами со знаком. для значений с плавающей запятой используйте <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `sub.ovf.un`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Реализует таблицу переходов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` >... < `int32` >|Switch (`N`, `t1`, `t2`... `tN`)|Переходит к одному из `N` значений.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Значение извлекается из стека, и выполнение передается в инструкцию со смещением, индексированным по значению, где значение меньше `N`.  
  
 Инструкция `switch` реализует таблицу переходов. В качестве формата инструкции используется `unsigned int32` представляющее количество целевых объектов `N`, за которыми следуют `N` значения Int32, указывающие цели перехода. Эти целевые объекты представлены в виде смещений (положительных или отрицательных) от начала инструкции, следующей за инструкцией `switch`.  
  
 Инструкция `switch` извлекает значение из стека и сравнивает его как целое число без знака, чтобы `N`. Если значение меньше `N`, выполнение передается в целевой индекс по значению, где конечные объекты нумеруются с 0 (например, значение 0 принимает первый целевой объект, значение 1 принимает второй целевой объект и т. д.). Если значение больше или равно `N`, выполнение продолжится в следующей инструкции (передается).  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.  
  
 Управление передачей в блоки `try`, `catch`, `filter`и `finally` не может выполняться этой инструкцией. (Такие передачи сильно ограничены и должны использовать инструкцию Leave).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `switch`. Аргумент `Label[]` — это массив меток, представляющий 32-битное смещение.  
  
-   ILGenerator. Emit (код операции, метка [])  
  
   
  
## Examples  
 В следующем образце кода показано использование кода операции `Switch` для создания таблицы переходов с помощью массива <xref:System.Reflection.Emit.Label>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет инструкцию вызова метода (префиксом которой является), предварительно удаляя кадр стека текущего метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 14|односторонне.|Последующий вызов завершает текущие методы|  
  
 Для этой инструкции не определено поведение перехода стека.  
  
 Инструкция префикса `tail` должна находиться непосредственно перед <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>или инструкцией <xref:System.Reflection.Emit.OpCodes.Callvirt>. Указывает, что кадр стека текущего метода должен быть удален перед выполнением инструкции вызова. Также подразумевается, что значение, возвращаемое из следующего вызова, является также значением, возвращаемым текущим методом, и поэтому вызов может быть преобразован в переход между методами.  
  
 Стек должен быть пустым, за исключением аргументов, передаваемых следующим вызовом. Инструкция, следующая за инструкцией Call, должна быть Ret. Таким образом, единственной допустимой последовательностью кода является `tail. call` (или `calli` или `callvirt`). Правильные инструкции промежуточного языка MSIL не должны выполнять переходы к инструкции `call`, но они могут выполнять переход к последующим <xref:System.Reflection.Emit.OpCodes.Ret>.  
  
 Текущий кадр не может быть отклонен, если управление передается из ненадежного кода в доверенный код, так как это может подвергнуть риску безопасность идентификации кода. Таким образом, .NET Framework проверки безопасности могут вызвать игнорирование `tail`, в результате чего будет использоваться стандартная инструкция <xref:System.Reflection.Emit.OpCodes.Call>. Аналогично, чтобы выйти из синхронизированной области после возврата вызова, префикс `tail` игнорируется при использовании для выхода из метода, помеченного как синхронизированный.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `tail`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Экземпляр объекта Opcode.</param>
        <summary>Возвращает true или false, в зависимости от того, принимает ли заданный код операции однобайтовый аргумент.</summary>
        <returns><see langword="true" /> или <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для определения того, какие коды MSIL являются "короткими формами", для использования в оптимизированном коде.  
  
 `TakesSingleByteArgument` возвращает `true`, если экземпляр <xref:System.Reflection.Emit.OpCode> принимает один байтовый аргумент в следующих случаях:  
  
-   Код операции выполняет инструкцию ветвления с адресом в байтах (например, <xref:System.Reflection.Emit.OpCodes.Br_S> и <xref:System.Reflection.Emit.OpCodes.Bgt_S>).  
  
-   Код операции помещает значение байта в стек (например, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).  
  
-   Код операции ссылается на переменную или аргумент с помощью короткой формы размером байта (например, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> и <xref:System.Reflection.Emit.OpCodes.Stloc_S>).  
  
 В противном случае она возвращает `false`.  
  
 В приведенном ниже примере демонстрируется использование `TakesSingleByteArgument` путем отражения в класс `OpCodes` и тестирования, чтобы проверить, принимает ли каждое поле `OpCode` однобайтовый аргумент.  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Создает объект исключения, находящийся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7а|throw|Создает исключение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект (исключение) помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и вызывается исключение.  
  
 Инструкция `throw` создает объект исключения (тип `O`) в данный момент в стеке.  
  
 <xref:System.NullReferenceException> создается, если ссылка на объект является пустой ссылкой.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `throw`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что адрес на вершине стека, возможно, не выровнен по естественному размеру следующей непосредственно за ним инструкции <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" /> или <see langword="cpblk" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|`unsigned int8`< FE 12  >|невыровненным. `alignment`|Указывает, что последующая инструкция указателя может быть несогласованной.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
 `Unaligned` указывает, что адрес (неуправляемый указатель, `native int`) в стеке может не соответствовать естественному размеру непосредственно следующего `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`или инструкции `cpblk`. Это значит, что для <xref:System.Reflection.Emit.OpCodes.Ldind_I4> инструкции выравнивание адреса может не допустить 4-байтовой границы. Для `initblk` и `cpblk` выравнивание по умолчанию зависит от архитектуры (4 байта на 32-разрядных ЦП, 8 байт на 64-разрядных ЦП). Генераторы кода, не ограничивающие свои выходные данные размером 32-разрядного слова, должны использовать `unaligned`, если во время компиляции неизвестно 8-байтное выравнивание.  
  
 Значение выравнивания должно быть равно 1, 2 или 4 и означает, что созданный код должен предположить, что адрес имеет тип Byte, двухбайтовые или четыре байта соответственно. Обратите внимание, что временные указатели (тип `*`) всегда согласовываются.  
  
 Хотя выравнивание для инструкции `cpblk` логически потребовало два числа (одно для источника и одно для назначения), на производительность не оказывает заметного влияния, если указано только меньшее число.  
  
 Префиксы `unaligned` и `volatile` можно объединять в любом порядке. Они должны непосредственно предшествовать инструкциям `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`или `cpblk`. Для <xref:System.Reflection.Emit.OpCodes.Ldsfld> и <xref:System.Reflection.Emit.OpCodes.Stsfld> инструкций допускается только префикс <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузки методов могут использовать код операции `unaligned`.  
  
-   ILGenerator. Emit (код операции, метка)  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует тип значения из упакованной формы в распакованную.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|79 < `T` >|Распаковка `valType`|Извлекает данные типа значения из `obj`, его упакованного представления.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и распаковывается в указатель типа значения.  
  
3.  Указатель типа значения помещается в стек.  
  
 Тип значения имеет два отдельных представления в Common Language Infrastructure (CLI):  
  
-   Необработанная форма, используемая при внедрении типа значения в другой объект.  
  
-   "Упакованная" форма, в которой данные в типе значения упаковываются (упаковываются) в объект, поэтому он может существовать как независимая сущность.  
  
 Инструкция `unbox` преобразует ссылку на объект (тип `O`), упакованное представление типа значения в указатель типа значения (управляемый указатель, тип `&`), его неупакованную форму. Указанный тип значения (`valType`) является маркером метаданных, указывающим тип значения, содержащегося в упакованном объекте.  
  
 В отличие от <xref:System.Reflection.Emit.OpCodes.Box>, которые необходимы для создания копии типа значения для использования в объекте, `unbox` не требуется копировать тип значения из объекта. Обычно он просто выполняет вычисление адреса типа значения, уже присутствующего внутри упакованного объекта.  
  
 <xref:System.InvalidCastException> создается, если объект не упакован как `valType`.  
  
 <xref:System.NullReferenceException> создается, если ссылка на объект является пустой ссылкой.  
  
 <xref:System.TypeLoadException> возникает, если не удается найти тип значения `valType`. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `unbox`.  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует тип, указанный в инструкции, из упакованной формы в распакованную.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|`T`< A5  >|Распаковка. любой `typeTok`|Извлеките данные из `obj`, их упакованного представления.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `obj` помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и распаковывается в тип, указанный в инструкции.  
  
3.  Результирующая ссылка на объект или тип значения помещается в стек.  
  
 При применении к упакованной форме типа значения инструкция `unbox.any` извлекает значение, содержащееся в `obj` (типа `O`), и поэтому эквивалентно `unbox`, за которым следует `ldobj`.  
  
 При применении к ссылочному типу инструкция `unbox.any` имеет тот же результат, что и `castclass` `typeTok`.  
  
 Если операнд `typeTok` является параметром универсального типа, то поведение среды выполнения определяется типом, указанным для этого параметра универсального типа.  
  
 <xref:System.InvalidCastException> возникает, если `obj` не является упакованным типом.  
  
 <xref:System.NullReferenceException> возникает, если `obj` является пустой ссылкой.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `unbox.any`.  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что адрес на вершине стека вычислений, возможно, является изменяемым и результаты чтения данной области невозможно кэшировать либо невозможно запретить множественные сохранения в эту область.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 13|независимо.|Указывает, что последующая ссылка на указатель является временной.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
 `volatile`. Указывает, что адрес является временным адресом (т. е. на него может ссылаться извне на текущий поток выполнения), и результаты чтения этого расположения не могут быть кэшированы или нельзя подавлять несколько магазинов в этом расположении. Пометка доступа `volatile` влияет только на этот единственный доступ. другие методы доступа к тому же расположению должны быть помечены отдельно. Доступ к временным расположениям не должен выполняться атомарно.  
  
 Префиксы <xref:System.Reflection.Emit.OpCodes.Unaligned> и `volatile` можно объединять в любом порядке. Они должны непосредственно предшествовать инструкциям `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`или `cpblk`. Для <xref:System.Reflection.Emit.OpCodes.Ldsfld> и <xref:System.Reflection.Emit.OpCodes.Stsfld> инструкций допускается только префикс `volatile`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `volatile`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое исключающее ИЛИ двух верхних значений в стеке вычислений и помещает результат обратно в стек.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|61|xor|Выполняет побитовое ИСКЛЮЧАЮЩее или двух целочисленных значений и возвращает целое число.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека и их побитовое исключающее XOR.  
  
4.  Побитовое исключающее XOR для `value2` и `value1` помещается в стек.  
  
 Инструкция `xor` вычислит побитовое ИСКЛЮЧАЮЩее и два верхних значения в стеке и оставляет результат в стеке.  
  
 `Xor` — это операция, относящаяся к целому числу.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `xor`.  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
