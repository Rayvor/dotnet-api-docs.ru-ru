<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aa01a71dcc6ff576fed0fc293d8b56805153408e" /><Meta Name="ms.sourcegitcommit" Value="08fc3691deb7adaf0dfd751b9d9d0b23a3d3a7b8" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/09/2019" /><Meta Name="ms.locfileid" Value="68906112" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Содержит поля, предоставляющие инструкции языка MSIL для выпуска элементами класса <see cref="T:System.Reflection.Emit.ILGenerator" /> (например, <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подробное описание кодов операций для элементов см. в документации по Common Language Infrastructure (CLI), особенно в разделе III: Набор инструкций CIL "и" раздел II: Определение и семантика метаданных ". Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.  
  
   
  
## Examples  
 В следующем примере демонстрируется создание динамического метода с помощью метода <xref:System.Reflection.Emit.ILGenerator> для порождения `OpCodes` в <xref:System.Reflection.Emit.MethodBuilder>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Складывает два значения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|58|add|Складывает два числовых значения, возвращая новое числовое значение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; добавляется в `value2`. `value1`  
  
4.  Результат помещается в стек.  
  
 Переполнение не обнаружено для целочисленных операций (для правильной обработки переполнения см. раздел <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).  
  
 Сложение целых чисел, а не насыщенность. Например, если для 8-разрядных целых чисел `value1` задано значение 255, `value2` а для параметра задано значение 1, то упакованный результат будет равен 0, а не 256.  
  
 Переполнение с плавающей `+inf` запятой`PositiveInfinity`возвращает ( `-inf` )`NegativeInfinity`или ().  
  
 Допустимые типы операндов и соответствующий тип данных результата перечислены в таблице ниже. Значение, если отсутствует запись для определенного сочетания типа (например, `int32` и; `float` `int32` и`int64`), это недопустимый промежуточный язык Майкрософт (MSIL) и создает ошибку.  
  
|операнд|Тип value1|Тип value2|Тип результата|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `add` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Складывает два целых числа, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D6|Добавить. ovf|Добавляет два целочисленных значения со знаком с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; добавляется в `value2` с проверками переполнения. `value1`  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException>Если результат не представлен в типе результата, создается исключение.  
  
 Эту операцию можно выполнить с целыми числами со знаком. Для значений с плавающей запятой используйте <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Допустимые типы операндов и соответствующий тип данных результата перечислены в таблице ниже. Значение, если отсутствует запись для определенного сочетания типа (например, `int32` и; `float` `int32` и`int64`), это недопустимая инструкция промежуточного языка MSIL и выдает ошибку.  
  
|операнд|Тип value1|Тип value2|Тип результата|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `add.ovf` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Складывает два целочисленных значения без знака, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D7|Добавить. ovf. un|Добавляет два целочисленных значения без знака с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; добавляется в `value2` с проверками переполнения. `value1`  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException>Если результат не представлен в типе результата, создается исключение.  
  
 Эту операцию можно выполнить с целыми числами со знаком. Для значений с плавающей запятой используйте <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Допустимые типы операндов и соответствующий тип данных результата перечислены в таблице ниже. Значение, если отсутствует запись для определенного сочетания типа (например, `int32` и; `float` `int32` и`int64`), это недопустимая инструкция промежуточного языка MSIL и выдает ошибку.  
  
|операнд|Тип value1|Тип value2|Тип результата|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `add.ovf.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое И двух значений и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Инструкция|Описание|  
|------------|-----------------|-----------------|  
|5F|и|Определяет побитовое и для двух целочисленных значений.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value1`и `value2` извлекаются из стека; побитовое и для двух значений является вычисленным.  
  
4.  Результат помещается в стек.  
  
 `and` Инструкция рассчитывает побитовое и для двух верхних значений в стеке и оставляет результат в стеке.  
  
 `And`— Это операция, относящаяся к целому числу.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `and` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает неуправляемый указатель на список аргументов текущего метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 00|arglist|Возвращает маркер списка аргументов для текущего метода.|  
  
 Эта операция не выполняет поведений стека вычислений.  
  
 Инструкция возвращает непрозрачный маркер (неуправляемый указатель типа `native int`), представляющий список аргументов текущего метода. `arglist` Этот маркер действителен только в течение времени существования текущего метода. Однако можно передать этот обработчик другим методам, если текущий метод находится в потоке управления. `arglist` Инструкцию можно выполнить только в методе, принимающем переменное число аргументов.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `arglist` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если два значения равны.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3B < `int32` >|бек`target`|Выполняет переход к целевой инструкции по смещению `target` , если два значения равны.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` равен `value2`, выполняется операция ветвления.  
  
 Инструкция передает управление в указанную целевую инструкцию `value1` , если равно `value2`. `beq` Результат такой же, как и при выполнении `ceq` инструкции, за которой `brtrue` следует ветвь к определенной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Допустимые типы операндов инкапсулированы ниже:  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.  
  
 Управление передачей в блоки `try`, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией <xref:System.Reflection.Emit.OpCodes.Leave> (такие передачи сильно ограничены и должны использовать инструкцию).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `beq` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если два значения равны.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2E < `int8` >|Бек. s`target`|Переход к целевой инструкции со смещением `target` если равно, краткая форма|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` равен `value2`, выполняется операция ветвления.  
  
 Инструкция передает управление в указанную целевую инструкцию `value1` , если равно `value2`. `beq.s` Результат такой же, как и при выполнении `ceq` инструкции, за которой `brtrue` следует ветвь к определенной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Допустимые типы операндов инкапсулированы ниже:  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.  
  
 Управление передачей в блоки `try`, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией <xref:System.Reflection.Emit.OpCodes.Leave> (такие передачи сильно ограничены и должны использовать инструкцию).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `beq.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3C`<int32>`|бже`target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго или равно ему.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` значение `value2`больше или равно, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции, если `value1` значение параметра `value2`больше или равно. `bge` Этот результат идентичен выполнению `clt.un` инструкции `brfalse` , за которой следует ветвь к определенной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `bge` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2F`<int8>`|бже. s`target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго или равно ему (краткая форма).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` значение `value2`больше или равно, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции, если `value1` значение параметра `value2`больше или равно. `bge.s` Этот результат идентичен выполнению `clt.un` инструкции `brfalse` , за которой следует ветвь к определенной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `bge.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|41 `<int32>`|бже. un`target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше или равно второму значению (значения без знака).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` значение `value2`больше или равно, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции `value2`, если `value1` значение больше или равно, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. `bge.un` Этот результат идентичен выполнению `clt` инструкции `brfalse` , за которой следует ветвь к определенной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `bge.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|34 < `int8` >|бже. un. s`target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше или равно второму (значения без знака), короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` значение `value2`больше или равно, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции `value2`, если `value1` значение больше или равно, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. `bge.un.s` Этот результат идентичен выполнению `clt` инструкции `brfalse` , за которой следует ветвь к определенной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `bge.un.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3D < `int32` >|бгт`target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` значение больше `value2`, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции, если `value1` больше `value2`. `bgt` Этот результат идентичен выполнению `cgt` инструкции `brtrue` , за которой следует ветвь к определенной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `bgt` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|30 < `int8` >|БГТ. s`target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго (краткая форма).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` значение больше `value2`, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции, если `value1` больше `value2`. `bgt.s` Этот результат идентичен выполнению `cgt` инструкции `brtrue` , за которой следует ветвь к определенной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `bgt.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|42 < `int32` >|БГТ. un`target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго (значения без знака).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` значение больше `value2`, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции `value2`, если `value1` значение больше, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. `bgt.un` Этот результат идентичен выполнению `cgt.un` инструкции `brtrue` , за которой следует ветвь к определенной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `bgt.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|35 < `int8` >|БГТ. un. s`target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго (значения без знака), короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` значение больше `value2`, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции `value2`, если `value1` значение больше, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. `bgt.un.s` Этот результат идентичен выполнению `cgt.un` инструкции `brtrue` , за которой следует ветвь к определенной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `bgt.un.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго значения или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3E`<int32>`|BLE`target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго или равно ему.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` значение `value2`меньше или равно, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции, если `value1` `value2`меньше или равно. `ble` Этот результат идентичен выполнению `cgt` инструкции (`cgt.un` для операций с плавающей запятой), за `brfalse` которой следует ветвь к определенной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ble` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|31 `<int8>`|BLE. s`target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго или равно ему (короткая форма).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` значение `value2`меньше или равно, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции, если `value1` `value2`меньше или равно. `ble.s` Этот результат идентичен выполнению `cgt` инструкции (`cgt.un` для операций с плавающей запятой`brfalse` ), за которой следует ветвь к определенной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ble.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго или равно ему (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|43 `<int32>`|BLE. un`target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше или равно второму значению (значения без знака).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` значение `value2`меньше или равно, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции `value2`, если `value1` меньше или равно, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. `ble.un` Этот результат идентичен выполнению `cgt.un` инструкции (`cgt` для операций с плавающей запятой), за `brfalse` которой следует ветвь к определенной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ble.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго или равно ему (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|36 `<int8>`|BLE. un. s`target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше или равно второму (значения без знака), короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` значение `value2`меньше или равно, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции `value2`, если `value1` меньше или равно, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. `ble.un.s` Этот результат идентичен выполнению `cgt.un` инструкции (`cgt` для операций с плавающей запятой), за `brfalse` которой следует ветвь к определенной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ble.un.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3F < `int32` >|блт`target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` меньше `value2`, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции, если `value1` `value2`меньше или равно. `blt` Этот результат идентичен выполнению `clt` инструкции `brtrue` , за которой следует ветвь к определенной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `blt` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|32 < `int8` >|БЛТ. s`target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго (краткая форма).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` меньше `value2`, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции, если `value1` меньше `value2`. `blt.s` Этот результат идентичен выполнению `clt` инструкции `brtrue` , за которой следует ветвь к определенной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `blt.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|44 < `int32` >|БЛТ. un`target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго (значения без знака).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` меньше `value2`, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции, если `value1` меньше, чем `value2`при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. `blt.un` Этот результат идентичен выполнению `clt.un` инструкции `brtrue` , за которой следует ветвь к определенной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `blt.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|37 < `int8` >|БЛТ. un. s`target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго (значения без знака), короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` меньше `value2`, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции, если `value1` меньше, чем `value2`при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. `blt.un` Этот результат идентичен выполнению `clt.un` инструкции `brtrue` , за которой следует ветвь к определенной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `blt.un.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции в случае неравенства двух целочисленных значений без знака или двух неупорядоченных значений с плавающей запятой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|40 < `int32` >|бне. un`target`|Выполняет переход к целевой инструкции с указанным смещением, если два целочисленных значения без знака не равны (значения без знака).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` не равно `value2`, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции `value2`, если `value1` не равно, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. `bne.un` Этот результат идентичен выполнению `ceq` инструкции `brfalse` , за которой следует ветвь к определенной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `bne.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма) в случае неравенства двух целочисленных значений без знака или двух неупорядоченных значений с плавающей запятой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|33 < `int8` >|бне. un. s`target`|Выполняет переход к целевой инструкции с указанным смещением, если два целочисленных значения без знака не равны (значения без знака), краткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; если `value1` не равно `value2`, выполняется операция ветвления.  
  
 Инструкция передает управление указанной конечной инструкции `value2`, если `value1` не равно, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. `bne.un` Этот результат идентичен выполнению `ceq` инструкции `brfalse` , за которой следует ветвь к определенной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `bne.un.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует тип значения в ссылку на объект (тип <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8C < `T` >|Box`valTypeToken`|Преобразование типа значения (типа, указанного в `valTypeToken`) в значение фактической ссылки на объект.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Тип значения помещается в стек.  
  
2.  Тип значения извлекается из стека; `box` операция выполняется.  
  
3.  Ссылка на объект, получивший "упакованный" тип значения, помещается в стек.  
  
 Тип значения имеет два отдельных представления в Common Language Infrastructure (CLI):  
  
-   Необработанная форма, используемая при внедрении типа значения в другой объект или в стек.  
  
-   "Упакованная" форма, в которой данные в типе значения упаковываются (упаковываются) в объект, поэтому он может существовать как независимая сущность.  
  
 Инструкция преобразует тип значения "RAW" (распакованного) в ссылку на объект (тип `O`). `box` Это достигается путем создания нового объекта и копирования данных из типа значения в новый выделенный объект. `valTypeToken`является маркером метаданных, указывающим тип значения в стеке.  
  
 <xref:System.OutOfMemoryException>возникает, если недостаточно памяти для удовлетворения запроса.  
  
 <xref:System.TypeLoadException>Если класс не найден, вызывается исключение. Обычно это обнаруживается при преобразовании MSIL в машинный код, а не во время выполнения.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `box` использовать код операции:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Обеспечивает безусловную передачу управления конечной инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br`target`|Выполняет переход к целевой инструкции по указанному смещению.|  
  
 Эта операция не выполняет поведений стека вычислений.  
  
 `br` Инструкция безусловно передает управление целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `br` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Обеспечивает безусловную передачу управления конечной инструкции (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br. s`target`|Выполняет переход к целевой инструкции по указанному смещению (краткая форма).|  
  
 Эта операция не выполняет поведений стека вычислений.  
  
 `br.s` Инструкция безусловно передает управление целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `br.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сообщает инфраструктуре CLI, что необходимо оповестить отладчик о достижении точки останова.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|01|break|Сообщите отладчику о достижении точки останова.|  
  
 Эта операция не выполняет поведений стека вычислений.  
  
 `break` Инструкция предназначена для поддержки отладки. Он сигнализирует интерфейсу командной строки сообщить отладчику о том, что точка останова была остановлена. Он не влияет на состояние интерпретатора.  
  
 `break` Инструкция имеет наименьший возможный размер инструкции, позволяя выполнять исправление кода с точкой останова и создавать минимальный беспорядки для окружающего кода.  
  
 `break` Инструкция может выполнять треппинг в отладчике, не выполнять никаких действий или вызывать исключение безопасности. Точное поведение определяется реализацией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `break` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если значением <paramref name="value" /> является <see langword="false" />, пустая ссылка (<see langword="Nothing" /> в Visual Basic) или ноль.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|39 < `int32` >|брфалсе`target`<br /><br /> брнулл`target`<br /><br /> брзеро`target`|Выполняет переход к целевой инструкции с указанным смещением, `false`если значение равно.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек с помощью предыдущей операции.  
  
2.  `value`извлекается из стека; Если `value` имеет `false`значение, то `target`ветвь устанавливается в.  
  
 `value` `brzero` `int32` `O` `int64`Инструкция (и ее псевдонимы `brnull` и) передает управление указанной конечной инструкции, если (типа,, ссылка на объект, управляемый указатель `brfalse` , временный `*`указатель `native int`,) равен нулю`false`(). `&` Если `value` выполнение не равно нулю (`true`), продолжение выполнения в следующей инструкции.  
  
 Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `brfalse` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если значением <paramref name="value" /> является <see langword="false" />, пустая ссылка или ноль.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2C <`int8` >|брфалсе. s`target`<br /><br /> брнулл. s`target`<br /><br /> брзеро. s`target`|Выполняет переход к целевой инструкции с указанным смещением, `false`если, краткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек с помощью предыдущей операции.  
  
2.  `value`извлекается из стека; Если `value` имеет `false`значение, то `target`ветвь устанавливается в.  
  
 `value` `brzero` `int32` `O` `int64`Инструкция (и ее псевдонимы `brnull` и) передает управление указанной конечной инструкции, если (типа,, ссылка на объект, управляемый указатель `brfalse.s` , временный `*`указатель `native int`,) равен нулю`false`(). `&` Если `value` выполнение не равно нулю (`true`), продолжение выполнения в следующей инструкции.  
  
 Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `brfalse.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если значение <paramref name="value" /> равно <see langword="true" />, либо отличается от null и от нуля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3A < `int32` >|требовалась brtrue`target`<br /><br /> бринст`target`|Выполняет переход к целевой инструкции с указанным смещением, если не равен нулю`true`().|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек с помощью предыдущей операции.  
  
2.  `value`извлекается из стека; Если `value` имеет `true`значение, то `target`ветвь устанавливается в.  
  
 Инструкция передает управление указанной конечной инструкции, если `value` (Type `native int`) не равно нулю (`true`). `brtrue` Если `value` значение равно нулю`false`(), продолжение выполнения в следующей инструкции.  
  
 Если `value` — это ссылка на объект ( `O`тип) `brinst` , то (псевдоним `brtrue`для) передает управление, если он представляет экземпляр объекта (например, если он не является ссылкой на объект null); см. <xref:System.Reflection.Emit.OpCodes.Ldnull>раздел).  
  
 Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `brtrue` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если значение <paramref name="value" /> равно <see langword="true" /> либо отличается от null и от нуля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2D < `int8` >|требовалась brtrue. s`target`<br /><br /> бринст. s`target`|Выполняет переход к целевой инструкции с указанным смещением, если ненулевая`true`(), короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек с помощью предыдущей операции.  
  
2.  `value`извлекается из стека; Если `value` имеет `true`значение, то `target`ветвь устанавливается в.  
  
 Инструкция передает управление указанной конечной инструкции, если `value` (Type `native int`) не равно нулю (`true`). `brtrue.s` Если `value` значение равно нулю`false`(), продолжение выполнения в следующей инструкции.  
  
 Если `value` — это ссылка на объект ( `O`тип) `brinst` , то (псевдоним `brtrue`для) передает управление, если он представляет экземпляр объекта (например, если он не является ссылкой на объект null); см. <xref:System.Reflection.Emit.OpCodes.Ldnull>раздел).  
  
 Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `brtrue.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывает метод, на который ссылается переданный дескриптор метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|28 < `T` >|обращение`methodDesc`|Вызовите метод, `methodDesc`описанный в.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Аргументы `arg1` метода посредством `argN` помещаются в стек.  
  
2.  Аргументы `arg1` метода через `argN` извлекаются из стека; вызов метода выполняется с этими аргументами, а управление передается методу, на который ссылается дескриптор метода. По завершении возвращаемое значение создается вызываемым методом и отправляется вызывающему объекту.  
  
3.  Возвращаемое значение помещается в стек.  
  
 `call` Инструкция вызывает метод, указанный дескриптором метода, передаваемым с инструкцией. Дескриптор метода — это маркер метаданных, указывающий вызываемый метод и число, тип и порядок аргументов, которые были помещены в стек для передачи в этот метод, а также соглашение о вызовах для использования. Инструкции может быть непосредственно перед `tail` инструкцией (<xref:System.Reflection.Emit.OpCodes.Tailcall>), чтобы указать, что текущее состояние метода должно быть освобождено перед передачей управления. `call` Если вызов передает управление методу более высокого уровня доверия, чем метод источника, кадр стека не освобождается. Вместо этого выполнение продолжится без уведомления, как если `tail` бы не было предоставлено. Маркер метаданных содержит достаточную информацию для определения того, относится ли вызов к статическому методу, методу экземпляра, виртуальному методу или глобальной функции. Во всех этих случаях адрес назначения определяется исключительно из дескриптора метода (Сравните это с <xref:System.Reflection.Emit.OpCodes.Callvirt> инструкцией для вызова виртуальных методов, где адрес назначения также зависит от типа экземпляра среды выполнения. ссылка, <xref:System.Reflection.Emit.OpCodes.Callvirt>помещаемая перед).  
  
 Аргументы помещаются в стек в порядке слева направо. То есть первый аргумент выводится и помещается в стек, затем второй аргумент — третий, пока все необходимые аргументы не помещаются в стек в убывающем порядке. Существует три важных случая.  
  
 1. Вызовы метода экземпляра (или виртуального) должны отправить ссылку на этот экземпляр перед любыми видимыми пользователем аргументами. Ссылка на экземпляр не должна быть пустой ссылкой. Подпись, переданная в метаданные, не содержит записи в списке параметров для `this` указателя; вместо этого используется бит, указывающий, требует ли метод `this` передачи указателя.  
  
 2. Допускается вызов виртуального метода с помощью `call` ( `callvirt`а не); это означает, что метод должен быть разрешен с помощью класса, заданного методом, а не как указано динамически в вызываемом объекте.  
  
 3. Обратите внимание, что `Invoke` метод делегата можно вызывать с `call` помощью инструкции `callvirt` или.  
  
 <xref:System.Security.SecurityException>может возникнуть, если система безопасности не предоставляет вызывающему объекту доступ к вызываемому методу. Проверка безопасности может происходить, когда инструкции MSIL преобразуются в машинный код, а не во время выполнения.  
  
> [!NOTE]
>  При вызове методов типа System. Object для типов значений рекомендуется использовать `constrained` префикс `callvirt` с инструкцией `call` вместо выдачи инструкции. Это избавляет от необходимости создавать разные IL в зависимости от того, переопределяет ли тип значения метод, избегая возможной проблемы управления версиями. Рекомендуется использовать `constrained` префикс при вызове методов интерфейса для типов значений, так как метод типа значения, реализующий метод интерфейса, можно изменить `MethodImpl`с помощью. Эти проблемы более подробно описаны в <xref:System.Reflection.Emit.OpCodes.Constrained> коде операций.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузки метода могут `call` использовать код операции:  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
-   ILGenerator. Емиткалл (код операции, MethodInfo, тип [])  
  
> [!NOTE]
>  Метод предоставляется для `varargs`вызовов. <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Используйте метод для обычных вызовов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывает метод, заданный в стеке вычислений (как указатель на точку входа), с аргументами, описанными в соглашении о вызовах.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|29 < `T` >|Calli`callSiteDescr`|Вызывает метод, указываемый с аргументами, описанными в соглашении о вызовах.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Аргументы `arg1` метода посредством `argN` помещаются в стек.  
  
2.  Указатель на запись метода помещается в стек.  
  
3.  Аргументы `arg1` метода через `argN` и указатель входа метода извлекаются из стека; выполняется вызов метода. По завершении возвращаемое значение создается вызываемым методом и отправляется вызывающему объекту.  
  
4.  Возвращаемое значение помещается в стек.  
  
 Инструкция вызывает указатель записи метода с аргументами `arg1` через `argN`. `calli` Типы этих аргументов описаны конкретным соглашением о вызовах (`callSiteDesc`). Инструкции может быть непосредственно предшествует `tail` префикс (<xref:System.Reflection.Emit.OpCodes.Tailcall>), чтобы указать, что текущее состояние метода должно быть освобождено перед передачей управления. `calli` Если вызов передает управление методу с более высоким уровнем доверия, чем метод источника, кадр стека не будет освобожден; Вместо этого выполнение продолжится без уведомления, как если `tail` бы не было предоставлено.  
  
 Указатель входа метода считается определенным указателем на машинный код (на целевом компьютере), который можно использовать с аргументами, описанными в соглашении о вызовах (маркер метаданных для отдельной подписи). Такой указатель может быть создан с помощью <xref:System.Reflection.Emit.OpCodes.Ldftn> инструкций или <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> или передается из машинного кода.  
  
 Соглашение о вызовах не проверяется динамически, поэтому код, использующий `calli` инструкцию, не работает должным образом, если назначение фактически не использует указанное соглашение о вызовах.  
  
 Аргументы помещаются в стек в порядке слева направо. То есть первый аргумент выводится и помещается в стек, затем второй аргумент — третий, пока все необходимые аргументы не помещаются в стек в убывающем порядке. Последовательность кода для создания аргументов для экземпляра или виртуального метода должна отправить ссылку на экземпляр (которая не должна быть пустой ссылкой) перед любыми видимыми пользователем аргументами.  
  
 <xref:System.Security.SecurityException>может возникнуть, если системная безопасность не предоставляет вызывающему объекту доступ к вызываемому методу. Проверка безопасности может происходить, когда инструкции MSIL преобразуются в машинный код, а не во время выполнения.  
  
 <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> Для`calli` выполнения инструкций в стеке можно использовать следующие методы. Обратите `calli` внимание, что метод должен вызываться через приведенные ниже <xref:System.Reflection.Emit.ILGenerator.Emit%2A> методы, а не использовать класс для размещения инструкции непосредственно в стеке.  
  
-   ILGenerator. Емиткалли (opcode, Каллингконвентионс, Type, Type [], Type []) для вызовов, использующих соглашение об управляемом вызовах.  
  
-   ILGenerator. Емиткалли (opcode, CallingConvention, Type, Type []) для вызовов, использующих неуправляемое соглашение о вызовах.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывает метод объекта с поздней привязкой и помещает возвращаемое значение в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6F < `T` >|применен`method`|Вызывает конкретный метод, связанный с `obj`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка `obj` на объект помещается в стек.  
  
2.  Аргументы `arg1` метода посредством `argN` помещаются в стек.  
  
3.  Аргументы `arg1` метода через `argN` и ссылка `obj` на объект извлекаются из стека; вызов метода выполняется с этими аргументами `obj` , а управление передается методу, который указан в методе. токен метаданных. По завершении возвращаемое значение создается вызываемым методом и отправляется вызывающему объекту.  
  
4.  Возвращаемое значение помещается в стек.  
  
 `callvirt` Инструкция вызывает метод с поздним связыванием для объекта. То есть метод выбирается на основе типа `obj` среды выполнения, а не класса времени компиляции, видимого в указателе метода. `Callvirt`может использоваться для вызова как виртуальных, так и методов экземпляра. Инструкции может предшествовать `tail` префикс (<xref:System.Reflection.Emit.OpCodes.Tailcall>), указывающий, что текущий кадр стека должен быть освобожден перед передачей управления. `callvirt` Если вызов передает управление методу с более высоким уровнем доверия, чем исходный метод, кадр стека не будет освобожден.  
  
 Токен метаданных метода предоставляет имя, класс и сигнатуру вызываемого метода. Класс, связанный с `obj` , является классом, экземпляром которого является. Если класс определяет нестатический метод, соответствующий указанному имени и сигнатуре метода, вызывается этот метод. В противном случае все классы в цепочке базовых классов этого класса проверяются по порядку. Если метод не найден, возникает ошибка.  
  
 `Callvirt`Извлекает объект и связанные аргументы из стека вычислений перед вызовом метода. Если метод имеет возвращаемое значение, он помещается в стек после завершения метода. На стороне `obj` вызываемого метода доступ к параметру осуществляется в качестве аргумента 0, `arg1` в качестве аргумента 1 и т. д.  
  
 Аргументы помещаются в стек в порядке слева направо. То есть первый аргумент выводится и помещается в стек, затем второй аргумент — третий, пока все необходимые аргументы не помещаются в стек в убывающем порядке. Ссылка `obj` на экземпляр (всегда требуется для `callvirt`) должна быть передана перед любыми видимыми пользователем аргументами. Сигнатура (переданная в маркере метаданных) не должна содержать запись в списке параметров для этого указателя.  
  
 Обратите внимание, что виртуальный метод также может вызываться <xref:System.Reflection.Emit.OpCodes.Call> с помощью инструкции.  
  
 <xref:System.MissingMethodException>вызывается, если нестатический метод с указанным именем и подписью не удалось найти в классе, связанном с `obj` базовыми классами или с любым из его базовых классов. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 <xref:System.NullReferenceException>если obj имеет значение null, создается исключение.  
  
 <xref:System.Security.SecurityException>возникает, если системная безопасность не предоставляет вызывающему объекту доступ к вызываемому методу. Проверка безопасности может произойти, когда CIL преобразуется в машинный код, а не во время выполнения.  
  
> [!NOTE]
>  При вызове методов типа System. Object для типов значений рекомендуется использовать `constrained` префикс `callvirt` с инструкцией. Это избавляет от необходимости создавать разные IL в зависимости от того, переопределяет ли тип значения метод, избегая возможной проблемы управления версиями. Рекомендуется использовать `constrained` префикс при вызове методов интерфейса для типов значений, так как метод типа значения, реализующий метод интерфейса, можно изменить `MethodImpl`с помощью. Эти проблемы более подробно описаны в <xref:System.Reflection.Emit.OpCodes.Constrained> коде операций.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `callvirt` использовать код операции:  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
-   ILGenerator. Емиткалл (код операции, MethodInfo, тип [])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Предпринимает попытку привести объект, передаваемый по ссылке, к указанному классу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|74 < `T` >|касткласс`class`|Приводит объект к новому объекту типа `class`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека; Объект, на который указывает ссылка, приводится к указанному `class`.  
  
3.  В случае успеха новая ссылка на объект помещается в стек.  
  
 Инструкция пытается привести ссылку на объект (тип `O`) на вершине стека к указанному классу. `castclass` Новый класс задается маркером метаданных, указывающим нужный класс. Если класс объекта в верхней части стека не реализует новый класс (предполагая, что новый класс является интерфейсом) и не является производным классом нового класса <xref:System.InvalidCastException> , создается исключение. Если ссылка на объект является пустой ссылкой, `castclass` метод завершается и возвращает новый объект как пустую ссылку.  
  
 <xref:System.InvalidCastException>если obj не может быть приведен к классу, создается исключение.  
  
 <xref:System.TypeLoadException>Если класс не найден, возникает исключение. Обычно это обнаруживается при преобразовании инструкции MSIL в машинный код, а не во время выполнения.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `castclass` использовать код операции:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения. Если они равны, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 01|цек|Отправляет 1, если `value1` равно `value2`; в противном случае отправляет 0.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; сравнивается с `value2`. `value1`  
  
4.  Если `value1` значение`value2`равно, 1 помещается в стек; в противном случае 0 помещается в стек.  
  
 `ceq` Инструкция`value1` сравнивает и .`value2` Если `value1` параметр `value2`равен ,`int32`то в стек помещается 1 (of). В противном случае в `int32`стек помещается значение 0 (of).  
  
 Для числа с плавающей запятой `ceq` возвращает 0, если числа не упорядочены (или оба имеют значение NaN). Бесконечные значения равны самому себе.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ceq` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения. Если первое значение больше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 02|кгт|Отправляет 1, если `value1` `value2`больше, иначе отправляет 0.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; проверяет, `value1` превышает ли значение `value2`. `cgt`  
  
4.  Если `value1` значение`value2`больше, 1 помещается в стек; в противном случае 0 помещается в стек.  
  
 `cgt` Инструкция`value1` сравнивает и .`value2` Если `value1` строго `int32` больше, то в стек помещается значение 1. `value2` В противном случае в стек помещается значение0.`int32`  
  
-   Для чисел с плавающей запятой `cgt` возвращает 0, если числа не упорядочены (то есть если один или оба аргумента имеют значение NaN).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `cgt` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения без знака или два неупорядоченных значения. Если первое значение больше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 03|КГТ. un|Отправляет 1, если `value1` `value2`больше, иначе отправляет 0 (неподписанные значения).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; проверяет, `value1` превышает ли значение `value2`. `cgt.un`  
  
4.  Если `value1` значение`value2`больше, 1 помещается в стек; в противном случае 0 помещается в стек.  
  
 Значение 1 помещается в стек, если имеется одно из `true` следующих значений: `int32`  
  
 Для чисел `value1` с плавающей запятой не упорядочивается по отношению к `value2`.  
  
 Для целочисленных значений `value1` строго больше, чем `value2` при использовании чисел без знака.  
  
 В противном случае в стек помещается значение0.`int32`  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `cgt.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Создает исключение <see cref="T:System.ArithmeticException" />, если значение не является конечным числом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|C3|ккфините|создавать <xref:System.ArithmeticException> , если значение не является конечным числом.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек. 
  
2.  `value`извлекается из стека, и `ckfinite` на него выполняется инструкция.  
  
3.  `value`помещается обратно в стек, если исключение не создается.  
  
 Создает `ckfinite instruction` исключение <xref:System.ArithmeticException> `+-` , Если`value` (число с плавающей запятой) является либо значением "не число" (NaN), либо бесконечностью. `Ckfinite`оставляет значение в стеке, если исключение не создается. Выполнение не указано, если `value` не является числом с плавающей запятой.  
  
 <xref:System.ArithmeticException>вызывается, `value` если не является нормальным числом.  
  
 Обратите внимание, что специальное исключение или производный <xref:System.ArithmeticException> класс могут быть более подходящими, передавая неверное значение обработчику исключений.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ckfinite` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения. Если первое значение меньше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 04|чилийскому|Отправляет 1, если `value1` `value2`меньше, иначе отправляет 0.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности: 

1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; проверяет, `value1` меньше`value2`лизначение. `clt`  
  
4.  Если `value1` значение`value2`меньше, 1 помещается в стек; в противном случае 0 помещается в стек.  
  
 `clt` Инструкция`value1` сравнивает и .`value2` Если `value1` строго `int32` меньше, то в стек помещается значение 1. `value2` В противном случае в стек помещается значение0.`int32`  
  
-   Для чисел с плавающей запятой `clt` возвращает 0, если числа не упорядочены (то есть если один или оба аргумента имеют значение NaN).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `clt` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения без знака или два неупорядоченных значения <paramref name="value1" /> и <paramref name="value2" />. Если значение <paramref name="value1" /> меньше значения <paramref name="value2" />, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 05|средство регистрации звонков. un|Помещает 1, `value1` если `value2`меньше; else отправляет 0 (неподписанные значения).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; проверяет, `value1` меньше`value2`лизначение. `clt.un`  
  
4.  Если `value1` значение`value2`меньше, 1 помещается в стек; в противном случае 0 помещается в стек.  
  
 `clt.un` Инструкция`value1` сравнивает и .`value2` `int32` Значение 1 помещается в стек, если выполняется одно из следующих условий.  
  
-   `value1`строго меньше `value2` (как для `clt`).  
  
-   Для чисел `value1` с плавающей запятой не упорядочивается по отношению к `value2`.  
  
-   Для целочисленных значений `value1` строго меньше, чем `value2` при использовании числа без знака.  
  
 В противном случае в стек помещается значение0.`int32`  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `clt.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ограничивает тип, для которого был вызван виртуальный метод.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 16 <`T` >|ограниченного. `thisType`|Вызов виртуального метода для типа, ограниченного типом `T`.|  
  
 Префикс разрешен только `callvirt` для инструкции. `constrained`  
  
 В этой точке состояние стека MSIL должно быть следующим:  
  
1.  Управляемый указатель `ptr`,, помещается в стек. Тип `ptr` должен быть управляемым указателем (`&`) на `thisType`. Обратите внимание, что это отличается от случая с непрефиксной `callvirt` инструкцией, которая принимает `thisType`ссылку.  
  
2.  Аргументы `arg1` метода посредством `argN` передаются в стек, как и `callvirt` при использовании непрефиксной инструкции.  
  
 Префикс предназначен для того `callvirt` , чтобы инструкции были выполнены единообразно независимо от того, является ли `thisType` тип значения или ссылочный тип. `constrained`  
  
 `callvirt` Еслиинструкция`constrained` имеет префикс ,инструкциявыполняетсяследующимобразом:`thisType` `method`  
  
-   Если `thisType` является ссылочным типом (в отличие от типа значения), то `ptr` разыменование отменяется и передается как указатель `callvirt` `method`this в.  
  
-   Если `thisType` является типом значения и `thisType` реализует `method` , то `ptr` `method` `call` передаетсянеизмененнымкак`method` указатель this на инструкцию, для реализации `thisType`.  
  
-   Если `thisType` является типом значения и `thisType` не реализуется `method` , то `ptr` он удаляется, упаковывается и передается в качестве указателя `callvirt` `method` this в инструкцию.  
  
 Последний случай может произойти, только если `method` был определен для <xref:System.Object>, <xref:System.ValueType>или <xref:System.Enum> , а не переопределен `thisType`. В этом случае упаковка создает копию исходного объекта. Однако, поскольку ни один из методов <xref:System.Object>, <xref:System.ValueType>и <xref:System.Enum> не изменяет состояние объекта, этот факт не может быть обнаружен.  
  
 `constrained` Префикс поддерживает генераторы IL, которые создают универсальный код. `callvirt` Обычно инструкция недопустима для типов значений. Вместо этого необходимо, чтобы компиляторы Il эффективно выполняли преобразование «this», описанное выше во время компиляции, в зависимости от типа `ptr` и вызываемого метода. Однако, если `ptr` является универсальным типом, неизвестным во время компиляции, невозможно сделать это преобразование во время компиляции.  
  
 Код операции позволяет компиляторам Il выполнять вызов виртуальной функции единообразно независимо от того, является ли `ptr` тип значения или ссылочный тип. `constrained` Хотя он предназначен для случая `thisType` `constrained` , когда является переменной универсального типа, префикс также работает для неуниверсальных типов и может уменьшить сложность создания виртуальных вызовов в языках, которые скрывают различие между типами значений и ссылочные типы.  
  
 `constrained` Использование префикса также позволяет избежать потенциальных проблем с управлением версиями с типами значений. `constrained` Если префикс не используется, должен выдаваться другой Il в зависимости от того, переопределяет ли тип значения метод System. Object. Например, если `V` тип значения переопределяет метод Object. ToString () `Object.ToString()` `call` `V.ToString()` , выдается инструкция; в `box` противном случае создается инструкция и `callvirt` инструкция. Проблема управления версиями может возникнуть в первом случае, если переопределение позже удаляется, и в последнем случае, если переопределение добавляется позже.  
  
 Префикс также можно использовать для вызова методов интерфейса для типов значений, так как метод типа значения, реализующий метод интерфейса, может быть изменен `MethodImpl`с помощью. `constrained` `constrained` Если префикс не используется, компилятор принудительно выбирает, к какому из методов типа значения следует выполнить привязку во время компиляции. `constrained` Использование префикса позволяет выполнить привязку MSIL к методу, реализующему метод интерфейса во время выполнения, а не во время компиляции.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `constrained` использовать код операции:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D3|Кредит i|Преобразование в `native int`, принудительная отправка `native int` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.i` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения `int32` менее 4 байт расширяются до, когда они загружаются в стек вычислений (если `conv.i` не используется или `conv.u` , в этом случае результат также `native int`равен). Значения с плавающей запятой преобразуются `F` в тип.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании типа `float64` в объект `float32`точность может быть потеряна. Если `value` значение слишком велико `float32 (F)`, чтобы вместить плюс бесконечность (если `value` является положительным) или отрицательная бесконечность `value` (если имеет отрицательное значение), возвращается значение. Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> . <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> инструкции и для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.i` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="int8" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|67|с кредитом. i1|Преобразование в `int8`, принудительная отправка `int32` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.i1` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения `int32` менее 4 байт расширяются до, когда они загружаются в стек вычислений (если `conv.i` не используется или `conv.u` , в этом случае результат также `native int`равен). Значения с плавающей запятой преобразуются `F` в тип.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании типа `float64` в объект `float32`точность может быть потеряна. Если `value` значение слишком велико `float32 (F)`, чтобы вместить плюс бесконечность (если `value` является положительным) или отрицательная бесконечность `value` (если имеет отрицательное значение), возвращается значение. Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> . <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> инструкции и для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.i1` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="int16" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|68|Кредитный I2|Преобразование в `int16`, принудительная отправка `int32` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.i2` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения `int32` менее 4 байт расширяются до, когда они загружаются в стек вычислений (если `conv.i` не используется или `conv.u` , в этом случае результат также `native int`равен). Значения с плавающей запятой преобразуются `F` в тип.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании типа `float64` в объект `float32`точность может быть потеряна. Если `value` значение слишком велико `float32 (F)`, чтобы вместить плюс бесконечность (если `value` является положительным) или отрицательная бесконечность `value` (если имеет отрицательное значение), возвращается значение. Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> . <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> инструкции и для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.i2` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|69|с просчетом. i4|Преобразование в `int32`, принудительная отправка `int32` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.i4` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения `int32` менее 4 байт расширяются до, когда они загружаются в стек вычислений (если `conv.i` не используется или `conv.u` , в этом случае результат также `native int`равен). Значения с плавающей запятой преобразуются `F` в тип.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании типа `float64` в объект `float32`точность может быть потеряна. Если `value` значение слишком велико `float32 (F)`, чтобы вместить плюс бесконечность (если `value` является положительным) или отрицательная бесконечность `value` (если имеет отрицательное значение), возвращается значение. Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> . <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> инструкции и для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.i4` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6A|заменяющий i8|Преобразование в `int64`, принудительная отправка `int64` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.i8` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения `int32` менее 4 байт расширяются до, когда они загружаются в стек вычислений (если `conv.i` не используется или `conv.u` , в этом случае результат также `native int`равен). Значения с плавающей запятой преобразуются `F` в тип.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании типа `float64` в объект `float32`точность может быть потеряна. Если `value` значение слишком велико `float32 (F)`, чтобы вместить плюс бесконечность (если `value` является положительным) или отрицательная бесконечность `value` (если имеет отрицательное значение), возвращается значение. Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> . <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> инструкции и для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.i8` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="native int" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D4|ovf. i|Преобразуйте в `native int` (в стеке как `native int`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.i` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="native int" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8A|проovf. i. un|Преобразует значение без знака в `native int` (в стеке как `native int`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i.un` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.i.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int8" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B3|ovf. i1|Преобразуйте в `int8` (в стеке как `int32`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i1` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.i1` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int8" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|82|ovf. i1. un|Преобразует значение без знака в `int8` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i1.un` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.i1.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int16" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B5|ovf. i2|Преобразуйте в `int16` (в стеке как `int32`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i2` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.i2` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int16" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|83|ovf. i2. un|Преобразует значение без знака в `int16` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i2.un` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.i2.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int32" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B7|ovf. i4|Преобразуйте в `int32` (в стеке как `int32`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i4` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.i4` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int32" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|84|ovf. i4. un|Преобразует значение без знака в `int32` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i4.un` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.i4.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int64" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B9|ovf. i8|Преобразуйте в `int64` (в стеке как `int64`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i8` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.i8` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int64" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|85|ovf. i8. un|Преобразует значение без знака в `int64` (в стеке как `int64`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.i8.un` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.i8.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned native int" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D5|ovf. u|Преобразуйте в `unsigned native int` (в стеке как `native int`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.u` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned native int" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8B|ovf. u. un|Преобразует значение UN без знака в `unsigned native int` (в стеке как `native int`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u.un` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.uvf.u.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="unsigned int8" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B4|ovf. U1|Преобразуйте в `unsigned int8` (в стеке как `int32`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u1` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.u1` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int8" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|86|ovf. U1. un|Преобразует значение без знака в `unsigned int8` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u1.un` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.u1.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="unsigned int16" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B6|ovf. U2|Преобразуйте в `unsigned int16` (в стеке как `int32`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u2` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.u2` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int16" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|87|проovf. U2. un|Преобразует значение без знака в `unsigned int16` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u2.un` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.u2.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B8|ovf. U4|Преобразуйте в `unsigned int32` (в стеке как `int32`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u4` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.u4` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|88|ovf. U4. un|Преобразует значение без знака в `unsigned int32` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u4.un` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.u4.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned int64" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|БИЗНЕС|ovf. u8|Преобразуйте в `unsigned int64` (в стеке как `int64`) и вызовите исключение при переполнении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u8` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.u8` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int64" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|89|ovf. u8. un|Преобразует значение без знака в `unsigned int64` (в стеке как `int64`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.ovf.u8.un` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и помещает это преобразованное значение в верхнюю часть стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 `int32` байт расширяются до, когда они загружаются в стек вычислений (если `conv.ovf.i` не используется или `conv.ovf.u` , в этом случае результат `native int`также равен).  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.ovf.u8.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразование целочисленного значения без знака на вершине стека вычислений в <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|76|Рассчет. r. un|Преобразует целое число без знака в число с плавающей `F` запятой, отправляя его в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.r.un` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения `int32` менее 4 байт расширяются до, когда они загружаются в стек вычислений (если `conv.i` не используется или `conv.u` , в этом случае результат также `native int`равен). Значения с плавающей запятой преобразуются `F` в тип.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании типа `float64` в объект `float32`точность может быть потеряна. Если `value` значение слишком велико `float32 (F)`, чтобы вместить плюс бесконечность (если `value` является положительным) или отрицательная бесконечность `value` (если имеет отрицательное значение), возвращается значение. Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в `result` целое число, возвращаемое значение не определено. Операция принимает целое число из стека, интерпретирует его как неподписанное и заменяет его на число с плавающей запятой, представляющее целое число: либо, `float32`если это достаточно для представления целого числа без потери точности, или в противном случае `conv.r.un` а `float64`.  
  
 При использовании этого поля исключения никогда не возникают.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.r.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6B|с кредитом. R4|Преобразование в `float32`, принудительная отправка `F` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.r4` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения `int32` менее 4 байт расширяются до, когда они загружаются в стек вычислений (если `conv.i` не используется или `conv.u` , в этом случае результат также `native int`равен). Значения с плавающей запятой преобразуются `F` в тип.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании типа `float64` в объект `float32`точность может быть потеряна. Если `value` значение слишком велико `float32 (F)`, чтобы вместить плюс бесконечность (если `value` является положительным) или отрицательная бесконечность `value` (если имеет отрицательное значение), возвращается значение. Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.r4` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="float64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6C|с кредитом. R8|Преобразование в `float64`, принудительная отправка `F` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.r8` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения `int32` менее 4 байт расширяются до, когда они загружаются в стек вычислений (если `conv.i` не используется или `conv.u` , в этом случае результат также `native int`равен). Значения с плавающей запятой преобразуются `F` в тип.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании типа `float64` в объект `float32`точность может быть потеряна. Если `value` значение слишком велико `float32 (F)`, чтобы вместить плюс бесконечность (если `value` является положительным) или отрицательная бесконечность `value` (если имеет отрицательное значение), возвращается значение. Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.r8` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned native int" />, а затем расширяет его до <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|E0|Кредит u|Преобразование в `unsigned native int`, принудительная отправка `native int` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.u` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения `int32` менее 4 байт расширяются до, когда они загружаются в стек вычислений (если `conv.i` не используется или `conv.u` , в этом случае результат также `native int`равен). Значения с плавающей запятой преобразуются `F` в тип.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании типа `float64` в объект `float32`точность может быть потеряна. Если `value` значение слишком велико `float32 (F)`, чтобы вместить плюс бесконечность (если `value` является положительным) или отрицательная бесконечность `value` (если имеет отрицательное значение), возвращается значение. Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> . <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> инструкции и для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.u` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int8" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D2|с кредитом. U1|Преобразование в `int8`, принудительная отправка `int32` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.u1` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения `int32` менее 4 байт расширяются до, когда они загружаются в стек вычислений (если `conv.i` не используется или `conv.u` , в этом случае результат также `native int`равен). Значения с плавающей запятой преобразуются `F` в тип.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании типа `float64` в объект `float32`точность может быть потеряна. Если `value` значение слишком велико `float32 (F)`, чтобы вместить плюс бесконечность (если `value` является положительным) или отрицательная бесконечность `value` (если имеет отрицательное значение), возвращается значение. Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> . <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> инструкции и для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.u1` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int16" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D1|Кредитный. U2|Преобразование в `int16`, принудительная отправка `int32` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.u2` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения `int32` менее 4 байт расширяются до, когда они загружаются в стек вычислений (если `conv.i` не используется или `conv.u` , в этом случае результат также `native int`равен). Значения с плавающей запятой преобразуются `F` в тип.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании типа `float64` в объект `float32`точность может быть потеряна. Если `value` значение слишком велико `float32 (F)`, чтобы вместить плюс бесконечность (если `value` является положительным) или отрицательная бесконечность `value` (если имеет отрицательное значение), возвращается значение. Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> . <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> инструкции и для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.u2` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int32" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6D|U4|Преобразование в `unsigned int32`, принудительная отправка `int32` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.u4` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения `int32` менее 4 байт расширяются до, когда они загружаются в стек вычислений (если `conv.i` не используется или `conv.u` , в этом случае результат также `native int`равен). Значения с плавающей запятой преобразуются `F` в тип.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании типа `float64` в объект `float32`точность может быть потеряна. Если `value` значение слишком велико `float32 (F)`, чтобы вместить плюс бесконечность (если `value` является положительным) или отрицательная бесконечность `value` (если имеет отрицательное значение), возвращается значение. Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> . <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> инструкции и для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.u4` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int64" />, а затем расширяет его до <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6E|U8|Преобразование в `int64`, принудительная отправка `int64` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 `conv.u8` Код операции `value` преобразует верх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения `int32` менее 4 байт расширяются до, когда они загружаются в стек вычислений (если `conv.i` не используется или `conv.u` , в этом случае результат также `native int`равен). Значения с плавающей запятой преобразуются `F` в тип.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании типа `float64` в объект `float32`точность может быть потеряна. Если `value` значение слишком велико `float32 (F)`, чтобы вместить плюс бесконечность (если `value` является положительным) или отрицательная бесконечность `value` (если имеет отрицательное значение), возвращается значение. Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше `int32`, значение будет расширено знаком для заполнения слота.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. См <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> . <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> инструкции и для эквивалентных инструкций, которые вызовут исключение, если тип результата не может правильно представить результирующее значение.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `conv.u8` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует заданное число байтов из исходного адреса в конечный.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|Копирование данных из одного блока памяти в другой.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес назначения помещается в стек.  
  
2.  Исходный адрес помещается в стек.  
  
3.  Число байтов для копирования помещается в стек.  
  
4.  Число байтов, исходный адрес и адрес назначения извлекаются из стека; указанное число байтов копируется из исходного адреса в конечный адрес.  
  
 `native int` `*` `*` `&` `&`Инструкция копирует число `unsigned int32`байт из исходного адреса (типа, или) в адрес назначения (тип, `native int`или). `cpblk` Если исходная `cpblk` и Целевая области перекрываются, поведение параметра не указывается.  
  
 `cpblk`Предполагается, что исходные и целевые адреса выровнены по естественному размеру компьютера. Инструкции может быть непосредственно перед `unaligned.<prefix>` инструкцией, чтобы указать, что источник или назначение не совпадают. `cpblk`  
  
 Операция `cpblk` инструкции может быть изменена непосредственно предшествующей <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксной инструкцией.  
  
 <xref:System.NullReferenceException>может возникнуть, если обнаружен недопустимый адрес.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `cpblk` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует тип значения по адресу объекта (с типом <see langword="&amp;" />, <see langword="*" /> или <see langword="native int" />) и помещает его по адресу конечного объекта (с типом <see langword="&amp;" />, <see langword="*" /> или <see langword="native int" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|70 < `T` >|кпобж`classTok`|Копирует тип значения из исходного объекта в целевой объект.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на целевой объект помещается в стек.  
  
2.  Ссылка на исходный объект помещается в стек.  
  
3.  Две ссылки на объекты извлекаются из стека; Тип значения по адресу исходного объекта копируется на адрес целевого объекта.  
  
 Поведение `cpobj` не указано, если ссылки на исходный и целевой объекты не являются указателями на экземпляры класса, представленного маркером `classTok` класса ( `typeref` или `typedef`), или если `classTok` не представляет Тип значения.  
  
 <xref:System.NullReferenceException>может возникнуть, если обнаружен недопустимый адрес.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `cpobj` использовать код операции:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно значение на другое и помещает результат в стек вычислений как число с плавающей запятой (с типом <see langword="F" />) или как частное (с типом <see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5B|div|Делит два значения, чтобы вернуть результат частного или с плавающей точкой.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; `value1` делится на `value2`.  
  
4.  Результат помещается в стек.  
  
 `result` = `value1`элемент div value2 удовлетворяет следующим условиям.  
  
 &#124;`result` &#124; = &#124; / &#124;, и: &#124; &#124; `value1` `value2`  
  
 Sign (`result`) = +, если знак (`value1`) = Sign (`value2`) или-, if знак (`value1`) ~ = Sign (`value2`)  
  
 `div` Инструкция вычислит результат и помещает его в стек.  
  
 Деление целых чисел усекается до нуля.  
  
 Деление конечного числа на ноль приводит к правильному бесконечному значению со знаком.  
  
 Деление нуля на ноль или бесконечность по бесконечности приводит к получению значения NaN (нечисловое). Любое число, деленное на бесконечность, приведет к нулевому значению.  
  
 Целочисленные операции <xref:System.ArithmeticException> вызывают исключение, если результат не может быть представлен типом результата. Это может произойти, `value1` если является максимальным отрицательным значением `value2` и равно-1.  
  
 Целочисленные операции <xref:System.DivideByZeroException> создают `value2` исключение, если равно нулю.  
  
 Обратите внимание, что на платформах <xref:System.OverflowException> на базе процессоров Intel при вычислении (minint div-1) создается исключение. Операции с плавающей запятой никогда не создают исключение (они создают значений NaN или бесконечность).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `div` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно целочисленное значение без знака на другое и помещает результат (<see langword="int32" />) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5C|Div. un|Делит два значения без знака, возвращая частное.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; `value1` делится на `value2`.  
  
4.  Результат помещается в стек.  
  
 Инструкция, разделенная на, принимается как целые числа `result` без знака и помещается в стек. `value1` `value2` `div.un`  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `div.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует текущее верхнее значение в стеке вычислений и помещает копию в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|25|DUP|Дублирует значение в верхней части стека.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека для дублирования.  
  
3.  `value`помещается обратно в стек.  
  
4.  Повторяющееся значение помещается в стек.  
  
 `dup` Инструкция дублирует верхний элемент стека и оставляет два одинаковых значения на вершине.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `dup` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление из предложения <see langword="filter" /> исключения обратно в обработчик исключений CLI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 11|Команда endfilter|Завершающее предложение фильтра обработки исключений SEH.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека; `endfilter` выполняется, и управление передается обработчику исключений.  
  
 `Value`(который должен иметь тип `int32` и является одним из определенного набора значений), возвращается из предложения Filter. Он должен быть одним из следующих:  
  
-   `exception_continue_search`(`value` = 0) продолжить поиск обработчика исключений  
  
-   `exception_execute_handler`(`value` = 1) для запуска второго этапа обработки исключений, в котором блоки finally выполняются до тех пор, пока не будет найден обработчик, связанный с этим предложением фильтра. После обнаружения выполняется обработчик.  
  
 Другие целочисленные значения приведут к неопределенным результатам.  
  
 Точка входа фильтра, как показано в таблице исключений метода, должна быть первой инструкцией в блоке кода фильтра. Инструкция должна быть последней инструкцией в блоке кода фильтра (следовательно, для одного блока фильтра может быть `endfilter` только один). `endfilter` После выполнения `endfilter` инструкции управление логически передается обратно механизму обработки исключений CLI.  
  
 Управление не может быть передано в блок фильтра, за исключением механизма исключения. Управление не может быть передано из блока фильтра, за исключением использования `throw` инструкции или выполнения последней `endfilter` инструкции. Нельзя внедрить `try` блок `filter` в блок. Если в `filter` блоке создается исключение, оно перехватывается и возвращается значение 0 (`exception_continue_search`).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `endfilter` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление из предложения <see langword="fault" /> или <see langword="finally" /> блока исключения обратно обработчику исключений CLI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DC|Команда endfinally<br /><br /> ендфаулт|Завершает предложение `fault`илиблокаисключения. `finally`|  
  
 Для этой инструкции нет поведений перехода стека.  
  
 `Endfinally`и `endfault` сообщают конец `finally` предложения или `fault` , чтобы очистка стека могла продолжаться до вызова обработчика исключений. Инструкция `endfinally` или`endfault` передает управление механизму исключения CLI. Затем механизм ищет следующее `finally` предложение в цепочке, если защищенный блок был завершен с помощью инструкции leave. Если защищенный блок завершился с исключением, интерфейс командной строки выполнит поиск следующего `finally` или `fault`или введите обработчик исключений, выбранный во время первого прохода обработки исключений.  
  
 Инструкция может быть только лексической `finally` внутри блока. `endfinally` В отличие `endfilter` от инструкции, нет необходимости в конце блока `endfinally` с инструкцией, и при необходимости может быть `endfinally` столько инструкций в блоке. Эти же ограничения применяются к `endfault` инструкции `fault` и к блоку.  
  
 Элемент управления нельзя передать в блок `finally` (или `fault`), за исключением механизма исключения. Управление не может быть передано из `finally` блока ( `fault`или), за исключением использования `throw` инструкции или выполнения `endfinally` инструкции (или `endfault`). В частности, `finally` нельзя попадать в <xref:System.Reflection.Emit.OpCodes.Ret> блок (или `fault`) или выполнить инструкцию или <xref:System.Reflection.Emit.OpCodes.Leave> в `finally` блоке (или `fault`).  
  
 Обратите внимание `endfault` , `endfinally` что инструкции и являются псевдонимами — они соответствуют одному коду операции.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `endfinally` использовать код операции (`endfault`), а также `ILGenerator` метод <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.  
  
-   ILGenerator. Emit (код операции)  
  
-   ILGenerator. Ендексцептионблокк ()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Инициализирует блок памяти с определенным адресом, присваивая его начальному значению с заданным размером.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 18|initblk|Установите для каждого расположения в блоке памяти заданное значение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Начальный адрес помещается в стек.  
  
2.  Значение инициализации помещается в стек.  
  
3.  Число байтов для инициализации помещается в стек.  
  
4.  Число байтов, значение инициализации и начальный адрес извлекаются из стека, а инициализация выполняется в соответствии с их значениями.  
  
 `&` `native int` `*` `unsigned int8`Инструкция задает число (`unsigned int32`) байтов, начиная с указанного адреса (типа, или) и до значения инициализации (типа). `initblk` `initblk`Предполагается, что начальный адрес соответствует естественному размеру компьютера.  
  
 Операция `initblk` с инструкциями может быть изменена непосредственно предшествующей <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксной инструкцией.  
  
 <xref:System.NullReferenceException>может возникнуть, если обнаружен недопустимый адрес.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `initblk` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Инициализирует каждое поле типа значения с определенным адресом пустой ссылкой или значением 0 соответствующего простого типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< FE 15`T` >|`initobj` `typeTok`|Инициализирует тип значения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес типа значения для инициализации помещается в стек.  
  
2.  Адрес извлекается из стека; Тип значения по указанному адресу инициализируется как тип `typeTok`.  
  
 Инструкция инициализирует каждое поле типа значения, заданное отправленным адресом (типа `native int`, `&`или `*`), на пустую ссылку или 0 соответствующего типа-примитива. `initobj` После вызова этого метода экземпляр готов к вызову метода-конструктора. Если `typeTok` является ссылочным типом, эта инструкция имеет тот же результат, `ldnull` что и `stind.ref`, за которым следует.  
  
 В отличие <xref:System.Reflection.Emit.OpCodes.Newobj>от `initobj` , не вызывает метод конструктора. `Initobj`предназначен для инициализации типов значений, а `newobj` используется для выделения и инициализации объектов.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `initobj` использовать код операции:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Проверяет, является ли ссылка на объект (с типом <see langword="O" />) экземпляром определенного класса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|75 < `T` >|исинст`class`|Проверяет `class`, является ли ссылка на объект экземпляром, возвращая либо пустую ссылку, либо экземпляр этого класса или интерфейса.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и проверяется на наличие экземпляра переданного `class`класса.  
  
3.  Результат (ссылка на объект или пустая ссылка) помещается в стек.  
  
 `Class`— это токен метаданных, указывающий нужный класс. Если класс объекта в верхней `class` части стека реализует (если `class` является интерфейсом) или `class` является производным классом (если `class` является обычным классом), то он приводится к типу `class` , а результат помещается в стек, точно так же <xref:System.Reflection.Emit.OpCodes.Castclass> , как будто они были вызваны. В противном случае в стек помещается пустая ссылка. Если ссылка на объект является пустой ссылкой, то `isinst` аналогичным образом возвращается пустая ссылка.  
  
 <xref:System.TypeLoadException>Если класс не найден, возникает исключение. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `isinst` использовать код операции:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Прекращает выполнение текущего метода и переходит к заданному методу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|27 < `T` >|Переход`method`|Завершение работы текущего метода и переход к указанному методу.|  
  
 Для этой инструкции нет поведений перехода стека.  
  
 Инструкция (переход) передает управление методу, указанному параметром `method`, который является маркером метаданных для ссылки на метод. `jmp` Текущие аргументы передаются в целевой метод.  
  
 При выполнении этой инструкции стек вычислений должен быть пустым. Соглашение о вызовах, число и тип аргументов в адресе назначения должны соответствовать требованиям текущего метода.  
  
 `filter` `try` `finally` `catch`Инструкция не может использоваться для передачи управления из блока,, или. `jmp`  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `jmp` использовать код операции:  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент (на который ссылается указанное значение индекса) в стек.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< FE 09`unsigned int16` >|лдарг`index`|Загрузить аргумент в `index` стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента в `index` помещается в стек.  
  
 Инструкция помещает аргумент в `index`индекс, где аргументы индексируются от 0 до назад, в стек вычислений. `ldarg` `ldarg` Инструкцию можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Для процедур, принимающих список аргументов переменной длины, `ldarg` инструкция может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры (Дополнительные сведения см. в <xref:System.Reflection.Emit.OpCodes.Arglist> инструкции).  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до `int32` типа, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера `F`(типа).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldarg` использовать код операции:  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 0 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|02|лдарг. 0|Загрузить аргумент 0 в стек|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента с индексом 0 помещается в стек.  
  
 `ldarg.0` Инструкция является эффективной кодировкой для загрузки значения аргумента по индексу 0.  
  
 `ldarg.0` Инструкция помещает аргумент с индексом 0 в стек вычислений. `ldarg.0` Инструкцию можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до `int32` типа, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера `F`(типа).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldarg.0` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 1 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|03|лдарг. 1|Загрузка аргумента 1 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента с индексом 1 помещается в стек.  
  
 `ldarg.1` Инструкция является эффективной кодировкой для загрузки значения аргумента с индексом 1.  
  
 `ldarg.1` Инструкция помещает аргумент с индексом 1 в стек вычислений. `ldarg.1` Инструкцию можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до `int32` типа, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера `F`(типа).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldarg.1` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 2 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|04|лдарг. 2|Загрузка аргумента 2 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента с индексом 2 помещается в стек.  
  
 `ldarg.2` Инструкция является эффективной кодировкой для загрузки значения аргумента по индексу 2.  
  
 `ldarg.2` Инструкция помещает аргумент с индексом 2 в стек вычислений. `ldarg.2` Инструкцию можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до `int32` типа, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера `F`(типа).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldarg.2` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 3 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|05|лдарг. 3|Загрузка аргумента 3 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента с индексом 3 помещается в стек.  
  
 `ldarg.3` Инструкция является эффективной кодировкой для загрузки значения аргумента с индексом 3.  
  
 `ldarg.3` Инструкция помещает аргумент с индексом 3 в стек вычислений. `ldarg.3` Инструкцию можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до `int32` типа, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера `F`(типа).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldarg.3` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент (на который ссылается указанное короткое значение индекса) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0E <`unsigned int8` >|лдарг. s`index`|Загрузить аргумент в `index` стек, короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента в `index` помещается в стек.  
  
 `ldarg.s` Инструкция является эффективной кодировкой для загрузки аргументов, индексируемых от 4 до 255.  
  
 Инструкция помещает аргумент в `index`индекс, где аргументы индексируются от 0 до назад, в стек вычислений. `ldarg.s` `ldarg.s` Инструкцию можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Для процедур, принимающих список аргументов переменной длины, `ldarg.s` инструкция может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры (Дополнительные сведения см. в <xref:System.Reflection.Emit.OpCodes.Arglist> инструкции).  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до `int32` типа, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера `F`(типа).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldarg.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает адрес аргумента в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< FE 0A`unsigned int16` >|лдарга`index`|Получение адреса аргумента, индексированного по `index`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес `addr` аргумента, индексированного методом `index` , помещается в стек.  
  
 Инструкция извлекает адрес (типа `*`) аргумента, индексированного по `index`, где аргументы индексируются от 0 до. `ldarga` Адрес `addr` всегда согласуется с естественной границей на целевом компьютере.  
  
 Для процедур, принимающих список аргументов переменной длины, `ldarga` инструкция может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры.  
  
 `ldarga`используется для передачи параметров by-ref. В других случаях <xref:System.Reflection.Emit.OpCodes.Ldarg> <xref:System.Reflection.Emit.OpCodes.Starg> следует использовать.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldarga` использовать код операции:  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает адрес аргумента (короткая форма) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0F <`unsigned int8` >|лдарга. s`index`|Получение адреса аргумента, индексированного по `index`краткому формату.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес `addr` аргумента, индексированного методом `index` , помещается в стек.  
  
 `ldarga.s`(краткая форма `ldarga`) следует использовать для номеров аргументов от 0 до 255, и это более эффективная кодировка.  
  
 Инструкция извлекает адрес (типа`*`) аргумента, индексированного по `index`, где аргументы индексируются от 0 до. `ldarga.s` Адрес `addr` всегда согласуется с естественной границей на целевом компьютере.  
  
 Для процедур, принимающих список аргументов переменной длины, `ldarga.s` инструкция может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры.  
  
 `ldarga.s`используется для передачи параметров by-ref. В других случаях <xref:System.Reflection.Emit.OpCodes.Ldarg_S> <xref:System.Reflection.Emit.OpCodes.Starg_S> следует использовать.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldarga.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="int32" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|20 < `int32` >|LDC. i4`num`|Помещает значение `num` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение `num` помещается в стек.  
  
 Обратите внимание, что существуют специальные короткие (и, следовательно, более эффективные) кодировки для целых чисел от-128 до 127 и особенно короткие кодировки для-1 – 8. Все короткие кодировки помещают в стек 4-байтовые целые числа. Более длинные кодировки используются для 8-байтовых целых чисел, 4 и 8 байт с плавающей запятой, а также для 4 байтовых значений, которые не помещаются в короткие формы. Существует три способа отправки 8-байтовой целочисленной константы в стек.  
  
 1. <xref:System.Reflection.Emit.OpCodes.Ldc_I8> Используйте инструкцию для констант, которые должны быть выражены более чем на 32 бит.  
  
 2. Используйте инструкцию, а затем <xref:System.Reflection.Emit.OpCodes.Conv_I8> для констант, для которых требуется от 9 до 32 бит. <xref:System.Reflection.Emit.OpCodes.Ldc_I4>  
  
 3. Используйте краткую инструкцию Form, за <xref:System.Reflection.Emit.OpCodes.Conv_I8> которой следует оператор для констант, которые могут быть выражены в 8 или меньшем количестве битов.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldc.i4` использовать код операции:  
  
-   ILGenerator. Emit (код операции, int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 0 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|16|LDC. i 4.0|Помещает 0 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 0 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целого значения 0. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldc.i4.0` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 1 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|17|LDC. i 4.1|Помещает 1 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 1 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целого значения 1. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldc.i4.1` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 2 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|18|LDC. i 4.2|Помещает 2 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 2 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленного значения 2. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldc.i4.2` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 3 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|19|LDC. i 4.3|Помещает 3 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 3 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленного значения 3. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldc.i4.3` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 4 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|SR1A|LDC. i 4.4|Передает 4 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 4 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленного значения 4. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldc.i4.4` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 5 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1B|LDC. i 4.5|Передает 5 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 5 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целого значения 5. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldc.i4.5` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 6 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1C|LDC. i 4.6|Помещает 6 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 6 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целого значения 6. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldc.i4.6` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 7 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1D|LDC. i 4.7|Помещает 7 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 7 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленного значения 7. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldc.i4.7` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 8 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1E|LDC. i 4.8|Отправляет 8 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 8 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленного значения 8. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldc.i4.8` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение –1 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|15|LDC. i4. M1|Передает значение 1 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение-1 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целого значения-1. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldc.i4.m1` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="int8" /> в стек вычислений как <see langword="int32" /> (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1F < `int8` >|LDC. i4. s`num`|Передает в стек в виде `int32`краткой формы. `num`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение `num` помещается в стек.  
  
 `ldc.i4.s`— более эффективная кодировка для отправки целых чисел с-128 по 127 в стек вычислений.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldc.i4.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="int64" /> в стек вычислений как <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|21 < `int64` >|LDC. i8`num`|Передает в стек как `int64`. `num`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение `num` помещается в стек.  
  
 Эта кодировка помещает `int64` значение в стек.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldc.i8` использовать код операции:  
  
-   ILGenerator. Emit (код операции, длинный)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="float32" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|22 < `float32` >|LDC. R4`num`|Передает в стек как `F`. `num`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение `num` помещается в стек.  
  
 Эта кодировка помещает `float32` значение в стек.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldc.r4` использовать код операции:  
  
-   ILGenerator. Emit (код операции, одиночный)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="float64" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|23 < `float64` >|LDC. R8`num`|Передает в стек как `F`. `num`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение `num` помещается в стек.  
  
 Эта кодировка помещает `float64` значение в стек.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldc.r8` использовать код операции:  
  
-   ILGenerator. Emit (код операции, Double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент с заданным индексом массива на вершину стека вычислений в качестве типа, указанного в инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A3 < `T` >|лделем`typeTok`|Загружает элемент, `index` расположенный в верхней части стека, как `typeTok`тип.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка `array` на объект помещается в стек.  
  
2.  Значение `index` индекса помещается в стек.  
  
3.  `index`и `array` извлекаются из стека; выполняется поиск значения, хранящегося `array` в позиции `index` в.  
  
4.  Значение помещается в стек.  
  
 Инструкция загружает значение элемента с индексом `index` (Type `native int`) в одномерный массив `array` с отсчетом от нуля и помещает его в начало стека. `ldelem` Массивы являются объектами, поэтому они представлены значением типа `O`.  
  
 Тип возвращаемого значения задается токеном `typeTok` в инструкции.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем верхняя `array`граница.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldelem` использовать код операции:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, имеющий тип <see langword="native int" />, на вершину стека вычислений как <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|97|лделем. i|Загружает элемент с типом `native int` , `index` расположенным в верхней части стека, `native int`как.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка `array` на объект помещается в стек.  
  
2.  Значение `index` индекса помещается в стек.  
  
3.  `index`и `array` извлекаются из стека; выполняется поиск значения, хранящегося `array` в позиции `index` в.  
  
4.  Значение помещается в стек.  
  
 Инструкция загружает значение элемента с индексом `index` (Type `native int`) в одномерный массив `array` с отсчетом от нуля и помещает его в начало стека. `ldelem.i` Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i` — `native int`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldelem.i` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int8" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|90|лделем. i1|Загружает элемент с типом `int8` , `index` расположенным в верхней части стека, `int32`как.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка `array` на объект помещается в стек.  
  
2.  Значение `index` индекса помещается в стек.  
  
3.  `index`и `array` извлекаются из стека; выполняется поиск значения, хранящегося `array` в позиции `index` в.  
  
4.  Значение помещается в стек.  
  
 Инструкция загружает значение элемента с индексом `index` (Type `native int`) в одномерный массив `array` с отсчетом от нуля и помещает его в начало стека. `ldelem.i1` Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i1` — `int8`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldelem.i1` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int16" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|92|лделем. i2|Загружает элемент с типом `int16` , `index` расположенным в верхней части стека, `int32`как.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка `array` на объект помещается в стек.  
  
2.  Значение `index` индекса помещается в стек.  
  
3.  `index`и `array` извлекаются из стека; выполняется поиск значения, хранящегося `array` в позиции `index` в.  
  
4.  Значение помещается в стек.  
  
 Инструкция загружает значение элемента с индексом `index` (Type `native int`) в одномерный массив `array` с отсчетом от нуля и помещает его в начало стека. `ldelem.i2` Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i2` — `int16`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldelem.i2` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int32" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|94|лделем. i4|Загружает элемент с типом `int32` , `index` расположенным в верхней части стека, `int32`как.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка `array` на объект помещается в стек.  
  
2.  Значение `index` индекса помещается в стек.  
  
3.  `index`и `array` извлекаются из стека; выполняется поиск значения, хранящегося `array` в позиции `index` в.  
  
4.  Значение помещается в стек.  
  
 Инструкция загружает значение элемента с индексом `index` (Type `native int`) в одномерный массив `array` с отсчетом от нуля и помещает его в начало стека. `ldelem.i4` Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i4` — `int32`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldelem.i4` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int64" /> с заданным индексом массива на вершину стека вычислений как <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|96|лделем. i8|Загружает элемент с типом `int64` , `index` расположенным в верхней части стека, `int64`как.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка `array` на объект помещается в стек.  
  
2.  Значение `index` индекса помещается в стек.  
  
3.  `index`и `array` извлекаются из стека; выполняется поиск значения, хранящегося `array` в позиции `index` в.  
  
4.  Значение помещается в стек.  
  
 Инструкция загружает значение элемента с индексом `index` (Type `native int`) в одномерный массив `array` с отсчетом от нуля и помещает его в начало стека. `ldelem.i8` Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i8` — `int64`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldelem.i8` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, имеющий тип <see langword="float32" />, на вершину стека вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|98|лделем. R4|Загружает элемент с типом `float32` , `index` расположенным в верхней части стека, как `F`тип.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка `array` на объект помещается в стек.  
  
2.  Значение `index` индекса помещается в стек.  
  
3.  `index`и `array` извлекаются из стека; выполняется поиск значения, хранящегося `array` в позиции `index` в.  
  
4.  Значение помещается в стек.  
  
 Инструкция загружает значение элемента с индексом `index` (Type `native int`) в одномерный массив `array` с отсчетом от нуля и помещает его в начало стека. `ldelem.r4` Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.r4` — `float32`.  
  
 Значения с плавающей запятой преобразуются `F` в тип при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldelem.r4` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, имеющий тип <see langword="float64" />, на вершину стека вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|99|лделем. R8|Загружает элемент с типом `float64` , `index` расположенным в верхней части стека, `F`как тип.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка `array` на объект помещается в стек.  
  
2.  Значение `index` индекса помещается в стек.  
  
3.  `index`и `array` извлекаются из стека; выполняется поиск значения, хранящегося `array` в позиции `index` в.  
  
4.  Значение помещается в стек.  
  
 Инструкция загружает значение элемента с индексом `index` (Type `native int`) в одномерный массив `array` с отсчетом от нуля и помещает его в начало стека. `ldelem.r8` Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.r8` — `float64`.  
  
 Значения с плавающей запятой преобразуются `F` в тип при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldelem.r8` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, содержащий ссылку на объект, на вершину стека вычислений как <see langword="O" /> (ссылка на объект).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9A|лделем. ref|Загружает элемент со ссылкой на объект в `index` верхней части стека как тип. `O`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка `array` на объект помещается в стек.  
  
2.  Значение `index` индекса помещается в стек.  
  
3.  `index`и `array` извлекаются из стека; выполняется поиск значения, хранящегося `array` в позиции `index` в.  
  
4.  Значение помещается в стек.  
  
 Инструкция загружает значение элемента с индексом `index` (Type `native int`) в одномерный массив `array` с отсчетом от нуля и помещает его в начало стека. `ldelem.ref` Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.ref` типа `O` (ссылка на объект).  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldelem.ref` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="unsigned int8" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|91|лделем. U1|Загружает элемент с типом `unsigned int8` , `index` расположенным в верхней части стека, `int32`как.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка `array` на объект помещается в стек.  
  
2.  Значение `index` индекса помещается в стек.  
  
3.  `index`и `array` извлекаются из стека; выполняется поиск значения, хранящегося `array` в позиции `index` в.  
  
4.  Значение помещается в стек.  
  
 Инструкция загружает значение элемента с индексом `index` (Type `native int`) в одномерный массив `array` с отсчетом от нуля и помещает его в начало стека. `ldelem.u1` Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.u1` — `int8`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldelem.u1` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="unsigned int16" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|93|лделем. U2|Загружает элемент с типом `unsigned int16` с индексом в верхнюю часть стека `int32`как.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка `array` на объект помещается в стек.  
  
2.  Значение `index` индекса помещается в стек.  
  
3.  `index`и `array` извлекаются из стека; выполняется поиск значения, хранящегося `array` в позиции `index` в.  
  
4.  Значение помещается в стек.  
  
 Инструкция загружает значение элемента с индексом `index` (Type `native int`) в одномерный массив `array` с отсчетом от нуля и помещает его в начало стека. `ldelem.u2` Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.u2` — `int16`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldelem.u2` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="unsigned int32" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|95|лделем. U4|Загружает элемент с типом `unsigned int32` с индексом в верхнюю часть стека `int32`как.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка `array` на объект помещается в стек.  
  
2.  Значение `index` индекса помещается в стек.  
  
3.  `index`и `array` извлекаются из стека; выполняется поиск значения, хранящегося `array` в позиции `index` в.  
  
4.  Значение помещается в стек.  
  
 Инструкция загружает значение элемента с индексом `index` (Type `native int`) в одномерный массив `array` с отсчетом от нуля и помещает его в начало стека. `ldelem.u4` Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.u4` — `int32`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.ArrayTypeMismatchException>Если массив не содержит элементов требуемого типа, создается исключение.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldelem.u4` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает адрес элемента массива с заданным индексом на вершину стека вычислений как <see langword="&amp;" /> (управляемый указатель).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8F < `T` >|ldelema`class`|Загружает адрес элемента массива в `index` верхней части стека вычислений как тип `&` (управляемый указатель).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка `array` на объект помещается в стек.  
  
2.  Значение `index` индекса помещается в стек.  
  
3.  `index`и `array` извлекаются из стека; выполняется поиск адреса, хранящегося `array` в позиции `index` в.  
  
4.  Адрес помещается в стек.  
  
 Используется для получения адреса объекта по определенному индексу в массиве объектов (типа `class`). `ldelema` Инструкция загружает адрес значения с индексом `index` (Type `native int`) в одномерный массив `array` с отсчетом от нуля и помещает его в начало стека. `ldelema` Массивы являются объектами и поэтому представлены значением типа `O`. Значение должно иметь тип `class` , переданный с инструкцией.  
  
 Возвращаемое значение для `ldelema` является управляемым указателем ( `&`тип).  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldelema` использовать код операции:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет поиск значения поля в объекте, ссылка на который находится в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld`field`|Помещает значение поля в указанном объекте в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект (или указатель) помещается в стек.  
  
2.  Ссылка на объект (или указатель) извлекается из стека; Найдено значение указанного поля в объекте.  
  
3.  Значение, хранящееся в поле, помещается в стек.  
  
 `ldfld` Инструкция помещает значение поля, расположенного в объекте, в стек. Объект должен находиться `O`в стеке как ссылка на объект (тип), управляемый указатель (тип `&`), неуправляемый указатель (тип `native int`), временный указатель (тип `*`) или экземпляр типа значения. Использование неуправляемого указателя в проверяемом коде не допускается. Поле объекта задается маркером метаданных, который должен ссылаться на элемент поля. Тип возвращаемого значения совпадает с типом, связанным с полем. Поле может быть либо полем экземпляра (в этом случае объект не должен быть пустой ссылкой), либо статическим полем.  
  
 Инструкции может предшествовать один или оба <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса и <xref:System.Reflection.Emit.OpCodes.Volatile>. `ldfld`  
  
 <xref:System.NullReferenceException>Если объект имеет значение NULL и поле не является статическим, создается исключение.  
  
 <xref:System.MissingFieldException>Если указанное поле не найдено в метаданных, создается исключение. Обычно это проверяется при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldfld` использовать код операции:  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ищет адрес поля в объекте, ссылка на который находится в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7C < `T` >|лдфлда`field`|Помещает адрес `field` в указанном объекте в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект (или указатель) помещается в стек.  
  
2.  Ссылка на объект (или указатель) извлекается из стека; найден адрес указанного поля в объекте.  
  
3.  Адрес указанного поля помещается в стек.  
  
 `ldflda` Инструкция помещает адрес поля, расположенного в объекте, в стек. Объект должен находиться `O`в стеке как ссылка на объект (тип), управляемый указатель (тип `&`), неуправляемый указатель (тип `native int`), временный указатель (тип `*`) или экземпляр типа значения. Использование неуправляемого указателя в проверяемом коде не допускается. Поле объекта задается маркером метаданных, который должен ссылаться на элемент поля.  
  
 Значение, возвращаемое `ldflda` , является управляемым указателем `&`(типом), если объект не помещается в стек как неуправляемый указатель, в этом случае обратный адрес также является неуправляемым указателем (тип `native int`).  
  
 Инструкции может предшествовать один или оба <xref:System.Reflection.Emit.OpCodes.Unaligned> префикса и <xref:System.Reflection.Emit.OpCodes.Volatile>. `ldflda`  
  
 <xref:System.InvalidOperationException>создается, если объект не находится в домене приложения, из которого осуществляется доступ. Не удается загрузить адрес поля, не находящегося внутри доступного домена приложения.  
  
 <xref:System.NullReferenceException>Если объект имеет значение NULL и поле не является статическим, создается исключение.  
  
 <xref:System.MissingFieldException>Если указанное поле не найдено в метаданных, создается исключение. Обычно это проверяется при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldflda` использовать код операции:  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений неуправляемый указатель (с типом <see langword="native int" />) на машинный код, реализующий заданный метод.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< FE 06`T` >|ldftn`method`|Помещает указатель на метод, `method` на который ссылается стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Неуправляемый указатель на конкретный метод помещается в стек.  
  
 Конкретный метод (`method`) может быть вызван с помощью инструкции <xref:System.Reflection.Emit.OpCodes.Calli> , если он ссылается на управляемый метод (или заглушку, переход от управляемого кода к неуправляемому).  
  
 Возвращаемое значение указывает на машинный код, используя соглашение о вызовах CLR. Этот указатель метода не должен передаваться в неуправляемый машинный код в качестве подпрограммы обратного вызова.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldftn` использовать код операции:  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="native int" /> в стек вычислений как <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4D|ldind. i|Загружает `addr` значениепоадресувстеккак.`native int` `native int`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 `native int` `&` `native int`Инструкция косвенно `native int` загружает значение из указанного адреса (типа, или *) в стек как. `ldind.i`  
  
 Все инструкции являются ярлыками <xref:System.Reflection.Emit.OpCodes.Ldobj> для инструкции, указывающей соответствующий встроенный класс значения. `ldind`  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений. Значения с плавающей запятой преобразуются в `F` тип при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти ( <xref:System.Reflection.Emit.OpCodes.Unaligned> см. инструкции по префиксу для превентивных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException>может возникнуть, если обнаружен недопустимый адрес.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldind.i` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int8" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|46|ldind. i1|Загружает `addr` значениепоадресувстеккак.`int32` `int8`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек. 
  
 `native int` `&` `int32`Инструкция косвенно `int8` загружает значение из указанного адреса (типа, или *) в стек как. `ldind.i1`  
  
 Все инструкции являются ярлыками <xref:System.Reflection.Emit.OpCodes.Ldobj> для инструкции, указывающей соответствующий встроенный класс значения. `ldind`  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений. Значения с плавающей запятой преобразуются в `F` тип при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти ( <xref:System.Reflection.Emit.OpCodes.Unaligned> см. инструкции по префиксу для превентивных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException>может возникнуть, если обнаружен недопустимый адрес.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldind.i1` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int16" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|48|ldind. i2|Загружает `addr` значениепоадресувстеккак.`int32` `int16`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 `native int` `&` `int32`Инструкция косвенно `int16` загружает значение из указанного адреса (типа, или *) в стек как. `ldind.i2`  
  
 Все инструкции являются ярлыками <xref:System.Reflection.Emit.OpCodes.Ldobj> для инструкции, указывающей соответствующий встроенный класс значения. `ldind`  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений. Значения с плавающей запятой преобразуются в `F` тип при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти ( <xref:System.Reflection.Emit.OpCodes.Unaligned> см. инструкции по префиксу для превентивных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException>может возникнуть, если обнаружен недопустимый адрес.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldind.i2` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int32" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4A|ldind. i4|Загружает `addr` значениепоадресувстеккак.`int32` `int32`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 `native int` `&` `int32`Инструкция косвенно `int32` загружает значение из указанного адреса (типа, или *) в стек как. `ldind.i4`  
  
 Все инструкции являются ярлыками <xref:System.Reflection.Emit.OpCodes.Ldobj> для инструкции, указывающей соответствующий встроенный класс значения. `ldind`  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений. Значения с плавающей запятой преобразуются в `F` тип при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти ( <xref:System.Reflection.Emit.OpCodes.Unaligned> см. инструкции по префиксу для превентивных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException>может возникнуть, если обнаружен недопустимый адрес.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldind.i4` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int64" /> в стек вычислений как <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4C|ldind. i8|Загружает `addr` значениепоадресувстеккак.`int64` `int64`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 `native int` `&` `int64`Инструкция косвенно `int64` загружает значение из указанного адреса (типа, или *) в стек как. `ldind.i8`  
  
 Все инструкции являются ярлыками <xref:System.Reflection.Emit.OpCodes.Ldobj> для инструкции, указывающей соответствующий встроенный класс значения. `ldind`  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений. Значения с плавающей запятой преобразуются в `F` тип при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти ( <xref:System.Reflection.Emit.OpCodes.Unaligned> см. инструкции по префиксу для превентивных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException>может возникнуть, если обнаружен недопустимый адрес.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldind.i8` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="float32" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4E|ldind. R4|Загружает `addr` значениепоадресувстеккактип.`F` `float32`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 `native int` `&` `F`Инструкция косвенно `float32` загружает значение из указанного адреса (типа, или *) в стек как тип. `ldind.r4`  
  
 Все инструкции являются ярлыками <xref:System.Reflection.Emit.OpCodes.Ldobj> для инструкции, указывающей соответствующий встроенный класс значения. `ldind`  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений. Значения с плавающей запятой преобразуются в `F` тип при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти ( <xref:System.Reflection.Emit.OpCodes.Unaligned> см. инструкции по префиксу для превентивных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException>может возникнуть, если обнаружен недопустимый адрес.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldind.r4` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="float64" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4F|ldind. R8|Загружает `addr` значениепоадресувстеккактип.`F` `float64`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 `native int` `&` `float64`Инструкция косвенно `float64` загружает значение из указанного адреса (типа, или *) в стек как. `ldind.r8`  
  
 Все инструкции являются ярлыками <xref:System.Reflection.Emit.OpCodes.Ldobj> для инструкции, указывающей соответствующий встроенный класс значения. `ldind`  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений. Значения с плавающей запятой преобразуются в `F` тип при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти ( <xref:System.Reflection.Emit.OpCodes.Unaligned> см. инструкции по префиксу для превентивных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException>может возникнуть, если обнаружен недопустимый адрес.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldind.r8` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку в стек вычислений ссылки на объект как <see langword="O" /> (ссылка на объект).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|50|ldind. ref|Загружает ссылку на объект по `addr` адресу в стек как тип`O`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; Ссылка на объект, расположенная по адресу, выбирается.  
  
3.  Извлеченная ссылка помещается в стек.  
  
 Инструкция косвенно загружает объект, ссылающийся на указанный адрес ( `native int`типа `&`, или *), в стек как тип `O`. `ldind.ref`  
  
 Все инструкции являются ярлыками <xref:System.Reflection.Emit.OpCodes.Ldobj> для инструкции, указывающей соответствующий встроенный класс значения. `ldind`  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений. Значения с плавающей запятой преобразуются в `F` тип при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти ( <xref:System.Reflection.Emit.OpCodes.Unaligned> см. инструкции по префиксу для превентивных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException>может возникнуть, если обнаружен недопустимый адрес.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldind.ref` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="unsigned int8" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|47|ldind. U1|Загружает `addr` значениепоадресувстеккак.`int32` `unsigned int8`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 `native int` `&` `int32`Инструкция косвенно `unsigned int8` загружает значение из указанного адреса (типа, или *) в стек как. `ldind.u1`  
  
 Все инструкции являются ярлыками <xref:System.Reflection.Emit.OpCodes.Ldobj> для инструкции, указывающей соответствующий встроенный класс значения. `ldind`  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений. Значения с плавающей запятой преобразуются в `F` тип при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти ( <xref:System.Reflection.Emit.OpCodes.Unaligned> см. инструкции по префиксу для превентивных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException>может возникнуть, если обнаружен недопустимый адрес.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldind.u1` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="unsigned int16" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|49|ldind. U2|Загружает `addr` значениепоадресувстеккак.`int32` `unsigned int16`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 `native int` `&` `int32`Инструкция косвенно `unsigned int16` загружает значение из указанного адреса (типа, или *) в стек как. `ldind.u2`  
  
 Все инструкции являются ярлыками <xref:System.Reflection.Emit.OpCodes.Ldobj> для инструкции, указывающей соответствующий встроенный класс значения. `ldind`  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений. Значения с плавающей запятой преобразуются в `F` тип при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти ( <xref:System.Reflection.Emit.OpCodes.Unaligned> см. инструкции по префиксу для превентивных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException>может возникнуть, если обнаружен недопустимый адрес.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldind.u2` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="unsigned int32" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4B|ldind. U4|Загружает `addr` значениепоадресувстеккак.`int32` `unsigned int32`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 `native int` `&` `int32`Инструкция косвенно `unsigned int32` загружает значение из указанного адреса (типа, или *) в стек как. `ldind.u4`  
  
 Все инструкции являются ярлыками <xref:System.Reflection.Emit.OpCodes.Ldobj> для инструкции, указывающей соответствующий встроенный класс значения. `ldind`  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются `int32` до `native int`(а не), когда они загружаются в стек вычислений. Значения с плавающей запятой преобразуются в `F` тип при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что `ldind` инструкции используются способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> может произойти ( <xref:System.Reflection.Emit.OpCodes.Unaligned> см. инструкции по префиксу для превентивных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласовываются. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException>может возникнуть, если обнаружен недопустимый адрес.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldind.u4` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений сведения о числе элементов одномерного массива с индексацией от нуля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8E|лдлен|Помещает в стек длину (тип `natural unsigned int`) массива.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект массива помещается в стек.  
  
2.  Ссылка на массив извлекается из стека, а длина вычислена.  
  
3.  Длина помещается в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Длина возвращается в виде `natural unsigned int`.  
  
 <xref:System.NullReferenceException>Если ссылка на массив является пустой ссылкой, создается исключение.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldlen` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с указанным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< FE 0C`unsigned int16` >|требовалась ldloc`index`|Загружает локальную переменную `index` с индексом в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной по указанному индексу помещается в стек.  
  
 `ldloc` Инструкция отправляет содержимое номера локальной переменной в переданный индекс в стеке вычислений, где локальные переменные нумеруются 0 и выше. Локальные переменные инициализируются значением 0 перед вводом метода только в том случае, если флаг инициализации метода имеет значение true. Возможны локальные переменные 65 535 (2 ^ 16-1) (0 – 65534). Индекс 65 535 является недопустимым, так как вероятные реализации будут использовать 2-байтовое целое число для записи как индекса локального объекта, так и общего числа локальных переменных для данного метода. Если индекс 65535 был сделан допустимым, для записи числа локальных переменных в таком методе потребуется более широкое целое число.  
  
 Инструкции `ldloc.0`, `ldloc.1`, `ldloc.2`и обеспечиваютэффективнуюкодировкудлядоступакпервымчетыремлокальнымпеременным.`ldloc.3`  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. См. раздел I. локальные переменные размером менее 4 байт развернуты до типа `int32` при загрузке в стек. Значения с плавающей запятой разворачиваются до их собственного размера `F`(типа).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузки метода могут `ldloc` использовать код операции:  
  
-   ILGenerator. Emit (код операции, LocalBuilder)  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|06|требовалась ldloc. 0|Загружает в стек вычислений локальную переменную с индексом 0.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной в индексе 0 помещается в стек.  
  
 `ldloc.0`является особенно эффективной кодировкой для <xref:System.Reflection.Emit.OpCodes.Ldloc>, предоставляя доступ к локальной переменной с индексом 0.  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. Локальные переменные, размер которых меньше 4 байт, разворачиваются до `int32` типа, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера `F`(типа).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldloc.0` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|07|требовалась ldloc. 1|Загружает в стек вычислений локальную переменную с индексом 1.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной в индексе 1 помещается в стек.  
  
 `ldloc.1`является особенно эффективной кодировкой для <xref:System.Reflection.Emit.OpCodes.Ldloc>, предоставляя доступ к локальной переменной с индексом 1.  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. Локальные переменные, размер которых меньше 4 байт, разворачиваются до `int32` типа, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера `F`(типа).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldloc.1` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|08|требовалась ldloc. 2|Загружает в стек вычислений локальную переменную с индексом 2.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной в индексе 2 помещается в стек.  
  
 `ldloc.2`является особенно эффективной кодировкой для <xref:System.Reflection.Emit.OpCodes.Ldloc>, предоставляя доступ к локальной переменной с индексом 2.  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. Локальные переменные, размер которых меньше 4 байт, разворачиваются до `int32` типа, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера `F`(типа).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldloc.2` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|09|требовалась ldloc. 3|Загружает в стек вычислений локальную переменную с индексом 3.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной в индексе 3 помещается в стек.  
  
 `ldloc.3`является особенно эффективной кодировкой для <xref:System.Reflection.Emit.OpCodes.Ldloc>, предоставляя доступ к локальной переменной с индексом 3.  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. Локальные переменные, размер которых меньше 4 байт, разворачиваются до `int32` типа, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера `F`(типа).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldloc.3` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с указанным индексом (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|требовалась ldloc. s`index`|Загружает локальную переменную `index` с индексом в стек, короткую форму.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной по указанному индексу помещается в стек.  
  
 `ldloc.s` Инструкция отправляет содержимое номера локальной переменной в переданный индекс в стеке вычислений, где локальные переменные нумеруются 0 и выше. Локальные переменные инициализируются значением 0 перед входом в метод, если флаг инициализации метода имеет значение true. В краткой форме имеется 256 (2 ^ 8) локальных переменных (0-255), что является более эффективной кодировкой, чем `ldloc`.  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. См. раздел I. локальные переменные размером менее 4 байт развернуты до типа `int32` при загрузке в стек. Значения с плавающей запятой разворачиваются до их собственного размера `F`(типа).  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузки метода могут `ldloc.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, LocalBuilder)  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений адрес локальной переменной с указанным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< FE OD`unsigned int16` >|лдлока`index`|Загружает адрес локальной переменной в `index` стек вычислений.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес, хранящийся в локальной переменной по указанному индексу, помещается в стек.  
  
 `ldloca` Инструкция помещает в стек адрес локальной переменной с переданным индексом, где локальные переменные нумеруются 0 – назад. Значение, помещаемое в стек, уже правильно согласовано для использования с такими инструкциями <xref:System.Reflection.Emit.OpCodes.Stind_I>, как <xref:System.Reflection.Emit.OpCodes.Ldind_I> и. Результатом является временный указатель (тип `*`).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldloca` использовать код операции:  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений адрес локальной переменной с указанным индексом (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|лдлока. s`index`|Загружает адрес локальной переменной в `index` стек вычислений, короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес, хранящийся в локальной переменной по указанному индексу, помещается в стек.  
  
 `ldloca.s` Инструкция помещает в стек адрес локальной переменной с переданным индексом, где локальные переменные нумеруются 0 – назад. Значение, помещаемое в стек, уже правильно согласовано для использования с такими инструкциями <xref:System.Reflection.Emit.OpCodes.Stind_I>, как <xref:System.Reflection.Emit.OpCodes.Ldind_I> и. Результатом является временный указатель (тип `*`).  
  
 `ldloca.s` Инструкция предоставляет эффективную кодировку для использования с локальными переменными от 0 до 255.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldloca.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений пустую ссылку (тип <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|14|требовался ldnull|Отправка пустой ссылки на стек|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на пустой объект помещается в стек.  
  
 `ldnull`помещает в стек пустую ссылку `O`(тип). Используется для инициализации расположений перед заполнением данными или в случае, когда они становятся нерекомендуемыми.  
  
 `ldnull`Предоставляет пустую ссылку, которая не зависит от размера.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldnull` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует объект с типом значения, размещенный по указанному адресу, на вершину стека вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj`class`|Копировать экземпляр типа `class` значения в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес объекта типа значения помещается в стек.  
  
2.  Адрес извлекается из стека, и происходит поиск экземпляра по определенному адресу.  
  
3.  Значение объекта, хранящегося в этом адресе, помещается в стек.  
  
 `ldobj` Инструкция используется для передачи типа значения в качестве параметра.  
  
 `addrOfValObj` `&` `*`Инструкция копирует значение, на которое указывает (тип, или `native int`), в верхнюю часть стека. `ldobj` Количество копируемых байтов зависит от размера класса (как указано в `class` параметре). `class` Параметр является маркером метаданных, представляющим тип значения.  
  
 Операция `ldobj` инструкции может быть изменена непосредственно предшествующей <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксной инструкцией.  
  
 <xref:System.TypeLoadException>Если класс не найден, возникает исключение. Обычно это обнаруживается при преобразовании инструкции MSIL в машинный код, а не во время выполнения.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldobj` использовать код операции:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений значение статического поля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld`field`|Отправка значения `field` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение конкретного поля помещается в стек.  
  
 `ldsfld` Инструкция отправляет значение статического (общего для всех экземпляров класса) поля в стеке. Тип возвращаемого значения, связанный с переданным токеном `field`метаданных.  
  
 `ldsfld` Инструкция может<xref:System.Reflection.Emit.OpCodes.Volatile> иметь префикс.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldsfld` использовать код операции:  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений адрес статического поля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7F < `T` >|требовался ldsflda`field`|Отправка адреса `field` в стеке|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес определенного поля помещается в стек.  
  
 `ldsflda` Инструкция помещает адрес статического поля (общего для всех экземпляров класса) в стеке. Адрес может быть представлен как временный указатель (тип `*`), если маркер `field` метаданных ссылается на тип, управляемый памятью. В противном случае он соответствует неуправляемому указателю ( `native int`тип). Обратите `field` внимание, что может быть статическим глобальным с назначенным относительным виртуальным адресом (смещением поля от базового адреса, в котором его содержащий PE-файл загружается в память), где память является неуправляемой.  
  
 `ldsflda` Инструкция может<xref:System.Reflection.Emit.OpCodes.Volatile> иметь префикс.  
  
 <xref:System.MissingFieldException>Если поле не найдено в метаданных, создается исключение. Обычно это проверяется при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldsflda` использовать код операции:  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек ссылку на новый объект, представляющий строковой литерал, хранящийся в метаданных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|72 < `T` >|лдстр`mdToken`|Отправляет строковый объект для токена `mdToken`строки метаданных.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект String помещается в стек.  
  
 Инструкция помещает ссылку на объект (тип `O`) в новый строковый объект, представляющий конкретный строковый литерал, хранящийся в метаданных. `ldstr` `ldstr` Инструкция выделяет необходимый объем памяти и выполняет любое преобразование формата, необходимое для преобразования строкового литерала из формы, используемой в файле, в формат строки, необходимый во время выполнения.  
  
 Common Language Infrastructure (CLI) гарантирует, что результат двух `ldstr` инструкций, ссылающихся на два токена метаданных с одинаковой последовательностью символов, возвращает один и тот же строковый объект (процесс, известный как «интернирование строк»).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldstr` использовать код операции:  
  
-   ILGenerator. Emit (код операции, строка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует лексему метаданных в его представление времени выполнения, а затем помещает в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< D0`T` >|коды операций ldtoken`token`|Преобразует маркер метаданных в представление среды выполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Переданный токен преобразуется `RuntimeHandle` в и помещается в стек.  
  
 Инструкция помещает объект `RuntimeHandle` для указанного маркера метаданных. `ldtoken` Может иметь значение`methodref/methoddef`, или .`typeref/typedef` `fieldref/fielddef` `RuntimeHandle`  
  
 Значение, помещаемое в стек, можно использовать в вызовах `Reflection` методов в системной библиотеке классов.  
  
 Дополнительные сведения о дескрипторах среды выполнения см. в следующих <xref:System.RuntimeFieldHandle>классах: <xref:System.RuntimeMethodHandle>, <xref:System.RuntimeTypeHandle>и.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузки метода могут `ldtoken` использовать код операции:  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений неуправляемый указатель (с типом <see langword="native int" />) на машинный код, реализующий виртуальный метод, связанный с заданным объектом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 07 <`T` >|ldvirtftn`method`|Помещает указатель на виртуальный метод `method` объекта в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека, а адрес точки входа в метод (как указано в маркере `method`метаданных) ищется.  
  
3.  Указатель на `method` помещается в стек.  
  
 Результирующий неуправляемый указатель, помещаемый в стек `ldvirtftn` инструкцией, можно вызвать с помощью инструкции, <xref:System.Reflection.Emit.OpCodes.Calli> если она ссылается на управляемый метод (или заглушку, переход от управляемого кода к неуправляемому).  
  
 Неуправляемый указатель указывает на машинный код, используя соглашение о вызовах CLR. Этот указатель метода не должен передаваться в неуправляемый машинный код в качестве подпрограммы обратного вызова.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ldvirtftn` использовать код операции:  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет выход из защищенной области кода с безусловной передачей управления указанной конечной инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< DD`int32` >|выхода`target`|Выходит из защищенной области кода.|  
  
 Для этой инструкции не задано поведение перехода стека.  
  
 `leave` Инструкция безусловно передает управление определенной конечной инструкции, представленной в виде смещения со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 `br` `try` `filter`Инструкция похожа на инструкцию, но ее можно использовать для выхода из блока, или `catch` , тогда как обычные инструкции ветвления можно использовать только в таком блоке для передачи управления внутри `leave` им. Инструкция очищает стек вычислений и обеспечивает выполнение соответствующих окружающих `finally` блоков. `leave`  
  
 Нельзя использовать `leave` инструкцию для `finally` выхода из блока. Чтобы упростить создание кода для обработчиков исключений, в блоке catch можно использовать `leave` инструкцию для перемещения управления в любую инструкцию в соответствующем `try` блоке.  
  
 Если инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузки метода могут `leave` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет выход из защищенной области кода с безусловной передачей управления указанной конечной инструкции (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DE <`int8` >|оставить. s`target`|Выйдите из защищенной области кода, короткой формы.|  
  
 Для этой инструкции не задано поведение перехода стека.  
  
 `leave.s` Инструкция выполняет безусловную передачу управления в переданную целевую инструкцию, представленную как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 `br` `try` `filter`Инструкция похожа на инструкцию, но ее можно использовать для выхода из блока, или `catch` , тогда как обычные инструкции ветвления можно использовать только в таком блоке для передачи управления внутри `leave.s` им. Инструкция очищает стек вычислений и обеспечивает выполнение соответствующих окружающих `finally` блоков. `leave.s`  
  
 Нельзя использовать `leave.s` инструкцию для `finally` выхода из блока. Чтобы упростить создание кода для обработчиков исключений, в блоке catch можно использовать `leave.s` инструкцию для перемещения управления в любую инструкцию в соответствующем `try` блоке.  
  
 Если инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `leave.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выделяет определенное количество байтов из пула локальной динамической памяти и помещает в стек вычислений адрес (временный указатель с типом <see langword="*" />) первого выделенного байта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|Выделение пространства из локальной кучи.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Число байтов, которое необходимо выделить, помещается в стек.  
  
2.  Число байтов извлекается из стека; объем памяти, соответствующий размеру, выделяется из локальной кучи.  
  
3.  Указатель на первый байт выделенной памяти помещается в стек.  
  
 `localloc` Инструкция выделяет`natural unsigned int`байты из локального пула динамической памяти и возвращает адрес (временный указатель, тип `*`) первого выделенного байта. `size` Возвращаемый блок памяти инициализируется значением 0 только в том случае, если флаг инициализации метода имеет `true`значение. Когда текущий метод выполняет <xref:System.Reflection.Emit.OpCodes.Ret>, пул локальной памяти становится доступным для повторного использования.  
  
 Полученный адрес будет согласовываться таким образом, что любой примитивный тип данных можно сохранить в `stind` нем с помощью инструкций <xref:System.Reflection.Emit.OpCodes.Stind_I4>(например, `ldind` ) и загрузить с помощью инструкций <xref:System.Reflection.Emit.OpCodes.Ldind_I4>(например,).  
  
 `finally` `filter` `catch` `fault` Инструкция не может находиться в блоке,, или. `localloc`  
  
 <xref:System.StackOverflowException>возникает, если недостаточно памяти для обслуживания запроса.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `localloc` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений ссылку на экземпляр определенного типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|C6 < `T` >|Mkrefany`class`|Помещает в стек типизированную ссылку `class` типа.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Указатель на фрагмент данных помещается в стек.  
  
2.  Указатель извлекается и преобразуется в типизированную ссылку типа `class`.  
  
3.  Типизированная ссылка помещается в стек.  
  
 `mkrefany` Инструкция поддерживает передачу ссылок с динамическим типом. Указатель должен иметь тип `&`, `*`или `native int`, и содержать допустимый адрес фрагмента данных. `Class`токен класса, описывающий тип данных, на которые ссылается указатель. `Mkrefany`отправляет типизированную ссылку на стек, предоставляя непрозрачный дескриптор указателя и типа `class`.  
  
 Единственной допустимой операцией, разрешенной для типизированной ссылки, является передача ее в метод, которому в качестве параметра требуется типизированная ссылка. Затем вызываемый объект может использовать <xref:System.Reflection.Emit.OpCodes.Refanytype> инструкции <xref:System.Reflection.Emit.OpCodes.Refanyval> и для получения типа (класса) и адреса соответственно.  
  
 <xref:System.TypeLoadException>Если `class` не удается найти, вызывается исключение. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `mkrefany` использовать код операции:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Умножает два значения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5A|mul|Умножает два значения в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; умножается на `value2`. `value1`  
  
4.  Результат помещается в стек.  
  
 `mul` Инструкция умножается`value2` на и помещает результат в стек. `value1` Целочисленные операции автоматически усекаются верхние биты в переполнении.  
  
 См <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> . раздел для операции умножения целого числа с обработкой переполнения.  
  
 Для типов с плавающей запятой 0 * Infinity = NaN.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `mul` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Умножает два целочисленных значения, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D8|mul. ovf|Умножает два целочисленных значения в стеке с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; умножается на `value2`с помощью проверки переполнения. `value1`  
  
4.  Результат помещается в стек.  
  
 Инструкция умножает целое число `value1` на целое число `value2` и передает результат в стек. `mul.ovf` Если результат не умещается в типе результата, выдается исключение.  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `mul.ovf` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Умножает два целочисленных значения без знака, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D9|mul. ovf. un|Умножает два значения без знака в стеке с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; умножается на `value2`с помощью проверки переполнения. `value1`  
  
4.  Результат помещается в стек.  
  
 Инструкция умножает целое число `value1` без знака на целое число `value2` без знака и помещает результат в стек. `mul.ovf.un` Если результат не умещается в типе результата, выдается исключение.  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `mul.ovf.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Отвергает значение и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|65|расход|Инвертирует значение, находящегося на вершине стека.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Значение извлекается из стека и инвертируется.  
  
3.  Результат помещается в стек.  
  
 `neg` Инструкция инвертирует значение и помещает результат поверх стека. Тип возвращаемого значения совпадает с типом операнда.  
  
 Отрицание целочисленных значений — это нестандартное отрицание числа единиц. В частности, при инвертировании самого отрицательного числа (которое не имеет положительного аналога) выдается наибольшее отрицательное число. Чтобы обнаружить это переполнение, <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> используйте инструкцию (то есть вычтите из 0).  
  
 Отрицание числа с плавающей запятой не может быть переполнено и отрицание NaN возвращает NaN.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `neg` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений ссылку на объект — новый одномерный массив с индексацией от нуля, состоящий из элементов заданного типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8D < `T` >|неварр`etype`|Создает новый массив с элементами типа `etype`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Число элементов в массиве помещается в стек.  
  
2.  Число элементов извлекается из стека и создается массив.  
  
3.  Ссылка на новый массив помещается в стек.  
  
 Инструкция помещает ссылку на объект (тип `O`) в новый одномерный массив, начинающийся с нуля, элементы которого имеют тип `etype` (маркер метаданных, описывающий тип). `newarr` Число элементов в новом массиве должно быть задано как `native int`. Допустимые индексы массива находятся в диапазоне от нуля до максимального числа элементов минус один.  
  
 Элементы массива могут быть любого типа, включая типы значений.  
  
 Одномерные массивы чисел с индексацией от нуля создаются с помощью маркера метаданных, ссылающегося на соответствующий тип значения<xref:System.Int32>(и т. д.). Элементы массива инициализируются значением 0 соответствующего типа.  
  
 Одномерные массивы с ненулевыми значениями и многомерные массивы создаются с <xref:System.Reflection.Emit.OpCodes.Newobj> помощью `newarr`, а не. Чаще всего они создаются с помощью методов <xref:System.Array> класса в .NET Framework.  
  
 <xref:System.OutOfMemoryException>возникает, если недостаточно памяти для удовлетворения запроса.  
  
 <xref:System.OverflowException>Если `numElems` значение меньше 0, возникает исключение.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `newarr` использовать код операции:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Создает новый объект или новый экземпляр типа значения и помещает ссылку на объект (тип <see langword="O" />) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|73 < `T` >|Инструкция`ctor`|Выделяет неинициализированный объект или тип значения и вызывает метод `ctor`конструктора.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Аргументы `arg1` посредством`argn` помещаются в стек последовательно.  
  
2.  Аргументы `argn` `ctor` через `arg1` извлекаются из стека и передаются в для создания объекта.  
  
3.  Ссылка на новый объект помещается в стек.  
  
 `newobj` Инструкция создает новый объект или новый экземпляр типа значения. `Ctor`— это маркер метаданных ( `methodref` или `methoddef` , который должен быть помечен как конструктор), указывающий имя, класс и сигнатуру вызываемого конструктора.  
  
 Инструкция выделяет новый экземпляр класса, связанный с `ctor` , и инициализирует все поля в новом экземпляре значением 0 (соответствующего типа) или пустыми ссылками, если это уместно. `newobj` Затем он вызывает конструктор `ctor` с заданными аргументами вместе с созданным экземпляром. После вызова конструктора в стек помещается ссылка на инициализированный объект (тип `O`).  
  
 С точки зрения конструктора неинициализированный объект является аргументом 0, а остальные аргументы, передаваемые в newobj, следуют по порядку.  
  
 Все одномерные массивы, начинающиеся с нуля, создаются с <xref:System.Reflection.Emit.OpCodes.Newarr>помощью, `newobj`а не. С другой стороны, все остальные массивы (более одного измерения или одномерные, но не основанные на нуле) создаются с помощью `newobj`.  
  
 Типы значений обычно не создаются с помощью `newobj`. Обычно они выделяются как аргументы или локальные переменные с помощью `newarr` (для одномерных массивов с индексацией от нуля) или как поля объектов. После выделения они инициализируются с помощью <xref:System.Reflection.Emit.OpCodes.Initobj>. Однако эту `newobj` инструкцию можно использовать для создания нового экземпляра типа значения в стеке, который затем может быть передан как аргумент, сохранен в локальной системе и т. д.  
  
 <xref:System.OutOfMemoryException>возникает, если недостаточно памяти для удовлетворения запроса.  
  
 <xref:System.MissingMethodException>вызывается, если не удалось `ctor` найти метод конструктора с указанным именем, классом и сигнатурой. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `newobj` использовать код операции:  
  
-   ILGenerator. Emit (код операции, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заполняет пространство, если коды операции содержат исправления. Никаких значимых операций не выполняется, хотя может быть пройден цикл обработки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|00|NOP|Выполняет операцию без поведения.|  
  
 Для этой инструкции не определено поведение перехода стека.  
  
 `nop` Операция не выполняет никаких действий. Он предназначен для заполнения пространства, если исправлены коды операций.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `nop` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое дополнение целочисленного значения, находящегося на вершине стека, и помещает результат в стек с тем же типом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|66|not|Вычисление побитового дополнения значения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value`помещается в стек.  
  
2.  `value`извлекается из стека и вычисляются его побитовое дополнение.  
  
3.  Результат помещается в стек.  
  
 `not` Инструкция вычислит побитовое дополнение целочисленного значения и помещает результат в стек. Тип возвращаемого значения совпадает с типом операнда.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `not` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое дополнение двух целочисленных значений, находящихся на вершине стека, и помещает результат в стек.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|60|или|Выполняет побитовое или для двух целочисленных значений, возвращает целое число.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека, их побитовые или вычисленные.  
  
4.  Результат помещается в стек.  
  
 `or` Инструкция рассчитывает побитовое или двух значений, расположенных поверх стека, помещая результат в стек.  
  
 `Or`— Это операция, относящаяся к целому числу.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `or` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Удаляет значение, находящееся на вершине стека.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|26|pop|Извлекает верхнее значение из стека.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Верхнее значение извлекается из стека.  
  
 `pop` Инструкция удаляет верхний элемент из стека.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `pop` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что последующая операция, связанная с адресом массива, не выполняет никаких проверок во время выполнения и возвращает управляемый указатель, изменение которого запрещено.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 1E|доступно.|Укажите, что последующие операции с адресом массива не выполняют проверку типа во время выполнения и возвращают управляемый указатель с ограниченными возможностями.|  
  
 Этот префикс может использоваться только непосредственно перед `ldelema` инструкцией и вызовами специального `Address` метода для массивов. Его воздействие на последующую операцию — двойная:  
  
1.  Во время выполнения операция проверки типа не выполняется. Обратите внимание, что обычно неявная проверка типа для `ldelema` инструкций `stelem` и используется в массивах ссылочного типа. Для классов значений никогда не выполняется проверка типа во время выполнения, поэтому `readonly` в этом случае это не операция.  
  
2.  Средство проверки обрабатывает результат операции адреса в качестве управляемого указателя с ограниченными возможностями.  
  
 Говорят, что указатель имеет ограниченную возможность, так как определяющий тип определяет, можно ли изменить значение. Для классов значений, которые не предоставляют открытых полей или методов, которые обновляют значение на месте, указатель доступен только для чтения (следовательно, имя префикса). В частности, классы, представляющие простые типы (например, System. Int32), не предоставляют мутатора и, таким образом, доступны только для чтения.  
  
 Управляемый указатель, ограниченный таким образом, может использоваться только следующими способами:  
  
-   `ldflda` `ldfld`Вкачестве`constrained callvirt` параметра для инструкций ,`stfld`,,или. `call` `object`  
  
-   В качестве `pointer` параметра `ldobj` инструкции`ldind` или одной из инструкций.  
  
-   В качестве `cpobj`параметраинструкции. `source`  
  
 Все `stobj`остальные операции запрещены, включая операции, `initobj`, или `mkrefany` , или любые `stind` инструкции.  
  
 Назначение `readonly` префикса заключается в том, чтобы избежать проверки типа при извлечении элемента из массива в универсальном коде. Например, выражение `arr[i].m()`, где тип элемента массива `arr` является универсальным типом, который был ограничен интерфейсом с помощью метода `m`, может компилироваться следующим кодом MSIL.  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 Без префикса `ldelema` инструкция выполняет проверку типа, если! 0 является ссылочным типом. `readonly` Этот тип не только неэффективен, но и семантически неверен. Проверка `ldelema` типа является точным совпадением, что является слишком строгим. Если массив удерживал подклассы типа! 0, приведенный выше код не сможет проверить тип.  
  
 Адрес элемента массива выбирается вместо самого элемента, чтобы иметь дескриптор для `arr[i]` этого типа значений и ссылочных типов, и поэтому может быть передан `constrained callvirt` в инструкцию.  
  
 Как правило, пропуск проверки во время выполнения может быть незащищенным, если массив удерживает элементы ссылочного типа. Чтобы быть в безопасности, необходимо убедиться, что с помощью этого указателя изменения в массиве не выполняются. Это гарантируется правилами проверки. Ограниченный управляемый указатель может передаваться как объект для вызовов метода экземпляра, поэтому он не должен строго говорить только для чтения для типов значений, но для типов значений не существует проблем безопасности типов.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `readonly` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает лексему типа, внедренную в ссылку с определенным типом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 1D|рефанитипе|Помещает токен типа, хранящийся в типизированной ссылке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на тип значения помещается в стек.  
  
2.  Типизированная ссылка извлекается из стека и полученного маркера соответствующего типа.  
  
3.  Токен типа помещается в стек.  
  
 Типизированная ссылка содержит токен типа и адрес экземпляра объекта.  
  
 `refanytype` Инструкция Получает лексему типа, внедренную в ссылку с определенным типом. Сведения о <xref:System.Reflection.Emit.OpCodes.Mkrefany> создании типизированных ссылок см. в инструкции.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `refanytype` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает адрес (тип <see langword="&amp;" />), внедренный в ссылку с определенным типом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|C2 < `T` >|рефанивал`type`|Отправляет адрес, хранящийся в типизированной ссылке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на тип значения помещается в стек.  
  
2.  Типизированная ссылка извлекается из стека, и извлекается соответствующий адрес.  
  
3.  Адрес помещается в стек.  
  
 Типизированная ссылка содержит токен типа и адрес экземпляра объекта.  
  
 `refanyval` Инструкция получает адрес, внедренный в ссылку с определенным типом. Тип, внедренный в ссылочную ссылку, предоставленный в стеке, должен соответствовать `type` типу, заданному (маркером метаданных `typeref`, `typedef` либо или). См. <xref:System.Reflection.Emit.OpCodes.Mkrefany> инструкции по связанному содержимому.  
  
 <xref:System.InvalidCastException>вызывается, `type` если не совпадает с типом, хранящимся в ссылке на тип (в данном `type` случае является классом, переданным <xref:System.Reflection.Emit.OpCodes.Mkrefany> в инструкцию, которая создала произнесенную типизированную ссылку).  
  
 <xref:System.TypeLoadException>Если `type` не удается найти, вызывается исключение.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `refanyval` использовать код операции:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно значение на другое и помещает остаток в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5D|оставшие|Помещает оставшуюся часть деления `value1` `value2` на стек.|  
  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Объект `value1` помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека и оставшейся части `value1` `div` `value2` вычисленного.  
  
4.  Результат помещается в стек.  
  
 `result` = `value1``rem` удовлетворяет`value2` следующим условиям.  
  
 `result` = `value1` - `value2``×` (`value1` )и:`div` `value2`  
  
 0 = &#124; `result` &#124; < &#124; (`result`) = `div` Sign (`value1`), где — это инструкция деления, которая усекается в сторону нуля. `value2` &#124;  
  
 Если `value2` значение равно нулю `value1` или является бесконечным, результатом является NaN. Если `value2` значение равно бесконечности, результатом `value1` является (отрицание `-infinity`для).  
  
 Целочисленные операции <xref:System.DivideByZeroException> создают `value2` исключение, если равно нулю.  
  
 Обратите внимание, что на платформах <xref:System.OverflowException> на базе технологии Intel при вычислении (minint `rem` -1) создается исключение.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `rem` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно значение без знака на другое значение без знака и помещает остаток в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5E|REM. un|Помещает оставшуюся часть деления без знака `value1` на `value2` неподписанный в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека и оставшейся части `value1` `div` `value2` вычисленного.  
  
4.  Результат помещается в стек.  
  
 `result` = `value1``rem.un` удовлетворяет`value2` следующим условиям.  
  
 `result` = `value1` - `value2`x (`value1` `div.un` )и`value2`:  
  
 0 = `result`  <  ,где`div.un` — это неподписанная инструкция деления. `value2`  
  
 Инструкция выполняет вычисление и помещает его в стек. `result` `rem.un` `Rem.un`обрабатывает свои аргументы как целые числа без знака, а <xref:System.Reflection.Emit.OpCodes.Rem> обрабатывает их как целые числа со знаком.  
  
 `Rem.un`не указан для чисел с плавающей запятой.  
  
 Целочисленные операции <xref:System.DivideByZeroException> создают `value2` исключение, если равно нулю.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `rem.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет возврат из текущего метода, помещая возвращаемое значение (если имеется) из стека вычислений вызываемого метода в стек вычислений вызывающего метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2A|обратно|Возвращает из метода, возможно, возвращающего значение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Возвращаемое значение извлекается из стека вычислений вызываемого метода.  
  
2.  Возвращаемое значение, полученное на шаге 1, помещается в стек вычислений вызывающего объекта.  
  
 Если возвращаемое значение отсутствует в стеке вычисления вызываемого метода, значение не возвращается (ни одно поведение перехода стека для вызываемого или вызывающего метода не используется).  
  
 Тип возвращаемого значения (если таковой имеется) текущего метода определяет тип значения, которое будет выбрано из верхней части стека и скопировано в стек метода, который вызвал текущий метод. Стек вычислений для текущего метода должен быть пустым, за исключением возвращаемого значения.  
  
 `filter``try` `finally` `catch`Инструкция не может использоваться для перемещения управления из блока,, или. `ret` `try` В или `catch`используйте `ret` инструкцию с назначением инструкции, находящимся за пределами охватывающих блоков исключений. <xref:System.Reflection.Emit.OpCodes.Leave> Поскольку блоки `finally` и логически являются частью обработки исключений, а не метода, в котором их код внедрен, правильно сформированные инструкции языка MSIL не выполняют возврат метода из `filter` `filter` или .`finally`  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `ret` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущее исключение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 1A|Rethrow|Повторная генерация текущего исключения|  
  
 Для этой инструкции не определено поведение перехода стека.  
  
 Инструкция разрешена только в теле `catch` обработчика. `rethrow` Он создает то же исключение, которое было перехвачено этим обработчиком.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `rethrow` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Смещает целочисленное значение влево (с заполнением нулями) на заданное число бит и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|62|шл|Сдвигает целое число влево (сдвиг в нули).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Количество битов для сдвига помещается в стек.  
  
3.  Число битов, которые необходимо сдвинуть, и значение, извлекаемое из стека; значение смещается влево на указанное число битов.  
  
4.  Результат помещается в стек.  
  
 Инструкция Сдвигает значение ( `int32` `int64` тип или`native int`) влево на указанное число битов. `shl` Число битов является значением типа `int32` или. `native int` Возвращаемое значение не указано, если число битов, которые необходимо сдвинуть, больше или равно ширине (в битах) указанного значения.  
  
 `Shl`вставляет нулевой бит в нижнюю точку при каждой смене.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `shl` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Смещает целочисленное значение вправо (с знаковым битом) на заданное число бит и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|63|SHR|Сдвигает целое число вправо (сдвиг в знак).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Количество битов для сдвига помещается в стек.  
  
3.  Число битов, которые необходимо сдвинуть, и значение, извлекаемое из стека; значение смещается вправо на указанное число битов.  
  
4.  Результат помещается в стек.  
  
 Инструкция Сдвигает значение ( `int32` `int64` тип или`native int`) вправо на указанное число битов. `shr.un` Число битов является значением типа `int32` или. `native int` Возвращаемое значение не указано, если число битов, которые необходимо сдвинуть, больше или равно ширине (в битах) указанного значения.  
  
 `Shr`реплицирует бит высокого порядка при каждой смене, сохраняя знак исходного значения в `result`.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `shr` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Смещает целочисленное значение без знака вправо (с заполнением нулями) на заданное число бит и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|64|SHR. un|Сдвигает целое число вправо (с сдвигом в нули).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Количество битов для сдвига помещается в стек.  
  
3.  Число битов, которые необходимо сдвинуть, и значение, извлекаемое из стека; значение смещается вправо на указанное число битов.  
  
4.  Результат помещается в стек.  
  
 Инструкция Сдвигает значение ( `int32` `int64` тип или`native int`) вправо на указанное число битов. `shr.un` Число битов является значением типа `int32` `int64` или `native int`. Возвращаемое значение не указано, если число битов, которые необходимо сдвинуть, больше или равно ширине (в битах) указанного значения.  
  
 `Shr.un`вставляет нулевой бит в самую верхнюю точку при каждой смене.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `shr.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений сведения о размере (в байтах) заданного типа значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< FE 1C`T` >|sizeof`valType`|Отправка размера (в байтах) типа значения в виде `unsigned int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Размер (в байтах) заданного типа значения (`valType`) помещается в стек.  
  
 `valType`должен быть токеном метаданных ( `typeref` или `typedef`), который указывает тип значения, ссылочный тип или параметр универсального типа.  
  
 Для ссылочного типа возвращаемый размер — это размер ссылочного значения соответствующего типа (4 байта в 32-разрядных системах), а не размер данных, хранящихся в объектах, на которые ссылается ссылочное значение. Параметр универсального типа может использоваться только в теле типа или метода, который его определяет. При создании экземпляра этого типа или метода параметр универсального типа заменяется типом значения или ссылочным типом.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `sizeof` использовать код операции:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение, находящееся на вершине стека вычислений, в ячейке аргумента с заданным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< FE 0B`unsigned int16` >|старг`num`|Извлекает верхнее значение из стека и сохраняет его в ячейке `num`аргументов.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение, находящегося на вершине стека, извлекается и помещается `num`в ячейку аргумента.  
  
 Инструкция извлекает значение из стека и помещает его в ячейку `num`аргумента. `starg` Тип значения должен соответствовать типу аргумента, как указано в сигнатуре текущего метода.  
  
 Для процедур, принимающих список аргументов переменных, `starg` инструкция может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры.  
  
 Выполнение хранилища в аргументах, содержащих целочисленное значение менее 4 байт, усекает значение при перемещении из стека в аргумент. Значения с плавающей запятой округляются от их собственного размера (типа `F`) до размера, связанного с аргументом.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `starg` использовать код операции:  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение, находящееся на вершине стека вычислений, в ячейке аргумента с заданным индексом (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|СТАРГ. s`num`|Извлекает верхнее значение из стека и сохраняет его в области `num`аргументов, краткой форме.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение, находящегося на вершине стека, извлекается и помещается `num`в ячейку аргумента.  
  
 Инструкция извлекает значение из стека и помещает его в ячейку `num`аргумента. `starg.s` Тип значения должен соответствовать типу аргумента, как указано в сигнатуре текущего метода.  
  
 `starg.s` Инструкция предоставляет эффективную кодировку для использования с первыми аргументами 256.  
  
 Для процедур, принимающих список аргументов переменных, `starg.s` инструкция может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры.  
  
 Выполнение хранилища в аргументах, содержащих целочисленное значение менее 4 байт, усекает значение при перемещении из стека в аргумент. Значения с плавающей запятой округляются от их собственного размера (типа `F`) до размера, связанного с аргументом.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `starg.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение в стеке вычислений, тип которого указан в инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A4 < `T` >|стелем`typeTok`|Заменяет элемент массива с заданным индексом на значение типа `typeTok` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве `array`помещается в стек.  
  
2.  Значение индекса, `index`, для элемента в `array` , помещается в стек.  
  
3.  Значение типа, указанное в инструкции, помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция заменяет значение элемента в указанном Отсчитываемый от нуля индексе в одномерном массиве `array` значением. `stelem` Значение имеет тип, заданный токеном `typeTok` в инструкции.  
  
 Массивы являются объектами, поэтому они представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stelem` использовать код операции:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="native int" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9Б|стелем. i|Заменяет элемент массива с `native int` заданным индексом на значение в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве `array`помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция заменяет значение элемента `index` в одномерном массиве `array` `native int` значением, помещаемым в стек. `stelem.i`  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stelem.i` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int8" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9C|стелем. i1|Заменяет элемент массива с `int8` заданным индексом на значение в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве `array`помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция заменяет значение элемента `index` в одномерном массиве `array` `int8` значением, помещаемым в стек. `stelem.i1`  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stelem.i1` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int16" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9D|стелем. i2|Заменяет элемент массива с `int16` заданным индексом на значение в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве `array`помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция заменяет значение элемента `index` в одномерном массиве `array` `int16` значением, помещаемым в стек. `stelem.i2`  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stelem.i2` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int32" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9E|стелем. i4|Заменяет элемент массива с `int32` заданным индексом на значение в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве `array`помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция заменяет значение элемента `index` в одномерном массиве `array` `int32` значением, помещаемым в стек. `stelem.i4`  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stelem.i4` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int64" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9F|стелем. i8|Заменяет элемент массива с `int64` заданным индексом на значение в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве `array`помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция заменяет значение элемента `index` в одномерном массиве `array` `int64` значением, помещаемым в стек. `stelem.i8`  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stelem.i8` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="float32" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A0|стелем. R4|Заменяет элемент массива с `float32` заданным индексом на значение в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве `array`помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция заменяет значение элемента `index` в одномерном массиве `array` `float32` значением, помещаемым в стек. `stelem.r4`  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stelem.r4` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="float64" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A1|стелем. R8|Заменяет элемент массива с `float64` заданным индексом на значение в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве `array`помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция заменяет значение элемента `index` в одномерном массиве `array` `float64` значением, помещаемым в стек. `stelem.r8`  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stelem.r8` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение object ref (тип <see langword="O" />), находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A2|стелем. ref|Заменяет элемент массива с `ref` заданным индексом на значение (Type `O`) в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект в массиве `array`помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция заменяет значение элемента по указанному индексу в одномерном массиве `array` `ref` значением (Type `O`), помещаемым в стек. `stelem.ref`  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 Обратите `stelem.ref` внимание, что неявно приводит переданное значение к `array` типу элемента перед присваиванием значения элементу массива. Это приведение может завершиться ошибкой даже для проверенного кода. Поэтому инструкция может создать исключение <xref:System.InvalidCastException>. `stelem.ref` Для одномерных массивов, которые не отсчитываются от нуля и для многомерных массивов <xref:System.Array> , класс <xref:System.Array.SetValue%2A> предоставляет метод.  
  
 <xref:System.NullReferenceException>Если `array` является пустой ссылкой, создается исключение.  
  
 <xref:System.IndexOutOfRangeException>вызывается, `index` если имеет отрицательное значение или больше, чем `array`граница.  
  
 <xref:System.ArrayTypeMismatchException>вызывается, `array` если не содержит элементов требуемого типа.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stelem.ref` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет значение в поле объекта, по ссылке на объект или указателю, на новое значение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld`field`|Заменяет значение `field` объекта новым значением.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект или указатель помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и ссылка на объект (указатель) извлекаются из стека; значение `field` в объекте заменяется заданным значением.  
  
 `native int` `O` `*` `&`Инструкция заменяет значение поля объекта (типа) или с помощью указателя (типа, или) на заданное значение. `stfld` `Field`— это маркер метаданных, который ссылается на ссылку на элемент поля. Инструкция может иметь префикс либо для, либо для того <xref:System.Reflection.Emit.OpCodes.Unaligned> и <xref:System.Reflection.Emit.OpCodes.Volatile>другого. `stfld`  
  
 <xref:System.NullReferenceException>вызывается, если ссылка на объект или указатель является пустой ссылкой, а поле не является статическим.  
  
 <xref:System.MissingFieldException>Если `field` не найден в метаданных, создается исключение. Обычно это проверяется при преобразовании инструкции MSIL в машинный код, а не во время выполнения.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stfld` использовать код операции:  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="native int" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DF|stind. i|`native int` Сохраняет значение по заданному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 `&` `*` `native int`Инструкция сохраняет значение по указанному адресу (тип, или). `native int` `stind.i`  
  
 Для операции с типом "безопасно `stind.i` " требуется, чтобы инструкция использовалась в соответствии с типом указателя. Операция `stind.i` инструкции может быть изменена непосредственно предшествующей <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксной инструкцией.  
  
 <xref:System.NullReferenceException>возникает, если `addr` не согласуется естественным образом для типа аргумента, подразумеваемого суффиксом инструкции.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stind.i` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int8" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|52|stind. i1|`int8` Сохраняет значение по заданному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 `&` `*` `native int`Инструкция сохраняет значение по указанному адресу (тип, или). `int8` `stind.i1`  
  
 Для операции с типом "безопасно `stind.i1` " требуется, чтобы инструкция использовалась в соответствии с типом указателя. Операция `stind.i1` инструкции может быть изменена непосредственно предшествующей <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксной инструкцией.  
  
 <xref:System.NullReferenceException>возникает, если `addr` не согласуется естественным образом для типа аргумента, подразумеваемого суффиксом инструкции.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stind.i1` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int16" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|53|stind. i2|`int16` Сохраняет значение по заданному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 `&` `*` `native int`Инструкция сохраняет значение по указанному адресу (тип, или). `int16` `stind.i2`  
  
 Для операции с типом "безопасно `stind.2i` " требуется, чтобы инструкция использовалась в соответствии с типом указателя. Операция `stind.i2` инструкции может быть изменена непосредственно предшествующей <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксной инструкцией.  
  
 <xref:System.NullReferenceException>возникает, если `addr` не согласуется естественным образом для типа аргумента, подразумеваемого суффиксом инструкции.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stind.i2` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int32" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|54|stind. i4|`int32` Сохраняет значение по заданному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 `&` `*` `native int`Инструкция сохраняет значение по указанному адресу (тип, или). `int32` `stind.i4`  
  
 Для операции с типом "безопасно `stind.i4` " требуется, чтобы инструкция использовалась в соответствии с типом указателя. Операция `stind.i4` инструкции может быть изменена непосредственно предшествующей <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксной инструкцией.  
  
 <xref:System.NullReferenceException>возникает, если `addr` не согласуется естественным образом для типа аргумента, подразумеваемого суффиксом инструкции.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stind.i4` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int64" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|55|stind. i8|`int64` Сохраняет значение по заданному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 `&` `*` `native int`Инструкция сохраняет значение по указанному адресу (тип, или). `int64` `stind.i8`  
  
 Для операции с типом "безопасно `stind.i8` " требуется, чтобы инструкция использовалась в соответствии с типом указателя. Операция `stind.i` инструкции может быть изменена непосредственно предшествующей <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксной инструкцией.  
  
 <xref:System.NullReferenceException>возникает, если `addr` не согласуется естественным образом для типа аргумента, подразумеваемого суффиксом инструкции.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stind.i8` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="float32" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|56|stind. R4|`float32` Сохраняет значение по заданному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 `&` `*` `native int`Инструкция сохраняет значение по указанному адресу (тип, или). `float32` `stind.r4`  
  
 Для операции с типом "безопасно `stind.r4` " требуется, чтобы инструкция использовалась в соответствии с типом указателя. Операция `stind.r4` инструкции может быть изменена непосредственно предшествующей <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксной инструкцией.  
  
 <xref:System.NullReferenceException>возникает, если `addr` не согласуется естественным образом для типа аргумента, подразумеваемого суффиксом инструкции.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stind.r4` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="float64" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|57|stind. R8|`float64` Сохраняет значение по заданному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 `&` `*` `native int`Инструкция сохраняет значение по указанному адресу (тип, или). `float64` `stind.r8`  
  
 Для операции с типом "безопасно `stind.r8` " требуется, чтобы инструкция использовалась в соответствии с типом указателя. Операция `stind.r8` инструкции может быть изменена непосредственно предшествующей <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксной инструкцией.  
  
 <xref:System.NullReferenceException>возникает, если `addr` не согласуется естественным образом для типа аргумента, подразумеваемого суффиксом инструкции.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stind.r8` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение ссылки на объект по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|51|stind. ref|Сохраняет значение ссылки на объект ( `O`тип) по указанному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 Инструкция сохраняет значение ссылки на объект по указанному адресу (тип `native int`, `*`или `&`). `stind.ref`  
  
 Для операции с типом "безопасно `stind.ref` " требуется, чтобы инструкция использовалась в соответствии с типом указателя. Операция `stind.ref` инструкции может быть изменена непосредственно предшествующей <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксной инструкцией.  
  
 <xref:System.NullReferenceException>возникает, если `addr` не согласуется естественным образом для типа аргумента, подразумеваемого суффиксом инструкции.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stind.ref` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с заданным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 0E <`unsigned int16` >|требовалась stloc`index`|Извлекает значение из стека и сохраняет его в локальной переменной `index`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную `index`.  
  
 Инструкция выводит верхнее значение из стека вычислений и перемещает его в номер `index`локальной переменной, где локальные переменные нумеруются 0 – назад. `stloc` Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (типа `F`) до размера, связанного с аргументом.  
  
 Для `index` правильных инструкций промежуточного языка MSIL требуется допустимый локальный индекс. `stloc` Для`index` инструкции должна находиться в диапазоне от 0 до 65534 включительно (в частности, 65535 является недопустимым). Исключение 65535 является практичным: вероятные реализации будут использовать 2-байтовое целое число для трассировки как индекса локальной версии, так и общего числа локальных переменных для данного метода. Если индекс 65535 был сделан допустимым, для записи числа локальных переменных в таком методе потребуется более широкое целое число.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузки метода могут `stloc` использовать код операции:  
  
-   ILGenerator. Emit (код операции, LocalBuilder)  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0A|требовалась stloc. 0|Извлекает значение из стека в локальную переменную 0.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 0.  
  
 `stloc.0` Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 0. Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 `stloc.0`— Это особо эффективная кодировка для хранения значений в локальной переменной 0.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (типа `F`) до размера, связанного с аргументом.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stloc.0` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение из стека вычислений и сохраняет его в списке локальных переменных с индексом 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0B|требовалась stloc. 1|Извлекает значение из стека в локальную переменную 1.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 1.  
  
 `stloc.1` Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 1. Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 `stloc.1`— Это особо эффективная кодировка для хранения значений в локальной переменной 1.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (типа `F`) до размера, связанного с аргументом.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stloc.1` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение из стека вычислений и сохраняет его в списке локальных переменных с индексом 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0C|требовалась stloc. 2|Извлекает значение из стека в локальную переменную 2|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 2.  
  
 `stloc.2` Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 2. Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 `stloc.2`— Это особо эффективная кодировка для хранения значений в локальной переменной 2.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (типа `F`) до размера, связанного с аргументом.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stloc.2` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение из стека вычислений и сохраняет его в списке локальных переменных с индексом 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0D|требовалась stloc. 3|Извлекает значение из стека в локальную переменную 3|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 3.  
  
 `stloc.3` Инструкция извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 3. Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 `stloc.3`— Это особо эффективная кодировка для хранения значений в локальной переменной 3.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (типа `F`) до размера, связанного с аргументом.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stloc.3` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом <paramref name="index" /> (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|требовалась stloc. s`index`|Извлекает значение из стека и сохраняет его в локальной переменной `index`краткой формы.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную `index`.  
  
 Инструкция выводит верхнее значение из стека вычислений и перемещает его в номер `index`локальной переменной, где локальные переменные нумеруются 0 – назад. `stloc.s` Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 `stloc.s` Инструкция обеспечивает эффективную кодировку для локальных переменных от 0 до 255.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (типа `F`) до размера, связанного с аргументом.  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузки метода могут `stloc.s` использовать код операции:  
  
-   ILGenerator. Emit (код операции, LocalBuilder)  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует значение с заданным типом из стека вычислений в указанный адрес памяти.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj`class`|Сохраняет значение типа `class` из стека в памяти.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Объект типа значения типа `class` помещается в стек.  
  
3.  Объект и адрес извлекаются из стека; Объект типа значения хранится по адресу.  
  
 Инструкция копирует объект типа значения в адрес, указанный в адресе (указатель типа `native int`, `*`или `&`). `stobj` Число копируемых байтов зависит от размера класса, представленного параметром `class`, маркера метаданных, представляющего тип значения.  
  
 Операция `stobj` инструкции может быть изменена непосредственно предшествующей <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned> префиксной инструкцией.  
  
 <xref:System.TypeLoadException>Если класс не найден, возникает исключение. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stobj` использовать код операции:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет значение статического поля на значение из стека вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld`field`|Заменяет значение в `field` заданном значении.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Значение извлекается из стека и сохраняется в `field`.  
  
 `stsfld` Инструкция заменяет значение статического поля значением из стека. `field`— это маркер метаданных, который должен ссылаться на член статического поля.  
  
 Инструкция может иметь <xref:System.Reflection.Emit.OpCodes.Volatile>префикс. `stsfld`  
  
 <xref:System.MissingFieldException>Если поле не найдено в метаданных, создается исключение. Обычно это проверяется при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `stsfld` использовать код операции:  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычитает одно значение из другого и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|59|sub|Вычитает одно значение из другого, возвращая новое числовое значение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; вычитается из `value1`. `value2`  
  
4.  Результат помещается в стек.  
  
 Переполнение не обнаружено для целочисленных операций (для правильной обработки переполнения см. раздел <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).  
  
 Вычитание целых чисел заключается в переносе, а не в насыщенность. Например, при наличии 8-разрядных целых чисел, `value1` где имеет значение 0, `value2` а значение 1, «упакованный» результат будет 255.  
  
 Переполнение с плавающей `+inf` запятой`PositiveInfinity`возвращает ( `-inf` )`NegativeInfinity`или ().  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `sub` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычитает одно целочисленное значение из другого, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DA|подovf|Вычитает одно целочисленное значение из другого с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; вычитается из `value1` с помощью проверки переполнения. `value2`  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Эта операция выполняется над целыми числами со знаком. для значений с плавающей запятой используйте <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `sub.ovf` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычитает одно целочисленное значение без знака из другого, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DB|ovf. un|Вычитает одно целочисленное значение без знака из другого с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека; вычитается из `value1` с помощью проверки переполнения. `value2`  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException>вызывается, если результат не может быть представлен типом результата.  
  
 Эта операция выполняется над целыми числами со знаком. для значений с плавающей запятой используйте <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `sub.ovf.un` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Реализует таблицу переходов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` >... < `int32` >|Switch (`N`, `t1` ,`t2`...) `tN`)|Переходит к одному из `N` значений.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Значение извлекается из стека, и выполнение передается в инструкцию со смещением, индексированным по значению, где значение меньше `N`.  
  
 `switch` Инструкция реализует таблицу переходов. Формат инструкции представляет `unsigned int32` количество целевых объектов `N`, за которыми следуют `N` значения Int32, указывающие цели перехода. Эти целевые объекты представлены в виде смещений (положительных или отрицательных) от начала инструкции, `switch` следующей за инструкцией.  
  
 Инструкция извлекает значение из стека и сравнивает его как целое число без знака с `N`. `switch` Если значение меньше `N`, выполнение передается в целевой индекс по значению, где конечные объекты нумеруются от 0 (например, значение 0 принимает первый целевой объект, значение 1 принимает второй целевой объект и т. д.). Если значение больше или равно `N`, выполнение переходит к следующей инструкции (передается).  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.  
  
 Управление `try`передачей в блоки, `catch`, `filter`и `finally` и из них не может выполняться этой инструкцией. (Такие передачи сильно ограничены и должны использовать инструкцию Leave).  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `switch` использовать код операции. `Label[]` Аргумент — это массив меток, представляющий 32-битное смещение.  
  
-   ILGenerator. Emit (код операции, метка [])  
  
   
  
## Examples  
 В следующем образце кода показано использование `Switch` кода операции для создания таблицы переходов с помощью <xref:System.Reflection.Emit.Label>массива.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет инструкцию вызова метода (префиксом которой является), предварительно удаляя кадр стека текущего метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 14|односторонне.|Последующий вызов завершает текущие методы|  
  
 Для этой инструкции не определено поведение перехода стека.  
  
 Инструкция префикса должна находиться непосредственно перед <xref:System.Reflection.Emit.OpCodes.Call>инструкцией <xref:System.Reflection.Emit.OpCodes.Calli>, или <xref:System.Reflection.Emit.OpCodes.Callvirt>. `tail` Указывает, что кадр стека текущего метода должен быть удален перед выполнением инструкции вызова. Также подразумевается, что значение, возвращаемое из следующего вызова, является также значением, возвращаемым текущим методом, и поэтому вызов может быть преобразован в переход между методами.  
  
 Стек должен быть пустым, за исключением аргументов, передаваемых следующим вызовом. Инструкция, следующая за инструкцией Call, должна быть Ret. Таким образом, единственной допустимой последовательностью `calli` кода `callvirt`является `tail. call` (или или). Правильные инструкции промежуточного языка MSIL не должны выполнять переход к `call` инструкции, но они могут выполнять переход к следующему. <xref:System.Reflection.Emit.OpCodes.Ret>  
  
 Текущий кадр не может быть отклонен, если управление передается из ненадежного кода в доверенный код, так как это может подвергнуть риску безопасность идентификации кода. Таким образом, .NET Framework проверки безопасности могут вызвать `tail` игнорирование, при этом будет использоваться <xref:System.Reflection.Emit.OpCodes.Call> стандартная инструкция. Аналогично, чтобы выйти из синхронизированной области после возврата вызова, этот `tail` префикс игнорируется при использовании для выхода из метода, помеченного как синхронизированный.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `tail` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Экземпляр объекта Opcode.</param>
        <summary>Возвращает true или false, в зависимости от того, принимает ли заданный код операции однобайтовый аргумент.</summary>
        <returns><see langword="true" /> или <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для определения того, какие коды MSIL являются "короткими формами", для использования в оптимизированном коде.  
  
 `TakesSingleByteArgument`Возвращает `true` значение, <xref:System.Reflection.Emit.OpCode> если экземпляр принимает один байтовый аргумент в следующих случаях:  
  
-   Код операции выполняет инструкцию ветвления с адресом в байтах (например, <xref:System.Reflection.Emit.OpCodes.Br_S> и <xref:System.Reflection.Emit.OpCodes.Bgt_S>).  
  
-   Код операции помещает значение байта в стек (например, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).  
  
-   Код операции ссылается на переменную или аргумент с помощью короткой формы размером байта (например, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> и <xref:System.Reflection.Emit.OpCodes.Stloc_S>).  
  
 В противном случае она возвращает `false`.  
  
 В приведенном ниже примере показано использование `TakesSingleByteArgument` путем отражения `OpCodes` к классу и проверки того, принимает ли каждое `OpCode` поле однобайтовый аргумент.  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Создает объект исключения, находящийся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7А|throw|Создает исключение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект (исключение) помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и вызывается исключение.  
  
 Инструкция создает объект исключения (тип `O`) в данный момент в стеке. `throw`  
  
 <xref:System.NullReferenceException>Если ссылка на объект является пустой ссылкой, создается исключение.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `throw` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что адрес на вершине стека, возможно, не выровнен по естественному размеру следующей непосредственно за ним инструкции <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" /> или <see langword="cpblk" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< FE 12`unsigned int8` >|невыровненным. `alignment`|Указывает, что последующая инструкция указателя может быть несогласованной.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
 `Unaligned`Указывает, что адрес ( `native int`неуправляемый указатель,) в стеке может не соответствовать естественному размеру `ldind`сразу после `stobj`, `stind`, `ldfld`, `stfld` `ldobj`,,, `initblk`инструкция или `cpblk` . Это значит, что для <xref:System.Reflection.Emit.OpCodes.Ldind_I4> инструкции выравнивание адреса не может быть равно 4-байтной границе. Для `initblk` и`cpblk` выравнивание по умолчанию зависит от архитектуры (4-байтовые на 32-разрядных ЦП, 8-байт на 64-разрядных ЦП). Генераторы кода, которые не ограничивают свои выходные данные размером 32-разрядного слова `unaligned` , должны использовать, если во время компиляции неизвестно 8-байтное выравнивание.  
  
 Значение выравнивания должно быть равно 1, 2 или 4 и означает, что созданный код должен предположить, что адрес имеет тип Byte, двухбайтовые или четыре байта соответственно. Обратите внимание, что временные `*`указатели (тип) всегда согласовываются.  
  
 Хотя выравнивание для `cpblk` инструкции логически потребовало два числа (одно для источника и одно для назначения), не существует заметного влияния на производительность, если указано только меньшее число.  
  
 Префиксы `volatile` и можно объединять в любом порядке. `unaligned` Они `ldind`должны следовать непосредственно перед инструкцией `stind` `ldfld`,, `stfld`, `ldobj` `stobj` ,,`cpblk` , или. `initblk` Для инструкций и<xref:System.Reflection.Emit.OpCodes.Stsfld>допускается только префикс.<xref:System.Reflection.Emit.OpCodes.Volatile> <xref:System.Reflection.Emit.OpCodes.Ldsfld>  
  
 Следующие <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузки метода могут `unaligned` использовать код операции:  
  
-   ILGenerator. Emit (код операции, метка)  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует тип значения из упакованной формы в распакованную.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|79 < `T` >|распакован`valType`|Извлекает из `obj`упакованного представления данные типа значения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и распаковывается в указатель типа значения.  
  
3.  Указатель типа значения помещается в стек.  
  
 Тип значения имеет два отдельных представления в Common Language Infrastructure (CLI):  
  
-   Необработанная форма, используемая при внедрении типа значения в другой объект.  
  
-   "Упакованная" форма, в которой данные в типе значения упаковываются (упаковываются) в объект, поэтому он может существовать как независимая сущность.  
  
 Инструкция преобразует ссылку на объект (тип `O`), упакованное представление типа значения, в указатель типа значения (управляемый указатель, тип `&`), его неупакованную форму. `unbox` Указанный тип значения (`valType`) является маркером метаданных, указывающим тип значения, содержащегося в упакованном объекте.  
  
 В отличие <xref:System.Reflection.Emit.OpCodes.Box>от, которое требуется для создания копии типа значения для использования в объекте, `unbox` не требуется копировать тип значения из объекта. Обычно он просто выполняет вычисление адреса типа значения, уже присутствующего внутри упакованного объекта.  
  
 <xref:System.InvalidCastException>возникает, если объект не упакован как `valType`.  
  
 <xref:System.NullReferenceException>Если ссылка на объект является пустой ссылкой, создается исключение.  
  
 <xref:System.TypeLoadException>Если тип `valType` значения не найден, вызывается исключение. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `unbox` использовать код операции:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует тип, указанный в инструкции, из упакованной формы в распакованную.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A5 < `T` >|Распакованный. Any`typeTok`|Извлеките данные из `obj`упакованного представления.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка `obj` на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и распаковывается в тип, указанный в инструкции.  
  
3.  Результирующая ссылка на объект или тип значения помещается в стек.  
  
 `unbox.any` При применении к упакованной форме типа значения инструкция извлекает значение `ldobj`, содержащееся в `obj` (типа `O`), и, следовательно, эквивалентно `unbox` .  
  
 При применении к ссылочному типу `unbox.any` инструкция имеет тот же результат, что `castclass` `typeTok`и.  
  
 Если операнд `typeTok` является параметром универсального типа, то поведение среды выполнения определяется типом, указанным для этого параметра универсального типа.  
  
 <xref:System.InvalidCastException>Если `obj` не является упакованным типом, создается исключение.  
  
 <xref:System.NullReferenceException>Если `obj` является пустой ссылкой, создается исключение.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `unbox.any` использовать код операции:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что адрес на вершине стека вычислений, возможно, является изменяемым и результаты чтения данной области невозможно кэшировать либо невозможно запретить множественные сохранения в эту область.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 13|независимо.|Указывает, что последующая ссылка на указатель является временной.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
 `volatile`. Указывает, что адрес является временным адресом (т. е. на него может ссылаться извне на текущий поток выполнения), и результаты чтения этого расположения не могут быть кэшированы или нельзя подавлять несколько магазинов в этом расположении. Пометка доступа как `volatile` влияет только на этот единый доступ; другие обращения к одному и тому же расположению должны быть помечены отдельно. Доступ к временным расположениям не должен выполняться атомарно.  
  
 Префиксы `volatile` и можно объединять в любом порядке. <xref:System.Reflection.Emit.OpCodes.Unaligned> Они `ldind`должны следовать непосредственно перед инструкцией `stind` `ldfld`,, `stfld`, `ldobj` `stobj` ,,`cpblk` , или. `initblk` Для инструкций и<xref:System.Reflection.Emit.OpCodes.Stsfld>допускается только префикс.`volatile` <xref:System.Reflection.Emit.OpCodes.Ldsfld>  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `volatile` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое исключающее ИЛИ двух верхних значений в стеке вычислений и помещает результат обратно в стек.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|61|xor|Выполняет побитовое ИСКЛЮЧАЮЩее или двух целочисленных значений и возвращает целое число.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1`помещается в стек.  
  
2.  `value2`помещается в стек.  
  
3.  `value2`и `value1` извлекаются из стека и их побитовое исключающее XOR.  
  
4.  Побитовое `value2` исключающее `value1` и помещается в стек.  
  
 `xor` Инструкция рассчитывает побитовое исключающее или двух верхних значений в стеке и оставляет результат в стеке.  
  
 `Xor`— Это операция, относящаяся к целому числу.  
  
 Следующая <xref:System.Reflection.Emit.ILGenerator.Emit%2A> перегрузка метода может `xor` использовать код операции:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>