<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="31aacfb3c9c41209604373f1222ef49403dcd208" /><Meta Name="ms.sourcegitcommit" Value="c573d537afba2d4c1463538f1095f2f155025464" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/16/2019" /><Meta Name="ms.locfileid" Value="72409087" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Содержит поля, предоставляющие инструкции языка MSIL для выпуска элементами класса <see cref="T:System.Reflection.Emit.ILGenerator" /> (например, <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подробное описание кодов операций для элементов см. в документации по Common Language Infrastructure (CLI), особенно в разделе III: Набор инструкций CIL "и" раздел II: Определение и семантика метаданных ". Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.  
  
   
  
## Examples  
 В следующем примере демонстрируется создание динамического метода с помощью <xref:System.Reflection.Emit.ILGenerator> для порождения `OpCodes` в <xref:System.Reflection.Emit.MethodBuilder>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Складывает два значения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|58|add|Складывает два числовых значения, возвращая новое числовое значение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` добавляется в `value2`.  
  
4.  Результат помещается в стек.  
  
 Переполнение не обнаружено для целочисленных операций (для правильной обработки переполнения см. <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).  
  
 Сложение целых чисел, а не насыщенность. Например, при использовании 8-разрядных целых чисел, где `value1` устанавливается равным 255, а `value2` — 1, то упакованным результатом будет 0, а не 256.  
  
 Переполнение с плавающей точкой возвращает `+inf` (`PositiveInfinity`) или `-inf` (`NegativeInfinity`).  
  
 Допустимые типы операндов и соответствующий тип данных результата перечислены в таблице ниже. Если нет записи для определенного сочетания типа (например, `int32` и `float`; `int32` и `int64`), это недопустимый MSIL и создает ошибку.  
  
|операнд|Тип value1|Тип value2|Тип результата|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `add`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Складывает два целых числа, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D6|Добавить. ovf|Добавляет два целочисленных значения со знаком с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` добавляется в `value2` с помощью проверки переполнения.  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException> создается, если результат не представлен типом результата.  
  
 Эту операцию можно выполнить с целыми числами со знаком. Для значений с плавающей запятой используйте <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Допустимые типы операндов и соответствующий тип данных результата перечислены в таблице ниже. Если нет записи для определенного сочетания типа (например, `int32` и `float`; `int32` и `int64`), это недопустимая инструкция языка MSIL, которая выдает ошибку.  
  
|операнд|Тип value1|Тип value2|Тип результата|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `add.ovf`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Складывает два целочисленных значения без знака, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D7|Добавить. ovf. un|Добавляет два целочисленных значения без знака с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` добавляется в `value2` с помощью проверки переполнения.  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException> создается, если результат не представлен типом результата.  
  
 Эту операцию можно выполнить с целыми числами со знаком. Для значений с плавающей запятой используйте <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Допустимые типы операндов и соответствующий тип данных результата перечислены в таблице ниже. Если нет записи для определенного сочетания типа (например, `int32` и `float`; `int32` и `int64`), это недопустимая инструкция языка MSIL, которая выдает ошибку.  
  
|операнд|Тип value1|Тип value2|Тип результата|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `add.ovf.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое И двух значений и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Инструкция|Описание|  
|------------|-----------------|-----------------|  
|5F|и|Определяет побитовое и для двух целочисленных значений.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value1` и `value2` извлекаются из стека; Побитовое и для двух значений является вычисленным.  
  
4.  Результат помещается в стек.  
  
 Инструкция `and` рассчитывает побитовое и для двух верхних значений в стеке и оставляет результат в стеке.  
  
 `And` является операцией, относящейся к целому числу.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `and`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает неуправляемый указатель на список аргументов текущего метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 00|arglist|Возвращает маркер списка аргументов для текущего метода.|  
  
 Эта операция не выполняет поведений стека вычислений.  
  
 Инструкция `arglist` возвращает непрозрачный маркер (неуправляемый указатель типа `native int`), представляющий список аргументов текущего метода. Этот маркер действителен только в течение времени существования текущего метода. Однако можно передать этот обработчик другим методам, если текущий метод находится в потоке управления. В методе, принимающем переменное число аргументов, можно выполнить только инструкцию `arglist`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `arglist`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если два значения равны.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3B < `int32` >|Бек `target`|Выполняет переход к целевой инструкции со смещением `target`, если два значения равны.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` равно `value2`, выполняется операция ветвления.  
  
 Инструкция `beq` передает управление в указанную целевую инструкцию, если `value1` равно `value2`. Результат аналогичен выполнению инструкции `ceq`, за которой следует ветвь `brtrue` для конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Допустимые типы операндов инкапсулированы ниже:  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.  
  
 Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией (такие передачи являются строго ограниченными и должны использовать инструкцию <xref:System.Reflection.Emit.OpCodes.Leave>).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `beq`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если два значения равны.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2E < `int8` >|Бек. s `target`|Переход к целевой инструкции со смещением `target`, если равно, краткая форма|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` равно `value2`, выполняется операция ветвления.  
  
 Инструкция `beq.s` передает управление в указанную целевую инструкцию, если `value1` равно `value2`. Результат аналогичен выполнению инструкции `ceq`, за которой следует ветвь `brtrue` для конкретной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Допустимые типы операндов инкапсулированы ниже:  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.  
  
 Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией (такие передачи являются строго ограниченными и должны использовать инструкцию <xref:System.Reflection.Emit.OpCodes.Leave>).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `beq.s`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3C `<int32>`|бже `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго или равно ему.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` больше или равно `value2`, выполняется операция ветвления.  
  
 Инструкция `bge` передает управление в указанную целевую инструкцию, если `value1` больше или равен `value2`. Этот результат идентичен выполнению инструкции `clt.un`, за которой следует ветвь `brfalse` для конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bge`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2F `<int8>`|бже. s `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго или равно ему (краткая форма).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` больше или равно `value2`, выполняется операция ветвления.  
  
 Инструкция `bge.s` передает управление в указанную целевую инструкцию, если `value1` больше или равен `value2`. Этот результат идентичен выполнению инструкции `clt.un`, за которой следует ветвь `brfalse` для конкретной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bge.s`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|41 `<int32>`|бже. un `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше или равно второму значению (значения без знака).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` больше или равно `value2`, выполняется операция ветвления.  
  
 Инструкция `bge.un` передает управление в указанную целевую инструкцию, если `value1` больше или равен `value2` при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `clt`, за которой следует ветвь `brfalse` для конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bge.un`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|34 < `int8` >|бже. un. s `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше или равно второму (значения без знака), короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` больше или равно `value2`, выполняется операция ветвления.  
  
 Инструкция `bge.un.s` передает управление в указанную целевую инструкцию, если `value1` больше или равен `value2` при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `clt`, за которой следует ветвь `brfalse` для конкретной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bge.un.s`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3D < `int32` >|БГТ `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` больше, чем `value2`, выполняется операция ветвления.  
  
 Инструкция `bgt` передает управление указанной конечной инструкции, если `value1` больше, чем `value2`. Этот результат идентичен выполнению инструкции `cgt`, за которой следует ветвь `brtrue` для конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bgt`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|30 < `int8` >|БГТ. s `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго (краткая форма).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` больше, чем `value2`, выполняется операция ветвления.  
  
 Инструкция `bgt.s` передает управление указанной конечной инструкции, если `value1` больше, чем `value2`. Этот результат идентичен выполнению инструкции `cgt`, за которой следует ветвь `brtrue` для конкретной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bgt.s`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|42 < `int32` >|БГТ. un `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго (значения без знака).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` больше, чем `value2`, выполняется операция ветвления.  
  
 Инструкция `bgt.un` передает управление указанной конечной инструкции, если `value1` больше, чем `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `cgt.un`, за которой следует ветвь `brtrue` для конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bgt.un`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|35 < `int8` >|БГТ. un. s `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго (значения без знака), короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` больше, чем `value2`, выполняется операция ветвления.  
  
 Инструкция `bgt.un.s` передает управление указанной конечной инструкции, если `value1` больше, чем `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `cgt.un`, за которой следует ветвь `brtrue` для конкретной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bgt.un.s`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго значения или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3E `<int32>`|BLE `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго или равно ему.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` меньше или равно `value2`, выполняется операция ветвления.  
  
 Инструкция `ble` передает управление указанной конечной инструкции, если `value1` меньше или равно `value2`. Этот результат идентичен выполнению инструкции `cgt` (`cgt.un` для float), за которой следует ветвь `brfalse` для конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ble`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго или равно ему.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|31 `<int8>`|BLE. s `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго или равно ему (короткая форма).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` меньше или равно `value2`, выполняется операция ветвления.  
  
 Инструкция `ble.s` передает управление указанной конечной инструкции, если `value1` меньше или равно `value2`. Этот результат идентичен выполнению инструкции `cgt` (`cgt.un` для float), за которой следует ветвь @ no__t-2 для конкретной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ble.s`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго или равно ему (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|43 `<int32>`|BLE. un `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше или равно второму значению (значения без знака).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` меньше или равно `value2`, выполняется операция ветвления.  
  
 Инструкция `ble.un` передает управление в указанную целевую инструкцию, если `value1` меньше или равен `value2` при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `cgt.un` (`cgt` для float), за которой следует ветвь `brfalse` для конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ble.un`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго или равно ему (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|36 `<int8>`|BLE. un. s `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше или равно второму (значения без знака), короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` меньше или равно `value2`, выполняется операция ветвления.  
  
 Инструкция `ble.un.s` передает управление в указанную целевую инструкцию, если `value1` меньше или равен `value2` при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `cgt.un` (`cgt` для float), за которой следует ветвь `brfalse` для конкретной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ble.un.s`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3F < `int32` >|БЛТ `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` меньше `value2`, выполняется операция ветвления.  
  
 Инструкция `blt` передает управление указанной конечной инструкции, если `value1` меньше или равно `value2`. Этот результат идентичен выполнению инструкции `clt`, за которой следует ветвь `brtrue` для конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `blt`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|32 < `int8` >|БЛТ. s `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго (краткая форма).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` меньше `value2`, выполняется операция ветвления.  
  
 Инструкция `blt.s` передает управление указанной конечной инструкции, если `value1` меньше, чем `value2`. Этот результат идентичен выполнению инструкции `clt`, за которой следует ветвь `brtrue` для конкретной целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `blt.s`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если первое значение меньше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|44 < `int32` >|БЛТ. un `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго (значения без знака).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` меньше `value2`, выполняется операция ветвления.  
  
 Инструкция `blt.un` передает управление указанной конечной инструкции, если `value1` меньше, чем `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `clt.un`, за которой следует ветвь `brtrue` для конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `blt.un`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если первое значение меньше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|37 < `int8` >|БЛТ. un. s `target`|Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго (значения без знака), короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` меньше `value2`, выполняется операция ветвления.  
  
 Инструкция `blt.un` передает управление указанной конечной инструкции, если `value1` меньше, чем `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `clt.un`, за которой следует ветвь `brtrue` для конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `blt.un.s`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции в случае неравенства двух целочисленных значений без знака или двух неупорядоченных значений с плавающей запятой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|40 < `int32` >|бне. un `target`|Выполняет переход к целевой инструкции с указанным смещением, если два целочисленных значения без знака не равны (значения без знака).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` не равно `value2`, выполняется операция ветвления.  
  
 Инструкция `bne.un` передает управление указанной конечной инструкции, если `value1` не равно `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `ceq`, за которой следует ветвь `brfalse` для конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bne.un`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма) в случае неравенства двух целочисленных значений без знака или двух неупорядоченных значений с плавающей запятой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|33 < `int8` >|бне. un. s `target`|Выполняет переход к целевой инструкции с указанным смещением, если два целочисленных значения без знака не равны (значения без знака), краткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; Если `value1` не равно `value2`, выполняется операция ветвления.  
  
 Инструкция `bne.un` передает управление указанной конечной инструкции, если `value1` не равно `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой. Этот результат идентичен выполнению инструкции `ceq`, за которой следует ветвь `brfalse` для конкретной целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bne.un.s`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует тип значения в ссылку на объект (тип <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8C < `T` >|Box `valTypeToken`|Преобразование типа значения (типа, указанного в `valTypeToken`) в истинную ссылку на объект.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Тип значения помещается в стек.  
  
2.  Тип значения извлекается из стека; выполняется операция `box`.  
  
3.  Ссылка на объект, получивший "упакованный" тип значения, помещается в стек.  
  
 Тип значения имеет два отдельных представления в Common Language Infrastructure (CLI):  
  
-   Необработанная форма, используемая при внедрении типа значения в другой объект или в стек.  
  
-   "Упакованная" форма, в которой данные в типе значения упаковываются (упаковываются) в объект, поэтому он может существовать как независимая сущность.  
  
 Инструкция `box` преобразует необработанный (неупакованный) тип значения в ссылку на объект (тип `O`). Это достигается путем создания нового объекта и копирования данных из типа значения в новый выделенный объект. `valTypeToken` является маркером метаданных, указывающим тип значения в стеке.  
  
 <xref:System.OutOfMemoryException> возникает, если недостаточно памяти для удовлетворения запроса.  
  
 Если класс не найден, возникает исключение <xref:System.TypeLoadException>. Обычно это обнаруживается при преобразовании MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `box`:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Обеспечивает безусловную передачу управления конечной инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|Выполняет переход к целевой инструкции по указанному смещению.|  
  
 Эта операция не выполняет поведений стека вычислений.  
  
 Инструкция `br` безусловно передает управление целевой инструкции. Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `br`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Обеспечивает безусловную передачу управления конечной инструкции (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br. s `target`|Выполняет переход к целевой инструкции по указанному смещению (краткая форма).|  
  
 Эта операция не выполняет поведений стека вычислений.  
  
 Инструкция `br.s` безусловно передает управление целевой инструкции. Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `br.s`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сообщает инфраструктуре CLI, что необходимо оповестить отладчик о достижении точки останова.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|01|break|Сообщите отладчику о достижении точки останова.|  
  
 Эта операция не выполняет поведений стека вычислений.  
  
 Инструкция `break` предназначена для поддержки отладки. Он сигнализирует интерфейсу командной строки сообщить отладчику о том, что точка останова была остановлена. Он не влияет на состояние интерпретатора.  
  
 Инструкция `break` имеет наименьший возможный размер инструкции, позволяя выполнять исправление кода с точкой останова и создавать минимальный беспорядки вокруг окружающего кода.  
  
 Инструкция `break` может быть перехватываться в отладчике, не выполнять никаких действий или вызывать исключение безопасности. Точное поведение определяется реализацией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `break`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если значением <paramref name="value" /> является <see langword="false" />, пустая ссылка (<see langword="Nothing" /> в Visual Basic) или ноль.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|39 < `int32` >|брфалсе `target`<br /><br /> брнулл `target`<br /><br /> брзеро `target`|Выполняет переход к целевой инструкции с указанным смещением, если `false`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек с помощью предыдущей операции.  
  
2.  `value` извлекается из стека; Если `value` — `false`, ветвь устанавливается в `target`.  
  
 Инструкция `brfalse` (и ее псевдонимы `brnull` и `brzero`) передает управление указанной конечной инструкции, если `value` (тип `int32`, `int64`, ссылка на объект `O`, управляемый указатель `&`, временный указатель `*`, `native int`) равен нулю. (0). Если `value` не равно нулю (`true`), продолжение выполнения выполняется в следующей инструкции.  
  
 Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `brfalse`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если значением <paramref name="value" /> является <see langword="false" />, пустая ссылка или ноль.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2C <`int8` >|брфалсе. s `target`<br /><br /> брнулл. s `target`<br /><br /> брзеро. s `target`|Выполняет переход к целевой инструкции с указанным смещением, если `false`, короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек с помощью предыдущей операции.  
  
2.  `value` извлекается из стека; Если `value` — `false`, ветвь устанавливается в `target`.  
  
 Инструкция `brfalse.s` (и ее псевдонимы `brnull` и `brzero`) передает управление указанной конечной инструкции, если `value` (тип `int32`, `int64`, ссылка на объект `O`, управляемый указатель `&`, временный указатель `*`, `native int`) равен нулю. (0). Если `value` не равно нулю (`true`), продолжение выполнения выполняется в следующей инструкции.  
  
 Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `brfalse.s`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции, если значение <paramref name="value" /> равно <see langword="true" />, либо отличается от null и от нуля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|3A < `int32` >|требовалась brtrue `target`<br /><br /> бринст `target`|Выполняет переход к целевой инструкции с указанным смещением, если не равен нулю (`true`).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек с помощью предыдущей операции.  
  
2.  `value` извлекается из стека; Если `value` — `true`, ветвь устанавливается в `target`.  
  
 Инструкция `brtrue` передает управление указанной конечной инструкции, если `value` (тип `native int`) не равен нулю (`true`). Если `value` равно нулю (`false`), выполнение продолжится в следующей инструкции.  
  
 Если `value` является ссылкой на объект (тип `O`), то `brinst` (псевдоним для `brtrue`) передает управление, если он представляет экземпляр объекта (например, если он не является ссылкой на объект null; см. <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `brtrue`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление конечной инструкции (короткая форма), если значение <paramref name="value" /> равно <see langword="true" /> либо отличается от null и от нуля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2D < `int8` >|требовалась brtrue. s `target`<br /><br /> бринст. s `target`|Переход к целевой инструкции с указанным смещением, если ненулевое значение (`true`), краткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек с помощью предыдущей операции.  
  
2.  `value` извлекается из стека; Если `value` — `true`, ветвь устанавливается в `target`.  
  
 Инструкция `brtrue.s` передает управление указанной конечной инструкции, если `value` (тип `native int`) не равен нулю (`true`). Если `value` равно нулю (`false`), выполнение продолжится в следующей инструкции.  
  
 Если `value` является ссылкой на объект (тип `O`), то `brinst` (псевдоним для `brtrue`) передает управление, если он представляет экземпляр объекта (например, если он не является ссылкой на объект null; см. <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов. Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `brtrue.s`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывает метод, на который ссылается переданный дескриптор метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|28 < `T` >|вызов `methodDesc`|Вызовите метод, описанный `methodDesc`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Аргументы метода @no__t от-0 до `argN` помещаются в стек.  
  
2.  Аргументы метода @no__t от-0 до `argN` извлекаются из стека; вызов метода выполняется с этими аргументами, и управление передается методу, на который ссылается дескриптор метода. По завершении возвращаемое значение создается вызываемым методом и отправляется вызывающему объекту.  
  
3.  Возвращаемое значение помещается в стек.  
  
 Инструкция `call` вызывает метод, указанный дескриптором метода, передаваемым с помощью инструкции. Дескриптор метода — это маркер метаданных, указывающий вызываемый метод и число, тип и порядок аргументов, которые были помещены в стек для передачи в этот метод, а также соглашение о вызовах для использования. Инструкция `call` может предшествовать префиксу `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>), чтобы указать, что текущее состояние метода должно быть освобождено перед передачей управления. Если вызов передает управление методу более высокого уровня доверия, чем метод источника, кадр стека не освобождается. Вместо этого выполнение продолжится автоматически, как если бы `tail` не было предоставлено. Маркер метаданных содержит достаточную информацию для определения того, относится ли вызов к статическому методу, методу экземпляра, виртуальному методу или глобальной функции. Во всех этих случаях адрес назначения определяется исключительно из дескриптора метода (Сравните это с инструкцией <xref:System.Reflection.Emit.OpCodes.Callvirt> для вызова виртуальных методов, где адрес назначения также зависит от типа среды выполнения ссылки на экземпляр помещается перед <xref:System.Reflection.Emit.OpCodes.Callvirt>).  
  
 Аргументы помещаются в стек в порядке слева направо. То есть первый аргумент выводится и помещается в стек, затем второй аргумент — третий, пока все необходимые аргументы не помещаются в стек в убывающем порядке. Существует три важных случая.  
  
 1. Вызовы метода экземпляра (или виртуального) должны отправить ссылку на этот экземпляр перед любыми видимыми пользователем аргументами. Ссылка на экземпляр не должна быть пустой ссылкой. Сигнатура, перенесенная в метаданные, не содержит записи в списке параметров для указателя `this`; Вместо этого используется бит, указывающий, требует ли метод передачи указателя `this`.  
  
 2. Вызов виртуального метода допускается с помощью `call` (а не `callvirt`); Это означает, что метод должен быть разрешен с помощью класса, заданного методом, а не как указано динамически в вызываемом объекте.  
  
 3. Обратите внимание, что метод `Invoke` делегата можно вызвать с помощью инструкции `call` или `callvirt`.  
  
 <xref:System.Security.SecurityException> может возникать, если система безопасности не предоставляет вызывающему объекту доступ к вызываемому методу. Проверка безопасности может происходить, когда инструкции MSIL преобразуются в машинный код, а не во время выполнения.  
  
> [!NOTE]
>  При вызове методов типа System. Object для типов значений рекомендуется использовать префикс `constrained` с инструкцией `callvirt` вместо выдачи инструкции `call`. Это избавляет от необходимости создавать разные IL в зависимости от того, переопределяет ли тип значения метод, избегая возможной проблемы управления версиями. Рекомендуется использовать префикс `constrained` при вызове методов интерфейса для типов значений, так как метод типа значения, реализующий метод интерфейса, можно изменить с помощью `MethodImpl`. Эти проблемы более подробно описаны в коде операции <xref:System.Reflection.Emit.OpCodes.Constrained>.  
  
 Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `call`:  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
-   ILGenerator. Емиткалл (код операции, MethodInfo, тип [])  
  
> [!NOTE]
>  Метод <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> предоставляется для вызовов `varargs`. Используйте метод <xref:System.Reflection.Emit.ILGenerator.Emit%2A> для обычных вызовов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывает метод, заданный в стеке вычислений (как указатель на точку входа), с аргументами, описанными в соглашении о вызовах.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|29 < `T` >|calli `callSiteDescr`|Вызывает метод, указываемый с аргументами, описанными в соглашении о вызовах.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Аргументы метода @no__t от-0 до `argN` помещаются в стек.  
  
2.  Указатель на запись метода помещается в стек.  
  
3.  Аргументы метода @no__t от-0 до `argN`, а указатель входа метода извлекается из стека; выполняется вызов метода. По завершении возвращаемое значение создается вызываемым методом и отправляется вызывающему объекту.  
  
4.  Возвращаемое значение помещается в стек.  
  
 Инструкция `calli` вызывает указатель входа метода с аргументами `arg1` до `argN`. Типы этих аргументов описаны определенным соглашением о вызовах (`callSiteDesc`). Инструкции `calli` может предшествовать префикс `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>), чтобы указать, что текущее состояние метода должно быть освобождено перед передачей управления. Если вызов передает управление методу с более высоким уровнем доверия, чем метод источника, кадр стека не будет освобожден; Вместо этого выполнение продолжится автоматически, как если бы `tail` не было предоставлено.  
  
 Указатель входа метода считается определенным указателем на машинный код (на целевом компьютере), который можно использовать с аргументами, описанными в соглашении о вызовах (маркер метаданных для отдельной подписи). Такой указатель может быть создан с помощью инструкций <xref:System.Reflection.Emit.OpCodes.Ldftn> или <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> или передается из машинного кода.  
  
 Соглашение о вызовах не проверяется динамически, поэтому код, использующий инструкцию `calli`, не работает правильно, если назначение фактически не использует указанное соглашение о вызовах.  
  
 Аргументы помещаются в стек в порядке слева направо. То есть первый аргумент выводится и помещается в стек, затем второй аргумент — третий, пока все необходимые аргументы не помещаются в стек в убывающем порядке. Последовательность кода для создания аргументов для экземпляра или виртуального метода должна отправить ссылку на экземпляр (которая не должна быть пустой ссылкой) перед любыми видимыми пользователем аргументами.  
  
 <xref:System.Security.SecurityException> может возникать, если системная безопасность не предоставляет вызывающему объекту доступ к вызываемому методу. Проверка безопасности может происходить, когда инструкции MSIL преобразуются в машинный код, а не во время выполнения.  
  
 Следующие методы <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> можно использовать для выполнения инструкции `calli` в стеке. Обратите внимание, что `calli` следует вызывать через приведенные ниже методы, а не использовать класс <xref:System.Reflection.Emit.ILGenerator.Emit%2A>, чтобы разместить инструкцию непосредственно в стеке.  
  
-   ILGenerator. Емиткалли (opcode, Каллингконвентионс, Type, Type [], Type []) для вызовов, использующих соглашение об управляемом вызовах.  
  
-   ILGenerator. Емиткалли (opcode, CallingConvention, Type, Type []) для вызовов, использующих неуправляемое соглашение о вызовах.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывает метод объекта с поздней привязкой и помещает возвращаемое значение в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt `method`|Вызывает конкретный метод, связанный с `obj`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `obj` помещается в стек.  
  
2.  Аргументы метода @no__t от-0 до `argN` помещаются в стек.  
  
3.  Аргументы метода @no__t от-0 до `argN` и ссылка на объект `obj` извлекаются из стека; вызов метода выполняется с этими аргументами, и управление передается методу в `obj`, на который ссылается токен метаданных метода. По завершении возвращаемое значение создается вызываемым методом и отправляется вызывающему объекту.  
  
4.  Возвращаемое значение помещается в стек.  
  
 Инструкция `callvirt` вызывает метод с поздним связыванием для объекта. То есть метод выбирается на основе типа среды выполнения `obj`, а не класса времени компиляции, видимого в указателе метода. `Callvirt` можно использовать для вызова как виртуальных, так и методов экземпляра. Инструкции `callvirt` может предшествовать префикс `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>), чтобы указать, что текущий кадр стека следует освободить перед передачей управления. Если вызов передает управление методу с более высоким уровнем доверия, чем исходный метод, кадр стека не будет освобожден.  
  
 Токен метаданных метода предоставляет имя, класс и сигнатуру вызываемого метода. Класс, связанный с `obj`, является классом, экземпляром которого является. Если класс определяет нестатический метод, соответствующий указанному имени и сигнатуре метода, вызывается этот метод. В противном случае все классы в цепочке базовых классов этого класса проверяются по порядку. Если метод не найден, возникает ошибка.  
  
 `Callvirt` извлекает объект и связанные аргументы из стека вычислений перед вызовом метода. Если метод имеет возвращаемое значение, он помещается в стек после завершения метода. На стороне вызываемого метода доступ к параметру `obj` осуществляется в качестве аргумента 0, `arg1` в качестве аргумента 1 и т. д.  
  
 Аргументы помещаются в стек в порядке слева направо. То есть первый аргумент выводится и помещается в стек, затем второй аргумент — третий, пока все необходимые аргументы не помещаются в стек в убывающем порядке. Ссылка на экземпляр `obj` (всегда требуется для `callvirt`) должна быть передана перед любыми видимыми пользователем аргументами. Сигнатура (переданная в маркере метаданных) не должна содержать запись в списке параметров для этого указателя.  
  
 Обратите внимание, что виртуальный метод также можно вызвать с помощью инструкции <xref:System.Reflection.Emit.OpCodes.Call>.  
  
 <xref:System.MissingMethodException> возникает, если нестатический метод с указанным именем и подписью не удалось найти в классе, связанном с `obj` или с любым из его базовых классов. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 если obj имеет значение null, возникает исключение <xref:System.NullReferenceException>.  
  
 <xref:System.Security.SecurityException> возникает, если система безопасности не предоставляет вызывающему объекту доступ к вызываемому методу. Проверка безопасности может произойти, когда CIL преобразуется в машинный код, а не во время выполнения.  
  
> [!NOTE]
>  При вызове методов типа System. Object для типов значений рекомендуется использовать префикс `constrained` с инструкцией `callvirt`. Это избавляет от необходимости создавать разные IL в зависимости от того, переопределяет ли тип значения метод, избегая возможной проблемы управления версиями. Рекомендуется использовать префикс `constrained` при вызове методов интерфейса для типов значений, так как метод типа значения, реализующий метод интерфейса, можно изменить с помощью `MethodImpl`. Эти проблемы более подробно описаны в коде операции <xref:System.Reflection.Emit.OpCodes.Constrained>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `callvirt`:  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
-   ILGenerator. Емиткалл (код операции, MethodInfo, тип [])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Предпринимает попытку привести объект, передаваемый по ссылке, к указанному классу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|74 < `T` >|касткласс `class`|Приводит объект к новому объекту типа `class`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека; Объект, на который указывает ссылка, приводится к указанному `class`.  
  
3.  В случае успеха новая ссылка на объект помещается в стек.  
  
 Инструкция `castclass` пытается привести ссылку на объект (Type `O`) на вершине стека к указанному классу. Новый класс задается маркером метаданных, указывающим нужный класс. Если класс объекта в верхней части стека не реализует новый класс (предполагая, что новый класс является интерфейсом) и не является производным классом нового класса, возникает исключение <xref:System.InvalidCastException>. Если ссылка на объект является пустой ссылкой, `castclass` завершается и возвращает новый объект как пустую ссылку.  
  
 если obj не может быть приведен к классу, возникает исключение <xref:System.InvalidCastException>.  
  
 Если класс не найден, возникает исключение <xref:System.TypeLoadException>. Обычно это обнаруживается при преобразовании инструкции MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `castclass`:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения. Если они равны, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 01|цек|Отправляет 1, если `value1` равно `value2`; в противном случае отправляет 0.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` сравнивается с `value2`.  
  
4.  Если `value1` равно `value2`, 1 помещается в стек; в противном случае в стек помещается значение 0.  
  
 Инструкция `ceq` сравнивает `value1` и `value2`. Если `value1` равно `value2`, то в стек помещается 1 (типа `int32`). В противном случае в стек помещается значение 0 (типа `int32`).  
  
 Для числа с плавающей запятой `ceq` возвращает 0, если числа не упорядочены (или оба имеют значение NaN). Бесконечные значения равны самому себе.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ceq`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения. Если первое значение больше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 02|кгт|Отправляет 1, если `value1` больше `value2`; в противном случае отправляет 0.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `cgt` тесты, если `value1` больше, чем `value2`.  
  
4.  Если `value1` больше `value2`, 1 помещается в стек; в противном случае в стек помещается значение 0.  
  
 Инструкция `cgt` сравнивает `value1` и `value2`. Если `value1` строго больше `value2`, то в стек помещается значение `int32`, равное 1. В противном случае в стек помещается значение `int32`, равное 0.  
  
-   Для чисел с плавающей запятой `cgt` возвращает 0, если числа не упорядочены (то есть если один или оба аргумента имеют значение NaN).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `cgt`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения без знака или два неупорядоченных значения. Если первое значение больше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 03|КГТ. un|Отправляет 1, если `value1` больше `value2`; в противном случае push-уведомления 0 (неподписанные значения).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `cgt.un` тесты, если `value1` больше, чем `value2`.  
  
4.  Если `value1` больше `value2`, 1 помещается в стек; в противном случае в стек помещается значение 0.  
  
 Значение `int32`, равное 1, помещается в стек, если любой из следующих `true`:  
  
 Для чисел с плавающей запятой `value1` не упорядочивается по отношению к `value2`.  
  
 Для целочисленных значений `value1` строго больше `value2`, если они считаются неподписанными числами.  
  
 В противном случае в стек помещается значение `int32`, равное 0.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `cgt.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Создает исключение <see cref="T:System.ArithmeticException" />, если значение не является конечным числом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|C3|ккфините|Вызовите <xref:System.ArithmeticException>, если значение не является конечным числом.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек. 
  
2.  `value` извлекается из стека и выполняется инструкция `ckfinite`.  
  
3.  `value` помещается обратно в стек, если исключение не создается.  
  
 @No__t-0 вызывает <xref:System.ArithmeticException>, если `value` (число с плавающей запятой) является либо значением "не число" (NaN), либо значением `+-` бесконечности. `Ckfinite` оставляет значение в стеке, если исключение не создается. Выполнение не указано, если `value` не является числом с плавающей запятой.  
  
 <xref:System.ArithmeticException> возникает, если `value` не является нормальным числом.  
  
 Обратите внимание, что специальное исключение или производный класс <xref:System.ArithmeticException> может быть более подходящим, передавая неверное значение обработчику исключений.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ckfinite`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения. Если первое значение меньше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 04|чилийскому|Отправляет 1, если `value1` меньше `value2`; в противном случае отправляет 0.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности: 

1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `clt` тесты, если `value1` меньше `value2`.  
  
4.  Если `value1` меньше `value2`, 1 помещается в стек; в противном случае в стек помещается значение 0.  
  
 Инструкция `clt` сравнивает `value1` и `value2`. Если `value1` строго меньше `value2`, то в стек помещается значение `int32`, равное 1. В противном случае в стек помещается значение `int32`, равное 0.  
  
-   Для чисел с плавающей запятой `clt` возвращает 0, если числа не упорядочены (то есть если один или оба аргумента имеют значение NaN).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `clt`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сравнивает два значения без знака или два неупорядоченных значения <paramref name="value1" /> и <paramref name="value2" />. Если значение <paramref name="value1" /> меньше значения <paramref name="value2" />, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 05|средство регистрации звонков. un|Отправляет 1, если `value1` меньше `value2`; в противном случае push-уведомления 0 (неподписанные значения).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `clt.un` тесты, если `value1` меньше `value2`.  
  
4.  Если `value1` меньше `value2`, 1 помещается в стек; в противном случае в стек помещается значение 0.  
  
 Инструкция `clt.un` сравнивает `value1` и `value2`. Значение `int32`, равное 1, помещается в стек, если выполняется одно из следующих условий.  
  
-   `value1` строго меньше `value2` (как для `clt`).  
  
-   Для чисел с плавающей запятой `value1` не упорядочивается по отношению к `value2`.  
  
-   Для целочисленных значений `value1` строго меньше `value2`, если считаться числами без знака.  
  
 В противном случае в стек помещается значение `int32`, равное 0.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `clt.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ограничивает тип, для которого был вызван виртуальный метод.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 16 < `T` @ NO__T-1|ограниченного. `thisType`|Вызов виртуального метода для типа, ограниченного типом `T`.|  
  
 Префикс `constrained` разрешен только для инструкции `callvirt`.  
  
 В этой точке состояние стека MSIL должно быть следующим:  
  
1.  Управляемый указатель, `ptr`, помещается в стек. Тип `ptr` должен быть управляемым указателем (`&`) до `thisType`. Обратите внимание, что это отличается от случая непрефиксной инструкции `callvirt`, которая принимает ссылку на `thisType`.  
  
2.  Аргументы метода @no__t от-0 до `argN` помещаются в стек, так же как и в случае непрефиксной инструкции `callvirt`.  
  
 Префикс `constrained` позволяет делать инструкции `callvirt` единообразно независимо от того, является ли `thisType` типом значения или ссылочным типом.  
  
 Если инструкция `callvirt` `method` предваряется `constrained` `thisType`, инструкция выполняется следующим образом:  
  
-   Если `thisType` является ссылочным типом (в отличие от типа значения), `ptr` удаляется из ссылок и передается как указатель this на `callvirt` из `method`.  
  
-   Если `thisType` является типом значения и `thisType` реализует `method`, то `ptr` передается без изменений в качестве указателя this на `call` `method` для реализации `method` с `thisType`.  
  
-   Если `thisType` является типом значения, а `thisType` не реализует `method`, то `ptr` отменяется, упаковывается и передается как указатель this в инструкцию `callvirt` `method`.  
  
 Последний случай может возникнуть, только если `method` был определен в <xref:System.Object>, <xref:System.ValueType> или <xref:System.Enum> и не переопределен `thisType`. В этом случае упаковка создает копию исходного объекта. Однако, поскольку ни один из методов <xref:System.Object>, <xref:System.ValueType> и <xref:System.Enum> изменяет состояние объекта, этот факт не может быть обнаружен.  
  
 Префикс `constrained` поддерживает генераторы IL, которые создают универсальный код. Обычно инструкция `callvirt` недопустима для типов значений. Вместо этого необходимо, чтобы компиляторы IL эффективно выполняли преобразование «this», описанное выше во время компиляции, в зависимости от типа `ptr` и вызываемого метода. Однако если `ptr` является универсальным типом, неизвестным во время компиляции, это преобразование невозможно выполнить во время компиляции.  
  
 Код операции `constrained` позволяет компиляторам IL выполнять вызов виртуальной функции единообразно независимо от того, является ли `ptr` типом значения или ссылочным типом. Хотя он предназначен для случая, когда `thisType` является переменной универсального типа, префикс `constrained` также работает для неуниверсальных типов и может уменьшить сложность создания виртуальных вызовов в языках, которые скрывают различие между типами значений и ссылками. типов.  
  
 Использование префикса `constrained` также позволяет избежать потенциальных проблем с управлением версиями с типами значений. Если префикс `constrained` не используется, должен выдаваться другой IL в зависимости от того, переопределяет ли тип значения метод System. Object. Например, если тип значения `V` переопределяет метод Object. ToString (), то создается инструкция `call` `V.ToString()`. в противном случае выдается инструкция `box` и инструкция `callvirt` `Object.ToString()`. Проблема управления версиями может возникнуть в первом случае, если переопределение позже удаляется, и в последнем случае, если переопределение добавляется позже.  
  
 Префикс `constrained` также можно использовать для вызова методов интерфейса для типов значений, так как метод типа значения, реализующий метод интерфейса, можно изменить с помощью `MethodImpl`. Если префикс `constrained` не используется, компилятор принудительно выбирает, к какому из методов типа значения следует выполнить привязку во время компиляции. Использование префикса `constrained` позволяет выполнить привязку MSIL к методу, реализующему метод интерфейса, во время выполнения, а не во время компиляции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `constrained`:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D3|Кредит i|Преобразует в `native int`, отправляя `native int` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.i` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32` точность может быть потеряна. Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.i`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="int8" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|67|с кредитом. i1|Преобразует в `int8`, отправляя `int32` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.i1` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32` точность может быть потеряна. Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.i1`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="int16" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|68|Кредитный I2|Преобразует в `int16`, отправляя `int32` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.i2` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32` точность может быть потеряна. Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.i2`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|69|с просчетом. i4|Преобразует в `int32`, отправляя `int32` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.i4` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32` точность может быть потеряна. Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.i4`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6A|заменяющий i8|Преобразует в `int64`, отправляя `int64` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.i8` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32` точность может быть потеряна. Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.i8`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="native int" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D4|ovf. i|Преобразует в `native int` (в стеке как `native int`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.i` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="native int" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8A|проovf. i. un|Преобразует значение без знака в `native int` (в стеке как `native int`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.i.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int8" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B3|ovf. i1|Преобразование в `int8` (в стеке как `int32`) и вызовет исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.i1` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i1`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int8" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|82|ovf. i1. un|Преобразует значение без знака в `int8` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.i1.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i1.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int16" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B5|ovf. i2|Преобразование в `int16` (в стеке как `int32`) и вызовет исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.i2` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i2`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int16" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|83|ovf. i2. un|Преобразует значение без знака в `int16` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.i2.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i2.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int32" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B7|ovf. i4|Преобразование в `int32` (в стеке как `int32`) и вызовет исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.i4` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i4`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int32" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|84|ovf. i4. un|Преобразует значение без знака в `int32` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.i4.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i4.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int64" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B9|ovf. i8|Преобразование в `int64` (в стеке как `int64`) и вызовет исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.i8` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i8`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="int64" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|85|ovf. i8. un|Преобразует значение без знака в `int64` (в стеке как `int64`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.i8.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i8.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned native int" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D5|ovf. u|Преобразование в `unsigned native int` (в стеке как `native int`) и вызовет исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.u` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned native int" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8B|ovf. u. un|Преобразует значение UN без знака в `unsigned native int` (в стеке как `native int`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.u.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.uvf.u.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="unsigned int8" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B4|ovf. U1|Преобразование в `unsigned int8` (в стеке как `int32`) и вызовет исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.u1` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u1`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int8" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|86|ovf. U1. un|Преобразует значение без знака в `unsigned int8` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.u1.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u1.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в значение <see langword="unsigned int16" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B6|ovf. U2|Преобразование в `unsigned int16` (в стеке как `int32`) и вызовет исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.u2` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u2`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int16" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|87|проovf. U2. un|Преобразует значение без знака в `unsigned int16` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.u2.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u2.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|B8|ovf. U4|Преобразование в `unsigned int32` (в стеке как `int32`) и вызовет исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.u4` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u4`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|88|ovf. U4. un|Преобразует значение без знака в `unsigned int32` (в стеке как `int32`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.u4.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u4.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned int64" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|БИЗНЕС|ovf. u8|Преобразование в `unsigned int64` (в стеке как `int64`) и вызовет исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.u8` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u8`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int64" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|89|ovf. u8. un|Преобразует значение без знака в `unsigned int64` (в стеке как `int64`) и создает исключение в случае переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования. Если возникает переполнение, возникает исключение.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.ovf.u8.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека. Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.  
  
 Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля. Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u8.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразование целочисленного значения без знака на вершине стека вычислений в <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|76|Рассчет. r. un|Преобразует целое число без знака в число с плавающей запятой, отправляя `F` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.r.un` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32` точность может быть потеряна. Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемый `result` не определен. Операция `conv.r.un` принимает целое число из стека, интерпретирует его как неподписанное и заменяет его на число с плавающей запятой для представления целого числа: значение `float32`, если это достаточно, чтобы представить целое число без потери точности, или, в противном случае `float64`.  
  
 При использовании этого поля исключения никогда не возникают.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.r.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6B|с кредитом. R4|Преобразует в `float32`, отправляя `F` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.r4` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32` точность может быть потеряна. Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.r4`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в тип <see langword="float64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6C|с кредитом. R8|Преобразует в `float64`, отправляя `F` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.r8` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32` точность может быть потеряна. Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.r8`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned native int" />, а затем расширяет его до <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|E0|Кредит u|Преобразует в `unsigned native int`, отправляя `native int` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.u` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32` точность может быть потеряна. Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.u`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int8" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D2|с кредитом. U1|Преобразует в `int8`, отправляя `int32` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.u1` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32` точность может быть потеряна. Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.u1`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int16" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D1|Кредитный. U2|Преобразует в `int16`, отправляя `int32` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.u2` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32` точность может быть потеряна. Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.u2`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int32" />, а затем расширяет его до <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6D|U4|Преобразует в `unsigned int32`, отправляя `int32` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.u4` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32` точность может быть потеряна. Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.u4`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int64" />, а затем расширяет его до <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|6E|U8|Преобразует в `int64`, отправляя `int64` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.  
  
3.  Если преобразование прошло успешно, полученное значение помещается в стек.  
  
 Код операции `conv.u8` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека. Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`). Значения с плавающей запятой преобразуются в тип `F`.  
  
 Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля. При преобразовании из `float64` в `float32` точность может быть потеряна. Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным). Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются. Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.  
  
 Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.  
  
 При использовании этого поля исключения никогда не возникают. Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.u8`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует заданное число байт из исходного адреса в конечный.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|Копирование данных из одного блока памяти в другой.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес назначения помещается в стек.  
  
2.  Исходный адрес помещается в стек.  
  
3.  Число байтов для копирования помещается в стек.  
  
4.  Число байтов, исходный адрес и адрес назначения извлекаются из стека; указанное число байтов копируется из исходного адреса в конечный адрес.  
  
 Инструкция `cpblk` копирует число (тип `unsigned int32`) байтов с исходного адреса (типа `*`, `native int` или `&`) в адрес назначения (типа `*`, `native int` или `&`). Поведение `cpblk` не указано, если исходная и Целевая области перекрываются.  
  
 `cpblk` предполагает, что исходные и целевые адреса выровнены по естественному размеру компьютера. Инструкция `cpblk` может быть непосредственно перед инструкцией `unaligned.<prefix>`, чтобы указать, что источник или назначение не совпадают.  
  
 Операция `cpblk` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.  
  
 При обнаружении недопустимого адреса может возникнуть исключение <xref:System.NullReferenceException>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `cpblk`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует тип значения по адресу объекта (с типом <see langword="&amp;" />, <see langword="*" /> или <see langword="native int" />) и помещает его по адресу конечного объекта (с типом <see langword="&amp;" />, <see langword="*" /> или <see langword="native int" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|70 < `T` >|кпобж `classTok`|Копирует тип значения из исходного объекта в целевой объект.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на целевой объект помещается в стек.  
  
2.  Ссылка на исходный объект помещается в стек.  
  
3.  Две ссылки на объекты извлекаются из стека; Тип значения по адресу исходного объекта копируется на адрес целевого объекта.  
  
 Поведение `cpobj` не указано, если исходные и целевые ссылки на объекты не являются указателями на экземпляры класса, представленного токеном класса `classTok` (a `typeref` или `typedef`) или если `classTok` не представляет тип значения.  
  
 При обнаружении недопустимого адреса может возникнуть исключение <xref:System.NullReferenceException>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `cpobj`:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно значение на другое и помещает результат в стек вычислений как число с плавающей запятой (с типом <see langword="F" />) или как частное (с типом <see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5B|div|Делит два значения, чтобы вернуть результат частного или с плавающей точкой.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` делится на `value2`.  
  
4.  Результат помещается в стек.  
  
 `result` @ no__t-1 @ no__t-2 div value2 удовлетворяет следующим условиям:  
  
 &#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, и:  
  
 Sign (`result`) = +, если знак (`value1`) = Sign (`value2`) или-, if знак (`value1`) ~ = Sign (`value2`)  
  
 Инструкция `div` вычислит результат и помещает его в стек.  
  
 Деление целых чисел усекается до нуля.  
  
 Деление конечного числа на ноль приводит к правильному бесконечному значению со знаком.  
  
 Деление нуля на ноль или бесконечность по бесконечности приводит к получению значения NaN (нечисловое). Любое число, деленное на бесконечность, приведет к нулевому значению.  
  
 Целочисленные операции создают исключение <xref:System.ArithmeticException>, если результат не может быть представлен типом результата. Это может произойти, если `value1` является максимальным отрицательным значением, а `value2` равно-1.  
  
 Целочисленные операции создают исключение <xref:System.DivideByZeroException>, если `value2` равно нулю.  
  
 Обратите внимание, что на платформах на базе процессоров Intel при вычислении (minint div-1) создается <xref:System.OverflowException>. Операции с плавающей запятой никогда не создают исключение (они создают значений NaN или бесконечность).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `div`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно целочисленное значение без знака на другое и помещает результат (<see langword="int32" />) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5C|Div. un|Делит два значения без знака, возвращая частное.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` делится на `value2`.  
  
4.  Результат помещается в стек.  
  
 Инструкция `div.un` делит `value1` на `value2`, как целые числа без знака, и помещает `result` в стек.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `div.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует текущее верхнее значение в стеке вычислений и помещает копию в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|25|DUP|Дублирует значение в верхней части стека.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека для дублирования.  
  
3.  `value` помещается обратно в стек.  
  
4.  Повторяющееся значение помещается в стек.  
  
 Инструкция `dup` дублирует верхний элемент стека и оставляет два одинаковых значения на вершине.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `dup`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление из предложения <see langword="filter" /> исключения обратно в обработчик исключений CLI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 11|Команда endfilter|Завершающее предложение фильтра обработки исключений SEH.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека; `endfilter` выполняется, и управление передается обработчику исключений.  
  
 `Value` (который должен иметь тип `int32` и является одним из определенного набора значений) возвращается из предложения Filter. Он должен быть одним из следующих:  
  
-   `exception_continue_search` (`value` = 0), чтобы продолжить поиск обработчика исключений  
  
-   `exception_execute_handler` (`value` = 1), чтобы начать второй этап обработки исключений, в котором блоки finally выполняются до тех пор, пока не будет найден обработчик, связанный с этим предложением фильтра. После обнаружения выполняется обработчик.  
  
 Другие целочисленные значения приведут к неопределенным результатам.  
  
 Точка входа фильтра, как показано в таблице исключений метода, должна быть первой инструкцией в блоке кода фильтра. Инструкция `endfilter` должна быть последней инструкцией в блоке кода фильтра (следовательно, для одного блока фильтра может быть только один `endfilter`). После выполнения инструкции `endfilter` Управление логически передается обратно механизму обработки исключений CLI.  
  
 Управление не может быть передано в блок фильтра, за исключением механизма исключения. Управление не может быть передано из блока фильтра, за исключением использования инструкции `throw` или выполнения последней инструкции `endfilter`. Нельзя внедрить блок `try` в блок `filter`. Если в блоке `filter` возникает исключение, оно перехватывается и возвращается значение 0 (`exception_continue_search`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `endfilter`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Передает управление из предложения <see langword="fault" /> или <see langword="finally" /> блока исключения обратно обработчику исключений CLI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DC|Команда endfinally<br /><br /> ендфаулт|Завершает предложение `finally` или `fault` блока исключения.|  
  
 Для этой инструкции нет поведений перехода стека.  
  
 `Endfinally` и `endfault` обозначают конец предложения `finally` или `fault`, чтобы очистка стека могла продолжаться до вызова обработчика исключений. Инструкция `endfinally` или `endfault` передает управление механизму исключения CLI. Затем механизм выполняет поиск следующего предложения `finally` в цепочке, если защищенный блок был завершен с помощью инструкции leave. Если защищенный блок завершился с исключением, интерфейс командной строки выполнит поиск следующего `finally` или `fault` или введите обработчик исключений, выбранный во время первого прохода обработки исключений.  
  
 Инструкция `endfinally` может отображаться только в блоке `finally`. В отличие от инструкции `endfilter`, нет необходимости в конце блока с инструкцией `endfinally`, и в блоке может быть столько инструкций `endfinally`, сколько необходимо. Эти же ограничения применяются к инструкциям `endfault` и блоку `fault`.  
  
 Элемент управления не может быть передан в блок `finally` (или `fault`), за исключением механизма исключения. Элемент управления не может быть передан из блока `finally` (или `fault`), за исключением использования инструкции `throw` или выполнения инструкции `endfinally` (или `endfault`). В частности, нельзя попадать в блок `finally` (или `fault`) или выполнить инструкцию <xref:System.Reflection.Emit.OpCodes.Ret> или <xref:System.Reflection.Emit.OpCodes.Leave> в блоке `finally` (или `fault`).  
  
 Обратите внимание, что инструкции `endfault` и `endfinally` являются псевдонимами, они соответствуют одному коду операции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `endfinally` (`endfault`), а также метод `ILGenerator` <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.  
  
-   ILGenerator. Emit (код операции)  
  
-   ILGenerator. Ендексцептионблокк ()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Инициализирует блок памяти с определенным адресом, присваивая его начальному значению с заданным размером.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 18|initblk|Установите для каждого расположения в блоке памяти заданное значение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Начальный адрес помещается в стек.  
  
2.  Значение инициализации помещается в стек.  
  
3.  Число байтов для инициализации помещается в стек.  
  
4.  Число байтов, значение инициализации и начальный адрес извлекаются из стека, а инициализация выполняется в соответствии с их значениями.  
  
 Инструкция `initblk` задает число (`unsigned int32`) байтов, начиная с указанного адреса (типа `native int`, `&` или `*`) к значению инициализации (типа `unsigned int8`). `initblk` предполагает, что начальный адрес соответствует естественному размеру компьютера.  
  
 Операция `initblk` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.  
  
 При обнаружении недопустимого адреса может возникнуть исключение <xref:System.NullReferenceException>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `initblk`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Инициализирует каждое поле типа значения с определенным адресом пустой ссылкой или значением 0 соответствующего простого типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 15 < `T` @ NO__T-1|`initobj` `typeTok`|Инициализирует тип значения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес типа значения для инициализации помещается в стек.  
  
2.  Адрес извлекается из стека; Тип значения по указанному адресу инициализируется как тип `typeTok`.  
  
 Инструкция `initobj` инициализирует каждое поле типа значения, заданное отправленным адресом (типа `native int`, `&` или `*`), на пустую ссылку или 0 соответствующего типа-примитива. После вызова этого метода экземпляр готов к вызову метода-конструктора. Если `typeTok` является ссылочным типом, эта инструкция имеет тот же результат, что и `ldnull`, за которым следует `stind.ref`.  
  
 В отличие от <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` не вызывает метод конструктора. `Initobj` предназначен для инициализации типов значений, тогда как `newobj` используется для выделения и инициализации объектов.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `initobj`:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Проверяет, является ли ссылка на объект (с типом <see langword="O" />) экземпляром определенного класса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|75 < `T` >|исинст `class`|Проверяет, является ли ссылка на объект экземпляром `class`, возвращая либо пустую ссылку, либо экземпляр этого класса или интерфейса.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и проверяется на наличие экземпляра класса, переданного `class`.  
  
3.  Результат (ссылка на объект или пустая ссылка) помещается в стек.  
  
 `Class` — это токен метаданных, указывающий нужный класс. Если класс объекта в верхней части стека реализует `class` (если `class` является интерфейсом) или является производным классом `class` (если `class` является обычным классом), то он приводится к типу `class`, а результат помещается в стек. , как будто было вызвано <xref:System.Reflection.Emit.OpCodes.Castclass>. В противном случае в стек помещается пустая ссылка. Если ссылка на объект является пустой ссылкой, то `isinst` аналогичным образом возвращает пустую ссылку.  
  
 Если класс не найден, возникает исключение <xref:System.TypeLoadException>. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `isinst`:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Прекращает выполнение текущего метода и переходит к заданному методу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|27 < `T` >|Переход `method`|Завершение работы текущего метода и переход к указанному методу.|  
  
 Для этой инструкции нет поведений перехода стека.  
  
 Инструкция `jmp` (переход) передает управление методу, указанному `method`, который является маркером метаданных для ссылки на метод. Текущие аргументы передаются в целевой метод.  
  
 При выполнении этой инструкции стек вычислений должен быть пустым. Соглашение о вызовах, число и тип аргументов в адресе назначения должны соответствовать требованиям текущего метода.  
  
 Инструкция `jmp` не может использоваться для передачи управления из блока `try`, `filter`, `catch` или `finally`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `jmp`:  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент (на который ссылается указанное значение индекса) в стек.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< FE 09 `unsigned int16` @ NO__T-1|лдарг `index`|Загрузка аргумента с `index` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента в `index` помещается в стек.  
  
 Инструкция `ldarg` помещает аргумент, индексируемый по `index`, где аргументы индексируются от 0 до назад в стеке вычислений. Инструкцию `ldarg` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Для процедур, принимающих список аргументов переменной длины, инструкция `ldarg` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры (Дополнительные сведения см. в инструкции <xref:System.Reflection.Emit.OpCodes.Arglist>).  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg`:  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 0 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|02|лдарг. 0|Загрузить аргумент 0 в стек|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента с индексом 0 помещается в стек.  
  
 Инструкция `ldarg.0` является эффективной кодировкой для загрузки значения аргумента по индексу 0.  
  
 Инструкция `ldarg.0` помещает в стек вычислений аргумент с индексом 0. Инструкцию `ldarg.0` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg.0`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 1 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|03|лдарг. 1|Загрузка аргумента 1 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента с индексом 1 помещается в стек.  
  
 Инструкция `ldarg.1` является эффективной кодировкой для загрузки значения аргумента с индексом 1.  
  
 Инструкция `ldarg.1` помещает в стек вычислений аргумент с индексом 1. Инструкцию `ldarg.1` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg.1`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 2 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|04|лдарг. 2|Загрузка аргумента 2 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента с индексом 2 помещается в стек.  
  
 Инструкция `ldarg.2` является эффективной кодировкой для загрузки значения аргумента по индексу 2.  
  
 Инструкция `ldarg.2` помещает аргумент с индексом 2 в стек вычислений. Инструкцию `ldarg.2` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg.2`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент с индексом 3 в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|05|лдарг. 3|Загрузка аргумента 3 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента с индексом 3 помещается в стек.  
  
 Инструкция `ldarg.3` является эффективной кодировкой для загрузки значения аргумента с индексом 3.  
  
 Инструкция `ldarg.3` помещает аргумент с индексом 3 в стек вычислений. Инструкцию `ldarg.3` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg.3`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает аргумент (на который ссылается указанное короткое значение индекса) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` @ NO__T-1|лдарг. s `index`|Загрузка аргумента с `index` в стек, краткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение аргумента в `index` помещается в стек.  
  
 Инструкция `ldarg.s` — это эффективная кодировка для загрузки аргументов, индексируемых от 4 до 255.  
  
 Инструкция `ldarg.s` помещает аргумент, индексируемый по `index`, где аргументы индексируются от 0 до назад в стеке вычислений. Инструкцию `ldarg.s` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента. Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.  
  
 Для процедур, принимающих список аргументов переменной длины, инструкция `ldarg.s` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры (Дополнительные сведения см. в инструкции <xref:System.Reflection.Emit.OpCodes.Arglist>).  
  
 Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg.s`:  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает адрес аргумента в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 0A < `unsigned int16` @ NO__T-1|лдарга `index`|Получение адреса аргумента, индексированного по `index`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес `addr` аргумента, индексируемого `index`, помещается в стек.  
  
 Инструкция `ldarga` извлекает адрес (типа `*`) аргумента, индексируемого `index`, где аргументы индексируются от 0 до. Адрес `addr` всегда согласуется с естественной границей на целевом компьютере.  
  
 Для процедур, принимающих список аргументов переменной длины, инструкция `ldarga` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры.  
  
 `ldarga` используется для передачи параметров по ссылке. В других случаях следует использовать <xref:System.Reflection.Emit.OpCodes.Ldarg> и <xref:System.Reflection.Emit.OpCodes.Starg>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarga`:  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает адрес аргумента (короткая форма) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` @ NO__T-1|лдарга. s `index`|Получение адреса аргумента, индексированного по `index`, короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес `addr` аргумента, индексируемого `index`, помещается в стек.  
  
 `ldarga.s` (краткая форма `ldarga`) следует использовать для номеров аргументов от 0 до 255 и является более эффективной кодировкой.  
  
 Инструкция `ldarga.s` извлекает адрес (типа @ no__t-1) аргумента, индексируемого по `index`, где аргументы индексируются от 0 до. Адрес `addr` всегда согласуется с естественной границей на целевом компьютере.  
  
 Для процедур, принимающих список аргументов переменной длины, инструкция `ldarga.s` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры.  
  
 `ldarga.s` используется для передачи параметров по ссылке. В других случаях следует использовать <xref:System.Reflection.Emit.OpCodes.Ldarg_S> и <xref:System.Reflection.Emit.OpCodes.Starg_S>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarga.s`:  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="int32" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|20 < `int32` >|LDC. i4 `num`|Помещает значение `num` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение `num` помещается в стек.  
  
 Обратите внимание, что существуют специальные короткие (и, следовательно, более эффективные) кодировки для целых чисел от-128 до 127 и особенно короткие кодировки для-1 – 8. Все короткие кодировки помещают в стек 4-байтовые целые числа. Более длинные кодировки используются для 8-байтовых целых чисел, 4 и 8 байт с плавающей запятой, а также для 4 байтовых значений, которые не помещаются в короткие формы. Существует три способа отправки 8-байтовой целочисленной константы в стек.  
  
 1. Используйте инструкцию <xref:System.Reflection.Emit.OpCodes.Ldc_I8> для констант, которые должны быть выражены более чем на 32 бит.  
  
 2. Используйте инструкцию <xref:System.Reflection.Emit.OpCodes.Ldc_I4>, за которой следует <xref:System.Reflection.Emit.OpCodes.Conv_I8> для констант, требующих от 9 до 32 бит.  
  
 3. Используйте краткую инструкцию Form, за которой следует <xref:System.Reflection.Emit.OpCodes.Conv_I8> для констант, которые могут быть выражены в 8 или меньшем количестве битов.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4`:  
  
-   ILGenerator. Emit (код операции, int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 0 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|16|LDC. i 4.0|Помещает 0 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 0 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целого значения 0. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.0`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 1 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|17|LDC. i 4.1|Помещает 1 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 1 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целого значения 1. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.1`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 2 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|18|LDC. i 4.2|Помещает 2 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 2 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленного значения 2. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.2`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 3 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|19|LDC. i 4.3|Помещает 3 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 3 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленного значения 3. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.3`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 4 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|SR1A|LDC. i 4.4|Передает 4 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 4 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленного значения 4. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.4`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 5 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1B|LDC. i 4.5|Передает 5 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 5 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целого значения 5. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.5`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 6 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1C|LDC. i 4.6|Помещает 6 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 6 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целого значения 6. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.6`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 7 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1D|LDC. i 4.7|Помещает 7 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 7 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленного значения 7. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.7`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение 8 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1E|LDC. i 4.8|Отправляет 8 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение 8 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целочисленного значения 8. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.8`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает целочисленное значение –1 в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|15|LDC. i4. M1|Передает значение 1 в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение-1 помещается в стек.  
  
 Это специальная короткая кодировка для принудительной отправки целого значения-1. Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.m1`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="int8" /> в стек вычислений как <see langword="int32" /> (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|1F < `int8` >|LDC. i4. s `num`|Помещает `num` в стек как `int32`, короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение `num` помещается в стек.  
  
 `ldc.i4.s` является более эффективной кодировкой для отправки целых чисел с-128 по 127 в стек вычислений.  
  
Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `ldc.i4.s`:
  
- <xref:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Byte)?displayProperty=nameWithType>
- <xref:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.SByte)?displayProperty=nameWithType>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="int64" /> в стек вычислений как <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|21 < `int64` >|LDC. i8 `num`|Помещает `num` в стек как `int64`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение `num` помещается в стек.  
  
 Эта кодировка помещает значение `int64` в стек.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i8`:  
  
-   ILGenerator. Emit (код операции, длинный)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="float32" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|22 < `float32` >|LDC. R4 `num`|Помещает `num` в стек как `F`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение `num` помещается в стек.  
  
 Эта кодировка помещает значение `float32` в стек.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.r4`:  
  
-   ILGenerator. Emit (код операции, одиночный)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает переданное значение с типом <see langword="float64" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|23 < `float64` >|LDC. R8 `num`|Помещает `num` в стек как `F`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение `num` помещается в стек.  
  
 Эта кодировка помещает значение `float64` в стек.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.r8`:  
  
-   ILGenerator. Emit (код операции, Double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент с заданным индексом массива на вершину стека вычислений в качестве типа, указанного в инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A3 < `T` >|лделем `typeTok`|Загружает элемент с `index` на вершину стека как тип `typeTok`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами, поэтому они представлены значением типа `O`.  
  
 Тип возвращаемого значения задается токеном `typeTok` в инструкции.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем верхняя граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem`:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, имеющий тип <see langword="native int" />, на вершину стека вычислений как <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|97|лделем. i|Загружает элемент с типом `native int` в `index` на вершину стека как `native int`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.i` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i` равно `native int`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.i`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int8" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|90|лделем. i1|Загружает элемент с типом `int8` в `index` на вершину стека как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.i1` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i1` равно `int8`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.i1`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int16" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|92|лделем. i2|Загружает элемент с типом `int16` в `index` на вершину стека как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.i2` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i2` равно `int16`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.i2`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int32" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|94|лделем. i4|Загружает элемент с типом `int32` в `index` на вершину стека как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.i4` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i4` равно `int32`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.i4`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="int64" /> с заданным индексом массива на вершину стека вычислений как <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|96|лделем. i8|Загружает элемент с типом `int64` в `index` на вершину стека как `int64`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.i8` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.i8` равно `int64`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.i8`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, имеющий тип <see langword="float32" />, на вершину стека вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|98|лделем. R4|Загружает элемент с типом `float32` в `index` на вершину стека как тип `F`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.r4` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.r4` равно `float32`.  
  
 Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.r4`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, имеющий тип <see langword="float64" />, на вершину стека вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|99|лделем. R8|Загружает элемент с типом `float64` в `index` в начало стека как тип `F`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.r8` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.r8` равно `float64`.  
  
 Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.r8`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент массива с заданным индексом, содержащий ссылку на объект, на вершину стека вычислений как <see langword="O" /> (ссылка на объект).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9A|лделем. ref|Загружает элемент со ссылкой на объект в `index` на вершину стека как тип `O`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.ref` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.ref` имеет тип `O` (ссылка на объект).  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.ref`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="unsigned int8" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|91|лделем. U1|Загружает элемент с типом `unsigned int8` в `index` на вершину стека как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.u1` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.u1` равно `int8`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.u1`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="unsigned int16" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|93|лделем. U2|Загружает элемент с типом `unsigned int16` по индексу на вершину стека как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.u2` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.u2` равно `int16`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.u2`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает элемент типа <see langword="unsigned int32" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|95|лделем. U4|Загружает элемент с типом `unsigned int32` по индексу на вершину стека как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.  
  
4.  Значение помещается в стек.  
  
 Инструкция `ldelem.u4` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`.  
  
 Возвращаемое значение для `ldelem.u4` равно `int32`.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> создается, если массив не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.u4`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает адрес элемента массива с заданным индексом на вершину стека вычислений как <see langword="&amp;" /> (управляемый указатель).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8F < `T` >|@no__t ldelema-0|Загружает адрес элемента массива с `index` на вершину стека вычислений как тип `&` (управляемый указатель).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `array` помещается в стек.  
  
2.  Значение индекса `index` помещается в стек.  
  
3.  `index` и `array` извлекаются из стека; выполняется поиск адреса, хранящегося в позиции `index` в `array`.  
  
4.  Адрес помещается в стек.  
  
 @No__t-0 используется для получения адреса объекта по определенному индексу в массиве объектов (типа `class`). Инструкция `ldelema` загружает адрес значения по индексу `index` (тип `native int`) в одномерном массиве с отсчетом от нуля `array` и помещает его в верхнюю часть стека. Массивы являются объектами и поэтому представлены значением типа `O`. Значение должно иметь тип `class`, переданный с инструкцией.  
  
 Возвращаемое значение для `ldelema` является управляемым указателем (тип `&`).  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelema`:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет поиск значения поля в объекте, ссылка на который находится в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld `field`|Помещает значение поля в указанном объекте в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект (или указатель) помещается в стек.  
  
2.  Ссылка на объект (или указатель) извлекается из стека; Найдено значение указанного поля в объекте.  
  
3.  Значение, хранящееся в поле, помещается в стек.  
  
 Инструкция `ldfld` помещает значение поля, расположенного в объекте, в стек. Объект должен находиться в стеке как ссылка на объект (тип `O`), управляемый указатель (тип `&`), неуправляемый указатель (тип `native int`), временный указатель (тип `*`) или экземпляр типа значения. Использование неуправляемого указателя в проверяемом коде не допускается. Поле объекта задается маркером метаданных, который должен ссылаться на элемент поля. Тип возвращаемого значения совпадает с типом, связанным с полем. Поле может быть либо полем экземпляра (в этом случае объект не должен быть пустой ссылкой), либо статическим полем.  
  
 Оператору `ldfld` может предшествовать один или оба префикса <xref:System.Reflection.Emit.OpCodes.Unaligned> и <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.NullReferenceException> создается, если объект имеет значение null, а поле не является статическим.  
  
 <xref:System.MissingFieldException> создается, если указанное поле не найдено в метаданных. Обычно это проверяется при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldfld`:  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ищет адрес поля в объекте, ссылка на который находится в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7C < `T` >|лдфлда `field`|Помещает адрес `field` в указанный объект в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект (или указатель) помещается в стек.  
  
2.  Ссылка на объект (или указатель) извлекается из стека; найден адрес указанного поля в объекте.  
  
3.  Адрес указанного поля помещается в стек.  
  
 Инструкция `ldflda` помещает адрес поля, расположенного в объекте, в стек. Объект должен находиться в стеке как ссылка на объект (тип `O`), управляемый указатель (тип `&`), неуправляемый указатель (тип `native int`), временный указатель (тип `*`) или экземпляр типа значения. Использование неуправляемого указателя в проверяемом коде не допускается. Поле объекта задается маркером метаданных, который должен ссылаться на элемент поля.  
  
 Значение, возвращаемое `ldflda`, является управляемым указателем (тип `&`), если только объект не передается в стек как неуправляемый указатель, в этом случае возвращаемый адрес также является неуправляемым указателем (тип `native int`).  
  
 Оператору `ldflda` может предшествовать один или оба префикса <xref:System.Reflection.Emit.OpCodes.Unaligned> и <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.InvalidOperationException> создается, если объект не находится в домене приложения, из которого осуществляется доступ. Не удается загрузить адрес поля, не находящегося внутри доступного домена приложения.  
  
 <xref:System.NullReferenceException> создается, если объект имеет значение null, а поле не является статическим.  
  
 <xref:System.MissingFieldException> создается, если указанное поле не найдено в метаданных. Обычно это проверяется при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldflda`:  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений неуправляемый указатель (с типом <see langword="native int" />) на машинный код, реализующий заданный метод.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 06 < `T` @ NO__T-1|ldftn `method`|Помещает указатель на метод, на который ссылается `method` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Неуправляемый указатель на конкретный метод помещается в стек.  
  
 Конкретный метод (`method`) можно вызывать с помощью инструкции <xref:System.Reflection.Emit.OpCodes.Calli>, если она ссылается на управляемый метод (или на заглушку, переход от управляемого кода к неуправляемому).  
  
 Возвращаемое значение указывает на машинный код, используя соглашение о вызовах CLR. Этот указатель метода не должен передаваться в неуправляемый машинный код в качестве подпрограммы обратного вызова.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldftn`:  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="native int" /> в стек вычислений как <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4D|ldind. i|Загружает значение `native int` по адресу `addr` в стек как `native int`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.i` выполняет косвенную загрузку значения `native int` из указанного адреса (типа `native int`, `&` или *) в стек как `native int`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.i`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int8" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|46|ldind. i1|Загружает значение `int8` по адресу `addr` в стек как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек. 
  
 Инструкция `ldind.i1` выполняет косвенную загрузку значения `int8` из указанного адреса (типа `native int`, `&` или *) в стек как `int32`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.i1`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int16" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|48|ldind. i2|Загружает значение `int16` по адресу `addr` в стек как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.i2` выполняет косвенную загрузку значения `int16` из указанного адреса (типа `native int`, `&` или *) в стек как `int32`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.i2`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int32" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4A|ldind. i4|Загружает значение `int32` по адресу `addr` в стек как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.i4` выполняет косвенную загрузку значения `int32` из указанного адреса (типа `native int`, `&` или *) в стек как `int32`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.i4`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="int64" /> в стек вычислений как <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4C|ldind. i8|Загружает значение `int64` по адресу `addr` в стек как `int64`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.i8` выполняет косвенную загрузку значения `int64` из указанного адреса (типа `native int`, `&` или *) в стек как `int64`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.i8`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="float32" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4E|ldind. R4|Загружает значение `float32` по адресу `addr` в стек как тип `F`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.r4` выполняет косвенную загрузку значения `float32` из указанного адреса (типа `native int`, `&` или *) в стек как тип `F`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.r4`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="float64" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4F|ldind. R8|Загружает значение `float64` по адресу `addr` в стек как тип `F`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.r8` выполняет косвенную загрузку значения `float64` из указанного адреса (типа `native int`, `&` или *) в стек как `float64`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.r8`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку в стек вычислений ссылки на объект как <see langword="O" /> (ссылка на объект).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|50|ldind. ref|Загружает ссылку на объект по адресу `addr` в стек как тип `O`|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; Ссылка на объект, расположенная по адресу, выбирается.  
  
3.  Извлеченная ссылка помещается в стек.  
  
 Инструкция `ldind.ref` выполняет косвенную загрузку ссылки на объект с указанным адресом (типа `native int`, `&` или *) в стек как тип `O`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.ref`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="unsigned int8" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|47|ldind. U1|Загружает значение `unsigned int8` по адресу `addr` в стек как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.u1` выполняет косвенную загрузку значения `unsigned int8` из указанного адреса (типа @ no__t-2, `&` или *) в стек как `int32`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.u1`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="unsigned int16" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|49|ldind. U2|Загружает значение `unsigned int16` по адресу `addr` в стек как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.u2` выполняет косвенную загрузку значения `unsigned int16` из указанного адреса (типа `native int`, `&` или *) в стек как `int32`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.u2`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет косвенную загрузку значения с типом <see langword="unsigned int32" /> в стек вычислений как <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|4B|ldind. U4|Загружает значение `unsigned int32` по адресу `addr` в стек как `int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Адрес извлекается из стека; извлекается значение, расположенное по адресу.  
  
3.  Полученное значение помещается в стек.  
  
 Инструкция `ldind.u4` выполняет косвенную загрузку значения `unsigned int32` из указанного адреса (типа `native int`, `&` или *) в стек как `int32`.  
  
 Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.  
  
 Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений. Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.  
  
 Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.  
  
 Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер). Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы. Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП. Код, зависящий от порядка байтов, может выполняться не на всех платформах.  
  
 <xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.u4`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений сведения о числе элементов одномерного массива с индексацией от нуля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8E|лдлен|Помещает длину (типа `natural unsigned int`) массива в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект массива помещается в стек.  
  
2.  Ссылка на массив извлекается из стека, а длина вычислена.  
  
3.  Длина помещается в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Длина возвращается как `natural unsigned int`.  
  
 Если ссылка на массив является пустой ссылкой, возникает исключение <xref:System.NullReferenceException>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldlen`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с указанным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 0C < `unsigned int16` @ NO__T-1|требовалась ldloc `index`|Загружает локальную переменную с индексом `index` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной по указанному индексу помещается в стек.  
  
 Инструкция `ldloc` отправляет содержимое номера локальной переменной по переданному индексу в стек вычислений, где локальные переменные нумеруются 0 – назад. Локальные переменные инициализируются значением 0 перед вводом метода только в том случае, если флаг инициализации метода имеет значение true. Возможны локальные переменные 65 535 (2 ^ 16-1) (0 – 65534). Индекс 65 535 является недопустимым, так как вероятные реализации будут использовать 2-байтовое целое число для записи как индекса локального объекта, так и общего числа локальных переменных для данного метода. Если индекс 65535 был сделан допустимым, для записи числа локальных переменных в таком методе потребуется более широкое целое число.  
  
 Инструкции `ldloc.0`, `ldloc.1`, `ldloc.2` и `ldloc.3` обеспечивают эффективную кодировку для доступа к первым четырем локальным переменным.  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. См. раздел I. локальные переменные размером менее 4 байт развернуты до типа `int32` при загрузке в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `ldloc`:  
  
-   ILGenerator. Emit (код операции, LocalBuilder)  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|06|требовалась ldloc. 0|Загружает в стек вычислений локальную переменную с индексом 0.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной в индексе 0 помещается в стек.  
  
 `ldloc.0` является особенно эффективной кодировкой для <xref:System.Reflection.Emit.OpCodes.Ldloc>, что позволяет получить доступ к локальной переменной по индексу 0.  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. Локальные переменные, размер которых меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloc.0`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|07|требовалась ldloc. 1|Загружает в стек вычислений локальную переменную с индексом 1.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной в индексе 1 помещается в стек.  
  
 `ldloc.1` является особенно эффективной кодировкой для <xref:System.Reflection.Emit.OpCodes.Ldloc>, что позволяет получить доступ к локальной переменной по индексу 1.  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. Локальные переменные, размер которых меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloc.1`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|08|требовалась ldloc. 2|Загружает в стек вычислений локальную переменную с индексом 2.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной в индексе 2 помещается в стек.  
  
 `ldloc.2` является особенно эффективной кодировкой для <xref:System.Reflection.Emit.OpCodes.Ldloc>, что позволяет получить доступ к локальной переменной по индексу 2.  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. Локальные переменные, размер которых меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloc.2`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с индексом 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|09|требовалась ldloc. 3|Загружает в стек вычислений локальную переменную с индексом 3.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной в индексе 3 помещается в стек.  
  
 `ldloc.3` является особенно эффективной кодировкой для <xref:System.Reflection.Emit.OpCodes.Ldloc>, что позволяет получить доступ к локальной переменной по индексу 3.  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. Локальные переменные, размер которых меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloc.3`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений локальную переменную с указанным индексом (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|требовалась ldloc. s `index`|Загружает локальную переменную с индексом `index` в стек, короткую форму.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение локальной переменной по указанному индексу помещается в стек.  
  
 Инструкция `ldloc.s` отправляет содержимое номера локальной переменной по переданному индексу в стек вычислений, где локальные переменные нумеруются 0 – назад. Локальные переменные инициализируются значением 0 перед входом в метод, если флаг инициализации метода имеет значение true. В краткой форме имеется 256 (2 ^ 8) локальных переменных (0-255), что является более эффективной кодировкой, чем `ldloc`.  
  
 Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода. См. раздел I. локальные переменные размером менее 4 байт развернуты до типа `int32` при загрузке в стек. Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).  
  
 Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `ldloc.s`:  
  
-   ILGenerator. Emit (код операции, LocalBuilder)  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений адрес локальной переменной с указанным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< FE OD `unsigned int16` @ NO__T-1|лдлока `index`|Загружает адрес локальной переменной с `index` в стек вычислений.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес, хранящийся в локальной переменной по указанному индексу, помещается в стек.  
  
 Инструкция `ldloca` помещает в стек адрес локальной переменной с переданным индексом, где локальные переменные нумеруются 0 – назад. Значение, помещаемое в стек, уже правильно согласовано для использования с такими инструкциями, как <xref:System.Reflection.Emit.OpCodes.Ldind_I> и <xref:System.Reflection.Emit.OpCodes.Stind_I>. Результатом является временный указатель (тип `*`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloca`:  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Загружает в стек вычислений адрес локальной переменной с указанным индексом (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|лдлока. s `index`|Загружает адрес локальной переменной с `index` в стек вычислений, короткая форма.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес, хранящийся в локальной переменной по указанному индексу, помещается в стек.  
  
 Инструкция `ldloca.s` помещает в стек адрес локальной переменной с переданным индексом, где локальные переменные нумеруются 0 – назад. Значение, помещаемое в стек, уже правильно согласовано для использования с такими инструкциями, как <xref:System.Reflection.Emit.OpCodes.Ldind_I> и <xref:System.Reflection.Emit.OpCodes.Stind_I>. Результатом является временный указатель (тип `*`).  
  
 Инструкция `ldloca.s` обеспечивает эффективную кодировку для использования с локальными переменными от 0 до 255.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloca.s`:  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений пустую ссылку (тип <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|14|требовался ldnull|Отправка пустой ссылки на стек|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на пустой объект помещается в стек.  
  
 `ldnull` отправляет в стек пустую ссылку (тип `O`). Используется для инициализации расположений перед заполнением данными или в случае, когда они становятся нерекомендуемыми.  
  
 `ldnull` предоставляет пустую ссылку, которая не зависит от размера.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldnull`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует объект с типом значения, размещенный по указанному адресу, на вершину стека вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|Скопируйте экземпляр типа значения `class` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес объекта типа значения помещается в стек.  
  
2.  Адрес извлекается из стека, и происходит поиск экземпляра по определенному адресу.  
  
3.  Значение объекта, хранящегося в этом адресе, помещается в стек.  
  
 Инструкция `ldobj` используется для передачи типа значения в качестве параметра.  
  
 Инструкция `ldobj` копирует значение, на которое указывает `addrOfValObj` (типа `&`, `*` или `native int`), в верхнюю часть стека. Количество копируемых байтов зависит от размера класса (как указано в параметре `class`). Параметр `class` является маркером метаданных, представляющим тип значения.  
  
 Операция `ldobj` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.  
  
 Если класс не найден, возникает исключение <xref:System.TypeLoadException>. Обычно это обнаруживается при преобразовании инструкции MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldobj`:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений значение статического поля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld `field`|Помещает значение `field` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение конкретного поля помещается в стек.  
  
 Инструкция `ldsfld` помещает значение статического (общего для всех экземпляров класса) поля в стеке. Тип возвращаемого значения связан с переданным маркером метаданных `field`.  
  
 Инструкция `ldsfld` может иметь префикс <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldsfld`:  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений адрес статического поля.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7F < `T` >|требовался ldsflda `field`|Отправка адреса `field` в стеке|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес определенного поля помещается в стек.  
  
 Инструкция `ldsflda` помещает адрес статического поля (общего для всех экземпляров класса) в стеке. Адрес может быть представлен временным указателем (тип `*`), если маркер метаданных `field` ссылается на тип, управляемый памятью. В противном случае он соответствует неуправляемому указателю (тип `native int`). Обратите внимание, что `field` может быть статическим глобальным с назначенным относительным виртуальным адресом (смещение поля от базового адреса, в котором его содержащий PE-файл загружается в память), где память является неуправляемой.  
  
 Инструкция `ldsflda` может иметь префикс <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 Если поле не найдено в метаданных, возникает исключение <xref:System.MissingFieldException>. Обычно это проверяется при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldsflda`:  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек ссылку на новый объект, представляющий строковой литерал, хранящийся в метаданных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|72 < `T` >|лдстр `mdToken`|Отправляет строковый объект для токена строки метаданных `mdToken`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект String помещается в стек.  
  
 Инструкция `ldstr` помещает ссылку на объект (тип `O`) в новый строковый объект, представляющий конкретный строковый литерал, хранящийся в метаданных. Инструкция `ldstr` выделяет необходимый объем памяти и выполняет любое преобразование формата, необходимое для преобразования строкового литерала из формы, используемой в файле, в формат строки, необходимый во время выполнения.  
  
 Common Language Infrastructure (CLI) гарантирует, что результат двух инструкций `ldstr`, ссылающихся на два токена метаданных с одинаковой последовательностью символов, возвращает один и тот же строковый объект (процесс, известный как "интернирование строк").  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldstr`:  
  
-   ILGenerator. Emit (код операции, строка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует токен метаданных в его представление времени выполнения, а затем помещает в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< D0 `T` @ NO__T-1|коды операций Ldtoken `token`|Преобразует маркер метаданных в представление среды выполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Переданный токен преобразуется в `RuntimeHandle` и помещается в стек.  
  
 Инструкция `ldtoken` помещает `RuntimeHandle` для указанного маркера метаданных. @No__t-0 может быть `fieldref/fielddef`, a `methodref/methoddef` или `typeref/typedef`.  
  
 Значение, помещаемое в стек, можно использовать в вызовах методов `Reflection` в библиотеке системных классов.  
  
 Сведения о дескрипторах среды выполнения см. в следующих классах: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle> и <xref:System.RuntimeMethodHandle>.  
  
 Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `ldtoken`:  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений неуправляемый указатель (с типом <see langword="native int" />) на машинный код, реализующий виртуальный метод, связанный с заданным объектом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 07 < `T` @ NO__T-1|ldvirtftn `method`|Помещает указатель на виртуальный метод объекта `method` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека, а адрес точки входа в метод (как указано маркером метаданных `method`) ищется.  
  
3.  Указатель на `method` помещается в стек.  
  
 Результирующий неуправляемый указатель, помещаемый в стек с помощью инструкции `ldvirtftn`, можно вызвать с помощью инструкции <xref:System.Reflection.Emit.OpCodes.Calli>, если она ссылается на управляемый метод (или на заглушку, переход от управляемого кода к неуправляемому).  
  
 Неуправляемый указатель указывает на машинный код, используя соглашение о вызовах CLR. Этот указатель метода не должен передаваться в неуправляемый машинный код в качестве подпрограммы обратного вызова.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldvirtftn`:  
  
-   ILGenerator. Emit (код операции, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет выход из защищенной области кода с безусловной передачей управления указанной конечной инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|ДД < `int32` @ NO__T-1|Оставьте `target`|Выходит из защищенной области кода.|  
  
 Для этой инструкции не задано поведение перехода стека.  
  
 Инструкция `leave` выполняет безусловную передачу управления в определенную целевую инструкцию, представленную в виде смещения со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.  
  
 Инструкция `leave` аналогична инструкции `br`, но ее можно использовать для выхода из блока `try`, `filter` или `catch`, в то время как обычные инструкции ветвления можно использовать только в таком блоке для передачи управления внутри него. Инструкция `leave` очищает стек вычислений и обеспечивает выполнение соответствующих блоков `finally`.  
  
 Нельзя использовать инструкцию `leave` для выхода из блока `finally`. Чтобы упростить создание кода для обработчиков исключений, оно допустимо в блоке catch, чтобы использовать инструкцию `leave` для перемещения управления в любую инструкцию в связанном блоке `try`.  
  
 Если инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.  
  
 Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `leave`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет выход из защищенной области кода с безусловной передачей управления указанной конечной инструкции (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DE < `int8` @ NO__T-1|Оставьте. s `target`|Выйдите из защищенной области кода, короткой формы.|  
  
 Для этой инструкции не задано поведение перехода стека.  
  
 Инструкция `leave.s` выполняет безусловную передачу управления в переданную целевую инструкцию, представленную как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.  
  
 Инструкция `leave.s` аналогична инструкции `br`, но ее можно использовать для выхода из блока `try`, `filter` или `catch`, в то время как обычные инструкции ветвления можно использовать только в таком блоке для передачи управления внутри него. Инструкция `leave.s` очищает стек вычислений и обеспечивает выполнение соответствующих блоков `finally`.  
  
 Нельзя использовать инструкцию `leave.s` для выхода из блока `finally`. Чтобы упростить создание кода для обработчиков исключений, оно допустимо в блоке catch, чтобы использовать инструкцию `leave.s` для перемещения управления в любую инструкцию в связанном блоке `try`.  
  
 Если инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `leave.s`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выделяет определенное количество байтов из пула локальной динамической памяти и помещает в стек вычислений адрес (временный указатель с типом <see langword="*" />) первого выделенного байта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|Выделение пространства из локальной кучи.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Число байтов, которое необходимо выделить, помещается в стек.  
  
2.  Число байтов извлекается из стека; объем памяти, соответствующий размеру, выделяется из локальной кучи.  
  
3.  Указатель на первый байт выделенной памяти помещается в стек.  
  
 Инструкция `localloc` выделяет `size` (тип `natural unsigned int`) байт из локального пула динамической памяти и возвращает адрес (временный указатель, тип `*`) первого выделенного байта. Возвращаемый блок памяти инициализируется значением 0 только в том случае, если флаг инициализации метода имеет значение `true`. Когда текущий метод выполняет <xref:System.Reflection.Emit.OpCodes.Ret>, пул локальной памяти становится доступным для повторного использования.  
  
 Полученный адрес будет согласован таким образом, чтобы любой тип примитива мог храниться в нем с помощью инструкций `stind` (например, <xref:System.Reflection.Emit.OpCodes.Stind_I4>) и загружался с помощью инструкций `ldind` (например, <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).  
  
 Инструкция `localloc` не может находиться в блоке `filter`, `catch`, `finally` или `fault`.  
  
 <xref:System.StackOverflowException> возникает, если недостаточно памяти для обслуживания запроса.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `localloc`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений ссылку на экземпляр определенного типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|C6 < `T` >|Mkrefany `class`|Помещает в стек типизированную ссылку типа `class`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Указатель на фрагмент данных помещается в стек.  
  
2.  Указатель извлекается и преобразуется в типизированную ссылку типа `class`.  
  
3.  Типизированная ссылка помещается в стек.  
  
 Инструкция `mkrefany` поддерживает передачу ссылок с динамическим типом. Указатель должен иметь тип `&`, `*` или `native int`, а также содержать допустимый адрес фрагмента данных. `Class` — это маркер класса, описывающий тип данных, на которые ссылается указатель. `Mkrefany` отправляет типизированную ссылку на стек, предоставляя непрозрачный дескриптор указателя и тип `class`.  
  
 Единственной допустимой операцией, разрешенной для типизированной ссылки, является передача ее в метод, которому в качестве параметра требуется типизированная ссылка. Затем вызываемый объект может использовать инструкции <xref:System.Reflection.Emit.OpCodes.Refanytype> и <xref:System.Reflection.Emit.OpCodes.Refanyval> для получения типа (класса) и адреса соответственно.  
  
 <xref:System.TypeLoadException> возникает, если не удается найти `class`. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `mkrefany`:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Умножает два значения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5A|mul|Умножает два значения в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` умножается на `value2`.  
  
4.  Результат помещается в стек.  
  
 Инструкция `mul` умножает `value1` на `value2` и помещает результат в стек. Целочисленные операции автоматически усекаются верхние биты в переполнении.  
  
 Для выполнения операции умножения целого числа на обработку переполнения см. <xref:System.Reflection.Emit.OpCodes.Mul_Ovf>.  
  
 Для типов с плавающей запятой 0 * Infinity = NaN.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `mul`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Умножает два целочисленных значения, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D8|mul. ovf|Умножает два целочисленных значения в стеке с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` умножается на `value2` с помощью проверки переполнения.  
  
4.  Результат помещается в стек.  
  
 Инструкция `mul.ovf` умножает целое число `value1` на целое число `value2` и помещает результат в стек. Если результат не умещается в типе результата, выдается исключение.  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `mul.ovf`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Умножает два целочисленных значения без знака, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|D9|mul. ovf. un|Умножает два значения без знака в стеке с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value1` умножается на `value2` с помощью проверки переполнения.  
  
4.  Результат помещается в стек.  
  
 Инструкция `mul.ovf.un` умножает целое число без знака `value1` на целое число без знака `value2` и передает результат в стек. Если результат не умещается в типе результата, выдается исключение.  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `mul.ovf.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Отвергает значение и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|65|расход|Инвертирует значение, находящегося на вершине стека.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Значение извлекается из стека и инвертируется.  
  
3.  Результат помещается в стек.  
  
 Инструкция `neg` инвертирует значение и помещает результат поверх стека. Тип возвращаемого значения совпадает с типом операнда.  
  
 Отрицание целочисленных значений — это нестандартное отрицание числа единиц. В частности, при инвертировании самого отрицательного числа (которое не имеет положительного аналога) выдается наибольшее отрицательное число. Чтобы обнаружить это переполнение, используйте инструкцию <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> (то есть вычтите из 0).  
  
 Отрицание числа с плавающей запятой не может быть переполнено и отрицание NaN возвращает NaN.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `neg`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений ссылку на объект — новый одномерный массив с индексацией от нуля, состоящий из элементов заданного типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|8D < `T` >|неварр `etype`|Создает новый массив с элементами типа `etype`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Число элементов в массиве помещается в стек.  
  
2.  Число элементов извлекается из стека и создается массив.  
  
3.  Ссылка на новый массив помещается в стек.  
  
 Инструкция `newarr` помещает ссылку на объект (тип `O`) в новый одномерный массив, начинающийся с нуля, элементы которого имеют тип `etype` (маркер метаданных, описывающий тип). Число элементов в новом массиве должно быть задано как `native int`. Допустимые индексы массива находятся в диапазоне от нуля до максимального числа элементов минус один.  
  
 Элементы массива могут быть любого типа, включая типы значений.  
  
 Одномерные массивы чисел с индексацией от нуля создаются с помощью маркера метаданных, ссылающегося на соответствующий тип значения (<xref:System.Int32> и т. д.). Элементы массива инициализируются значением 0 соответствующего типа.  
  
 Одномерные массивы с ненулевыми значениями и многомерные массивы создаются с помощью <xref:System.Reflection.Emit.OpCodes.Newobj>, а не `newarr`. Чаще всего они создаются с помощью методов класса <xref:System.Array> в .NET Framework.  
  
 <xref:System.OutOfMemoryException> возникает, если недостаточно памяти для удовлетворения запроса.  
  
 <xref:System.OverflowException> возникает, если `numElems` меньше 0.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `newarr`:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Создает новый объект или новый экземпляр типа значения и помещает ссылку на объект (тип <see langword="O" />) в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|Выделяет неинициализированный объект или тип значения и вызывает метод конструктора `ctor`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Аргументы @no__t от-0 до `argn` помещаются в стек последовательно.  
  
2.  Аргументы @no__t от-0 до `arg1` извлекаются из стека и передаются в `ctor` для создания объекта.  
  
3.  Ссылка на новый объект помещается в стек.  
  
 Инструкция `newobj` создает новый объект или новый экземпляр типа значения. `Ctor` является маркером метаданных (`methodref` или `methoddef`, который должен быть помечен как конструктор), который указывает имя, класс и сигнатуру вызываемого конструктора.  
  
 Инструкция `newobj` выделяет новый экземпляр класса, связанный с `ctor`, и инициализирует все поля в новом экземпляре значением 0 (соответствующего типа) или пустыми ссылками, если это уместно. Затем он вызывает конструктор `ctor` с заданными аргументами вместе с созданным экземпляром. После вызова конструктора в стек помещается ссылка на инициализированный объект (тип `O`).  
  
 С точки зрения конструктора неинициализированный объект является аргументом 0, а остальные аргументы, передаваемые в newobj, следуют по порядку.  
  
 Все одномерные массивы, начинающиеся с нуля, создаются с помощью <xref:System.Reflection.Emit.OpCodes.Newarr>, а не `newobj`. С другой стороны, все остальные массивы (более одного измерения или одномерные, но не основанные на нуле) создаются с помощью `newobj`.  
  
 Типы значений обычно не создаются с помощью `newobj`. Обычно они выделяются как аргументы или локальные переменные с помощью `newarr` (для одномерных массивов с индексацией от нуля) или как поля объектов. После выделения они инициализируются с помощью <xref:System.Reflection.Emit.OpCodes.Initobj>. Однако инструкцию `newobj` можно использовать для создания нового экземпляра типа значения в стеке, который затем может передаваться в качестве аргумента, храниться в локальной системе и т. д.  
  
 <xref:System.OutOfMemoryException> возникает, если недостаточно памяти для удовлетворения запроса.  
  
 <xref:System.MissingMethodException> возникает, если не удалось найти метод конструктора `ctor` с указанным именем, классом и сигнатурой. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `newobj`:  
  
-   ILGenerator. Emit (код операции, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заполняет пространство, если коды операции содержат исправления. Никаких значимых операций не выполняется, хотя может быть пройден цикл обработки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|00|NOP|Выполняет операцию без поведения.|  
  
 Для этой инструкции не определено поведение перехода стека.  
  
 Операция `nop` не выполняет никаких действий. Он предназначен для заполнения пространства, если исправлены коды операций.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `nop`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое дополнение целочисленного значения, находящегося на вершине стека, и помещает результат в стек с тем же типом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|66|not|Вычисление побитового дополнения значения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value` помещается в стек.  
  
2.  `value` извлекается из стека и вычисленное побитовое дополнение.  
  
3.  Результат помещается в стек.  
  
 Инструкция `not` делит побитовое дополнение целочисленного значения и помещает результат в стек. Тип возвращаемого значения совпадает с типом операнда.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `not`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое дополнение двух целочисленных значений, находящихся на вершине стека, и помещает результат в стек.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|60|или|Выполняет побитовое или для двух целочисленных значений, возвращает целое число.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека и их побитовые или вычисленные.  
  
4.  Результат помещается в стек.  
  
 Инструкция `or` рассчитывает побитовое или двух значений в стеке, помещая результат в стек.  
  
 `Or` является операцией, относящейся к целому числу.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `or`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Удаляет значение, находящееся на вершине стека.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|26|pop|Извлекает верхнее значение из стека.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Верхнее значение извлекается из стека.  
  
 Инструкция `pop` удаляет верхний элемент из стека.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `pop`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Эта инструкция зарезервирована.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что последующая операция, связанная с адресом массива, не выполняет никаких проверок во время выполнения и возвращает управляемый указатель, изменение которого запрещено.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 1E|доступно.|Укажите, что последующие операции с адресом массива не выполняют проверку типа во время выполнения и возвращают управляемый указатель с ограниченными возможностями.|  
  
 Этот префикс может использоваться только непосредственно перед инструкцией `ldelema` и вызовами специального метода `Address` для массивов. Его воздействие на последующую операцию — двойная:  
  
1.  Во время выполнения операция проверки типа не выполняется. Обратите внимание, что обычно неявная проверка типа для инструкций `ldelema` и `stelem` при использовании массивов ссылочного типа. Для классов значений никогда не выполняется проверка типа во время выполнения, поэтому `readonly` является отсутствием операции в этом случае.  
  
2.  Средство проверки обрабатывает результат операции адреса в качестве управляемого указателя с ограниченными возможностями.  
  
 Говорят, что указатель имеет ограниченную возможность, так как определяющий тип определяет, можно ли изменить значение. Для классов значений, которые не предоставляют открытых полей или методов, которые обновляют значение на месте, указатель доступен только для чтения (следовательно, имя префикса). В частности, классы, представляющие простые типы (например, System. Int32), не предоставляют мутатора и, таким образом, доступны только для чтения.  
  
 Управляемый указатель, ограниченный таким образом, может использоваться только следующими способами:  
  
-   В качестве параметра `object` для инструкций `ldfld`, `ldflda`, `stfld`, `call` или @ no__t-5.  
  
-   В качестве параметра `pointer` для инструкции `ldobj` или для одной из инструкций `ldind`.  
  
-   В качестве параметра `source` для инструкции `cpobj`.  
  
 Все другие операции запрещены, включая `stobj`, `initobj` или `mkrefany`, или любые инструкции `stind`.  
  
 Назначение префикса `readonly` заключается в том, чтобы избежать проверки типа при извлечении элемента из массива в универсальном коде. Например, выражение `arr[i].m()`, где тип элемента массива `arr` является универсальным типом, который был ограничен интерфейсом с методом `m`, может компилироваться следующим кодом MSIL.  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 Без префикса `readonly` Инструкция `ldelema` будет выполнять проверку типа, если! 0 является ссылочным типом. Этот тип не только неэффективен, но и семантически неверен. Проверка типа `ldelema` является точным совпадением, что является слишком строгим. Если массив удерживал подклассы типа! 0, приведенный выше код не сможет проверить тип.  
  
 Адрес элемента массива извлекается вместо самого элемента, чтобы иметь дескриптор для `arr[i]`, который работает как для типов значений, так и для ссылочных типов и поэтому может быть передан в инструкцию `constrained callvirt`.  
  
 Как правило, пропуск проверки во время выполнения может быть незащищенным, если массив удерживает элементы ссылочного типа. Чтобы быть в безопасности, необходимо убедиться, что с помощью этого указателя изменения в массиве не выполняются. Это гарантируется правилами проверки. Ограниченный управляемый указатель может передаваться как объект для вызовов метода экземпляра, поэтому он не должен строго говорить только для чтения для типов значений, но для типов значений не существует проблем безопасности типов.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `readonly`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает токен типа, внедренный в ссылку с определенным типом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 1D|рефанитипе|Помещает токен типа, хранящийся в типизированной ссылке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на тип значения помещается в стек.  
  
2.  Типизированная ссылка извлекается из стека и полученного маркера соответствующего типа.  
  
3.  Токен типа помещается в стек.  
  
 Типизированная ссылка содержит токен типа и адрес экземпляра объекта.  
  
 Инструкция `refanytype` извлекает лексему типа, внедренную в типизированную ссылку. Сведения о создании типизированных ссылок см. в инструкции <xref:System.Reflection.Emit.OpCodes.Mkrefany>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `refanytype`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает адрес (тип <see langword="&amp;" />), внедренный в ссылку с определенным типом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|C2 < `T` >|рефанивал `type`|Отправляет адрес, хранящийся в типизированной ссылке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на тип значения помещается в стек.  
  
2.  Типизированная ссылка извлекается из стека, и извлекается соответствующий адрес.  
  
3.  Адрес помещается в стек.  
  
 Типизированная ссылка содержит токен типа и адрес экземпляра объекта.  
  
 Инструкция `refanyval` извлекает адрес, внедренный в ссылку с определенным типом. Тип, внедренный в ссылочную ссылку, предоставленный в стеке, должен соответствовать типу, заданному `type` (маркер метаданных: `typedef` или `typeref`). См. инструкции по <xref:System.Reflection.Emit.OpCodes.Mkrefany> для связанного содержимого.  
  
 <xref:System.InvalidCastException> возникает, если `type` не совпадает с типом, хранящимся в ссылке на тип (в данном случае `type` является классом, переданным в инструкцию <xref:System.Reflection.Emit.OpCodes.Mkrefany>, которая создала произнесенную типизированную ссылку).  
  
 <xref:System.TypeLoadException> возникает, если не удается найти `type`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `refanyval`:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно значение на другое и помещает остаток в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5D|оставшие|Помещает остаток деления `value1` на `value2` в стек.|  
  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  @No__t-0 помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека, а оставшаяся часть `value1` `div` `value2`.  
  
4.  Результат помещается в стек.  
  
 `result` @ no__t-1 @ no__t-2 `rem` `value2` соответствует следующим условиям.  
  
 `result` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 `×` (`value1` `div` `value2`) и:  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;, знак (`result`) = sign (`value1`), где `div` — это инструкция деления, которая усекается в сторону нуля.  
  
 Если `value2` равно нулю или `value1` — бесконечность, результатом будет NaN. Если `value2` — бесконечность, результатом будет `value1` (с отрицанием для `-infinity`).  
  
 Целочисленные операции создают исключение <xref:System.DivideByZeroException>, если `value2` равно нулю.  
  
 Обратите внимание, что на платформах на базе процессоров Intel при вычислениях выдается <xref:System.OverflowException> (minint `rem` -1).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `rem`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Делит одно значение без знака на другое значение без знака и помещает остаток в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|5E|REM. un|Помещает оставшуюся часть деления без знака `value1` на `value2` в стек.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека, а оставшаяся часть `value1` `div` `value2`.  
  
4.  Результат помещается в стек.  
  
 `result` @ no__t-1 @ no__t-2 `rem.un` `value2` соответствует следующим условиям.  
  
 `result` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4 x (`value1` `div.un` `value2`) и:  
  
 0 = `result` @ no__t-1 @ no__t-2, где `div.un` — это неподписанная инструкция деления.  
  
 Инструкция `rem.un` выполняет вычисление `result` и помещает его в стек. `Rem.un` обрабатывает свои аргументы как целые числа без знака, а <xref:System.Reflection.Emit.OpCodes.Rem> обрабатывает их как целые числа со знаком.  
  
 значение `Rem.un` не указано для чисел с плавающей запятой.  
  
 Целочисленные операции создают исключение <xref:System.DivideByZeroException>, если `value2` равно нулю.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `rem.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет возврат из текущего метода, помещая возвращаемое значение (если имеется) из стека вычислений вызываемого метода в стек вычислений вызывающего метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|2A|обратно|Возвращает из метода, возможно, возвращающего значение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Возвращаемое значение извлекается из стека вычислений вызываемого метода.  
  
2.  Возвращаемое значение, полученное на шаге 1, помещается в стек вычислений вызывающего объекта.  
  
 Если возвращаемое значение отсутствует в стеке вычисления вызываемого метода, значение не возвращается (ни одно поведение перехода стека для вызываемого или вызывающего метода не используется).  
  
 Тип возвращаемого значения (если таковой имеется) текущего метода определяет тип значения, которое будет выбрано из верхней части стека и скопировано в стек метода, который вызвал текущий метод. Стек вычислений для текущего метода должен быть пустым, за исключением возвращаемого значения.  
  
 Инструкция `ret` не может использоваться для перемещения управления из блока @ no__t-1, `filter`, `catch` или `finally`. В `try` или `catch` используйте инструкцию <xref:System.Reflection.Emit.OpCodes.Leave> с назначением инструкции `ret`, которая находится за пределами всех охватывающих блоков исключений. Поскольку блоки `filter` и `finally` логически являются частью обработки исключений, а не метода, в котором внедрен их код, правильно сформированные инструкции языка MSIL не выполняют возврат метода из `filter` или `finally`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ret`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущее исключение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 1A|Rethrow|Повторная генерация текущего исключения|  
  
 Для этой инструкции не определено поведение перехода стека.  
  
 Инструкция `rethrow` разрешена только в теле обработчика `catch`. Он создает то же исключение, которое было перехвачено этим обработчиком.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `rethrow`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Смещает целочисленное значение влево (с заполнением нулями) на заданное число бит и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|62|шл|Сдвигает целое число влево (сдвиг в нули).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Количество битов для сдвига помещается в стек.  
  
3.  Число битов, которые необходимо сдвинуть, и значение, извлекаемое из стека; значение смещается влево на указанное число битов.  
  
4.  Результат помещается в стек.  
  
 Инструкция `shl` Сдвигает значение (Type `int32`, `int64` или `native int`) влево на указанное число битов. Число битов является значением типа `int32` или `native int`. Возвращаемое значение не указано, если число битов, которые необходимо сдвинуть, больше или равно ширине (в битах) указанного значения.  
  
 `Shl` вставляет нулевой бит в нижнюю точку при каждой смене.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `shl`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Смещает целочисленное значение вправо (с знаковым битом) на заданное число бит и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|63|SHR|Сдвигает целое число вправо (сдвиг в знак).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Количество битов для сдвига помещается в стек.  
  
3.  Число битов, которые необходимо сдвинуть, и значение, извлекаемое из стека; значение смещается вправо на указанное число битов.  
  
4.  Результат помещается в стек.  
  
 Инструкция `shr.un` Сдвигает значение (Type `int32`, `int64` или `native int`) вправо на указанное число битов. Число битов является значением типа `int32` или `native int`. Возвращаемое значение не указано, если число битов, которые необходимо сдвинуть, больше или равно ширине (в битах) указанного значения.  
  
 `Shr` реплицирует бит высокого порядка при каждой смене, сохраняя знак исходного значения в `result`.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `shr`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Смещает целочисленное значение без знака вправо (с заполнением нулями) на заданное число бит и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|64|SHR. un|Сдвигает целое число вправо (с сдвигом в нули).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Количество битов для сдвига помещается в стек.  
  
3.  Число битов, которые необходимо сдвинуть, и значение, извлекаемое из стека; значение смещается вправо на указанное число битов.  
  
4.  Результат помещается в стек.  
  
 Инструкция `shr.un` Сдвигает значение (Type `int32`, `int64` или `native int`) вправо на указанное число битов. Число битов является значением типа `int32`, `int64` или `native int`. Возвращаемое значение не указано, если число битов, которые необходимо сдвинуть, больше или равно ширине (в битах) указанного значения.  
  
 `Shr.un` вставляет нулевой бит в самую верхнюю точку при каждой смене.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `shr.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Помещает в стек вычислений сведения о размере (в байтах) заданного типа значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 1C < `T` @ NO__T-1|sizeof `valType`|Отправка размера (в байтах) типа значения в качестве `unsigned int32`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Размер (в байтах) заданного типа значения (`valType`) помещается в стек.  
  
 `valType` должен быть токеном метаданных (`typeref` или `typedef`), который указывает тип значения, ссылочный тип или параметр универсального типа.  
  
 Для ссылочного типа возвращаемый размер — это размер ссылочного значения соответствующего типа (4 байта в 32-разрядных системах), а не размер данных, хранящихся в объектах, на которые ссылается ссылочное значение. Параметр универсального типа может использоваться только в теле типа или метода, который его определяет. При создании экземпляра этого типа или метода параметр универсального типа заменяется типом значения или ссылочным типом.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `sizeof`:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение, находящееся на вершине стека вычислений, в ячейке аргумента с заданным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 0B < `unsigned int16` @ NO__T-1|СТАРГ `num`|Извлекает верхнее значение из стека и сохраняет его в ячейке аргумента `num`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение, находящегося на вершине стека, извлекается и помещается в ячейку аргумента `num`.  
  
 Инструкция `starg` извлекает значение из стека и помещает его в ячейку аргумента `num`. Тип значения должен соответствовать типу аргумента, как указано в сигнатуре текущего метода.  
  
 Для процедур, принимающих переменный список аргументов, инструкция `starg` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры.  
  
 Выполнение хранилища в аргументах, содержащих целочисленное значение менее 4 байт, усекает значение при перемещении из стека в аргумент. Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `starg`:  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение, находящееся на вершине стека вычислений, в ячейке аргумента с заданным индексом (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|СТАРГ. s `num`|Извлекает верхнее значение из стека и сохраняет его в ячейке аргумента `num` (краткая форма).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение, находящегося на вершине стека, извлекается и помещается в ячейку аргумента `num`.  
  
 Инструкция `starg.s` извлекает значение из стека и помещает его в ячейку аргумента `num`. Тип значения должен соответствовать типу аргумента, как указано в сигнатуре текущего метода.  
  
 Инструкция `starg.s` обеспечивает эффективную кодировку для использования с первыми аргументами 256.  
  
 Для процедур, принимающих переменный список аргументов, инструкция `starg.s` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры.  
  
 Выполнение хранилища в аргументах, содержащих целочисленное значение менее 4 байт, усекает значение при перемещении из стека в аргумент. Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `starg.s`:  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение в стеке вычислений, тип которого указан в инструкции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A4 < `T` >|стелем `typeTok`|Заменяет элемент массива с заданным индексом на значение типа `typeTok` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект Array, `array`, помещается в стек.  
  
2.  Значение индекса, `index`, в элемент в `array` помещается в стек.  
  
3.  Значение типа, указанное в инструкции, помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem` заменяет значение элемента в указанном индексе, начинающемся с нуля, в одномерном массиве `array` со значением. Значение имеет тип, заданный токеном `typeTok` в инструкции.  
  
 Массивы являются объектами, поэтому они представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem`:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="native int" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9Б|стелем. i|Заменяет элемент массива с заданным индексом на значение `native int` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект Array, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem.i` заменяет значение элемента `index` в одномерным массиве `array` на значение `native int`, помещаемое в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.i`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int8" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9C|стелем. i1|Заменяет элемент массива с заданным индексом на значение `int8` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект Array, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem.i1` заменяет значение элемента `index` в одномерным массиве `array` на значение `int8`, помещаемое в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.i1`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int16" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9D|стелем. i2|Заменяет элемент массива с заданным индексом на значение `int16` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект Array, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem.i2` заменяет значение элемента `index` в одномерным массиве `array` на значение `int16`, помещаемое в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.i2`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int32" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9E|стелем. i4|Заменяет элемент массива с заданным индексом на значение `int32` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект Array, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem.i4` заменяет значение элемента `index` в одномерным массиве `array` на значение `int32`, помещаемое в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.i4`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="int64" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|9F|стелем. i8|Заменяет элемент массива с заданным индексом на значение `int64` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект Array, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem.i8` заменяет значение элемента `index` в одномерным массиве `array` на значение `int64`, помещаемое в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.i8`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="float32" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A0|стелем. R4|Заменяет элемент массива с заданным индексом на значение `float32` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект Array, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem.r4` заменяет значение элемента `index` в одномерным массиве `array` на значение `float32`, помещаемое в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.r4`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение <see langword="float64" />, находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A1|стелем. R8|Заменяет элемент массива с заданным индексом на значение `float64` в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект Array, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem.r8` заменяет значение элемента `index` в одномерным массиве `array` на значение `float64`, помещаемое в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.r8`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет элемент массива с заданным индексом на значение object ref (тип <see langword="O" />), находящееся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A2|стелем. ref|Заменяет элемент массива с заданным индексом на значение `ref` (тип `O`) в стеке.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект Array, `array`, помещается в стек.  
  
2.  Допустимый индекс элемента в `array` помещается в стек.  
  
3.  Значение помещается в стек.  
  
4.  Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.  
  
 Инструкция `stelem.ref` заменяет значение элемента по указанному индексу в одномерном массиве `array` на значение `ref` (тип `O`), помещаемое в стек.  
  
 Массивы являются объектами и поэтому представлены значением типа `O`. Индекс имеет тип `native int`.  
  
 Обратите внимание, что `stelem.ref` неявно приводит заданное значение к типу элемента `array` перед присваиванием значения элементу массива. Это приведение может завершиться ошибкой даже для проверенного кода. Поэтому инструкция `stelem.ref` может вызвать <xref:System.InvalidCastException>. Для одномерных массивов без индексации от нуля и для многомерных массивов класс <xref:System.Array> предоставляет метод <xref:System.Array.SetValue%2A>.  
  
 <xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.  
  
 <xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.  
  
 <xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.ref`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет значение в поле объекта, по ссылке на объект или указателю, на новое значение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld `field`|Заменяет значение `field` объекта на новое значение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект или указатель помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и ссылка на объект (указатель) извлекаются из стека; значение `field` в объекте заменяется на заданное значение.  
  
 Инструкция `stfld` заменяет значение поля объекта (тип `O`) или через указатель (тип `native int`, `&` или `*`) с заданным значением. `Field` — это маркер метаданных, который ссылается на ссылку на поле. Инструкция `stfld` может иметь префикс либо для <xref:System.Reflection.Emit.OpCodes.Unaligned>, и для <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.NullReferenceException> создается, если ссылка на объект или указатель является пустой ссылкой, а поле не является статическим.  
  
 <xref:System.MissingFieldException> возникает, если `field` не найден в метаданных. Обычно это проверяется при преобразовании инструкции MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stfld`:  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="native int" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DF|stind. i|Сохраняет значение `native int` по указанному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 Инструкция `stind.i` сохраняет значение `native int` по указанному адресу (тип `native int`, `*` или `&`).  
  
 Для операции с типом "безопасно" требуется, чтобы инструкция `stind.i` соответствовала типу указателя. Операция `stind.i` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом с типом аргумента, подразумеваемым суффиксом инструкции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.i`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int8" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|52|stind. i1|Сохраняет значение `int8` по заданному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 Инструкция `stind.i1` сохраняет значение `int8` по указанному адресу (тип `native int`, `*` или `&`).  
  
 Для операции с типом "безопасно" требуется, чтобы инструкция `stind.i1` соответствовала типу указателя. Операция `stind.i1` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом с типом аргумента, подразумеваемым суффиксом инструкции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.i1`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int16" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|53|stind. i2|Сохраняет значение `int16` по заданному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 Инструкция `stind.i2` сохраняет значение `int16` по указанному адресу (тип `native int`, `*` или `&`).  
  
 Для операции с типом "безопасно" требуется, чтобы инструкция `stind.2i` соответствовала типу указателя. Операция `stind.i2` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом с типом аргумента, подразумеваемым суффиксом инструкции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.i2`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int32" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|54|stind. i4|Сохраняет значение `int32` по заданному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 Инструкция `stind.i4` сохраняет значение `int32` по указанному адресу (тип `native int`, `*` или `&`).  
  
 Для операции с типом "безопасно" требуется, чтобы инструкция `stind.i4` соответствовала типу указателя. Операция `stind.i4` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом с типом аргумента, подразумеваемым суффиксом инструкции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.i4`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="int64" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|55|stind. i8|Сохраняет значение `int64` по заданному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 Инструкция `stind.i8` сохраняет значение `int64` по указанному адресу (тип `native int`, `*` или `&`).  
  
 Для операции с типом "безопасно" требуется, чтобы инструкция `stind.i8` соответствовала типу указателя. Операция `stind.i` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом с типом аргумента, подразумеваемым суффиксом инструкции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.i8`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="float32" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|56|stind. R4|Сохраняет значение `float32` по указанному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 Инструкция `stind.r4` сохраняет значение `float32` по указанному адресу (тип `native int`, `*` или `&`).  
  
 Для операции с типом "безопасно" требуется, чтобы инструкция `stind.r4` соответствовала типу указателя. Операция `stind.r4` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом с типом аргумента, подразумеваемым суффиксом инструкции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.r4`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение с типом <see langword="float64" /> по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|57|stind. R8|Сохраняет значение `float64` по указанному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 Инструкция `stind.r8` сохраняет значение `float64` по указанному адресу (тип `native int`, `*` или `&`).  
  
 Для операции с типом "безопасно" требуется, чтобы инструкция `stind.r8` соответствовала типу указателя. Операция `stind.r8` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом с типом аргумента, подразумеваемым суффиксом инструкции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.r8`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Сохраняет значение ссылки на объект по указанному адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|51|stind. ref|Сохраняет ссылку на объект (тип `O`) по указанному адресу.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Значение помещается в стек.  
  
3.  Значение и адрес извлекаются из стека; значение хранится по адресу.  
  
 Инструкция `stind.ref` сохраняет значение ссылки на объект по указанному адресу (тип `native int`, `*` или `&`).  
  
 Для операции с типом "безопасно" требуется, чтобы инструкция `stind.ref` соответствовала типу указателя. Операция `stind.ref` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.  
  
 <xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом с типом аргумента, подразумеваемым суффиксом инструкции.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.ref`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с заданным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 0E < `unsigned int16` @ NO__T-1|требовалась stloc `index`|Извлекает значение из стека и сохраняет его в локальной переменной `index`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную `index`.  
  
 Инструкция `stloc` выводит верхнее значение из стека вычислений и перемещает его в локальную переменную с номером `index`, где локальные переменные нумеруются 0 – назад. Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.  
  
 Для правильных инструкций промежуточного языка MSIL требуется, чтобы `index` был допустимым локальным индексом. Для инструкции `stloc` `index` должно находиться в диапазоне от 0 до 65534 включительно (в частности, 65535 является недопустимым). Исключение 65535 является практичным: вероятные реализации будут использовать 2-байтовое целое число для трассировки как индекса локальной версии, так и общего числа локальных переменных для данного метода. Если индекс 65535 был сделан допустимым, для записи числа локальных переменных в таком методе потребуется более широкое целое число.  
  
 Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `stloc`:  
  
-   ILGenerator. Emit (код операции, LocalBuilder)  
  
-   ILGenerator. Emit (код операции, короткий)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0A|требовалась stloc. 0|Извлекает значение из стека в локальную переменную 0.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 0.  
  
 Инструкция `stloc.0` извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 0. Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 `stloc.0` является особенно эффективным кодированием для хранения значений в локальной переменной 0.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stloc.0`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение из стека вычислений и сохраняет его в списке локальных переменных с индексом 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0B|требовалась stloc. 1|Извлекает значение из стека в локальную переменную 1.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 1.  
  
 Инструкция `stloc.1` извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 1. Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 `stloc.1` является особенно эффективным кодированием для хранения значений в локальной переменной 1.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stloc.1`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение из стека вычислений и сохраняет его в списке локальных переменных с индексом 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0C|требовалась stloc. 2|Извлекает значение из стека в локальную переменную 2|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 2.  
  
 Инструкция `stloc.2` извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 2. Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 `stloc.2` является особенно эффективным кодированием для хранения значений в локальной переменной 2.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stloc.2`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение из стека вычислений и сохраняет его в списке локальных переменных с индексом 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|0D|требовалась stloc. 3|Извлекает значение из стека в локальную переменную 3|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную с индексом 3.  
  
 Инструкция `stloc.3` извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 3. Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 `stloc.3` является особенно эффективным кодированием для хранения значений в локальной переменной 3.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stloc.3`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом <paramref name="index" /> (короткая форма).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|требовалась stloc. s `index`|Извлекает значение из стека и сохраняет его в локальной переменной `index` (краткая форма).|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение извлекается из стека и помещается в локальную переменную `index`.  
  
 Инструкция `stloc.s` выводит верхнее значение из стека вычислений и перемещает его в локальную переменную с номером `index`, где локальные переменные нумеруются 0 – назад. Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.  
  
 Инструкция `stloc.s` обеспечивает эффективную кодировку для локальных переменных от 0 до 255.  
  
 При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную. Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.  
  
 Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `stloc.s`:  
  
-   ILGenerator. Emit (код операции, LocalBuilder)  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Копирует значение с заданным типом из стека вычислений в указанный адрес памяти.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|Сохраняет значение типа `class` из стека в память.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
2.  Объект типа значения типа `class` помещается в стек.  
  
3.  Объект и адрес извлекаются из стека; Объект типа значения хранится по адресу.  
  
 Инструкция `stobj` копирует объект типа значения в адрес, указанный в адресе (указатель типа `native int`, `*` или `&`). Число копируемых байтов зависит от размера класса, представленного `class`, маркера метаданных, представляющего тип значения.  
  
 Операция `stobj` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.  
  
 Если класс не найден, возникает исключение <xref:System.TypeLoadException>. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stobj`:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Заменяет значение статического поля на значение из стека вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|Заменяет значение в `field` на заданное значение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Значение извлекается из стека и сохраняется в `field`.  
  
 Инструкция `stsfld` заменяет значение статического поля значением из стека. `field` является маркером метаданных, который должен ссылаться на член статического поля.  
  
 Инструкция `stsfld` может иметь префикс <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 Если поле не найдено в метаданных, возникает исключение <xref:System.MissingFieldException>. Обычно это проверяется при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stsfld`:  
  
-   ILGenerator. Emit (код операции, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычитает одно значение из другого и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|59|sub|Вычитает одно значение из другого, возвращая новое числовое значение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value2` вычитается из `value1`.  
  
4.  Результат помещается в стек.  
  
 Переполнение не обнаружено для целочисленных операций (для правильной обработки переполнения см. <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).  
  
 Вычитание целых чисел заключается в переносе, а не в насыщенность. Например, если предположить 8-разрядные целые числа, где `value1` имеет значение 0, а `value2` — 1, то "упакованный" результат будет 255.  
  
 Переполнение с плавающей точкой возвращает `+inf` (`PositiveInfinity`) или `-inf` (`NegativeInfinity`).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `sub`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычитает одно целочисленное значение из другого, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DA|подovf|Вычитает одно целочисленное значение из другого с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value2` вычитается из `value1` с помощью проверки переполнения.  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Эта операция выполняется над целыми числами со знаком. для значений с плавающей запятой используйте <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `sub.ovf`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычитает одно целочисленное значение без знака из другого, выполняет проверку переполнения и помещает результат в стек вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|DB|ovf. un|Вычитает одно целочисленное значение без знака из другого с помощью проверки переполнения.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека; `value2` вычитается из `value1` с помощью проверки переполнения.  
  
4.  Результат помещается в стек.  
  
 <xref:System.OverflowException> создается, если результат не может быть представлен типом результата.  
  
 Эта операция выполняется над целыми числами со знаком. для значений с плавающей запятой используйте <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `sub.ovf.un`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Реализует таблицу переходов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` >... < `int32` >|Switch (`N`, `t1`, `t2`... `tN`)|Переходит к одному из значений `N`.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Значение помещается в стек.  
  
2.  Значение извлекается из стека, и выполнение передается в инструкцию со смещением, индексированным по значению, где значение меньше `N`.  
  
 Инструкция `switch` реализует таблицу переходов. Инструкция имеет следующий формат: `unsigned int32`, представляющее количество целевых объектов `N`, за которыми следуют значения `N` Int32, указывающие цели перехода. Эти целевые объекты представлены в виде смещений (положительных или отрицательных) от начала инструкции, следующей за инструкцией `switch`.  
  
 Инструкция `switch` извлекает значение из стека и сравнивает его как целое число без знака с `N`. Если значение меньше `N`, выполнение передается в целевой индекс по значению, где конечные объекты нумеруются от 0 (например, значение 0 принимает первый целевой объект, значение 1 принимает второй целевой объект и т. д.). Если значение больше или равно `N`, выполнение продолжится в следующей инструкции (с переходом).  
  
 Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.  
  
 Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией. (Такие передачи сильно ограничены и должны использовать инструкцию Leave).  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `switch`. Аргумент `Label[]` является массивом меток, представляющих 32-разрядные смещения.  
  
-   ILGenerator. Emit (код операции, метка [])  
  
   
  
## Examples  
 В следующем образце кода показано использование кода операции `Switch` для создания таблицы переходов с помощью массива <xref:System.Reflection.Emit.Label>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Выполняет инструкцию вызова метода (префиксом которой является), предварительно удаляя кадр стека текущего метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 14|односторонне.|Последующий вызов завершает текущие методы|  
  
 Для этой инструкции не определено поведение перехода стека.  
  
 Инструкция префикса `tail` должна находиться непосредственно перед инструкцией <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli> или <xref:System.Reflection.Emit.OpCodes.Callvirt>. Указывает, что кадр стека текущего метода должен быть удален перед выполнением инструкции вызова. Также подразумевается, что значение, возвращаемое из следующего вызова, является также значением, возвращаемым текущим методом, и поэтому вызов может быть преобразован в переход между методами.  
  
 Стек должен быть пустым, за исключением аргументов, передаваемых следующим вызовом. Инструкция, следующая за инструкцией Call, должна быть Ret. Таким образом, единственной допустимой последовательностью кода является `tail. call` (или `calli` или `callvirt`). Правильные инструкции промежуточного языка MSIL не должны выполнять переход к инструкции `call`, но они могут выполнять переход к последующей <xref:System.Reflection.Emit.OpCodes.Ret>.  
  
 Текущий кадр не может быть отклонен, если управление передается из ненадежного кода в доверенный код, так как это может подвергнуть риску безопасность идентификации кода. Таким образом, .NET Framework проверки безопасности могут вызвать игнорирование `tail`, при этом будет использоваться стандартная инструкция <xref:System.Reflection.Emit.OpCodes.Call>. Аналогично, чтобы выйти из синхронизированной области после возврата вызова, префикс `tail` игнорируется при использовании для выхода из метода, помеченного как синхронизированный.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `tail`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Экземпляр объекта Opcode.</param>
        <summary>Возвращает true или false, в зависимости от того, принимает ли заданный код операции однобайтовый аргумент.</summary>
        <returns><see langword="true" /> или <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для определения того, какие коды MSIL являются "короткими формами", для использования в оптимизированном коде.  
  
 `TakesSingleByteArgument` возвращает значение `true`, если экземпляр <xref:System.Reflection.Emit.OpCode> принимает один байтовый аргумент в следующих случаях:  
  
-   Код операции выполняет инструкцию ветвления с адресом в байтовой кодировке (например, <xref:System.Reflection.Emit.OpCodes.Br_S> и <xref:System.Reflection.Emit.OpCodes.Bgt_S>).  
  
-   Код операции помещает значение байта в стек (например, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).  
  
-   Код операции ссылается на переменную или аргумент с помощью короткой формы размером байта (например, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> и <xref:System.Reflection.Emit.OpCodes.Stloc_S>).  
  
 В противном случае она возвращает `false`.  
  
 В приведенном ниже примере показано использование `TakesSingleByteArgument` в соответствии с классом `OpCodes` и тестированием, чтобы определить, принимает ли каждое поле `OpCode` однобайтовый аргумент.  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Создает объект исключения, находящийся в стеке вычислений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|7А|throw|Создает исключение.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект (исключение) помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и вызывается исключение.  
  
 Инструкция `throw` создает объект исключения (тип `O`) в данный момент в стеке.  
  
 <xref:System.NullReferenceException> создается, если ссылка на объект является пустой ссылкой.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `throw`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что адрес на вершине стека, возможно, не выровнен по естественному размеру следующей непосредственно за ним инструкции <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" /> или <see langword="cpblk" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|< FE 12 `unsigned int8` @ NO__T-1|невыровненным. `alignment`|Указывает, что последующая инструкция указателя может быть несогласованной.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
 `Unaligned` указывает, что адрес (неуправляемый указатель, `native int`) в стеке может не соответствовать естественному размеру сразу после `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk` или `cpblk`. То есть для инструкции <xref:System.Reflection.Emit.OpCodes.Ldind_I4> выравнивание адреса может не доставлять 4 байта. Для `initblk` и `cpblk` выравнивание по умолчанию зависит от архитектуры (4-байтный на 32-разрядных ЦП, 8-байт на 64-разрядных ЦП). Генераторы кода, которые не ограничивают свои выходные данные размером 32-разрядного слова, должны использовать `unaligned`, если во время компиляции неизвестно 8-байтное выравнивание.  
  
 Значение выравнивания должно быть равно 1, 2 или 4 и означает, что созданный код должен предположить, что адрес имеет тип Byte, двухбайтовые или четыре байта соответственно. Обратите внимание, что временные указатели (тип `*`) всегда согласовываются.  
  
 Хотя выравнивание для инструкции `cpblk` логически потребовало два числа (одно для источника и одно для назначения), не существует заметного влияния на производительность, если указано только меньшее число.  
  
 Префиксы `unaligned` и `volatile` можно объединять в любом порядке. Они должны находиться непосредственно перед инструкциями `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, @no__t – 6 или `cpblk`. Только префикс <xref:System.Reflection.Emit.OpCodes.Volatile> разрешен для инструкций <xref:System.Reflection.Emit.OpCodes.Ldsfld> и <xref:System.Reflection.Emit.OpCodes.Stsfld>.  
  
 Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `unaligned`:  
  
-   ILGenerator. Emit (код операции, метка)  
  
-   ILGenerator. Emit (код операции, байт)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует тип значения из упакованной формы в распакованную.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|79 < `T` >|Распаковка `valType`|Извлекает данные типа значения из `obj`, его упакованного представления.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и распаковывается в указатель типа значения.  
  
3.  Указатель типа значения помещается в стек.  
  
 Тип значения имеет два отдельных представления в Common Language Infrastructure (CLI):  
  
-   Необработанная форма, используемая при внедрении типа значения в другой объект.  
  
-   "Упакованная" форма, в которой данные в типе значения упаковываются (упаковываются) в объект, поэтому он может существовать как независимая сущность.  
  
 Инструкция `unbox` преобразует ссылку на объект (тип `O`), упакованное представление типа значения в указатель типа значения (управляемый указатель, тип `&`), его неупакованную форму. Указанный тип значения (`valType`) является маркером метаданных, указывающим тип значения, содержащегося в упакованном объекте.  
  
 В отличие от <xref:System.Reflection.Emit.OpCodes.Box>, которое требуется для создания копии типа значения для использования в объекте, `unbox` не требуется копировать тип значения из объекта. Обычно он просто выполняет вычисление адреса типа значения, уже присутствующего внутри упакованного объекта.  
  
 <xref:System.InvalidCastException> создается, если объект не упакован как `valType`.  
  
 <xref:System.NullReferenceException> создается, если ссылка на объект является пустой ссылкой.  
  
 <xref:System.TypeLoadException> возникает, если не удается найти тип значения `valType`. Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `unbox`:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Преобразует тип, указанный в инструкции, из упакованной формы в распакованную.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|A5 < `T` >|Распаковка. любой `typeTok`|Извлеките данные из `obj`, их упакованного представления.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Ссылка на объект `obj` помещается в стек.  
  
2.  Ссылка на объект извлекается из стека и распаковывается в тип, указанный в инструкции.  
  
3.  Результирующая ссылка на объект или тип значения помещается в стек.  
  
 При применении к упакованной форме типа значения инструкция `unbox.any` извлекает значение, содержащееся в `obj` (типа `O`), и, следовательно, эквивалентно `unbox`, за которым следует `ldobj`.  
  
 При применении к ссылочному типу инструкция `unbox.any` действует так же, как `castclass` `typeTok`.  
  
 Если операнд `typeTok` является параметром универсального типа, то поведение среды выполнения определяется типом, указанным для этого параметра универсального типа.  
  
 <xref:System.InvalidCastException> возникает, если `obj` не является упакованным типом.  
  
 <xref:System.NullReferenceException> возникает, если `obj` является пустой ссылкой.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `unbox.any`:  
  
-   ILGenerator. Emit (код операции, тип)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что адрес на вершине стека вычислений, возможно, является изменяемым и результаты чтения данной области невозможно кэшировать либо невозможно запретить множественные сохранения в эту область.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|FE 13|независимо.|Указывает, что последующая ссылка на указатель является временной.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  Адрес помещается в стек.  
  
 `volatile`. Указывает, что адрес является временным адресом (т. е. на него может ссылаться извне на текущий поток выполнения), и результаты чтения этого расположения не могут быть кэшированы или нельзя подавлять несколько магазинов в этом расположении. Пометка доступа как `volatile` влияет только на этот единственный доступ. другие методы доступа к тому же расположению должны быть помечены отдельно. Доступ к временным расположениям не должен выполняться атомарно.  
  
 Префиксы <xref:System.Reflection.Emit.OpCodes.Unaligned> и `volatile` можно объединять в любом порядке. Они должны находиться непосредственно перед инструкциями `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, @no__t – 6 или `cpblk`. Только префикс `volatile` разрешен для инструкций <xref:System.Reflection.Emit.OpCodes.Ldsfld> и <xref:System.Reflection.Emit.OpCodes.Stsfld>.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `volatile`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вычисляет побитовое исключающее ИЛИ двух верхних значений в стеке вычислений и помещает результат обратно в стек.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.  
  
|Формат|Формат сборки|Описание|  
|------------|---------------------|-----------------|  
|61|xor|Выполняет побитовое ИСКЛЮЧАЮЩее или двух целочисленных значений и возвращает целое число.|  
  
 Переход в стек в последовательном порядке имеет следующие особенности:  
  
1.  `value1` помещается в стек.  
  
2.  `value2` помещается в стек.  
  
3.  `value2` и `value1` извлекаются из стека и их побитовое исключающее XOR.  
  
4.  Побитовое ИСКЛЮЧАЮЩее или `value2` и `value1` помещается в стек.  
  
 Инструкция `xor` рассчитывает побитовое ИСКЛЮЧАЮЩее и два верхних значения в стеке и оставляет результат в стеке.  
  
 `Xor` является операцией, относящейся к целому числу.  
  
 Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `xor`:  
  
-   ILGenerator. Emit (код операции)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
