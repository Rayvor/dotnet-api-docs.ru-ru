<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="31aacfb3c9c41209604373f1222ef49403dcd208" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73336605" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="de49f-101">Содержит поля, предоставляющие инструкции языка MSIL для выпуска элементами класса <see cref="T:System.Reflection.Emit.ILGenerator" /> (например, <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</span><span class="sxs-lookup"><span data-stu-id="de49f-101">Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <see cref="T:System.Reflection.Emit.ILGenerator" /> class members (such as <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-102">Подробное описание кодов операций для элементов см. в документации по Common Language Infrastructure (CLI), особенно в разделе III: набор инструкций CIL и "Секция II: определение метаданных и семантика".</span><span class="sxs-lookup"><span data-stu-id="de49f-102">For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially "Partition III: CIL Instruction Set" and "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="de49f-103">Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.</span><span class="sxs-lookup"><span data-stu-id="de49f-103">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="de49f-104">В следующем примере демонстрируется создание динамического метода с помощью <xref:System.Reflection.Emit.ILGenerator> для порождения `OpCodes` в <xref:System.Reflection.Emit.MethodBuilder>.</span><span class="sxs-lookup"><span data-stu-id="de49f-104">The following example demonstrates the construction of a dynamic method using <xref:System.Reflection.Emit.ILGenerator> to emit `OpCodes` into a <xref:System.Reflection.Emit.MethodBuilder>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-105">Складывает два значения и помещает результат в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-105">Adds two values and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-106">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-106">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-107">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-107">Format</span></span>|<span data-ttu-id="de49f-108">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-108">Assembly Format</span></span>|<span data-ttu-id="de49f-109">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-109">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-110">58</span><span class="sxs-lookup"><span data-stu-id="de49f-110">58</span></span>|<span data-ttu-id="de49f-111">add</span><span class="sxs-lookup"><span data-stu-id="de49f-111">add</span></span>|<span data-ttu-id="de49f-112">Складывает два числовых значения, возвращая новое числовое значение.</span><span class="sxs-lookup"><span data-stu-id="de49f-112">Adds two numeric values, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="de49f-113">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-113">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-114">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-114">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-115">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-115">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-116">`value2` и `value1` извлекаются из стека; `value1` добавляется в `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-116">`value2` and `value1` are popped from the stack; `value1` is added to `value2`.</span></span>  
  
4.  <span data-ttu-id="de49f-117">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-117">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-118">Переполнение не обнаружено для целочисленных операций (для правильной обработки переполнения см. <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span><span class="sxs-lookup"><span data-stu-id="de49f-118">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span></span>  
  
 <span data-ttu-id="de49f-119">Сложение целых чисел, а не насыщенность.</span><span class="sxs-lookup"><span data-stu-id="de49f-119">Integer addition wraps, rather than saturates.</span></span> <span data-ttu-id="de49f-120">Например, при использовании 8-разрядных целых чисел, где `value1` устанавливается равным 255, а `value2` — 1, то упакованным результатом будет 0, а не 256.</span><span class="sxs-lookup"><span data-stu-id="de49f-120">For example, assuming 8-bit integers where `value1` is set to 255 and `value2` is set to 1, the wrapped result is 0 rather than 256.</span></span>  
  
 <span data-ttu-id="de49f-121">Переполнение с плавающей точкой возвращает `+inf` (`PositiveInfinity`) или `-inf` (`NegativeInfinity`).</span><span class="sxs-lookup"><span data-stu-id="de49f-121">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="de49f-122">Допустимые типы операндов и соответствующий тип данных результата перечислены в таблице ниже.</span><span class="sxs-lookup"><span data-stu-id="de49f-122">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="de49f-123">Если нет записи для определенного сочетания типа (например, `int32` и `float`; `int32` и `int64`), это недопустимый MSIL и создает ошибку.</span><span class="sxs-lookup"><span data-stu-id="de49f-123">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</span></span>  
  
|<span data-ttu-id="de49f-124">операнд</span><span class="sxs-lookup"><span data-stu-id="de49f-124">operand</span></span>|<span data-ttu-id="de49f-125">Тип value1</span><span class="sxs-lookup"><span data-stu-id="de49f-125">value1 type</span></span>|<span data-ttu-id="de49f-126">Тип value2</span><span class="sxs-lookup"><span data-stu-id="de49f-126">value2 type</span></span>|<span data-ttu-id="de49f-127">Тип результата</span><span class="sxs-lookup"><span data-stu-id="de49f-127">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="de49f-128">add</span><span class="sxs-lookup"><span data-stu-id="de49f-128">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="de49f-129">add</span><span class="sxs-lookup"><span data-stu-id="de49f-129">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="de49f-130">add</span><span class="sxs-lookup"><span data-stu-id="de49f-130">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="de49f-131">add</span><span class="sxs-lookup"><span data-stu-id="de49f-131">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="de49f-132">add</span><span class="sxs-lookup"><span data-stu-id="de49f-132">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="de49f-133">add</span><span class="sxs-lookup"><span data-stu-id="de49f-133">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="de49f-134">add</span><span class="sxs-lookup"><span data-stu-id="de49f-134">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="de49f-135">add</span><span class="sxs-lookup"><span data-stu-id="de49f-135">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="de49f-136">add</span><span class="sxs-lookup"><span data-stu-id="de49f-136">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="de49f-137">add</span><span class="sxs-lookup"><span data-stu-id="de49f-137">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="de49f-138">add</span><span class="sxs-lookup"><span data-stu-id="de49f-138">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="de49f-139">add</span><span class="sxs-lookup"><span data-stu-id="de49f-139">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="de49f-140">add</span><span class="sxs-lookup"><span data-stu-id="de49f-140">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="de49f-141">add</span><span class="sxs-lookup"><span data-stu-id="de49f-141">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="de49f-142">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `add`:</span><span class="sxs-lookup"><span data-stu-id="de49f-142">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-143">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-143">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-144">Складывает два целых числа, выполняет проверку переполнения и помещает результат в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-144">Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-145">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-145">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-146">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-146">Format</span></span>|<span data-ttu-id="de49f-147">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-147">Assembly Format</span></span>|<span data-ttu-id="de49f-148">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-148">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-149">D6</span><span class="sxs-lookup"><span data-stu-id="de49f-149">D6</span></span>|<span data-ttu-id="de49f-150">Добавить. ovf</span><span class="sxs-lookup"><span data-stu-id="de49f-150">add.ovf</span></span>|<span data-ttu-id="de49f-151">Добавляет два целочисленных значения со знаком с помощью проверки переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-151">Adds two signed integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="de49f-152">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-152">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-153">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-153">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-154">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-154">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-155">`value2` и `value1` извлекаются из стека; `value1` добавляется в `value2` с помощью проверки переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-155">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="de49f-156">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-156">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-157"><xref:System.OverflowException> создается, если результат не представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-157"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-158">Эту операцию можно выполнить с целыми числами со знаком.</span><span class="sxs-lookup"><span data-stu-id="de49f-158">You can perform this operation on signed integers.</span></span> <span data-ttu-id="de49f-159">Для значений с плавающей запятой используйте <xref:System.Reflection.Emit.OpCodes.Add>.</span><span class="sxs-lookup"><span data-stu-id="de49f-159">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="de49f-160">Допустимые типы операндов и соответствующий тип данных результата перечислены в таблице ниже.</span><span class="sxs-lookup"><span data-stu-id="de49f-160">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="de49f-161">Если нет записи для определенного сочетания типа (например, `int32` и `float`; `int32` и `int64`), это недопустимая инструкция языка MSIL, которая выдает ошибку.</span><span class="sxs-lookup"><span data-stu-id="de49f-161">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="de49f-162">операнд</span><span class="sxs-lookup"><span data-stu-id="de49f-162">operand</span></span>|<span data-ttu-id="de49f-163">Тип value1</span><span class="sxs-lookup"><span data-stu-id="de49f-163">value1 type</span></span>|<span data-ttu-id="de49f-164">Тип value2</span><span class="sxs-lookup"><span data-stu-id="de49f-164">value2 type</span></span>|<span data-ttu-id="de49f-165">Тип результата</span><span class="sxs-lookup"><span data-stu-id="de49f-165">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="de49f-166">add</span><span class="sxs-lookup"><span data-stu-id="de49f-166">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="de49f-167">add</span><span class="sxs-lookup"><span data-stu-id="de49f-167">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="de49f-168">add</span><span class="sxs-lookup"><span data-stu-id="de49f-168">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="de49f-169">add</span><span class="sxs-lookup"><span data-stu-id="de49f-169">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="de49f-170">add</span><span class="sxs-lookup"><span data-stu-id="de49f-170">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="de49f-171">add</span><span class="sxs-lookup"><span data-stu-id="de49f-171">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="de49f-172">add</span><span class="sxs-lookup"><span data-stu-id="de49f-172">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="de49f-173">add</span><span class="sxs-lookup"><span data-stu-id="de49f-173">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="de49f-174">add</span><span class="sxs-lookup"><span data-stu-id="de49f-174">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="de49f-175">add</span><span class="sxs-lookup"><span data-stu-id="de49f-175">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="de49f-176">add</span><span class="sxs-lookup"><span data-stu-id="de49f-176">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="de49f-177">add</span><span class="sxs-lookup"><span data-stu-id="de49f-177">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="de49f-178">add</span><span class="sxs-lookup"><span data-stu-id="de49f-178">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="de49f-179">add</span><span class="sxs-lookup"><span data-stu-id="de49f-179">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="de49f-180">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `add.ovf`:</span><span class="sxs-lookup"><span data-stu-id="de49f-180">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-181">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-181">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-182">Складывает два целочисленных значения без знака, выполняет проверку переполнения и помещает результат в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-182">Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-183">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-183">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-184">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-184">Format</span></span>|<span data-ttu-id="de49f-185">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-185">Assembly Format</span></span>|<span data-ttu-id="de49f-186">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-186">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-187">D7</span><span class="sxs-lookup"><span data-stu-id="de49f-187">D7</span></span>|<span data-ttu-id="de49f-188">Добавить. ovf. un</span><span class="sxs-lookup"><span data-stu-id="de49f-188">add.ovf.un</span></span>|<span data-ttu-id="de49f-189">Добавляет два целочисленных значения без знака с помощью проверки переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-189">Adds two unsigned integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="de49f-190">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-190">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-191">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-191">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-192">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-192">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-193">`value2` и `value1` извлекаются из стека; `value1` добавляется в `value2` с помощью проверки переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-193">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="de49f-194">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-194">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-195"><xref:System.OverflowException> создается, если результат не представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-195"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-196">Эту операцию можно выполнить с целыми числами со знаком.</span><span class="sxs-lookup"><span data-stu-id="de49f-196">You can perform this operation on signed integers.</span></span> <span data-ttu-id="de49f-197">Для значений с плавающей запятой используйте <xref:System.Reflection.Emit.OpCodes.Add>.</span><span class="sxs-lookup"><span data-stu-id="de49f-197">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="de49f-198">Допустимые типы операндов и соответствующий тип данных результата перечислены в таблице ниже.</span><span class="sxs-lookup"><span data-stu-id="de49f-198">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="de49f-199">Если нет записи для определенного сочетания типа (например, `int32` и `float`; `int32` и `int64`), это недопустимая инструкция языка MSIL, которая выдает ошибку.</span><span class="sxs-lookup"><span data-stu-id="de49f-199">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="de49f-200">операнд</span><span class="sxs-lookup"><span data-stu-id="de49f-200">operand</span></span>|<span data-ttu-id="de49f-201">Тип value1</span><span class="sxs-lookup"><span data-stu-id="de49f-201">value1 type</span></span>|<span data-ttu-id="de49f-202">Тип value2</span><span class="sxs-lookup"><span data-stu-id="de49f-202">value2 type</span></span>|<span data-ttu-id="de49f-203">Тип результата</span><span class="sxs-lookup"><span data-stu-id="de49f-203">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="de49f-204">add</span><span class="sxs-lookup"><span data-stu-id="de49f-204">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="de49f-205">add</span><span class="sxs-lookup"><span data-stu-id="de49f-205">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="de49f-206">add</span><span class="sxs-lookup"><span data-stu-id="de49f-206">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="de49f-207">add</span><span class="sxs-lookup"><span data-stu-id="de49f-207">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="de49f-208">add</span><span class="sxs-lookup"><span data-stu-id="de49f-208">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="de49f-209">add</span><span class="sxs-lookup"><span data-stu-id="de49f-209">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="de49f-210">add</span><span class="sxs-lookup"><span data-stu-id="de49f-210">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="de49f-211">add</span><span class="sxs-lookup"><span data-stu-id="de49f-211">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="de49f-212">add</span><span class="sxs-lookup"><span data-stu-id="de49f-212">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="de49f-213">add</span><span class="sxs-lookup"><span data-stu-id="de49f-213">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="de49f-214">add</span><span class="sxs-lookup"><span data-stu-id="de49f-214">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="de49f-215">add</span><span class="sxs-lookup"><span data-stu-id="de49f-215">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="de49f-216">add</span><span class="sxs-lookup"><span data-stu-id="de49f-216">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="de49f-217">add</span><span class="sxs-lookup"><span data-stu-id="de49f-217">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="de49f-218">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `add.ovf.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-218">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-219">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-219">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-220">Вычисляет побитовое И двух значений и помещает результат в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-220">Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-221">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-221">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-222">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-222">Format</span></span>|<span data-ttu-id="de49f-223">Инструкция</span><span class="sxs-lookup"><span data-stu-id="de49f-223">Instruction</span></span>|<span data-ttu-id="de49f-224">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-224">Description</span></span>|  
|------------|-----------------|-----------------|  
|<span data-ttu-id="de49f-225">5F</span><span class="sxs-lookup"><span data-stu-id="de49f-225">5F</span></span>|<span data-ttu-id="de49f-226">и</span><span class="sxs-lookup"><span data-stu-id="de49f-226">and</span></span>|<span data-ttu-id="de49f-227">Определяет побитовое и для двух целочисленных значений.</span><span class="sxs-lookup"><span data-stu-id="de49f-227">Determines the bitwise AND of two integer values.</span></span>|  
  
 <span data-ttu-id="de49f-228">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-228">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-229">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-229">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-230">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-230">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-231">`value1` и `value2` извлекаются из стека; Побитовое и для двух значений является вычисленным.</span><span class="sxs-lookup"><span data-stu-id="de49f-231">`value1` and `value2` are popped from the stack; the bitwise AND of the two values is computed.</span></span>  
  
4.  <span data-ttu-id="de49f-232">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-232">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-233">Инструкция `and` рассчитывает побитовое и для двух верхних значений в стеке и оставляет результат в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-233">The `and` instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="de49f-234">`And` является операцией, относящейся к целому числу.</span><span class="sxs-lookup"><span data-stu-id="de49f-234">`And` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="de49f-235">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `and`:</span><span class="sxs-lookup"><span data-stu-id="de49f-235">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `and` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-236">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-236">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-237">Возвращает неуправляемый указатель на список аргументов текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-237">Returns an unmanaged pointer to the argument list of the current method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-238">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-238">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-239">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-239">Format</span></span>|<span data-ttu-id="de49f-240">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-240">Assembly Format</span></span>|<span data-ttu-id="de49f-241">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-241">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-242">FE 00</span><span class="sxs-lookup"><span data-stu-id="de49f-242">FE 00</span></span>|<span data-ttu-id="de49f-243">arglist</span><span class="sxs-lookup"><span data-stu-id="de49f-243">arglist</span></span>|<span data-ttu-id="de49f-244">Возвращает маркер списка аргументов для текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-244">Returns an argument list handle for the current method.</span></span>|  
  
 <span data-ttu-id="de49f-245">Эта операция не выполняет поведений стека вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-245">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="de49f-246">Инструкция `arglist` возвращает непрозрачный маркер (неуправляемый указатель типа `native int`), представляющий список аргументов текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-246">The `arglist` instruction returns an opaque handle (an unmanaged pointer, of type `native int`) that represents the argument list of the current method.</span></span> <span data-ttu-id="de49f-247">Этот маркер действителен только в течение времени существования текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-247">This handle is valid only during the lifetime of the current method.</span></span> <span data-ttu-id="de49f-248">Однако можно передать этот обработчик другим методам, если текущий метод находится в потоке управления.</span><span class="sxs-lookup"><span data-stu-id="de49f-248">You can, however, pass the handle to other methods as long as the current method is on the thread of control.</span></span> <span data-ttu-id="de49f-249">В методе, принимающем переменное число аргументов, можно выполнить только инструкцию `arglist`.</span><span class="sxs-lookup"><span data-stu-id="de49f-249">You can only execute the `arglist` instruction within a method that takes a variable number of arguments.</span></span>  
  
 <span data-ttu-id="de49f-250">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `arglist`:</span><span class="sxs-lookup"><span data-stu-id="de49f-250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `arglist` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-251">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-251">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-252">Передает управление конечной инструкции, если два значения равны.</span><span class="sxs-lookup"><span data-stu-id="de49f-252">Transfers control to a target instruction if two values are equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-253">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-253">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-254">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-254">Format</span></span>|<span data-ttu-id="de49f-255">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-255">Assembly Format</span></span>|<span data-ttu-id="de49f-256">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-256">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-257">3B < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de49f-257">3B < `int32` ></span></span>|<span data-ttu-id="de49f-258">Бек `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-258">beq `target`</span></span>|<span data-ttu-id="de49f-259">Выполняет переход к целевой инструкции со смещением `target`, если два значения равны.</span><span class="sxs-lookup"><span data-stu-id="de49f-259">Branch to the target instruction at offset `target` if the two values are equal.</span></span>|  
  
 <span data-ttu-id="de49f-260">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-260">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-261">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-261">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-262">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-262">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-263">`value2` и `value1` извлекаются из стека; Если `value1` равно `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-263">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-264">Инструкция `beq` передает управление в указанную целевую инструкцию, если `value1` равно `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-264">The `beq` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="de49f-265">Результат аналогичен выполнению инструкции `ceq`, за которой следует ветвь `brtrue` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-265">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-266">Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-266">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-267">Допустимые типы операндов инкапсулированы ниже:</span><span class="sxs-lookup"><span data-stu-id="de49f-267">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="de49f-268">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-268">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="de49f-269">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией (такие передачи являются строго ограниченными и должны использовать инструкцию <xref:System.Reflection.Emit.OpCodes.Leave>).</span><span class="sxs-lookup"><span data-stu-id="de49f-269">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="de49f-270">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `beq`:</span><span class="sxs-lookup"><span data-stu-id="de49f-270">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-271">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-271">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-272">Передает управление конечной инструкции (короткая форма), если два значения равны.</span><span class="sxs-lookup"><span data-stu-id="de49f-272">Transfers control to a target instruction (short form) if two values are equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-273">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-273">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-274">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-274">Format</span></span>|<span data-ttu-id="de49f-275">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-275">Assembly Format</span></span>|<span data-ttu-id="de49f-276">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-276">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-277">`int8`< 2E  ></span><span class="sxs-lookup"><span data-stu-id="de49f-277">2E < `int8` ></span></span>|<span data-ttu-id="de49f-278">Бек. s `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-278">beq.s `target`</span></span>|<span data-ttu-id="de49f-279">Переход к целевой инструкции со смещением `target`, если равно, краткая форма</span><span class="sxs-lookup"><span data-stu-id="de49f-279">Branch to the target instruction at offset `target` if equal, short form</span></span>|  
  
 <span data-ttu-id="de49f-280">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-280">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-281">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-281">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-282">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-282">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-283">`value2` и `value1` извлекаются из стека; Если `value1` равно `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-283">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-284">Инструкция `beq.s` передает управление в указанную целевую инструкцию, если `value1` равно `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-284">The `beq.s` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="de49f-285">Результат аналогичен выполнению инструкции `ceq`, за которой следует ветвь `brtrue` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-285">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-286">Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-286">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-287">Допустимые типы операндов инкапсулированы ниже:</span><span class="sxs-lookup"><span data-stu-id="de49f-287">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="de49f-288">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-288">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="de49f-289">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией (такие передачи являются строго ограниченными и должны использовать инструкцию <xref:System.Reflection.Emit.OpCodes.Leave>).</span><span class="sxs-lookup"><span data-stu-id="de49f-289">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="de49f-290">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `beq.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-290">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-291">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-291">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-292">Передает управление конечной инструкции, если первое значение больше второго или равно ему.</span><span class="sxs-lookup"><span data-stu-id="de49f-292">Transfers control to a target instruction if the first value is greater than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-293">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-293">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-294">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-294">Format</span></span>|<span data-ttu-id="de49f-295">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-295">Assembly Format</span></span>|<span data-ttu-id="de49f-296">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-296">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-297">3C `<int32>`</span><span class="sxs-lookup"><span data-stu-id="de49f-297">3C `<int32>`</span></span>|<span data-ttu-id="de49f-298">бже `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-298">bge `target`</span></span>|<span data-ttu-id="de49f-299">Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго или равно ему.</span><span class="sxs-lookup"><span data-stu-id="de49f-299">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="de49f-300">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-300">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-301">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-301">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-302">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-302">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-303">`value2` и `value1` извлекаются из стека; Если `value1` больше или равно `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-303">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-304">Инструкция `bge` передает управление в указанную целевую инструкцию, если `value1` больше или равен `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-304">The `bge` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="de49f-305">Этот результат идентичен выполнению инструкции `clt.un`, за которой следует ветвь `brfalse` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-305">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-306">Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-306">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-307">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-307">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-308">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-308">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-309">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bge`:</span><span class="sxs-lookup"><span data-stu-id="de49f-309">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-310">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-310">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-311">Передает управление конечной инструкции (короткая форма), если первое значение больше второго или равно ему.</span><span class="sxs-lookup"><span data-stu-id="de49f-311">Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-312">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-312">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-313">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-313">Format</span></span>|<span data-ttu-id="de49f-314">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-314">Assembly Format</span></span>|<span data-ttu-id="de49f-315">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-315">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-316">2F `<int8>`</span><span class="sxs-lookup"><span data-stu-id="de49f-316">2F `<int8>`</span></span>|<span data-ttu-id="de49f-317">бже. s `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-317">bge.s `target`</span></span>|<span data-ttu-id="de49f-318">Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго или равно ему (краткая форма).</span><span class="sxs-lookup"><span data-stu-id="de49f-318">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="de49f-319">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-319">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-320">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-320">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-321">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-321">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-322">`value2` и `value1` извлекаются из стека; Если `value1` больше или равно `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-322">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-323">Инструкция `bge.s` передает управление в указанную целевую инструкцию, если `value1` больше или равен `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-323">The `bge.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="de49f-324">Этот результат идентичен выполнению инструкции `clt.un`, за которой следует ветвь `brfalse` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-324">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-325">Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-325">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-326">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-326">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-327">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-327">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-328">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bge.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-328">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-329">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-329">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-330">Передает управление конечной инструкции, если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</span><span class="sxs-lookup"><span data-stu-id="de49f-330">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-331">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-331">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-332">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-332">Format</span></span>|<span data-ttu-id="de49f-333">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-333">Assembly Format</span></span>|<span data-ttu-id="de49f-334">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-334">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-335">41 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="de49f-335">41 `<int32>`</span></span>|<span data-ttu-id="de49f-336">бже. un `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-336">bge.un `target`</span></span>|<span data-ttu-id="de49f-337">Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше или равно второму значению (значения без знака).</span><span class="sxs-lookup"><span data-stu-id="de49f-337">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="de49f-338">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-338">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-339">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-339">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-340">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-340">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-341">`value2` и `value1` извлекаются из стека; Если `value1` больше или равно `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-341">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-342">Инструкция `bge.un` передает управление в указанную целевую инструкцию, если `value1` больше или равен `value2` при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="de49f-342">The `bge.un` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de49f-343">Этот результат идентичен выполнению инструкции `clt`, за которой следует ветвь `brfalse` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-343">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-344">Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-344">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-345">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-345">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-346">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-346">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-347">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bge.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-347">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-348">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-348">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-349">Передает управление конечной инструкции (короткая форма), если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</span><span class="sxs-lookup"><span data-stu-id="de49f-349">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-350">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-350">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-351">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-351">Format</span></span>|<span data-ttu-id="de49f-352">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-352">Assembly Format</span></span>|<span data-ttu-id="de49f-353">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-353">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-354">34 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de49f-354">34 < `int8` ></span></span>|<span data-ttu-id="de49f-355">бже. un. s `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-355">bge.un.s `target`</span></span>|<span data-ttu-id="de49f-356">Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше или равно второму (значения без знака), короткая форма.</span><span class="sxs-lookup"><span data-stu-id="de49f-356">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="de49f-357">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-357">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-358">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-358">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-359">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-359">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-360">`value2` и `value1` извлекаются из стека; Если `value1` больше или равно `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-360">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-361">Инструкция `bge.un.s` передает управление в указанную целевую инструкцию, если `value1` больше или равен `value2` при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="de49f-361">The `bge.un.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de49f-362">Этот результат идентичен выполнению инструкции `clt`, за которой следует ветвь `brfalse` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-362">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-363">Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-363">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-364">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-364">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-365">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-365">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-366">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bge.un.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-366">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-367">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-367">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-368">Передает управление конечной инструкции, если первое значение больше второго.</span><span class="sxs-lookup"><span data-stu-id="de49f-368">Transfers control to a target instruction if the first value is greater than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-369">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-369">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-370">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-370">Format</span></span>|<span data-ttu-id="de49f-371">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-371">Assembly Format</span></span>|<span data-ttu-id="de49f-372">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-372">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-373">Трехмерная < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de49f-373">3D < `int32` ></span></span>|<span data-ttu-id="de49f-374">БГТ `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-374">bgt `target`</span></span>|<span data-ttu-id="de49f-375">Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго.</span><span class="sxs-lookup"><span data-stu-id="de49f-375">Branch to the target instruction at the specified offset if the first value is greater than the second value.</span></span>|  
  
 <span data-ttu-id="de49f-376">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-376">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-377">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-377">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-378">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-378">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-379">`value2` и `value1` извлекаются из стека; Если `value1` больше, чем `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-379">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-380">Инструкция `bgt` передает управление указанной конечной инструкции, если `value1` больше, чем `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-380">The `bgt` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="de49f-381">Этот результат идентичен выполнению инструкции `cgt`, за которой следует ветвь `brtrue` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-381">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-382">Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-382">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-383">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-383">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-384">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-384">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-385">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bgt`:</span><span class="sxs-lookup"><span data-stu-id="de49f-385">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-386">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-386">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-387">Передает управление конечной инструкции (короткая форма), если первое значение больше второго.</span><span class="sxs-lookup"><span data-stu-id="de49f-387">Transfers control to a target instruction (short form) if the first value is greater than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-388">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-388">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-389">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-389">Format</span></span>|<span data-ttu-id="de49f-390">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-390">Assembly Format</span></span>|<span data-ttu-id="de49f-391">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-391">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-392">30 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de49f-392">30 < `int8` ></span></span>|<span data-ttu-id="de49f-393">БГТ. s `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-393">bgt.s `target`</span></span>|<span data-ttu-id="de49f-394">Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго (краткая форма).</span><span class="sxs-lookup"><span data-stu-id="de49f-394">Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.</span></span>|  
  
 <span data-ttu-id="de49f-395">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-395">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-396">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-396">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-397">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-397">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-398">`value2` и `value1` извлекаются из стека; Если `value1` больше, чем `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-398">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-399">Инструкция `bgt.s` передает управление указанной конечной инструкции, если `value1` больше, чем `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-399">The `bgt.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="de49f-400">Этот результат идентичен выполнению инструкции `cgt`, за которой следует ветвь `brtrue` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-400">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-401">Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-401">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-402">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-402">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-403">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-403">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-404">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bgt.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-404">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-405">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-405">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-406">Передает управление конечной инструкции, если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</span><span class="sxs-lookup"><span data-stu-id="de49f-406">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-407">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-407">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-408">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-408">Format</span></span>|<span data-ttu-id="de49f-409">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-409">Assembly Format</span></span>|<span data-ttu-id="de49f-410">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-410">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-411">42 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de49f-411">42 < `int32` ></span></span>|<span data-ttu-id="de49f-412">БГТ. un `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-412">bgt.un `target`</span></span>|<span data-ttu-id="de49f-413">Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго (значения без знака).</span><span class="sxs-lookup"><span data-stu-id="de49f-413">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="de49f-414">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-414">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-415">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-415">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-416">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-416">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-417">`value2` и `value1` извлекаются из стека; Если `value1` больше, чем `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-417">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-418">Инструкция `bgt.un` передает управление указанной конечной инструкции, если `value1` больше, чем `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="de49f-418">The `bgt.un` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de49f-419">Этот результат идентичен выполнению инструкции `cgt.un`, за которой следует ветвь `brtrue` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-419">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-420">Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-420">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-421">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-421">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-422">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-422">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-423">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bgt.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-423">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-424">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-424">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-425">Передает управление конечной инструкции (короткая форма), если первое значение больше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</span><span class="sxs-lookup"><span data-stu-id="de49f-425">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-426">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-426">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-427">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-427">Format</span></span>|<span data-ttu-id="de49f-428">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-428">Assembly Format</span></span>|<span data-ttu-id="de49f-429">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-429">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-430">35 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de49f-430">35 < `int8` ></span></span>|<span data-ttu-id="de49f-431">БГТ. un. s `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-431">bgt.un.s `target`</span></span>|<span data-ttu-id="de49f-432">Выполняет переход к целевой инструкции с указанным смещением, если первое значение больше второго (значения без знака), короткая форма.</span><span class="sxs-lookup"><span data-stu-id="de49f-432">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="de49f-433">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-433">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-434">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-434">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-435">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-435">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-436">`value2` и `value1` извлекаются из стека; Если `value1` больше, чем `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-436">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-437">Инструкция `bgt.un.s` передает управление указанной конечной инструкции, если `value1` больше, чем `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="de49f-437">The `bgt.un.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de49f-438">Этот результат идентичен выполнению инструкции `cgt.un`, за которой следует ветвь `brtrue` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-438">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-439">Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-439">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-440">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-440">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-441">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-441">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-442">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bgt.un.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-442">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-443">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-443">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-444">Передает управление конечной инструкции, если первое значение меньше второго значения или равно ему.</span><span class="sxs-lookup"><span data-stu-id="de49f-444">Transfers control to a target instruction if the first value is less than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-445">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-445">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-446">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-446">Format</span></span>|<span data-ttu-id="de49f-447">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-447">Assembly Format</span></span>|<span data-ttu-id="de49f-448">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-448">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-449">3E `<int32>`</span><span class="sxs-lookup"><span data-stu-id="de49f-449">3E `<int32>`</span></span>|<span data-ttu-id="de49f-450">BLE `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-450">ble `target`</span></span>|<span data-ttu-id="de49f-451">Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго или равно ему.</span><span class="sxs-lookup"><span data-stu-id="de49f-451">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="de49f-452">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-452">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-453">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-453">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-454">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-454">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-455">`value2` и `value1` извлекаются из стека; Если `value1` меньше или равно `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-455">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-456">Инструкция `ble` передает управление указанной конечной инструкции, если `value1` меньше или равно `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-456">The `ble` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="de49f-457">Этот результат идентичен выполнению инструкции `cgt` (`cgt.un` для float), за которой следует ветвь `brfalse` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-457">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-458">Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-458">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-459">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-459">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-460">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-460">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-461">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ble`:</span><span class="sxs-lookup"><span data-stu-id="de49f-461">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-462">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-462">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-463">Передает управление конечной инструкции (короткая форма), если первое значение меньше второго или равно ему.</span><span class="sxs-lookup"><span data-stu-id="de49f-463">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-464">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-464">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-465">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-465">Format</span></span>|<span data-ttu-id="de49f-466">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-466">Assembly Format</span></span>|<span data-ttu-id="de49f-467">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-467">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-468">31 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="de49f-468">31 `<int8>`</span></span>|<span data-ttu-id="de49f-469">BLE. s `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-469">ble.s `target`</span></span>|<span data-ttu-id="de49f-470">Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго или равно ему (короткая форма).</span><span class="sxs-lookup"><span data-stu-id="de49f-470">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="de49f-471">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-471">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-472">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-472">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-473">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-473">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-474">`value2` и `value1` извлекаются из стека; Если `value1` меньше или равно `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-474">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-475">Инструкция `ble.s` передает управление указанной конечной инструкции, если `value1` меньше или равно `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-475">The `ble.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="de49f-476">Этот результат идентичен выполнению инструкции `cgt` инструкции (`cgt.un` for float), за которой следует`brfalse`ная ветвь к конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-476">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) instruction followed by a`brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-477">Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-477">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-478">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-478">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-479">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-479">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-480">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ble.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-481">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-481">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-482">Передает управление конечной инструкции, если первое значение меньше второго или равно ему (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</span><span class="sxs-lookup"><span data-stu-id="de49f-482">Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-483">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-484">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-484">Format</span></span>|<span data-ttu-id="de49f-485">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-485">Assembly Format</span></span>|<span data-ttu-id="de49f-486">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-487">43 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="de49f-487">43 `<int32>`</span></span>|<span data-ttu-id="de49f-488">BLE. un `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-488">ble.un `target`</span></span>|<span data-ttu-id="de49f-489">Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше или равно второму значению (значения без знака).</span><span class="sxs-lookup"><span data-stu-id="de49f-489">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="de49f-490">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-491">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-491">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-492">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-492">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-493">`value2` и `value1` извлекаются из стека; Если `value1` меньше или равно `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-493">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-494">Инструкция `ble.un` передает управление в указанную целевую инструкцию, если `value1` меньше или равен `value2` при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="de49f-494">The `ble.un` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de49f-495">Этот результат идентичен выполнению инструкции `cgt.un` (`cgt` для float), за которой следует ветвь `brfalse` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-495">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-496">Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-496">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-497">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-497">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-498">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-498">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-499">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ble.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-499">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-500">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-500">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-501">Передает управление конечной инструкции (короткая форма), если первое значение меньше второго или равно ему (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</span><span class="sxs-lookup"><span data-stu-id="de49f-501">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-502">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-502">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-503">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-503">Format</span></span>|<span data-ttu-id="de49f-504">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-504">Assembly Format</span></span>|<span data-ttu-id="de49f-505">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-505">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-506">36 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="de49f-506">36 `<int8>`</span></span>|<span data-ttu-id="de49f-507">BLE. un. s `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-507">ble.un.s `target`</span></span>|<span data-ttu-id="de49f-508">Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше или равно второму (значения без знака), короткая форма.</span><span class="sxs-lookup"><span data-stu-id="de49f-508">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="de49f-509">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-509">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-510">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-510">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-511">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-511">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-512">`value2` и `value1` извлекаются из стека; Если `value1` меньше или равно `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-512">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-513">Инструкция `ble.un.s` передает управление в указанную целевую инструкцию, если `value1` меньше или равен `value2` при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="de49f-513">The `ble.un.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de49f-514">Этот результат идентичен выполнению инструкции `cgt.un` (`cgt` для float), за которой следует ветвь `brfalse` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-514">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-515">Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-515">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-516">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-516">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-517">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-517">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-518">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ble.un.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-518">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-519">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-519">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-520">Передает управление конечной инструкции, если первое значение меньше второго.</span><span class="sxs-lookup"><span data-stu-id="de49f-520">Transfers control to a target instruction if the first value is less than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-521">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-521">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-522">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-522">Format</span></span>|<span data-ttu-id="de49f-523">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-523">Assembly Format</span></span>|<span data-ttu-id="de49f-524">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-524">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-525">3F < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de49f-525">3F < `int32` ></span></span>|<span data-ttu-id="de49f-526">БЛТ `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-526">blt `target`</span></span>|<span data-ttu-id="de49f-527">Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго.</span><span class="sxs-lookup"><span data-stu-id="de49f-527">Branch to the target instruction at the specified offset if the first value is less than the second value.</span></span>|  
  
 <span data-ttu-id="de49f-528">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-528">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-529">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-529">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-530">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-530">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-531">`value2` и `value1` извлекаются из стека; Если `value1` меньше `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-531">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-532">Инструкция `blt` передает управление указанной конечной инструкции, если `value1` меньше или равно `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-532">The `blt` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="de49f-533">Этот результат идентичен выполнению инструкции `clt`, за которой следует ветвь `brtrue` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-533">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-534">Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-534">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-535">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-535">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-536">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-536">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-537">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `blt`:</span><span class="sxs-lookup"><span data-stu-id="de49f-537">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-538">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-538">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-539">Передает управление конечной инструкции (короткая форма), если первое значение меньше второго значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-539">Transfers control to a target instruction (short form) if the first value is less than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-540">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-540">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-541">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-541">Format</span></span>|<span data-ttu-id="de49f-542">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-542">Assembly Format</span></span>|<span data-ttu-id="de49f-543">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-543">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-544">32 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de49f-544">32 < `int8` ></span></span>|<span data-ttu-id="de49f-545">БЛТ. s `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-545">blt.s `target`</span></span>|<span data-ttu-id="de49f-546">Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго (краткая форма).</span><span class="sxs-lookup"><span data-stu-id="de49f-546">Branch to the target instruction at the specified offset if the first value is less than the second value, short form.</span></span>|  
  
 <span data-ttu-id="de49f-547">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-547">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-548">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-548">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-549">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-549">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-550">`value2` и `value1` извлекаются из стека; Если `value1` меньше `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-550">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-551">Инструкция `blt.s` передает управление указанной конечной инструкции, если `value1` меньше, чем `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-551">The `blt.s` instruction transfers control to the specified target instruction if `value1` is less than `value2`.</span></span> <span data-ttu-id="de49f-552">Этот результат идентичен выполнению инструкции `clt`, за которой следует ветвь `brtrue` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-552">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-553">Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-553">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-554">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-554">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-555">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-555">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-556">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `blt.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-556">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-557">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-557">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-558">Передает управление конечной инструкции, если первое значение меньше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</span><span class="sxs-lookup"><span data-stu-id="de49f-558">Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-559">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-559">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-560">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-560">Format</span></span>|<span data-ttu-id="de49f-561">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-561">Assembly Format</span></span>|<span data-ttu-id="de49f-562">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-562">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-563">44 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de49f-563">44 < `int32` ></span></span>|<span data-ttu-id="de49f-564">БЛТ. un `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-564">blt.un `target`</span></span>|<span data-ttu-id="de49f-565">Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго (значения без знака).</span><span class="sxs-lookup"><span data-stu-id="de49f-565">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="de49f-566">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-566">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-567">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-567">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-568">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-568">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-569">`value2` и `value1` извлекаются из стека; Если `value1` меньше `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-569">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-570">Инструкция `blt.un` передает управление указанной конечной инструкции, если `value1` меньше, чем `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="de49f-570">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de49f-571">Этот результат идентичен выполнению инструкции `clt.un`, за которой следует ветвь `brtrue` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-571">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-572">Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-572">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-573">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-573">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-574">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-574">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-575">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `blt.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-575">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-576">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-576">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-577">Передает управление конечной инструкции (короткая форма), если первое значение меньше второго (при сравнении целочисленных значений без знака или неупорядоченных значений с плавающей запятой).</span><span class="sxs-lookup"><span data-stu-id="de49f-577">Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-578">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-578">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-579">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-579">Format</span></span>|<span data-ttu-id="de49f-580">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-580">Assembly Format</span></span>|<span data-ttu-id="de49f-581">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-581">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-582">37 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de49f-582">37 < `int8` ></span></span>|<span data-ttu-id="de49f-583">БЛТ. un. s `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-583">blt.un.s `target`</span></span>|<span data-ttu-id="de49f-584">Выполняет переход к целевой инструкции с указанным смещением, если первое значение меньше второго (значения без знака), короткая форма.</span><span class="sxs-lookup"><span data-stu-id="de49f-584">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="de49f-585">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-585">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-586">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-586">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-587">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-587">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-588">`value2` и `value1` извлекаются из стека; Если `value1` меньше `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-588">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-589">Инструкция `blt.un` передает управление указанной конечной инструкции, если `value1` меньше, чем `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="de49f-589">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de49f-590">Этот результат идентичен выполнению инструкции `clt.un`, за которой следует ветвь `brtrue` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-590">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-591">Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-591">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-592">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-592">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-593">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-593">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-594">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `blt.un.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-594">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-595">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-595">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-596">Передает управление конечной инструкции в случае неравенства двух целочисленных значений без знака или двух неупорядоченных значений с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="de49f-596">Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-597">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-597">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-598">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-598">Format</span></span>|<span data-ttu-id="de49f-599">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-599">Assembly Format</span></span>|<span data-ttu-id="de49f-600">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-600">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-601">40 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de49f-601">40 < `int32` ></span></span>|<span data-ttu-id="de49f-602">бне. un `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-602">bne.un `target`</span></span>|<span data-ttu-id="de49f-603">Выполняет переход к целевой инструкции с указанным смещением, если два целочисленных значения без знака не равны (значения без знака).</span><span class="sxs-lookup"><span data-stu-id="de49f-603">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).</span></span>|  
  
 <span data-ttu-id="de49f-604">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-604">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-605">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-605">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-606">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-606">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-607">`value2` и `value1` извлекаются из стека; Если `value1` не равно `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-607">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-608">Инструкция `bne.un` передает управление указанной конечной инструкции, если `value1` не равно `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="de49f-608">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de49f-609">Этот результат идентичен выполнению инструкции `ceq`, за которой следует ветвь `brfalse` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-609">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-610">Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-610">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-611">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-611">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-612">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-612">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-613">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bne.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-613">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-614">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-614">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-615">Передает управление конечной инструкции (короткая форма) в случае неравенства двух целочисленных значений без знака или двух неупорядоченных значений с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="de49f-615">Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-616">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-616">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-617">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-617">Format</span></span>|<span data-ttu-id="de49f-618">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-618">Assembly Format</span></span>|<span data-ttu-id="de49f-619">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-619">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-620">33 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de49f-620">33 < `int8` ></span></span>|<span data-ttu-id="de49f-621">бне. un. s `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-621">bne.un.s `target`</span></span>|<span data-ttu-id="de49f-622">Выполняет переход к целевой инструкции с указанным смещением, если два целочисленных значения без знака не равны (значения без знака), краткая форма.</span><span class="sxs-lookup"><span data-stu-id="de49f-622">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="de49f-623">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-623">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-624">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-624">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-625">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-625">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-626">`value2` и `value1` извлекаются из стека; Если `value1` не равно `value2`, выполняется операция ветвления.</span><span class="sxs-lookup"><span data-stu-id="de49f-626">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="de49f-627">Инструкция `bne.un` передает управление указанной конечной инструкции, если `value1` не равно `value2`, при сравнении с использованием целого числа без знака или неупорядоченных значений с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="de49f-627">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="de49f-628">Этот результат идентичен выполнению инструкции `ceq`, за которой следует ветвь `brfalse` для конкретной целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-628">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="de49f-629">Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-629">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-630">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-630">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-631">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-631">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-632">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `bne.un.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-632">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-633">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-633">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-634">Преобразует тип значения в ссылку на объект (тип <see langword="O" />).</span><span class="sxs-lookup"><span data-stu-id="de49f-634">Converts a value type to an object reference (type <see langword="O" />).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-635">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-635">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-636">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-636">Format</span></span>|<span data-ttu-id="de49f-637">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-637">Assembly Format</span></span>|<span data-ttu-id="de49f-638">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-638">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-639">8В < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-639">8C < `T` ></span></span>|<span data-ttu-id="de49f-640">Box `valTypeToken`</span><span class="sxs-lookup"><span data-stu-id="de49f-640">box `valTypeToken`</span></span>|<span data-ttu-id="de49f-641">Преобразование типа значения (типа, указанного в `valTypeToken`) в истинную ссылку на объект.</span><span class="sxs-lookup"><span data-stu-id="de49f-641">Convert a value type (of the type specified in `valTypeToken`) to a true object reference.</span></span>|  
  
 <span data-ttu-id="de49f-642">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-642">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-643">Тип значения помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-643">A value type is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-644">Тип значения извлекается из стека; выполняется операция `box`.</span><span class="sxs-lookup"><span data-stu-id="de49f-644">The value type is popped from the stack; the `box` operation is performed.</span></span>  
  
3.  <span data-ttu-id="de49f-645">Ссылка на объект, получивший "упакованный" тип значения, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-645">An object reference to the resulting "boxed" value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-646">Тип значения имеет два отдельных представления в Common Language Infrastructure (CLI):</span><span class="sxs-lookup"><span data-stu-id="de49f-646">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="de49f-647">Необработанная форма, используемая при внедрении типа значения в другой объект или в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-647">A 'raw' form used when a value type is embedded within another object or on the stack.</span></span>  
  
-   <span data-ttu-id="de49f-648">"Упакованная" форма, в которой данные в типе значения упаковываются (упаковываются) в объект, поэтому он может существовать как независимая сущность.</span><span class="sxs-lookup"><span data-stu-id="de49f-648">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="de49f-649">Инструкция `box` преобразует необработанный (неупакованный) тип значения в ссылку на объект (тип `O`).</span><span class="sxs-lookup"><span data-stu-id="de49f-649">The `box` instruction converts the 'raw' (unboxed) value type into an object reference (type `O`).</span></span> <span data-ttu-id="de49f-650">Это достигается путем создания нового объекта и копирования данных из типа значения в новый выделенный объект.</span><span class="sxs-lookup"><span data-stu-id="de49f-650">This is accomplished by creating a new object and copying the data from the value type into the newly allocated object.</span></span> <span data-ttu-id="de49f-651">`valTypeToken` является маркером метаданных, указывающим тип значения в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-651">`valTypeToken` is a metadata token indicating the type of the value type on the stack.</span></span>  
  
 <span data-ttu-id="de49f-652"><xref:System.OutOfMemoryException> возникает, если недостаточно памяти для удовлетворения запроса.</span><span class="sxs-lookup"><span data-stu-id="de49f-652"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="de49f-653">Если класс не найден, возникает исключение <xref:System.TypeLoadException>.</span><span class="sxs-lookup"><span data-stu-id="de49f-653"><xref:System.TypeLoadException> is thrown if the class cannot be found.</span></span> <span data-ttu-id="de49f-654">Обычно это обнаруживается при преобразовании MSIL в машинный код, а не во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-654">This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="de49f-655">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `box`:</span><span class="sxs-lookup"><span data-stu-id="de49f-655">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `box` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-656">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-656">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-657">Обеспечивает безусловную передачу управления конечной инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-657">Unconditionally transfers control to a target instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-658">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-658">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-659">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-659">Format</span></span>|<span data-ttu-id="de49f-660">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-660">Assembly Format</span></span>|<span data-ttu-id="de49f-661">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-661">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-662">38 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de49f-662">38 < `int32` ></span></span>|<span data-ttu-id="de49f-663">br `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-663">br `target`</span></span>|<span data-ttu-id="de49f-664">Выполняет переход к целевой инструкции по указанному смещению.</span><span class="sxs-lookup"><span data-stu-id="de49f-664">Branches to a target instruction at the specified offset.</span></span>|  
  
 <span data-ttu-id="de49f-665">Эта операция не выполняет поведений стека вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-665">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="de49f-666">Инструкция `br` безусловно передает управление целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-666">The `br` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="de49f-667">Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-667">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-668">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-668">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-669">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-669">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-670">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `br`:</span><span class="sxs-lookup"><span data-stu-id="de49f-670">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-671">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-671">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-672">Обеспечивает безусловную передачу управления конечной инструкции (короткая форма).</span><span class="sxs-lookup"><span data-stu-id="de49f-672">Unconditionally transfers control to a target instruction (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-673">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-673">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-674">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-674">Format</span></span>|<span data-ttu-id="de49f-675">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-675">Assembly Format</span></span>|<span data-ttu-id="de49f-676">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-676">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-677">2B < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de49f-677">2B < `int8` ></span></span>|<span data-ttu-id="de49f-678">br. s `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-678">br.s `target`</span></span>|<span data-ttu-id="de49f-679">Выполняет переход к целевой инструкции по указанному смещению (краткая форма).</span><span class="sxs-lookup"><span data-stu-id="de49f-679">Branches to a target instruction at the specified offset, short form.</span></span>|  
  
 <span data-ttu-id="de49f-680">Эта операция не выполняет поведений стека вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-680">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="de49f-681">Инструкция `br.s` безусловно передает управление целевой инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-681">The `br.s` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="de49f-682">Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-682">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-683">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-683">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-684">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-684">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-685">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `br.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-685">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-686">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-686">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-687">Сообщает инфраструктуре CLI, что необходимо оповестить отладчик о достижении точки останова.</span><span class="sxs-lookup"><span data-stu-id="de49f-687">Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-688">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-688">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-689">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-689">Format</span></span>|<span data-ttu-id="de49f-690">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-690">Assembly Format</span></span>|<span data-ttu-id="de49f-691">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-691">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-692">01</span><span class="sxs-lookup"><span data-stu-id="de49f-692">01</span></span>|<span data-ttu-id="de49f-693">break</span><span class="sxs-lookup"><span data-stu-id="de49f-693">break</span></span>|<span data-ttu-id="de49f-694">Сообщите отладчику о достижении точки останова.</span><span class="sxs-lookup"><span data-stu-id="de49f-694">inform a debugger that a breakpoint has been reached.</span></span>|  
  
 <span data-ttu-id="de49f-695">Эта операция не выполняет поведений стека вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-695">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="de49f-696">Инструкция `break` предназначена для поддержки отладки.</span><span class="sxs-lookup"><span data-stu-id="de49f-696">The `break` instruction is for debugging support.</span></span> <span data-ttu-id="de49f-697">Он сигнализирует интерфейсу командной строки сообщить отладчику о том, что точка останова была остановлена.</span><span class="sxs-lookup"><span data-stu-id="de49f-697">It signals the CLI to inform the debugger that a break point has been tripped.</span></span> <span data-ttu-id="de49f-698">Он не влияет на состояние интерпретатора.</span><span class="sxs-lookup"><span data-stu-id="de49f-698">It has no other effect on the interpreter state.</span></span>  
  
 <span data-ttu-id="de49f-699">Инструкция `break` имеет наименьший возможный размер инструкции, позволяя выполнять исправление кода с точкой останова и создавать минимальный беспорядки вокруг окружающего кода.</span><span class="sxs-lookup"><span data-stu-id="de49f-699">The `break` instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</span></span>  
  
 <span data-ttu-id="de49f-700">Инструкция `break` может быть перехватываться в отладчике, не выполнять никаких действий или вызывать исключение безопасности.</span><span class="sxs-lookup"><span data-stu-id="de49f-700">The `break` instruction can trap to a debugger, do nothing, or raise a security exception.</span></span> <span data-ttu-id="de49f-701">Точное поведение определяется реализацией.</span><span class="sxs-lookup"><span data-stu-id="de49f-701">The exact behavior is implementation-defined.</span></span>  
  
 <span data-ttu-id="de49f-702">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `break`:</span><span class="sxs-lookup"><span data-stu-id="de49f-702">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `break` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-703">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-703">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-704">Передает управление конечной инструкции, если значением <paramref name="value" /> является <see langword="false" />, пустая ссылка (<see langword="Nothing" /> в Visual Basic) или ноль.</span><span class="sxs-lookup"><span data-stu-id="de49f-704">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference (<see langword="Nothing" /> in Visual Basic), or zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-705">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-705">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-706">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-706">Format</span></span>|<span data-ttu-id="de49f-707">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-707">Assembly Format</span></span>|<span data-ttu-id="de49f-708">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-708">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-709">39 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de49f-709">39 < `int32` ></span></span>|<span data-ttu-id="de49f-710">брфалсе `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-710">brfalse `target`</span></span><br /><br /> <span data-ttu-id="de49f-711">брнулл `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-711">brnull `target`</span></span><br /><br /> <span data-ttu-id="de49f-712">брзеро `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-712">brzero `target`</span></span>|<span data-ttu-id="de49f-713">Выполняет переход к целевой инструкции с указанным смещением, если `false`.</span><span class="sxs-lookup"><span data-stu-id="de49f-713">Branches to a target instruction at the specified offset if `false`.</span></span>|  
  
 <span data-ttu-id="de49f-714">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-714">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-715">`value` помещается в стек с помощью предыдущей операции.</span><span class="sxs-lookup"><span data-stu-id="de49f-715">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="de49f-716">`value` извлекается из стека; Если `value` — `false`, ветвь устанавливается в `target`.</span><span class="sxs-lookup"><span data-stu-id="de49f-716">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="de49f-717">Инструкция `brfalse` (и ее псевдонимы `brnull` и `brzero`) передает управление указанной конечной инструкции, если `value` (тип `int32`, `int64`, ссылка на объект `O`, управляемый указатель `&`, временный указатель `*`, `native int`) равен нулю. (0).`false`</span><span class="sxs-lookup"><span data-stu-id="de49f-717">The `brfalse` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="de49f-718">Если `value` не равно нулю (`true`), продолжение выполнения выполняется в следующей инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-718">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="de49f-719">Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-719">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-720">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-720">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-721">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-721">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-722">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `brfalse`:</span><span class="sxs-lookup"><span data-stu-id="de49f-722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-723">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-723">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-724">Передает управление конечной инструкции, если значением <paramref name="value" /> является <see langword="false" />, пустая ссылка или ноль.</span><span class="sxs-lookup"><span data-stu-id="de49f-724">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference, or zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-725">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-726">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-726">Format</span></span>|<span data-ttu-id="de49f-727">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-727">Assembly Format</span></span>|<span data-ttu-id="de49f-728">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-729">2C <`int8` ></span><span class="sxs-lookup"><span data-stu-id="de49f-729">2C <`int8` ></span></span>|<span data-ttu-id="de49f-730">брфалсе. s `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-730">brfalse.s `target`</span></span><br /><br /> <span data-ttu-id="de49f-731">брнулл. s `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-731">brnull.s `target`</span></span><br /><br /> <span data-ttu-id="de49f-732">брзеро. s `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-732">brzero.s `target`</span></span>|<span data-ttu-id="de49f-733">Выполняет переход к целевой инструкции с указанным смещением, если `false`, короткая форма.</span><span class="sxs-lookup"><span data-stu-id="de49f-733">Branches to a target instruction at the specified offset if `false`, short form.</span></span>|  
  
 <span data-ttu-id="de49f-734">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-734">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-735">`value` помещается в стек с помощью предыдущей операции.</span><span class="sxs-lookup"><span data-stu-id="de49f-735">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="de49f-736">`value` извлекается из стека; Если `value` — `false`, ветвь устанавливается в `target`.</span><span class="sxs-lookup"><span data-stu-id="de49f-736">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="de49f-737">Инструкция `brfalse.s` (и ее псевдонимы `brnull` и `brzero`) передает управление указанной конечной инструкции, если `value` (тип `int32`, `int64`, ссылка на объект `O`, управляемый указатель `&`, временный указатель `*`, `native int`) равен нулю. (0).`false`</span><span class="sxs-lookup"><span data-stu-id="de49f-737">The `brfalse.s` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="de49f-738">Если `value` не равно нулю (`true`), продолжение выполнения выполняется в следующей инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-738">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="de49f-739">Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-739">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-740">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-740">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-741">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-741">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-742">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `brfalse.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-742">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-743">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-743">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-744">Передает управление конечной инструкции, если значение <paramref name="value" /> равно <see langword="true" />, либо отличается от null и от нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-744">Transfers control to a target instruction if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-745">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-745">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-746">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-746">Format</span></span>|<span data-ttu-id="de49f-747">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-747">Assembly Format</span></span>|<span data-ttu-id="de49f-748">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-748">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-749">< 3A `int32` ></span><span class="sxs-lookup"><span data-stu-id="de49f-749">3A < `int32` ></span></span>|<span data-ttu-id="de49f-750">требовалась brtrue `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-750">brtrue `target`</span></span><br /><br /> <span data-ttu-id="de49f-751">бринст `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-751">brinst `target`</span></span>|<span data-ttu-id="de49f-752">Выполняет переход к целевой инструкции с указанным смещением, если не равен нулю (`true`).</span><span class="sxs-lookup"><span data-stu-id="de49f-752">Branch to a target instruction at the specified offset if non-zero (`true`).</span></span>|  
  
 <span data-ttu-id="de49f-753">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-753">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-754">`value` помещается в стек с помощью предыдущей операции.</span><span class="sxs-lookup"><span data-stu-id="de49f-754">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="de49f-755">`value` извлекается из стека; Если `value` — `true`, ветвь устанавливается в `target`.</span><span class="sxs-lookup"><span data-stu-id="de49f-755">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="de49f-756">Инструкция `brtrue` передает управление указанной конечной инструкции, если `value` (тип `native int`) не равен нулю (`true`).</span><span class="sxs-lookup"><span data-stu-id="de49f-756">The `brtrue` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="de49f-757">Если `value` равно нулю (`false`), выполнение продолжится в следующей инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-757">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="de49f-758">Если `value` является ссылкой на объект (тип `O`), то `brinst` (псевдоним для `brtrue`) передает управление, если он представляет экземпляр объекта (например, если он не является ссылкой на объект null; см. <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span><span class="sxs-lookup"><span data-stu-id="de49f-758">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="de49f-759">Целевая инструкция представляется как смещение со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-759">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-760">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-760">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-761">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-761">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-762">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `brtrue`:</span><span class="sxs-lookup"><span data-stu-id="de49f-762">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-763">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-763">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-764">Передает управление конечной инструкции (короткая форма), если значение <paramref name="value" /> равно <see langword="true" /> либо отличается от null и от нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-764">Transfers control to a target instruction (short form) if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-765">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-765">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-766">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-766">Format</span></span>|<span data-ttu-id="de49f-767">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-767">Assembly Format</span></span>|<span data-ttu-id="de49f-768">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-768">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-769">`int8`2D-<  ></span><span class="sxs-lookup"><span data-stu-id="de49f-769">2D < `int8` ></span></span>|<span data-ttu-id="de49f-770">требовалась brtrue. s `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-770">brtrue.s `target`</span></span><br /><br /> <span data-ttu-id="de49f-771">бринст. s `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-771">brinst.s `target`</span></span>|<span data-ttu-id="de49f-772">Переход к целевой инструкции с указанным смещением, если ненулевое значение (`true`), краткая форма.</span><span class="sxs-lookup"><span data-stu-id="de49f-772">Branch to a target instruction at the specified offset if non-zero (`true`), short form.</span></span>|  
  
 <span data-ttu-id="de49f-773">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-773">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-774">`value` помещается в стек с помощью предыдущей операции.</span><span class="sxs-lookup"><span data-stu-id="de49f-774">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="de49f-775">`value` извлекается из стека; Если `value` — `true`, ветвь устанавливается в `target`.</span><span class="sxs-lookup"><span data-stu-id="de49f-775">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="de49f-776">Инструкция `brtrue.s` передает управление указанной конечной инструкции, если `value` (тип `native int`) не равен нулю (`true`).</span><span class="sxs-lookup"><span data-stu-id="de49f-776">The `brtrue.s` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="de49f-777">Если `value` равно нулю (`false`), выполнение продолжится в следующей инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-777">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="de49f-778">Если `value` является ссылкой на объект (тип `O`), то `brinst` (псевдоним для `brtrue`) передает управление, если он представляет экземпляр объекта (например, если он не является ссылкой на объект null; см. <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span><span class="sxs-lookup"><span data-stu-id="de49f-778">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="de49f-779">Целевая инструкция представлена как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-779">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-780">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-780">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="de49f-781">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-781">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="de49f-782">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `brtrue.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-782">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-783">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-783">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-784">Вызывает метод, на который ссылается переданный дескриптор метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-784">Calls the method indicated by the passed method descriptor.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-785">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-785">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-786">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-786">Format</span></span>|<span data-ttu-id="de49f-787">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-787">Assembly Format</span></span>|<span data-ttu-id="de49f-788">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-788">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-789">28 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-789">28 < `T` ></span></span>|<span data-ttu-id="de49f-790">вызов `methodDesc`</span><span class="sxs-lookup"><span data-stu-id="de49f-790">call `methodDesc`</span></span>|<span data-ttu-id="de49f-791">Вызовите метод, описанный `methodDesc`.</span><span class="sxs-lookup"><span data-stu-id="de49f-791">Call the method described by `methodDesc`.</span></span>|  
  
 <span data-ttu-id="de49f-792">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-792">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-793">Аргументы метода, `arg1` с помощью `argN`, помещаются в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-793">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-794">Аргументы метода, `arg1` с помощью `argN`, извлекаются из стека; вызов метода выполняется с этими аргументами, и управление передается методу, на который ссылается дескриптор метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-794">Method arguments `arg1` through `argN` are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor.</span></span> <span data-ttu-id="de49f-795">По завершении возвращаемое значение создается вызываемым методом и отправляется вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="de49f-795">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
3.  <span data-ttu-id="de49f-796">Возвращаемое значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-796">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-797">Инструкция `call` вызывает метод, указанный дескриптором метода, передаваемым с помощью инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-797">The `call` instruction calls the method indicated by the method descriptor passed with the instruction.</span></span> <span data-ttu-id="de49f-798">Дескриптор метода — это маркер метаданных, указывающий вызываемый метод и число, тип и порядок аргументов, которые были помещены в стек для передачи в этот метод, а также соглашение о вызовах для использования.</span><span class="sxs-lookup"><span data-stu-id="de49f-798">The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used.</span></span> <span data-ttu-id="de49f-799">Инструкция `call` может предшествовать префиксу `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>), чтобы указать, что текущее состояние метода должно быть освобождено перед передачей управления.</span><span class="sxs-lookup"><span data-stu-id="de49f-799">The `call` instruction can be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix instruction to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="de49f-800">Если вызов передает управление методу более высокого уровня доверия, чем метод источника, кадр стека не освобождается.</span><span class="sxs-lookup"><span data-stu-id="de49f-800">If the call transfers control to a method of higher trust than the origin method, the stack frame is not released.</span></span> <span data-ttu-id="de49f-801">Вместо этого выполнение продолжится автоматически, как если бы `tail` не было предоставлено.</span><span class="sxs-lookup"><span data-stu-id="de49f-801">Instead, the execution continues silently as if the `tail` had not been supplied.</span></span> <span data-ttu-id="de49f-802">Маркер метаданных содержит достаточную информацию для определения того, относится ли вызов к статическому методу, методу экземпляра, виртуальному методу или глобальной функции.</span><span class="sxs-lookup"><span data-stu-id="de49f-802">The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function.</span></span> <span data-ttu-id="de49f-803">Во всех этих случаях адрес назначения определяется исключительно из дескриптора метода (Сравните это с инструкцией <xref:System.Reflection.Emit.OpCodes.Callvirt> для вызова виртуальных методов, где адрес назначения также зависит от типа среды выполнения ссылки на экземпляр помещается перед <xref:System.Reflection.Emit.OpCodes.Callvirt>).</span><span class="sxs-lookup"><span data-stu-id="de49f-803">In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <xref:System.Reflection.Emit.OpCodes.Callvirt>).</span></span>  
  
 <span data-ttu-id="de49f-804">Аргументы помещаются в стек в порядке слева направо.</span><span class="sxs-lookup"><span data-stu-id="de49f-804">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="de49f-805">То есть первый аргумент выводится и помещается в стек, затем второй аргумент — третий, пока все необходимые аргументы не помещаются в стек в убывающем порядке.</span><span class="sxs-lookup"><span data-stu-id="de49f-805">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="de49f-806">Существует три важных случая.</span><span class="sxs-lookup"><span data-stu-id="de49f-806">There are three important special cases:</span></span>  
  
 1. <span data-ttu-id="de49f-807">Вызовы метода экземпляра (или виртуального) должны отправить ссылку на этот экземпляр перед любыми видимыми пользователем аргументами.</span><span class="sxs-lookup"><span data-stu-id="de49f-807">Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments.</span></span> <span data-ttu-id="de49f-808">Ссылка на экземпляр не должна быть пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-808">The instance reference must not be a null reference.</span></span> <span data-ttu-id="de49f-809">Сигнатура, перенесенная в метаданные, не содержит записи в списке параметров для указателя `this`; Вместо этого используется бит, указывающий, требует ли метод передачи указателя `this`.</span><span class="sxs-lookup"><span data-stu-id="de49f-809">The signature carried in the metadata does not contain an entry in the parameter list for the `this` pointer; instead, it uses a bit to indicate whether the method requires passing the `this` pointer.</span></span>  
  
 2. <span data-ttu-id="de49f-810">Вызов виртуального метода допускается с помощью `call` (а не `callvirt`); Это означает, что метод должен быть разрешен с помощью класса, заданного методом, а не как указано динамически в вызываемом объекте.</span><span class="sxs-lookup"><span data-stu-id="de49f-810">It is valid to call a virtual method using `call` (rather than `callvirt`); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</span></span>  
  
 3. <span data-ttu-id="de49f-811">Обратите внимание, что метод `Invoke` делегата можно вызвать с помощью инструкции `call` или `callvirt`.</span><span class="sxs-lookup"><span data-stu-id="de49f-811">Note that a delegate's `Invoke` method can be called with either the `call` or `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="de49f-812"><xref:System.Security.SecurityException> может возникать, если система безопасности не предоставляет вызывающему объекту доступ к вызываемому методу.</span><span class="sxs-lookup"><span data-stu-id="de49f-812"><xref:System.Security.SecurityException> may be thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="de49f-813">Проверка безопасности может происходить, когда инструкции MSIL преобразуются в машинный код, а не во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-813">The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="de49f-814">При вызове методов типа System. Object для типов значений рекомендуется использовать префикс `constrained` с инструкцией `callvirt` вместо выдачи инструкции `call`.</span><span class="sxs-lookup"><span data-stu-id="de49f-814">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction instead of emitting a `call` instruction.</span></span> <span data-ttu-id="de49f-815">Это избавляет от необходимости создавать разные IL в зависимости от того, переопределяет ли тип значения метод, избегая возможной проблемы управления версиями.</span><span class="sxs-lookup"><span data-stu-id="de49f-815">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="de49f-816">Рекомендуется использовать префикс `constrained` при вызове методов интерфейса для типов значений, так как метод типа значения, реализующий метод интерфейса, можно изменить с помощью `MethodImpl`.</span><span class="sxs-lookup"><span data-stu-id="de49f-816">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="de49f-817">Эти проблемы более подробно описаны в коде операции <xref:System.Reflection.Emit.OpCodes.Constrained>.</span><span class="sxs-lookup"><span data-stu-id="de49f-817">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="de49f-818">Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `call`:</span><span class="sxs-lookup"><span data-stu-id="de49f-818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `call` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-819">ILGenerator. Emit (код операции, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="de49f-819">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="de49f-820">ILGenerator. Емиткалл (код операции, MethodInfo, тип [])</span><span class="sxs-lookup"><span data-stu-id="de49f-820">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="de49f-821">Метод <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> предоставляется для вызовов `varargs`.</span><span class="sxs-lookup"><span data-stu-id="de49f-821">The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is provided for `varargs` calls.</span></span> <span data-ttu-id="de49f-822">Используйте метод <xref:System.Reflection.Emit.ILGenerator.Emit%2A> для обычных вызовов.</span><span class="sxs-lookup"><span data-stu-id="de49f-822">Use the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method for normal calls.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-823">Вызывает метод, заданный в стеке вычислений (как указатель на точку входа), с аргументами, описанными в соглашении о вызовах.</span><span class="sxs-lookup"><span data-stu-id="de49f-823">Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-824">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-824">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-825">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-825">Format</span></span>|<span data-ttu-id="de49f-826">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-826">Assembly Format</span></span>|<span data-ttu-id="de49f-827">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-827">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-828">29 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-828">29 < `T` ></span></span>|<span data-ttu-id="de49f-829">calli `callSiteDescr`</span><span class="sxs-lookup"><span data-stu-id="de49f-829">calli `callSiteDescr`</span></span>|<span data-ttu-id="de49f-830">Вызывает метод, указываемый с аргументами, описанными в соглашении о вызовах.</span><span class="sxs-lookup"><span data-stu-id="de49f-830">Calls the method pointed to with arguments described by the calling convention.</span></span>|  
  
 <span data-ttu-id="de49f-831">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-831">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-832">Аргументы метода, `arg1` с помощью `argN`, помещаются в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-832">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-833">Указатель на запись метода помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-833">The method entry pointer is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-834">Аргументы метода `arg1`ся через `argN` и указатель входа метода извлекается из стека; выполняется вызов метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-834">Method arguments `arg1` through `argN` and the method entry pointer are popped from the stack; the call to the method is performed.</span></span> <span data-ttu-id="de49f-835">По завершении возвращаемое значение создается вызываемым методом и отправляется вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="de49f-835">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="de49f-836">Возвращаемое значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-836">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-837">Инструкция `calli` вызывает указатель входа метода с аргументами `arg1` до `argN`.</span><span class="sxs-lookup"><span data-stu-id="de49f-837">The `calli` instruction calls the method entry pointer with the arguments `arg1` through `argN`.</span></span> <span data-ttu-id="de49f-838">Типы этих аргументов описаны определенным соглашением о вызовах (`callSiteDesc`).</span><span class="sxs-lookup"><span data-stu-id="de49f-838">The types of these arguments are described by the specific calling convention (`callSiteDesc`).</span></span> <span data-ttu-id="de49f-839">Инструкции `calli` может предшествовать префикс `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>), чтобы указать, что текущее состояние метода должно быть освобождено перед передачей управления.</span><span class="sxs-lookup"><span data-stu-id="de49f-839">The `calli` instruction may be immediately preceded by a `tail` prefix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="de49f-840">Если вызов передает управление методу с более высоким уровнем доверия, чем метод источника, кадр стека не будет освобожден; Вместо этого выполнение продолжится автоматически, как если бы `tail` не было предоставлено.</span><span class="sxs-lookup"><span data-stu-id="de49f-840">If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the `tail` had not been supplied.</span></span>  
  
 <span data-ttu-id="de49f-841">Указатель входа метода считается определенным указателем на машинный код (на целевом компьютере), который можно использовать с аргументами, описанными в соглашении о вызовах (маркер метаданных для отдельной подписи).</span><span class="sxs-lookup"><span data-stu-id="de49f-841">The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature).</span></span> <span data-ttu-id="de49f-842">Такой указатель может быть создан с помощью инструкций <xref:System.Reflection.Emit.OpCodes.Ldftn> или <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> или передается из машинного кода.</span><span class="sxs-lookup"><span data-stu-id="de49f-842">Such a pointer can be created using the <xref:System.Reflection.Emit.OpCodes.Ldftn> or <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instructions, or passed in from native code.</span></span>  
  
 <span data-ttu-id="de49f-843">Соглашение о вызовах не проверяется динамически, поэтому код, использующий инструкцию `calli`, не работает правильно, если назначение фактически не использует указанное соглашение о вызовах.</span><span class="sxs-lookup"><span data-stu-id="de49f-843">The calling convention is not checked dynamically, so code that uses a `calli` instruction does not work correctly if the destination does not actually use the specified calling convention.</span></span>  
  
 <span data-ttu-id="de49f-844">Аргументы помещаются в стек в порядке слева направо.</span><span class="sxs-lookup"><span data-stu-id="de49f-844">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="de49f-845">То есть первый аргумент выводится и помещается в стек, затем второй аргумент — третий, пока все необходимые аргументы не помещаются в стек в убывающем порядке.</span><span class="sxs-lookup"><span data-stu-id="de49f-845">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="de49f-846">Последовательность кода для создания аргументов для экземпляра или виртуального метода должна отправить ссылку на экземпляр (которая не должна быть пустой ссылкой) перед любыми видимыми пользователем аргументами.</span><span class="sxs-lookup"><span data-stu-id="de49f-846">The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</span></span>  
  
 <span data-ttu-id="de49f-847"><xref:System.Security.SecurityException> может возникать, если системная безопасность не предоставляет вызывающему объекту доступ к вызываемому методу.</span><span class="sxs-lookup"><span data-stu-id="de49f-847"><xref:System.Security.SecurityException> may be thrown if the system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="de49f-848">Проверка безопасности может происходить, когда инструкции MSIL преобразуются в машинный код, а не во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-848">The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="de49f-849">Следующие методы <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> можно использовать для выполнения инструкции `calli` в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-849">The following <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> methods can be used to perform a `calli` instruction on the stack.</span></span> <span data-ttu-id="de49f-850">Обратите внимание, что `calli` следует вызывать через приведенные ниже методы, а не использовать класс <xref:System.Reflection.Emit.ILGenerator.Emit%2A>, чтобы разместить инструкцию непосредственно в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-850">Note that `calli` should be called through the below methods rather than using the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> class to place the instruction directly on the stack.</span></span>  
  
-   <span data-ttu-id="de49f-851">ILGenerator. Емиткалли (opcode, Каллингконвентионс, Type, Type [], Type []) для вызовов, использующих соглашение об управляемом вызовах.</span><span class="sxs-lookup"><span data-stu-id="de49f-851">ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</span></span>  
  
-   <span data-ttu-id="de49f-852">ILGenerator. Емиткалли (opcode, CallingConvention, Type, Type []) для вызовов, использующих неуправляемое соглашение о вызовах.</span><span class="sxs-lookup"><span data-stu-id="de49f-852">ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-853">Вызывает метод объекта с поздней привязкой и помещает возвращаемое значение в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-853">Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-854">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-854">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-855">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-855">Format</span></span>|<span data-ttu-id="de49f-856">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-856">Assembly Format</span></span>|<span data-ttu-id="de49f-857">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-857">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-858">6F < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-858">6F < `T` ></span></span>|<span data-ttu-id="de49f-859">callvirt `method`</span><span class="sxs-lookup"><span data-stu-id="de49f-859">callvirt `method`</span></span>|<span data-ttu-id="de49f-860">Вызывает конкретный метод, связанный с `obj`.</span><span class="sxs-lookup"><span data-stu-id="de49f-860">Calls a specific method associated with `obj`.</span></span>|  
  
 <span data-ttu-id="de49f-861">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-861">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-862">Ссылка на объект `obj` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-862">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-863">Аргументы метода, `arg1` с помощью `argN`, помещаются в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-863">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-864">Аргументы метода `arg1`ся через `argN` и ссылку на объект `obj` извлекаются из стека. вызов метода выполняется с этими аргументами, и управление передается методу в `obj`, на который ссылается токен метаданных метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-864">Method arguments `arg1` through `argN` and the object reference `obj` are popped from the stack; the method call is performed with these arguments and control is transferred to the method in `obj` referred to by the method metadata token.</span></span> <span data-ttu-id="de49f-865">По завершении возвращаемое значение создается вызываемым методом и отправляется вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="de49f-865">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="de49f-866">Возвращаемое значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-866">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-867">Инструкция `callvirt` вызывает метод с поздним связыванием для объекта.</span><span class="sxs-lookup"><span data-stu-id="de49f-867">The `callvirt` instruction calls a late-bound method on an object.</span></span> <span data-ttu-id="de49f-868">То есть метод выбирается на основе типа среды выполнения `obj`, а не класса времени компиляции, видимого в указателе метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-868">That is, the method is chosen based on the runtime type of `obj` rather than the compile-time class visible in the method pointer.</span></span> <span data-ttu-id="de49f-869">`Callvirt` можно использовать для вызова как виртуальных, так и методов экземпляра.</span><span class="sxs-lookup"><span data-stu-id="de49f-869">`Callvirt` can be used to call both virtual and instance methods.</span></span> <span data-ttu-id="de49f-870">Инструкции `callvirt` может предшествовать префикс `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>), чтобы указать, что текущий кадр стека следует освободить перед передачей управления.</span><span class="sxs-lookup"><span data-stu-id="de49f-870">The `callvirt` instruction may be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix to specify that the current stack frame should be released before transferring control.</span></span> <span data-ttu-id="de49f-871">Если вызов передает управление методу с более высоким уровнем доверия, чем исходный метод, кадр стека не будет освобожден.</span><span class="sxs-lookup"><span data-stu-id="de49f-871">If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</span></span>  
  
 <span data-ttu-id="de49f-872">Токен метаданных метода предоставляет имя, класс и сигнатуру вызываемого метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-872">The method metadata token provides the name, class and signature of the method to call.</span></span> <span data-ttu-id="de49f-873">Класс, связанный с `obj`, является классом, экземпляром которого является.</span><span class="sxs-lookup"><span data-stu-id="de49f-873">The class associated with `obj` is the class of which it is an instance.</span></span> <span data-ttu-id="de49f-874">Если класс определяет нестатический метод, соответствующий указанному имени и сигнатуре метода, вызывается этот метод.</span><span class="sxs-lookup"><span data-stu-id="de49f-874">If the class defines a non-static method that matches the indicated method name and signature, this method is called.</span></span> <span data-ttu-id="de49f-875">В противном случае все классы в цепочке базовых классов этого класса проверяются по порядку.</span><span class="sxs-lookup"><span data-stu-id="de49f-875">Otherwise all classes in the base class chain of this class are checked in order.</span></span> <span data-ttu-id="de49f-876">Если метод не найден, возникает ошибка.</span><span class="sxs-lookup"><span data-stu-id="de49f-876">It is an error if no method is found.</span></span>  
  
 <span data-ttu-id="de49f-877">`Callvirt` извлекает объект и связанные аргументы из стека вычислений перед вызовом метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-877">`Callvirt` pops the object and the associated arguments off the evaluation stack before calling the method.</span></span> <span data-ttu-id="de49f-878">Если метод имеет возвращаемое значение, он помещается в стек после завершения метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-878">If the method has a return value, it is pushed on the stack upon method completion.</span></span> <span data-ttu-id="de49f-879">На стороне вызываемого метода доступ к параметру `obj` осуществляется в качестве аргумента 0, `arg1` в качестве аргумента 1 и т. д.</span><span class="sxs-lookup"><span data-stu-id="de49f-879">On the callee side, the `obj` parameter is accessed as argument 0, `arg1` as argument 1, and so on.</span></span>  
  
 <span data-ttu-id="de49f-880">Аргументы помещаются в стек в порядке слева направо.</span><span class="sxs-lookup"><span data-stu-id="de49f-880">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="de49f-881">То есть первый аргумент выводится и помещается в стек, затем второй аргумент — третий, пока все необходимые аргументы не помещаются в стек в убывающем порядке.</span><span class="sxs-lookup"><span data-stu-id="de49f-881">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="de49f-882">Ссылка на экземпляр `obj` (всегда требуется для `callvirt`) должна быть передана перед любыми видимыми пользователем аргументами.</span><span class="sxs-lookup"><span data-stu-id="de49f-882">The instance reference `obj` (always required for `callvirt`) must be pushed before any of the user-visible arguments.</span></span> <span data-ttu-id="de49f-883">Сигнатура (переданная в маркере метаданных) не должна содержать запись в списке параметров для этого указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-883">The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</span></span>  
  
 <span data-ttu-id="de49f-884">Обратите внимание, что виртуальный метод также можно вызвать с помощью инструкции <xref:System.Reflection.Emit.OpCodes.Call>.</span><span class="sxs-lookup"><span data-stu-id="de49f-884">Note that a virtual method can also be called using the <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span>  
  
 <span data-ttu-id="de49f-885"><xref:System.MissingMethodException> возникает, если нестатический метод с указанным именем и подписью не удалось найти в классе, связанном с `obj` или с любым из его базовых классов.</span><span class="sxs-lookup"><span data-stu-id="de49f-885"><xref:System.MissingMethodException> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with `obj` or any of its base classes.</span></span> <span data-ttu-id="de49f-886">Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-886">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="de49f-887">если obj имеет значение null, возникает исключение <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="de49f-887"><xref:System.NullReferenceException> is thrown if obj is null.</span></span>  
  
 <span data-ttu-id="de49f-888"><xref:System.Security.SecurityException> возникает, если система безопасности не предоставляет вызывающему объекту доступ к вызываемому методу.</span><span class="sxs-lookup"><span data-stu-id="de49f-888"><xref:System.Security.SecurityException> is thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="de49f-889">Проверка безопасности может произойти, когда CIL преобразуется в машинный код, а не во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-889">The security check may occur when the CIL is converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="de49f-890">При вызове методов типа System. Object для типов значений рекомендуется использовать префикс `constrained` с инструкцией `callvirt`.</span><span class="sxs-lookup"><span data-stu-id="de49f-890">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction.</span></span> <span data-ttu-id="de49f-891">Это избавляет от необходимости создавать разные IL в зависимости от того, переопределяет ли тип значения метод, избегая возможной проблемы управления версиями.</span><span class="sxs-lookup"><span data-stu-id="de49f-891">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="de49f-892">Рекомендуется использовать префикс `constrained` при вызове методов интерфейса для типов значений, так как метод типа значения, реализующий метод интерфейса, можно изменить с помощью `MethodImpl`.</span><span class="sxs-lookup"><span data-stu-id="de49f-892">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="de49f-893">Эти проблемы более подробно описаны в коде операции <xref:System.Reflection.Emit.OpCodes.Constrained>.</span><span class="sxs-lookup"><span data-stu-id="de49f-893">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="de49f-894">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `callvirt`:</span><span class="sxs-lookup"><span data-stu-id="de49f-894">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `callvirt` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-895">ILGenerator. Emit (код операции, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="de49f-895">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="de49f-896">ILGenerator. Емиткалл (код операции, MethodInfo, тип [])</span><span class="sxs-lookup"><span data-stu-id="de49f-896">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-897">Предпринимает попытку привести объект, передаваемый по ссылке, к указанному классу.</span><span class="sxs-lookup"><span data-stu-id="de49f-897">Attempts to cast an object passed by reference to the specified class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-898">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-899">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-899">Format</span></span>|<span data-ttu-id="de49f-900">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-900">Assembly Format</span></span>|<span data-ttu-id="de49f-901">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-902">74 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-902">74 < `T` ></span></span>|<span data-ttu-id="de49f-903">касткласс `class`</span><span class="sxs-lookup"><span data-stu-id="de49f-903">castclass `class`</span></span>|<span data-ttu-id="de49f-904">Приводит объект к новому объекту типа `class`.</span><span class="sxs-lookup"><span data-stu-id="de49f-904">Casts an object to a new object of type `class`.</span></span>|  
  
 <span data-ttu-id="de49f-905">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-906">Ссылка на объект помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-906">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-907">Ссылка на объект извлекается из стека; Объект, на который указывает ссылка, приводится к указанному `class`.</span><span class="sxs-lookup"><span data-stu-id="de49f-907">The object reference is popped from the stack; the referenced object is cast as the specified `class`.</span></span>  
  
3.  <span data-ttu-id="de49f-908">В случае успеха новая ссылка на объект помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-908">If successful, a new object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-909">Инструкция `castclass` пытается привести ссылку на объект (Type `O`) на вершине стека к указанному классу.</span><span class="sxs-lookup"><span data-stu-id="de49f-909">The `castclass` instruction attempts to cast the object reference (type `O`) atop the stack to a specified class.</span></span> <span data-ttu-id="de49f-910">Новый класс задается маркером метаданных, указывающим нужный класс.</span><span class="sxs-lookup"><span data-stu-id="de49f-910">The new class is specified by a metadata token indicating the desired class.</span></span> <span data-ttu-id="de49f-911">Если класс объекта в верхней части стека не реализует новый класс (предполагая, что новый класс является интерфейсом) и не является производным классом нового класса, возникает исключение <xref:System.InvalidCastException>.</span><span class="sxs-lookup"><span data-stu-id="de49f-911">If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <xref:System.InvalidCastException> is thrown.</span></span> <span data-ttu-id="de49f-912">Если ссылка на объект является пустой ссылкой, `castclass` завершается и возвращает новый объект как пустую ссылку.</span><span class="sxs-lookup"><span data-stu-id="de49f-912">If the object reference is a null reference, `castclass` succeeds and returns the new object as a null reference.</span></span>  
  
 <span data-ttu-id="de49f-913">если obj не может быть приведен к классу, возникает исключение <xref:System.InvalidCastException>.</span><span class="sxs-lookup"><span data-stu-id="de49f-913"><xref:System.InvalidCastException> is thrown if obj cannot be cast to class.</span></span>  
  
 <span data-ttu-id="de49f-914">Если класс не найден, возникает исключение <xref:System.TypeLoadException>.</span><span class="sxs-lookup"><span data-stu-id="de49f-914"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="de49f-915">Обычно это обнаруживается при преобразовании инструкции MSIL в машинный код, а не во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-915">This is typically detected when a Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="de49f-916">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `castclass`:</span><span class="sxs-lookup"><span data-stu-id="de49f-916">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `castclass` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-917">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-917">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-918">Сравнивает два значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-918">Compares two values.</span></span> <span data-ttu-id="de49f-919">Если они равны, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</span><span class="sxs-lookup"><span data-stu-id="de49f-919">If they are equal, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-920">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-920">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-921">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-921">Format</span></span>|<span data-ttu-id="de49f-922">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-922">Assembly Format</span></span>|<span data-ttu-id="de49f-923">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-923">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-924">FE 01</span><span class="sxs-lookup"><span data-stu-id="de49f-924">FE 01</span></span>|<span data-ttu-id="de49f-925">цек</span><span class="sxs-lookup"><span data-stu-id="de49f-925">ceq</span></span>|<span data-ttu-id="de49f-926">Отправляет 1, если `value1` равно `value2`; в противном случае отправляет 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-926">Pushes 1 if `value1` equals `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="de49f-927">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-927">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-928">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-928">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-929">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-929">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-930">`value2` и `value1` извлекаются из стека; `value1` сравнивается с `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-930">`value2` and `value1` are popped from the stack; `value1` is compared to `value2`.</span></span>  
  
4.  <span data-ttu-id="de49f-931">Если `value1` равно `value2`, 1 помещается в стек; в противном случае в стек помещается значение 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-931">If `value1` is equal to `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-932">Инструкция `ceq` сравнивает `value1` и `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-932">The `ceq` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="de49f-933">Если `value1` равно `value2`, то в стек помещается 1 (типа `int32`).</span><span class="sxs-lookup"><span data-stu-id="de49f-933">If `value1` is equal to `value2`, then 1 (of type `int32`) is pushed on the stack.</span></span> <span data-ttu-id="de49f-934">В противном случае в стек помещается значение 0 (типа `int32`).</span><span class="sxs-lookup"><span data-stu-id="de49f-934">Otherwise 0 (of type `int32`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="de49f-935">Для числа с плавающей запятой `ceq` возвращает 0, если числа не упорядочены (или оба имеют значение NaN).</span><span class="sxs-lookup"><span data-stu-id="de49f-935">For floating-point number, `ceq` will return 0 if the numbers are unordered (either or both are NaN).</span></span> <span data-ttu-id="de49f-936">Бесконечные значения равны самому себе.</span><span class="sxs-lookup"><span data-stu-id="de49f-936">The infinite values are equal to themselves.</span></span>  
  
 <span data-ttu-id="de49f-937">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ceq`:</span><span class="sxs-lookup"><span data-stu-id="de49f-937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ceq` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-938">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-939">Сравнивает два значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-939">Compares two values.</span></span> <span data-ttu-id="de49f-940">Если первое значение больше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</span><span class="sxs-lookup"><span data-stu-id="de49f-940">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-941">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-941">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-942">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-942">Format</span></span>|<span data-ttu-id="de49f-943">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-943">Assembly Format</span></span>|<span data-ttu-id="de49f-944">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-944">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-945">FE 02</span><span class="sxs-lookup"><span data-stu-id="de49f-945">FE 02</span></span>|<span data-ttu-id="de49f-946">кгт</span><span class="sxs-lookup"><span data-stu-id="de49f-946">cgt</span></span>|<span data-ttu-id="de49f-947">Отправляет 1, если `value1` больше `value2`; в противном случае отправляет 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-947">Pushes 1 if `value1` is greater than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="de49f-948">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-948">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-949">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-949">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-950">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-950">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-951">`value2` и `value1` извлекаются из стека; `cgt` тесты, если `value1` больше, чем `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-951">`value2` and `value1` are popped from the stack; `cgt` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="de49f-952">Если `value1` больше `value2`, 1 помещается в стек; в противном случае в стек помещается значение 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-952">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-953">Инструкция `cgt` сравнивает `value1` и `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-953">The `cgt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="de49f-954">Если `value1` строго больше `value2`, то в стек помещается значение `int32`, равное 1.</span><span class="sxs-lookup"><span data-stu-id="de49f-954">If `value1` is strictly greater than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="de49f-955">В противном случае в стек помещается значение `int32`, равное 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-955">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="de49f-956">Для чисел с плавающей запятой `cgt` возвращает 0, если числа не упорядочены (то есть если один или оба аргумента имеют значение NaN).</span><span class="sxs-lookup"><span data-stu-id="de49f-956">For floating-point numbers, `cgt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="de49f-957">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `cgt`:</span><span class="sxs-lookup"><span data-stu-id="de49f-957">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-958">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-958">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-959">Сравнивает два значения без знака или два неупорядоченных значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-959">Compares two unsigned or unordered values.</span></span> <span data-ttu-id="de49f-960">Если первое значение больше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</span><span class="sxs-lookup"><span data-stu-id="de49f-960">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-961">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-961">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-962">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-962">Format</span></span>|<span data-ttu-id="de49f-963">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-963">Assembly Format</span></span>|<span data-ttu-id="de49f-964">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-964">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-965">FE 03</span><span class="sxs-lookup"><span data-stu-id="de49f-965">FE 03</span></span>|<span data-ttu-id="de49f-966">КГТ. un</span><span class="sxs-lookup"><span data-stu-id="de49f-966">cgt.un</span></span>|<span data-ttu-id="de49f-967">Отправляет 1, если `value1` больше `value2`; в противном случае push-уведомления 0 (неподписанные значения).</span><span class="sxs-lookup"><span data-stu-id="de49f-967">Pushes 1 if `value1` is greater than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="de49f-968">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-968">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-969">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-969">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-970">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-970">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-971">`value2` и `value1` извлекаются из стека; `cgt.un` тесты, если `value1` больше, чем `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-971">`value2` and `value1` are popped from the stack; `cgt.un` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="de49f-972">Если `value1` больше `value2`, 1 помещается в стек; в противном случае в стек помещается значение 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-972">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-973">Значение `int32`, равное 1, помещается в стек, если любой из следующих `true`:</span><span class="sxs-lookup"><span data-stu-id="de49f-973">An `int32` value of 1 is pushed on the stack if any of the following is `true` :</span></span>  
  
 <span data-ttu-id="de49f-974">Для чисел с плавающей запятой `value1` не упорядочивается по отношению к `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-974">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
 <span data-ttu-id="de49f-975">Для целочисленных значений `value1` строго больше `value2`, если они считаются неподписанными числами.</span><span class="sxs-lookup"><span data-stu-id="de49f-975">For integer values, `value1` is strictly greater than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="de49f-976">В противном случае в стек помещается значение `int32`, равное 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-976">Otherwise an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="de49f-977">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `cgt.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-977">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-978">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-978">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-979">Создает исключение <see cref="T:System.ArithmeticException" />, если значение не является конечным числом.</span><span class="sxs-lookup"><span data-stu-id="de49f-979">Throws <see cref="T:System.ArithmeticException" /> if value is not a finite number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-980">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-980">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-981">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-981">Format</span></span>|<span data-ttu-id="de49f-982">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-982">Assembly Format</span></span>|<span data-ttu-id="de49f-983">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-983">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-984">C3</span><span class="sxs-lookup"><span data-stu-id="de49f-984">C3</span></span>|<span data-ttu-id="de49f-985">ккфините</span><span class="sxs-lookup"><span data-stu-id="de49f-985">ckfinite</span></span>|<span data-ttu-id="de49f-986">Вызовите <xref:System.ArithmeticException>, если значение не является конечным числом.</span><span class="sxs-lookup"><span data-stu-id="de49f-986">throw <xref:System.ArithmeticException> if value is not a finite number.</span></span>|  
  
 <span data-ttu-id="de49f-987">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-987">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-988">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-988">`value` is pushed onto the stack.</span></span> 
  
2.  <span data-ttu-id="de49f-989">`value` извлекается из стека и выполняется инструкция `ckfinite`.</span><span class="sxs-lookup"><span data-stu-id="de49f-989">`value` is popped from the stack and the `ckfinite` instruction is performed on it.</span></span>  
  
3.  <span data-ttu-id="de49f-990">`value` помещается обратно в стек, если исключение не создается.</span><span class="sxs-lookup"><span data-stu-id="de49f-990">`value` is pushed back onto the stack if no exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-991">`ckfinite instruction` создает исключение <xref:System.ArithmeticException> если `value` (число с плавающей запятой) является либо значением "не число" (NaN), либо значением `+-` бесконечности.</span><span class="sxs-lookup"><span data-stu-id="de49f-991">The `ckfinite instruction` throws <xref:System.ArithmeticException> if `value` (a floating-point number) is either a "not a number" value (NaN) or a `+-` infinity value.</span></span> <span data-ttu-id="de49f-992">`Ckfinite` оставляет значение в стеке, если исключение не создается.</span><span class="sxs-lookup"><span data-stu-id="de49f-992">`Ckfinite` leaves the value on the stack if no exception is thrown.</span></span> <span data-ttu-id="de49f-993">Выполнение не указано, если `value` не является числом с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="de49f-993">Execution is unspecified if `value` is not a floating-point number.</span></span>  
  
 <span data-ttu-id="de49f-994"><xref:System.ArithmeticException> возникает, если `value` не является нормальным числом.</span><span class="sxs-lookup"><span data-stu-id="de49f-994"><xref:System.ArithmeticException> is thrown if `value` is not a 'normal' number.</span></span>  
  
 <span data-ttu-id="de49f-995">Обратите внимание, что специальное исключение или производный класс <xref:System.ArithmeticException> может быть более подходящим, передавая неверное значение обработчику исключений.</span><span class="sxs-lookup"><span data-stu-id="de49f-995">Note that a special exception or a derived class of <xref:System.ArithmeticException> may be more appropriate, passing the incorrect value to the exception handler.</span></span>  
  
 <span data-ttu-id="de49f-996">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ckfinite`:</span><span class="sxs-lookup"><span data-stu-id="de49f-996">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ckfinite` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-997">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-997">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-998">Сравнивает два значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-998">Compares two values.</span></span> <span data-ttu-id="de49f-999">Если первое значение меньше второго, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</span><span class="sxs-lookup"><span data-stu-id="de49f-999">If the first value is less than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1000">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1000">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1001">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1001">Format</span></span>|<span data-ttu-id="de49f-1002">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1002">Assembly Format</span></span>|<span data-ttu-id="de49f-1003">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1003">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1004">FE 04</span><span class="sxs-lookup"><span data-stu-id="de49f-1004">FE 04</span></span>|<span data-ttu-id="de49f-1005">чилийскому</span><span class="sxs-lookup"><span data-stu-id="de49f-1005">clt</span></span>|<span data-ttu-id="de49f-1006">Отправляет 1, если `value1` меньше `value2`; в противном случае отправляет 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-1006">Pushes 1 if `value1` is less than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="de49f-1007">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1007">The stack transitional behavior, in sequential order, is:</span></span> 

1.  <span data-ttu-id="de49f-1008">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1008">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1009">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1009">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-1010">`value2` и `value1` извлекаются из стека; `clt` тесты, если `value1` меньше `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1010">`value2` and `value1` are popped from the stack; `clt` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="de49f-1011">Если `value1` меньше `value2`, 1 помещается в стек; в противном случае в стек помещается значение 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-1011">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1012">Инструкция `clt` сравнивает `value1` и `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1012">The `clt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="de49f-1013">Если `value1` строго меньше `value2`, то в стек помещается значение `int32`, равное 1.</span><span class="sxs-lookup"><span data-stu-id="de49f-1013">If `value1` is strictly less than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="de49f-1014">В противном случае в стек помещается значение `int32`, равное 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-1014">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="de49f-1015">Для чисел с плавающей запятой `clt` возвращает 0, если числа не упорядочены (то есть если один или оба аргумента имеют значение NaN).</span><span class="sxs-lookup"><span data-stu-id="de49f-1015">For floating-point numbers, `clt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="de49f-1016">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `clt`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1016">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1017">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1017">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1018">Сравнивает два значения без знака или два неупорядоченных значения <paramref name="value1" /> и <paramref name="value2" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-1018">Compares the unsigned or unordered values <paramref name="value1" /> and <paramref name="value2" />.</span></span> <span data-ttu-id="de49f-1019">Если значение <paramref name="value1" /> меньше значения <paramref name="value2" />, целочисленное значение 1 (<see langword="(int32" />) помещается в стек вычислений; в противном случае в стек вычислений помещается 0 (<see langword="int32" />).</span><span class="sxs-lookup"><span data-stu-id="de49f-1019">If <paramref name="value1" /> is less than <paramref name="value2" />, then the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1020">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1020">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1021">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1021">Format</span></span>|<span data-ttu-id="de49f-1022">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1022">Assembly Format</span></span>|<span data-ttu-id="de49f-1023">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1023">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1024">FE 2005 Г.</span><span class="sxs-lookup"><span data-stu-id="de49f-1024">FE 05</span></span>|<span data-ttu-id="de49f-1025">средство регистрации звонков. un</span><span class="sxs-lookup"><span data-stu-id="de49f-1025">clt.un</span></span>|<span data-ttu-id="de49f-1026">Отправляет 1, если `value1` меньше `value2`; в противном случае push-уведомления 0 (неподписанные значения).</span><span class="sxs-lookup"><span data-stu-id="de49f-1026">Pushes 1 if `value1` is less than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="de49f-1027">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1027">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1028">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1028">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1029">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1029">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-1030">`value2` и `value1` извлекаются из стека; `clt.un` тесты, если `value1` меньше `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1030">`value2` and `value1` are popped from the stack; `clt.un` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="de49f-1031">Если `value1` меньше `value2`, 1 помещается в стек; в противном случае в стек помещается значение 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-1031">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1032">Инструкция `clt.un` сравнивает `value1` и `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1032">The `clt.un` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="de49f-1033">Значение `int32`, равное 1, помещается в стек, если выполняется одно из следующих условий.</span><span class="sxs-lookup"><span data-stu-id="de49f-1033">An `int32` value of 1 is pushed on the stack if any of the following is true:</span></span>  
  
-   <span data-ttu-id="de49f-1034">`value1` строго меньше `value2` (как для `clt`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1034">`value1` is strictly less than `value2` (as for `clt`).</span></span>  
  
-   <span data-ttu-id="de49f-1035">Для чисел с плавающей запятой `value1` не упорядочивается по отношению к `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1035">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
-   <span data-ttu-id="de49f-1036">Для целочисленных значений `value1` строго меньше `value2`, если считаться числами без знака.</span><span class="sxs-lookup"><span data-stu-id="de49f-1036">For integer values, `value1` is strictly less than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="de49f-1037">В противном случае в стек помещается значение `int32`, равное 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-1037">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="de49f-1038">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `clt.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1038">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1039">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1039">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1040">Ограничивает тип, для которого был вызван виртуальный метод.</span><span class="sxs-lookup"><span data-stu-id="de49f-1040">Constrains the type on which a virtual method call is made.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1041">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1041">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1042">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1042">Format</span></span>|<span data-ttu-id="de49f-1043">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1043">Assembly Format</span></span>|<span data-ttu-id="de49f-1044">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1044">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1045">`T`FE 16 <  ></span><span class="sxs-lookup"><span data-stu-id="de49f-1045">FE 16 < `T` ></span></span>|<span data-ttu-id="de49f-1046">ограниченного.</span><span class="sxs-lookup"><span data-stu-id="de49f-1046">constrained.</span></span> `thisType`|<span data-ttu-id="de49f-1047">Вызов виртуального метода для типа, ограниченного типом `T`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1047">Call a virtual method on a type constrained to be type `T`.</span></span>|  
  
 <span data-ttu-id="de49f-1048">Префикс `constrained` разрешен только для инструкции `callvirt`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1048">The `constrained` prefix is permitted only on a `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="de49f-1049">В этой точке состояние стека MSIL должно быть следующим:</span><span class="sxs-lookup"><span data-stu-id="de49f-1049">The state of the MSIL stack at this point must be as follows:</span></span>  
  
1.  <span data-ttu-id="de49f-1050">Управляемый указатель, `ptr`, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1050">A managed pointer, `ptr`, is pushed onto the stack.</span></span> <span data-ttu-id="de49f-1051">Тип `ptr` должен быть управляемым указателем (`&`) до `thisType`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1051">The type of `ptr` must be a managed pointer (`&`) to `thisType`.</span></span> <span data-ttu-id="de49f-1052">Обратите внимание, что это отличается от случая непрефиксной инструкции `callvirt`, которая принимает ссылку на `thisType`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1052">Note that this is different from the case of an unprefixed `callvirt` instruction, which expects a reference of `thisType`.</span></span>  
  
2.  <span data-ttu-id="de49f-1053">Аргументы метода, `arg1` с помощью `argN`, помещаются в стек, так же как и в случае с непрефиксной инструкцией `callvirt`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1053">Method arguments `arg1` through `argN` are pushed onto the stack, just as with an unprefixed `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="de49f-1054">Префикс `constrained` позволяет делать инструкции `callvirt` единообразно независимо от того, является ли `thisType` типом значения или ссылочным типом.</span><span class="sxs-lookup"><span data-stu-id="de49f-1054">The `constrained` prefix is designed to allow `callvirt` instructions to be made in a uniform way independent of whether `thisType` is a value type or a reference type.</span></span>  
  
 <span data-ttu-id="de49f-1055">Если инструкция `callvirt` `method` предваряется `constrained` `thisType`, инструкция выполняется следующим образом:</span><span class="sxs-lookup"><span data-stu-id="de49f-1055">When a `callvirt` `method` instruction has been prefixed by `constrained` `thisType`, the instruction is executed as follows:</span></span>  
  
-   <span data-ttu-id="de49f-1056">Если `thisType` является ссылочным типом (в отличие от типа значения), `ptr` удаляется из ссылок и передается как указатель this на `callvirt` из `method`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1056">If `thisType` is a reference type (as opposed to a value type) then `ptr` is dereferenced and passed as the 'this' pointer to the `callvirt` of `method`.</span></span>  
  
-   <span data-ttu-id="de49f-1057">Если `thisType` является типом значения и `thisType` реализует `method`, то `ptr` передается без изменений в качестве указателя this на `call` `method` для реализации `method` с `thisType`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1057">If `thisType` is a value type and `thisType` implements `method` then `ptr` is passed unmodified as the 'this' pointer to a `call` `method` instruction, for the implementation of `method` by `thisType`.</span></span>  
  
-   <span data-ttu-id="de49f-1058">Если `thisType` является типом значения, а `thisType` не реализует `method`, то `ptr` отменяется, упаковывается и передается как указатель this в инструкцию `callvirt` `method`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1058">If `thisType` is a value type and `thisType` does not implement `method` then `ptr` is dereferenced, boxed, and passed as the 'this' pointer to the `callvirt` `method` instruction.</span></span>  
  
 <span data-ttu-id="de49f-1059">Последний случай может возникнуть, только если `method` был определен в <xref:System.Object>, <xref:System.ValueType> или <xref:System.Enum> и не переопределен `thisType`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1059">This last case can occur only when `method` was defined on <xref:System.Object>, <xref:System.ValueType>, or <xref:System.Enum> and not overridden by `thisType`.</span></span> <span data-ttu-id="de49f-1060">В этом случае упаковка создает копию исходного объекта.</span><span class="sxs-lookup"><span data-stu-id="de49f-1060">In this case, the boxing causes a copy of the original object to be made.</span></span> <span data-ttu-id="de49f-1061">Однако, поскольку ни один из методов <xref:System.Object>, <xref:System.ValueType> и <xref:System.Enum> изменяет состояние объекта, этот факт не может быть обнаружен.</span><span class="sxs-lookup"><span data-stu-id="de49f-1061">However, because none of the methods of <xref:System.Object>, <xref:System.ValueType>, and <xref:System.Enum> modify the state of the object, this fact cannot be detected.</span></span>  
  
 <span data-ttu-id="de49f-1062">Префикс `constrained` поддерживает генераторы IL, которые создают универсальный код.</span><span class="sxs-lookup"><span data-stu-id="de49f-1062">The `constrained` prefix supports IL generators that create generic code.</span></span> <span data-ttu-id="de49f-1063">Обычно инструкция `callvirt` недопустима для типов значений.</span><span class="sxs-lookup"><span data-stu-id="de49f-1063">Normally the `callvirt` instruction is not valid on value types.</span></span> <span data-ttu-id="de49f-1064">Вместо этого необходимо, чтобы компиляторы IL эффективно выполняли преобразование «this», описанное выше во время компиляции, в зависимости от типа `ptr` и вызываемого метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-1064">Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of `ptr` and the method being called.</span></span> <span data-ttu-id="de49f-1065">Однако если `ptr` является универсальным типом, неизвестным во время компиляции, это преобразование невозможно выполнить во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="de49f-1065">However, when `ptr` is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</span></span>  
  
 <span data-ttu-id="de49f-1066">Код операции `constrained` позволяет компиляторам IL выполнять вызов виртуальной функции единообразно независимо от того, является ли `ptr` типом значения или ссылочным типом.</span><span class="sxs-lookup"><span data-stu-id="de49f-1066">The `constrained` opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether `ptr` is a value type or a reference type.</span></span> <span data-ttu-id="de49f-1067">Хотя он предназначен для случая, когда `thisType` является переменной универсального типа, префикс `constrained` также работает для неуниверсальных типов и может уменьшить сложность создания виртуальных вызовов в языках, которые скрывают различие между типами значений и ссылками. типов.</span><span class="sxs-lookup"><span data-stu-id="de49f-1067">Although it is intended for the case where `thisType` is a generic type variable, the `constrained` prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.</span></span>  
  
 <span data-ttu-id="de49f-1068">Использование префикса `constrained` также позволяет избежать потенциальных проблем с управлением версиями с типами значений.</span><span class="sxs-lookup"><span data-stu-id="de49f-1068">Using the `constrained` prefix also avoids potential versioning problems with value types.</span></span> <span data-ttu-id="de49f-1069">Если префикс `constrained` не используется, должен выдаваться другой IL в зависимости от того, переопределяет ли тип значения метод System. Object.</span><span class="sxs-lookup"><span data-stu-id="de49f-1069">If the `constrained` prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object.</span></span> <span data-ttu-id="de49f-1070">Например, если тип значения `V` переопределяет метод Object. ToString (), то создается инструкция `call` `V.ToString()`. в противном случае выдается инструкция `box` и инструкция `callvirt` `Object.ToString()`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1070">For example, if a value type `V` overrides the Object.ToString() method, a `call` `V.ToString()` instruction is emitted; if it does not, a `box` instruction and a `callvirt` `Object.ToString()` instruction are emitted.</span></span> <span data-ttu-id="de49f-1071">Проблема управления версиями может возникнуть в первом случае, если переопределение позже удаляется, и в последнем случае, если переопределение добавляется позже.</span><span class="sxs-lookup"><span data-stu-id="de49f-1071">A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.</span></span>  
  
 <span data-ttu-id="de49f-1072">Префикс `constrained` также можно использовать для вызова методов интерфейса для типов значений, так как метод типа значения, реализующий метод интерфейса, можно изменить с помощью `MethodImpl`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1072">The `constrained` prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="de49f-1073">Если префикс `constrained` не используется, компилятор принудительно выбирает, к какому из методов типа значения следует выполнить привязку во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="de49f-1073">If the `constrained` prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time.</span></span> <span data-ttu-id="de49f-1074">Использование префикса `constrained` позволяет выполнить привязку MSIL к методу, реализующему метод интерфейса, во время выполнения, а не во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="de49f-1074">Using the `constrained` prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</span></span>  
  
 <span data-ttu-id="de49f-1075">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `constrained`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1075">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `constrained` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1076">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-1076">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1077">Преобразует верхнее значение в стеке вычислений в тип <see langword="native int" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-1077">Converts the value on top of the evaluation stack to <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1078">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1078">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1079">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1079">Format</span></span>|<span data-ttu-id="de49f-1080">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1080">Assembly Format</span></span>|<span data-ttu-id="de49f-1081">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1081">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1082">D3</span><span class="sxs-lookup"><span data-stu-id="de49f-1082">D3</span></span>|<span data-ttu-id="de49f-1083">Кредит i</span><span class="sxs-lookup"><span data-stu-id="de49f-1083">conv.i</span></span>|<span data-ttu-id="de49f-1084">Преобразует в `native int`, отправляя `native int` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1084">Convert to `native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="de49f-1085">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1085">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1086">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1086">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1087">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1087">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de49f-1088">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1088">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1089">Код операции `conv.i` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1089">The `conv.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1090">Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1090">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de49f-1091">Значения с плавающей запятой преобразуются в тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1091">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de49f-1092">Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1092">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de49f-1093">При преобразовании из `float64` в `float32` точность может быть потеряна.</span><span class="sxs-lookup"><span data-stu-id="de49f-1093">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="de49f-1094">Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным).</span><span class="sxs-lookup"><span data-stu-id="de49f-1094">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de49f-1095">Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются.</span><span class="sxs-lookup"><span data-stu-id="de49f-1095">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de49f-1096">Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.</span><span class="sxs-lookup"><span data-stu-id="de49f-1096">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de49f-1097">Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.</span><span class="sxs-lookup"><span data-stu-id="de49f-1097">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de49f-1098">При использовании этого поля исключения никогда не возникают.</span><span class="sxs-lookup"><span data-stu-id="de49f-1098">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de49f-1099">Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1099">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de49f-1100">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.i`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1100">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1101">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1101">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1102">Преобразует верхнее значение в стеке вычислений в <see langword="int8" />, а затем расширяет его до <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-1102">Converts the value on top of the evaluation stack to <see langword="int8" />, then extends (pads) it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1103">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1103">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1104">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1104">Format</span></span>|<span data-ttu-id="de49f-1105">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1105">Assembly Format</span></span>|<span data-ttu-id="de49f-1106">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1106">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1107">67</span><span class="sxs-lookup"><span data-stu-id="de49f-1107">67</span></span>|<span data-ttu-id="de49f-1108">с кредитом. i1</span><span class="sxs-lookup"><span data-stu-id="de49f-1108">conv.i1</span></span>|<span data-ttu-id="de49f-1109">Преобразует в `int8`, отправляя `int32` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1109">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="de49f-1110">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1110">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1111">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1111">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1112">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1112">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de49f-1113">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1113">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1114">Код операции `conv.i1` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1114">The `conv.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1115">Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1115">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de49f-1116">Значения с плавающей запятой преобразуются в тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1116">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de49f-1117">Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1117">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de49f-1118">При преобразовании из `float64` в `float32` точность может быть потеряна.</span><span class="sxs-lookup"><span data-stu-id="de49f-1118">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="de49f-1119">Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным).</span><span class="sxs-lookup"><span data-stu-id="de49f-1119">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de49f-1120">Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются.</span><span class="sxs-lookup"><span data-stu-id="de49f-1120">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de49f-1121">Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.</span><span class="sxs-lookup"><span data-stu-id="de49f-1121">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de49f-1122">Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.</span><span class="sxs-lookup"><span data-stu-id="de49f-1122">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de49f-1123">При использовании этого поля исключения никогда не возникают.</span><span class="sxs-lookup"><span data-stu-id="de49f-1123">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de49f-1124">Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1124">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de49f-1125">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.i1`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1125">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i1` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1126">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1126">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1127">Преобразует верхнее значение в стеке вычислений в <see langword="int16" />, а затем расширяет его до <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-1127">Converts the value on top of the evaluation stack to <see langword="int16" />, then extends (pads) it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1128">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1128">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1129">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1129">Format</span></span>|<span data-ttu-id="de49f-1130">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1130">Assembly Format</span></span>|<span data-ttu-id="de49f-1131">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1131">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1132">68</span><span class="sxs-lookup"><span data-stu-id="de49f-1132">68</span></span>|<span data-ttu-id="de49f-1133">Кредитный I2</span><span class="sxs-lookup"><span data-stu-id="de49f-1133">conv.i2</span></span>|<span data-ttu-id="de49f-1134">Преобразует в `int16`, отправляя `int32` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1134">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="de49f-1135">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1135">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1136">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1136">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1137">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1137">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de49f-1138">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1138">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1139">Код операции `conv.i2` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1139">The `conv.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1140">Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1140">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de49f-1141">Значения с плавающей запятой преобразуются в тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1141">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de49f-1142">Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1142">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de49f-1143">При преобразовании из `float64` в `float32` точность может быть потеряна.</span><span class="sxs-lookup"><span data-stu-id="de49f-1143">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="de49f-1144">Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным).</span><span class="sxs-lookup"><span data-stu-id="de49f-1144">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de49f-1145">Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются.</span><span class="sxs-lookup"><span data-stu-id="de49f-1145">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de49f-1146">Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.</span><span class="sxs-lookup"><span data-stu-id="de49f-1146">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de49f-1147">Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.</span><span class="sxs-lookup"><span data-stu-id="de49f-1147">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de49f-1148">При использовании этого поля исключения никогда не возникают.</span><span class="sxs-lookup"><span data-stu-id="de49f-1148">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de49f-1149">Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1149">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de49f-1150">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.i2`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1150">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i2` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1151">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1151">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1152">Преобразует верхнее значение в стеке вычислений в тип <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-1152">Converts the value on top of the evaluation stack to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1153">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1153">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1154">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1154">Format</span></span>|<span data-ttu-id="de49f-1155">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1155">Assembly Format</span></span>|<span data-ttu-id="de49f-1156">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1156">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1157">69</span><span class="sxs-lookup"><span data-stu-id="de49f-1157">69</span></span>|<span data-ttu-id="de49f-1158">с просчетом. i4</span><span class="sxs-lookup"><span data-stu-id="de49f-1158">conv.i4</span></span>|<span data-ttu-id="de49f-1159">Преобразует в `int32`, отправляя `int32` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1159">Convert to `int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="de49f-1160">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1160">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1161">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1161">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1162">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1162">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de49f-1163">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1163">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1164">Код операции `conv.i4` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1164">The `conv.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1165">Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1165">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de49f-1166">Значения с плавающей запятой преобразуются в тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1166">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de49f-1167">Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1167">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de49f-1168">При преобразовании из `float64` в `float32` точность может быть потеряна.</span><span class="sxs-lookup"><span data-stu-id="de49f-1168">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="de49f-1169">Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным).</span><span class="sxs-lookup"><span data-stu-id="de49f-1169">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de49f-1170">Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются.</span><span class="sxs-lookup"><span data-stu-id="de49f-1170">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de49f-1171">Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.</span><span class="sxs-lookup"><span data-stu-id="de49f-1171">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de49f-1172">Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.</span><span class="sxs-lookup"><span data-stu-id="de49f-1172">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de49f-1173">При использовании этого поля исключения никогда не возникают.</span><span class="sxs-lookup"><span data-stu-id="de49f-1173">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de49f-1174">Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1174">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de49f-1175">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.i4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1175">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1176">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1176">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1177">Преобразует верхнее значение в стеке вычислений в тип <see langword="int64" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-1177">Converts the value on top of the evaluation stack to <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1178">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1178">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1179">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1179">Format</span></span>|<span data-ttu-id="de49f-1180">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1180">Assembly Format</span></span>|<span data-ttu-id="de49f-1181">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1181">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1182">Sp6a</span><span class="sxs-lookup"><span data-stu-id="de49f-1182">6A</span></span>|<span data-ttu-id="de49f-1183">заменяющий i8</span><span class="sxs-lookup"><span data-stu-id="de49f-1183">conv.i8</span></span>|<span data-ttu-id="de49f-1184">Преобразует в `int64`, отправляя `int64` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1184">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="de49f-1185">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1185">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1186">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1186">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1187">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1187">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de49f-1188">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1188">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1189">Код операции `conv.i8` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1189">The `conv.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1190">Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1190">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de49f-1191">Значения с плавающей запятой преобразуются в тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1191">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de49f-1192">Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1192">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de49f-1193">При преобразовании из `float64` в `float32` точность может быть потеряна.</span><span class="sxs-lookup"><span data-stu-id="de49f-1193">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="de49f-1194">Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным).</span><span class="sxs-lookup"><span data-stu-id="de49f-1194">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de49f-1195">Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются.</span><span class="sxs-lookup"><span data-stu-id="de49f-1195">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de49f-1196">Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.</span><span class="sxs-lookup"><span data-stu-id="de49f-1196">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de49f-1197">Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.</span><span class="sxs-lookup"><span data-stu-id="de49f-1197">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de49f-1198">При использовании этого поля исключения никогда не возникают.</span><span class="sxs-lookup"><span data-stu-id="de49f-1198">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de49f-1199">Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1199">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de49f-1200">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.i8`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1200">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i8` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1201">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1201">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1202">Преобразует значение со знаком на вершине стека вычислений в значение <see langword="native int" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1202">Converts the signed value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1203">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1203">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1204">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1204">Format</span></span>|<span data-ttu-id="de49f-1205">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1205">Assembly Format</span></span>|<span data-ttu-id="de49f-1206">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1206">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1207">D4</span><span class="sxs-lookup"><span data-stu-id="de49f-1207">D4</span></span>|<span data-ttu-id="de49f-1208">ovf. i</span><span class="sxs-lookup"><span data-stu-id="de49f-1208">conv.ovf.i</span></span>|<span data-ttu-id="de49f-1209">Преобразует в `native int` (в стеке как `native int`) и создает исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1209">Convert to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1210">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1210">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1211">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1211">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1212">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1212">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1213">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1213">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1214">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1214">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1215">Код операции `conv.ovf.i` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1215">The `conv.ovf.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1216">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1216">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1217">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1217">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1218">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1218">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1219"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1219"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1220">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1220">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1221">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1221">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1222">Преобразует значение без знака на вершине стека вычислений в значение <see langword="native int" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1222">Converts the unsigned value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1223">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1223">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1224">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1224">Format</span></span>|<span data-ttu-id="de49f-1225">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1225">Assembly Format</span></span>|<span data-ttu-id="de49f-1226">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1226">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1227">8A</span><span class="sxs-lookup"><span data-stu-id="de49f-1227">8A</span></span>|<span data-ttu-id="de49f-1228">проovf. i. un</span><span class="sxs-lookup"><span data-stu-id="de49f-1228">conv.ovf.i.un</span></span>|<span data-ttu-id="de49f-1229">Преобразует значение без знака в `native int` (в стеке как `native int`) и создает исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1229">Converts an unsigned value to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1230">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1230">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1231">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1231">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1232">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1232">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1233">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1233">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1234">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1234">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1235">Код операции `conv.ovf.i.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1235">The `conv.ovf.i.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1236">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1236">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1237">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1237">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1238">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1238">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1239"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1239"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1240">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1240">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1241">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1241">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1242">Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int8" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1242">Converts the signed value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1243">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1243">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1244">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1244">Format</span></span>|<span data-ttu-id="de49f-1245">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1245">Assembly Format</span></span>|<span data-ttu-id="de49f-1246">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1246">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1247">B3</span><span class="sxs-lookup"><span data-stu-id="de49f-1247">B3</span></span>|<span data-ttu-id="de49f-1248">ovf. i1</span><span class="sxs-lookup"><span data-stu-id="de49f-1248">conv.ovf.i1</span></span>|<span data-ttu-id="de49f-1249">Преобразование в `int8` (в стеке как `int32`) и вызовет исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1249">Convert to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1250">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1250">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1251">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1251">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1252">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1252">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1253">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1253">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1254">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1254">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1255">Код операции `conv.ovf.i1` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1255">The `conv.ovf.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1256">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1256">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1257">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1257">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1258">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1258">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1259"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1259"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1260">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i1`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1260">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1261">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1261">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1262">Преобразует значение без знака на вершине стека вычислений в значение <see langword="int8" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1262">Converts the unsigned value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1263">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1263">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1264">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1264">Format</span></span>|<span data-ttu-id="de49f-1265">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1265">Assembly Format</span></span>|<span data-ttu-id="de49f-1266">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1266">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1267">82</span><span class="sxs-lookup"><span data-stu-id="de49f-1267">82</span></span>|<span data-ttu-id="de49f-1268">ovf. i1. un</span><span class="sxs-lookup"><span data-stu-id="de49f-1268">conv.ovf.i1.un</span></span>|<span data-ttu-id="de49f-1269">Преобразует значение без знака в `int8` (в стеке как `int32`) и создает исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1269">Converts an unsigned value to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1270">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1270">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1271">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1271">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1272">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1272">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1273">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1273">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1274">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1274">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1275">Код операции `conv.ovf.i1.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1275">The `conv.ovf.i1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1276">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1276">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1277">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1277">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1278">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1278">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1279"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1279"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1280">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i1.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1280">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1281">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1281">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1282">Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int16" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1282">Converts the signed value on top of the evaluation stack to signed <see langword="int16" /> and extending it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1283">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1283">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1284">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1284">Format</span></span>|<span data-ttu-id="de49f-1285">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1285">Assembly Format</span></span>|<span data-ttu-id="de49f-1286">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1286">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1287">B5</span><span class="sxs-lookup"><span data-stu-id="de49f-1287">B5</span></span>|<span data-ttu-id="de49f-1288">ovf. i2</span><span class="sxs-lookup"><span data-stu-id="de49f-1288">conv.ovf.i2</span></span>|<span data-ttu-id="de49f-1289">Преобразование в `int16` (в стеке как `int32`) и вызовет исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1289">Convert to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1290">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1290">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1291">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1291">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1292">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1292">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1293">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1293">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1294">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1294">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1295">Код операции `conv.ovf.i2` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1295">The `conv.ovf.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1296">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1296">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1297">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1297">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1298">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1298">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1299"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1299"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1300">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i2`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1300">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1301">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1301">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1302">Преобразует значение без знака на вершине стека вычислений в значение <see langword="int16" /> со знаком, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1302">Converts the unsigned value on top of the evaluation stack to signed <see langword="int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1303">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1303">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1304">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1304">Format</span></span>|<span data-ttu-id="de49f-1305">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1305">Assembly Format</span></span>|<span data-ttu-id="de49f-1306">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1306">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1307">83</span><span class="sxs-lookup"><span data-stu-id="de49f-1307">83</span></span>|<span data-ttu-id="de49f-1308">ovf. i2. un</span><span class="sxs-lookup"><span data-stu-id="de49f-1308">conv.ovf.i2.un</span></span>|<span data-ttu-id="de49f-1309">Преобразует значение без знака в `int16` (в стеке как `int32`) и создает исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1309">Converts an unsigned value to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1310">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1310">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1311">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1311">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1312">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1312">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1313">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1313">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1314">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1314">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1315">Код операции `conv.ovf.i2.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1315">The `conv.ovf.i2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1316">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1316">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1317">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1317">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1318">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1318">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1319"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1319"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1320">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i2.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1320">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1321">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1321">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1322">Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int32" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1322">Converts the signed value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1323">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1323">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1324">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1324">Format</span></span>|<span data-ttu-id="de49f-1325">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1325">Assembly Format</span></span>|<span data-ttu-id="de49f-1326">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1326">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1327">B7</span><span class="sxs-lookup"><span data-stu-id="de49f-1327">B7</span></span>|<span data-ttu-id="de49f-1328">ovf. i4</span><span class="sxs-lookup"><span data-stu-id="de49f-1328">conv.ovf.i4</span></span>|<span data-ttu-id="de49f-1329">Преобразование в `int32` (в стеке как `int32`) и вызовет исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1329">Convert to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1330">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1330">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1331">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1331">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1332">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1332">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1333">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1333">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1334">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1334">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1335">Код операции `conv.ovf.i4` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1335">The `conv.ovf.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1336">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1336">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1337">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1337">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1338">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1338">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1339"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1339"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1340">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1340">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1341">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1341">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1342">Преобразует значение без знака на вершине стека вычислений в значение <see langword="int32" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1342">Converts the unsigned value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1343">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1343">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1344">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1344">Format</span></span>|<span data-ttu-id="de49f-1345">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1345">Assembly Format</span></span>|<span data-ttu-id="de49f-1346">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1346">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1347">84</span><span class="sxs-lookup"><span data-stu-id="de49f-1347">84</span></span>|<span data-ttu-id="de49f-1348">ovf. i4. un</span><span class="sxs-lookup"><span data-stu-id="de49f-1348">conv.ovf.i4.un</span></span>|<span data-ttu-id="de49f-1349">Преобразует значение без знака в `int32` (в стеке как `int32`) и создает исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1349">Converts an unsigned value to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1350">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1350">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1351">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1351">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1352">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1352">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1353">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1353">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1354">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1354">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1355">Код операции `conv.ovf.i4.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1355">The `conv.ovf.i4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1356">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1356">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1357">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1357">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1358">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1358">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1359"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1359"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1360">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i4.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1360">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1361">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1361">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1362">Преобразует значение со знаком на вершине стека вычислений в значение <see langword="int64" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1362">Converts the signed value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1363">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1363">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1364">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1364">Format</span></span>|<span data-ttu-id="de49f-1365">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1365">Assembly Format</span></span>|<span data-ttu-id="de49f-1366">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1366">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1367">B9</span><span class="sxs-lookup"><span data-stu-id="de49f-1367">B9</span></span>|<span data-ttu-id="de49f-1368">ovf. i8</span><span class="sxs-lookup"><span data-stu-id="de49f-1368">conv.ovf.i8</span></span>|<span data-ttu-id="de49f-1369">Преобразование в `int64` (в стеке как `int64`) и вызовет исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1369">Convert to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1370">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1370">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1371">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1371">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1372">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1372">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1373">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1373">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1374">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1374">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1375">Код операции `conv.ovf.i8` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1375">The `conv.ovf.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1376">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1376">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1377">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1377">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1378">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1378">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1379"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1379"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1380">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i8`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1380">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1381">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1381">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1382">Преобразует значение без знака на вершине стека вычислений в значение <see langword="int64" /> со знаком и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1382">Converts the unsigned value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1383">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1383">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1384">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1384">Format</span></span>|<span data-ttu-id="de49f-1385">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1385">Assembly Format</span></span>|<span data-ttu-id="de49f-1386">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1386">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1387">85</span><span class="sxs-lookup"><span data-stu-id="de49f-1387">85</span></span>|<span data-ttu-id="de49f-1388">ovf. i8. un</span><span class="sxs-lookup"><span data-stu-id="de49f-1388">conv.ovf.i8.un</span></span>|<span data-ttu-id="de49f-1389">Преобразует значение без знака в `int64` (в стеке как `int64`) и создает исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1389">Converts an unsigned value to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1390">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1390">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1391">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1391">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1392">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1392">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1393">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1393">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1394">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1394">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1395">Код операции `conv.ovf.i8.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1395">The `conv.ovf.i8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1396">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1396">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1397">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1397">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1398">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1398">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1399"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1399"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1400">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.i8.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1400">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1401">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1401">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1402">Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned native int" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1402">Converts the signed value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1403">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1403">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1404">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1404">Format</span></span>|<span data-ttu-id="de49f-1405">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1405">Assembly Format</span></span>|<span data-ttu-id="de49f-1406">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1406">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1407">D5</span><span class="sxs-lookup"><span data-stu-id="de49f-1407">D5</span></span>|<span data-ttu-id="de49f-1408">ovf. u</span><span class="sxs-lookup"><span data-stu-id="de49f-1408">conv.ovf.u</span></span>|<span data-ttu-id="de49f-1409">Преобразование в `unsigned native int` (в стеке как `native int`) и вызовет исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1409">Convert to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1410">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1410">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1411">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1411">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1412">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1412">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1413">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1413">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1414">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1414">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1415">Код операции `conv.ovf.u` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1415">The `conv.ovf.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1416">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1416">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1417">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1417">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1418">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1418">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1419"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1419"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1420">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1420">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1421">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1421">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1422">Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned native int" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1422">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1423">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1423">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1424">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1424">Format</span></span>|<span data-ttu-id="de49f-1425">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1425">Assembly Format</span></span>|<span data-ttu-id="de49f-1426">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1426">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1427">8B</span><span class="sxs-lookup"><span data-stu-id="de49f-1427">8B</span></span>|<span data-ttu-id="de49f-1428">ovf. u. un</span><span class="sxs-lookup"><span data-stu-id="de49f-1428">conv.ovf.u.un</span></span>|<span data-ttu-id="de49f-1429">Преобразует значение UN без знака в `unsigned native int` (в стеке как `native int`) и создает исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1429">Converts un unsigned value to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1430">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1430">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1431">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1431">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1432">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1432">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1433">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1433">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1434">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1434">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1435">Код операции `conv.ovf.u.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1435">The `conv.ovf.u.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1436">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1436">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1437">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1437">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1438">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1438">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1439"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1439"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1440">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.uvf.u.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1440">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.uvf.u.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1441">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1441">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1442">Преобразует значение со знаком на вершине стека вычислений в значение <see langword="unsigned int8" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1442">Converts the signed value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1443">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1443">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1444">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1444">Format</span></span>|<span data-ttu-id="de49f-1445">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1445">Assembly Format</span></span>|<span data-ttu-id="de49f-1446">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1446">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1447">B4</span><span class="sxs-lookup"><span data-stu-id="de49f-1447">B4</span></span>|<span data-ttu-id="de49f-1448">ovf. U1</span><span class="sxs-lookup"><span data-stu-id="de49f-1448">conv.ovf.u1</span></span>|<span data-ttu-id="de49f-1449">Преобразование в `unsigned int8` (в стеке как `int32`) и вызовет исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1449">Convert to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1450">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1450">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1451">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1451">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1452">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1452">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1453">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1453">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1454">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1454">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1455">Код операции `conv.ovf.u1` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1455">The `conv.ovf.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1456">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1456">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1457">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1457">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1458">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1458">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1459"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1459"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1460">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u1`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1460">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1461">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1461">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1462">Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int8" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1462">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1463">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1463">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1464">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1464">Format</span></span>|<span data-ttu-id="de49f-1465">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1465">Assembly Format</span></span>|<span data-ttu-id="de49f-1466">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1466">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1467">86</span><span class="sxs-lookup"><span data-stu-id="de49f-1467">86</span></span>|<span data-ttu-id="de49f-1468">ovf. U1. un</span><span class="sxs-lookup"><span data-stu-id="de49f-1468">conv.ovf.u1.un</span></span>|<span data-ttu-id="de49f-1469">Преобразует значение без знака в `unsigned int8` (в стеке как `int32`) и создает исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1469">Converts an unsigned value to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1470">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1470">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1471">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1471">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1472">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1472">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1473">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1473">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1474">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1474">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1475">Код операции `conv.ovf.u1.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1475">The `conv.ovf.u1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1476">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1476">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1477">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1477">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1478">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1478">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1479"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1479"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1480">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u1.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1481">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1481">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1482">Преобразует значение со знаком на вершине стека вычислений в значение <see langword="unsigned int16" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1482">Converts the signed value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1483">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1484">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1484">Format</span></span>|<span data-ttu-id="de49f-1485">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1485">Assembly Format</span></span>|<span data-ttu-id="de49f-1486">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1487">B6</span><span class="sxs-lookup"><span data-stu-id="de49f-1487">B6</span></span>|<span data-ttu-id="de49f-1488">ovf. U2</span><span class="sxs-lookup"><span data-stu-id="de49f-1488">conv.ovf.u2</span></span>|<span data-ttu-id="de49f-1489">Преобразование в `unsigned int16` (в стеке как `int32`) и вызовет исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1489">Convert to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1490">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1491">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1491">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1492">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1492">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1493">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1493">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1494">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1494">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1495">Код операции `conv.ovf.u2` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1495">The `conv.ovf.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1496">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1496">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1497">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1497">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1498">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1498">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1499"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1499"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1500">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u2`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1500">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1501">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1501">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1502">Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int16" />, расширяет его до <see langword="int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1502">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1503">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1503">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1504">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1504">Format</span></span>|<span data-ttu-id="de49f-1505">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1505">Assembly Format</span></span>|<span data-ttu-id="de49f-1506">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1506">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1507">87</span><span class="sxs-lookup"><span data-stu-id="de49f-1507">87</span></span>|<span data-ttu-id="de49f-1508">проovf. U2. un</span><span class="sxs-lookup"><span data-stu-id="de49f-1508">conv.ovf.u2.un</span></span>|<span data-ttu-id="de49f-1509">Преобразует значение без знака в `unsigned int16` (в стеке как `int32`) и создает исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1509">Converts an unsigned value to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1510">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1510">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1511">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1511">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1512">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1512">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1513">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1513">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1514">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1514">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1515">Код операции `conv.ovf.u2.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1515">The `conv.ovf.u2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1516">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1516">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1517">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1517">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1518">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1518">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1519"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1519"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1520">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u2.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1520">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1521">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1521">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1522">Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1522">Converts the signed value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1523">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1523">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1524">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1524">Format</span></span>|<span data-ttu-id="de49f-1525">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1525">Assembly Format</span></span>|<span data-ttu-id="de49f-1526">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1526">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1527">B8</span><span class="sxs-lookup"><span data-stu-id="de49f-1527">B8</span></span>|<span data-ttu-id="de49f-1528">ovf. U4</span><span class="sxs-lookup"><span data-stu-id="de49f-1528">conv.ovf.u4</span></span>|<span data-ttu-id="de49f-1529">Преобразование в `unsigned int32` (в стеке как `int32`) и вызовет исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1529">Convert to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1530">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1530">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1531">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1531">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1532">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1532">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1533">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1533">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1534">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1534">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1535">Код операции `conv.ovf.u4` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1535">The `conv.ovf.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1536">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1536">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1537">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1537">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1538">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1538">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1539"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1539"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1540">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1540">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1541">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1541">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1542">Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int32" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1542">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1543">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1543">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1544">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1544">Format</span></span>|<span data-ttu-id="de49f-1545">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1545">Assembly Format</span></span>|<span data-ttu-id="de49f-1546">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1546">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1547">88</span><span class="sxs-lookup"><span data-stu-id="de49f-1547">88</span></span>|<span data-ttu-id="de49f-1548">ovf. U4. un</span><span class="sxs-lookup"><span data-stu-id="de49f-1548">conv.ovf.u4.un</span></span>|<span data-ttu-id="de49f-1549">Преобразует значение без знака в `unsigned int32` (в стеке как `int32`) и создает исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1549">Converts an unsigned value to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1550">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1550">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1551">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1551">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1552">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1552">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1553">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1553">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1554">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1554">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1555">Код операции `conv.ovf.u4.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1555">The `conv.ovf.u4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1556">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1556">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1557">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1557">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1558">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1558">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1559"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1559"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1560">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u4.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1560">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1561">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1561">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1562">Преобразует значение со знаком на вершине стека вычислений в <see langword="unsigned int64" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1562">Converts the signed value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1563">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1563">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1564">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1564">Format</span></span>|<span data-ttu-id="de49f-1565">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1565">Assembly Format</span></span>|<span data-ttu-id="de49f-1566">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1566">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1567">Бизнес</span><span class="sxs-lookup"><span data-stu-id="de49f-1567">BA</span></span>|<span data-ttu-id="de49f-1568">ovf. u8</span><span class="sxs-lookup"><span data-stu-id="de49f-1568">conv.ovf.u8</span></span>|<span data-ttu-id="de49f-1569">Преобразование в `unsigned int64` (в стеке как `int64`) и вызовет исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1569">Convert to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1570">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1570">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1571">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1571">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1572">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1572">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1573">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1573">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1574">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1574">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1575">Код операции `conv.ovf.u8` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1575">The `conv.ovf.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1576">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1576">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1577">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1577">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1578">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1578">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1579"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1579"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1580">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u8`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1580">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1581">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1581">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1582">Преобразует значение без знака на вершине стека вычислений в значение <see langword="unsigned int64" /> и создает исключение <see cref="T:System.OverflowException" /> в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1582">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1583">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1583">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1584">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1584">Format</span></span>|<span data-ttu-id="de49f-1585">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1585">Assembly Format</span></span>|<span data-ttu-id="de49f-1586">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1586">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1587">89</span><span class="sxs-lookup"><span data-stu-id="de49f-1587">89</span></span>|<span data-ttu-id="de49f-1588">ovf. u8. un</span><span class="sxs-lookup"><span data-stu-id="de49f-1588">conv.ovf.u8.un</span></span>|<span data-ttu-id="de49f-1589">Преобразует значение без знака в `unsigned int64` (в стеке как `int64`) и создает исключение в случае переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1589">Converts an unsigned value to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="de49f-1590">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1590">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1591">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1591">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1592">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1592">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="de49f-1593">Если возникает переполнение, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1593">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="de49f-1594">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1594">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1595">Код операции `conv.ovf.u8.un` преобразует `value` поверх стека в тип, указанный в коде операции, и помещает это преобразованное значение в начало стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1595">The `conv.ovf.u8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1596">Если значение слишком велико или слишком мало для представления целевым типом, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1596">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="de49f-1597">Преобразования чисел с плавающей запятой в целые значения сокращают число в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1597">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="de49f-1598">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используются `conv.ovf.i` или `conv.ovf.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1598">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="de49f-1599"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1599"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-1600">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.ovf.u8.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1600">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1601">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1601">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1602">Преобразование целочисленного значения без знака на вершине стека вычислений в <see langword="float32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-1602">Converts the unsigned integer value on top of the evaluation stack to <see langword="float32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1603">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1603">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1604">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1604">Format</span></span>|<span data-ttu-id="de49f-1605">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1605">Assembly Format</span></span>|<span data-ttu-id="de49f-1606">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1606">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1607">76</span><span class="sxs-lookup"><span data-stu-id="de49f-1607">76</span></span>|<span data-ttu-id="de49f-1608">Рассчет. r. un</span><span class="sxs-lookup"><span data-stu-id="de49f-1608">conv.r.un</span></span>|<span data-ttu-id="de49f-1609">Преобразует целое число без знака в число с плавающей запятой, отправляя `F` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1609">Convert unsigned integer to floating-point, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="de49f-1610">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1610">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1611">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1611">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1612">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1612">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de49f-1613">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1613">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1614">Код операции `conv.r.un` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1614">The `conv.r.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1615">Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1615">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de49f-1616">Значения с плавающей запятой преобразуются в тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1616">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de49f-1617">Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1617">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de49f-1618">При преобразовании из `float64` в `float32` точность может быть потеряна.</span><span class="sxs-lookup"><span data-stu-id="de49f-1618">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="de49f-1619">Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным).</span><span class="sxs-lookup"><span data-stu-id="de49f-1619">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de49f-1620">Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются.</span><span class="sxs-lookup"><span data-stu-id="de49f-1620">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de49f-1621">Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.</span><span class="sxs-lookup"><span data-stu-id="de49f-1621">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de49f-1622">Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемый `result` не определен.</span><span class="sxs-lookup"><span data-stu-id="de49f-1622">If overflow occurs converting a floating-point type to an integer the `result` returned is unspecified.</span></span> <span data-ttu-id="de49f-1623">Операция `conv.r.un` принимает целое число из стека, интерпретирует его как неподписанное и заменяет его на число с плавающей запятой для представления целого числа: значение `float32`, если это достаточно, чтобы представить целое число без потери точности, или, в противном случае `float64`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1623">The `conv.r.un` operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a `float32`, if this is wide enough to represent the integer without loss of precision, or else a `float64`.</span></span>  
  
 <span data-ttu-id="de49f-1624">При использовании этого поля исключения никогда не возникают.</span><span class="sxs-lookup"><span data-stu-id="de49f-1624">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="de49f-1625">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.r.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1625">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1626">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1626">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1627">Преобразует верхнее значение в стеке вычислений в тип <see langword="float32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-1627">Converts the value on top of the evaluation stack to <see langword="float32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1628">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1628">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1629">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1629">Format</span></span>|<span data-ttu-id="de49f-1630">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1630">Assembly Format</span></span>|<span data-ttu-id="de49f-1631">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1631">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1632">6B</span><span class="sxs-lookup"><span data-stu-id="de49f-1632">6B</span></span>|<span data-ttu-id="de49f-1633">с кредитом. R4</span><span class="sxs-lookup"><span data-stu-id="de49f-1633">conv.r4</span></span>|<span data-ttu-id="de49f-1634">Преобразует в `float32`, отправляя `F` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1634">Convert to `float32`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="de49f-1635">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1635">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1636">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1636">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1637">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1637">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de49f-1638">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1638">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1639">Код операции `conv.r4` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1639">The `conv.r4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1640">Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1640">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de49f-1641">Значения с плавающей запятой преобразуются в тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1641">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de49f-1642">Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1642">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de49f-1643">При преобразовании из `float64` в `float32` точность может быть потеряна.</span><span class="sxs-lookup"><span data-stu-id="de49f-1643">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="de49f-1644">Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным).</span><span class="sxs-lookup"><span data-stu-id="de49f-1644">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de49f-1645">Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются.</span><span class="sxs-lookup"><span data-stu-id="de49f-1645">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de49f-1646">Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.</span><span class="sxs-lookup"><span data-stu-id="de49f-1646">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de49f-1647">Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.</span><span class="sxs-lookup"><span data-stu-id="de49f-1647">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de49f-1648">При использовании этого поля исключения никогда не возникают.</span><span class="sxs-lookup"><span data-stu-id="de49f-1648">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="de49f-1649">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.r4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1649">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1650">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1650">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1651">Преобразует верхнее значение в стеке вычислений в тип <see langword="float64" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-1651">Converts the value on top of the evaluation stack to <see langword="float64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1652">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1652">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1653">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1653">Format</span></span>|<span data-ttu-id="de49f-1654">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1654">Assembly Format</span></span>|<span data-ttu-id="de49f-1655">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1655">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1656">6C</span><span class="sxs-lookup"><span data-stu-id="de49f-1656">6C</span></span>|<span data-ttu-id="de49f-1657">с кредитом. R8</span><span class="sxs-lookup"><span data-stu-id="de49f-1657">conv.r8</span></span>|<span data-ttu-id="de49f-1658">Преобразует в `float64`, отправляя `F` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1658">Convert to `float64`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="de49f-1659">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1659">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1660">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1660">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1661">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1661">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de49f-1662">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1662">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1663">Код операции `conv.r8` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1663">The `conv.r8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1664">Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1664">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de49f-1665">Значения с плавающей запятой преобразуются в тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1665">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de49f-1666">Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1666">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de49f-1667">При преобразовании из `float64` в `float32` точность может быть потеряна.</span><span class="sxs-lookup"><span data-stu-id="de49f-1667">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="de49f-1668">Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным).</span><span class="sxs-lookup"><span data-stu-id="de49f-1668">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de49f-1669">Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются.</span><span class="sxs-lookup"><span data-stu-id="de49f-1669">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de49f-1670">Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.</span><span class="sxs-lookup"><span data-stu-id="de49f-1670">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de49f-1671">Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.</span><span class="sxs-lookup"><span data-stu-id="de49f-1671">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de49f-1672">При использовании этого поля исключения никогда не возникают.</span><span class="sxs-lookup"><span data-stu-id="de49f-1672">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="de49f-1673">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.r8`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1673">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r8` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1674">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1674">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1675">Преобразует верхнее значение в стеке вычислений в <see langword="unsigned native int" />, а затем расширяет его до <see langword="native int" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-1675">Converts the value on top of the evaluation stack to <see langword="unsigned native int" />, and extends it to <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1676">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1676">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1677">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1677">Format</span></span>|<span data-ttu-id="de49f-1678">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1678">Assembly Format</span></span>|<span data-ttu-id="de49f-1679">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1679">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1680">E0</span><span class="sxs-lookup"><span data-stu-id="de49f-1680">E0</span></span>|<span data-ttu-id="de49f-1681">Кредит u</span><span class="sxs-lookup"><span data-stu-id="de49f-1681">conv.u</span></span>|<span data-ttu-id="de49f-1682">Преобразует в `unsigned native int`, отправляя `native int` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1682">Convert to `unsigned native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="de49f-1683">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1683">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1684">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1684">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1685">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1685">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de49f-1686">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1686">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1687">Код операции `conv.u` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1687">The `conv.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1688">Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1688">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de49f-1689">Значения с плавающей запятой преобразуются в тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1689">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de49f-1690">Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1690">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de49f-1691">При преобразовании из `float64` в `float32` точность может быть потеряна.</span><span class="sxs-lookup"><span data-stu-id="de49f-1691">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="de49f-1692">Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным).</span><span class="sxs-lookup"><span data-stu-id="de49f-1692">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de49f-1693">Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются.</span><span class="sxs-lookup"><span data-stu-id="de49f-1693">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de49f-1694">Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.</span><span class="sxs-lookup"><span data-stu-id="de49f-1694">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de49f-1695">Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.</span><span class="sxs-lookup"><span data-stu-id="de49f-1695">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de49f-1696">При использовании этого поля исключения никогда не возникают.</span><span class="sxs-lookup"><span data-stu-id="de49f-1696">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de49f-1697">Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1697">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de49f-1698">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.u`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1698">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1699">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1699">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1700">Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int8" />, а затем расширяет его до <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-1700">Converts the value on top of the evaluation stack to <see langword="unsigned int8" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1701">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1701">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1702">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1702">Format</span></span>|<span data-ttu-id="de49f-1703">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1703">Assembly Format</span></span>|<span data-ttu-id="de49f-1704">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1704">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1705">D2</span><span class="sxs-lookup"><span data-stu-id="de49f-1705">D2</span></span>|<span data-ttu-id="de49f-1706">с кредитом. U1</span><span class="sxs-lookup"><span data-stu-id="de49f-1706">conv.u1</span></span>|<span data-ttu-id="de49f-1707">Преобразует в `int8`, отправляя `int32` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1707">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="de49f-1708">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1708">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1709">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1709">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1710">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1710">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de49f-1711">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1711">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1712">Код операции `conv.u1` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1712">The `conv.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1713">Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1713">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de49f-1714">Значения с плавающей запятой преобразуются в тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1714">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de49f-1715">Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1715">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de49f-1716">При преобразовании из `float64` в `float32` точность может быть потеряна.</span><span class="sxs-lookup"><span data-stu-id="de49f-1716">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="de49f-1717">Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным).</span><span class="sxs-lookup"><span data-stu-id="de49f-1717">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de49f-1718">Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются.</span><span class="sxs-lookup"><span data-stu-id="de49f-1718">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de49f-1719">Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.</span><span class="sxs-lookup"><span data-stu-id="de49f-1719">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de49f-1720">Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.</span><span class="sxs-lookup"><span data-stu-id="de49f-1720">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de49f-1721">При использовании этого поля исключения никогда не возникают.</span><span class="sxs-lookup"><span data-stu-id="de49f-1721">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de49f-1722">Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1722">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de49f-1723">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.u1`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1723">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u1` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1724">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1724">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1725">Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int16" />, а затем расширяет его до <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-1725">Converts the value on top of the evaluation stack to <see langword="unsigned int16" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1726">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1726">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1727">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1727">Format</span></span>|<span data-ttu-id="de49f-1728">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1728">Assembly Format</span></span>|<span data-ttu-id="de49f-1729">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1729">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1730">D1</span><span class="sxs-lookup"><span data-stu-id="de49f-1730">D1</span></span>|<span data-ttu-id="de49f-1731">Кредитный. U2</span><span class="sxs-lookup"><span data-stu-id="de49f-1731">conv.u2</span></span>|<span data-ttu-id="de49f-1732">Преобразует в `int16`, отправляя `int32` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1732">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="de49f-1733">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1733">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1734">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1734">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1735">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1735">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de49f-1736">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1736">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1737">Код операции `conv.u2` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1737">The `conv.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1738">Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1738">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de49f-1739">Значения с плавающей запятой преобразуются в тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1739">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de49f-1740">Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1740">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de49f-1741">При преобразовании из `float64` в `float32` точность может быть потеряна.</span><span class="sxs-lookup"><span data-stu-id="de49f-1741">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="de49f-1742">Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным).</span><span class="sxs-lookup"><span data-stu-id="de49f-1742">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de49f-1743">Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются.</span><span class="sxs-lookup"><span data-stu-id="de49f-1743">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de49f-1744">Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.</span><span class="sxs-lookup"><span data-stu-id="de49f-1744">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de49f-1745">Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.</span><span class="sxs-lookup"><span data-stu-id="de49f-1745">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de49f-1746">При использовании этого поля исключения никогда не возникают.</span><span class="sxs-lookup"><span data-stu-id="de49f-1746">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de49f-1747">Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1747">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de49f-1748">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.u2`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1748">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u2` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1749">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1749">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1750">Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int32" />, а затем расширяет его до <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-1750">Converts the value on top of the evaluation stack to <see langword="unsigned int32" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1751">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1751">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1752">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1752">Format</span></span>|<span data-ttu-id="de49f-1753">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1753">Assembly Format</span></span>|<span data-ttu-id="de49f-1754">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1754">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1755">6D</span><span class="sxs-lookup"><span data-stu-id="de49f-1755">6D</span></span>|<span data-ttu-id="de49f-1756">U4</span><span class="sxs-lookup"><span data-stu-id="de49f-1756">conv.u4</span></span>|<span data-ttu-id="de49f-1757">Преобразует в `unsigned int32`, отправляя `int32` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1757">Convert to `unsigned int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="de49f-1758">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1758">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1759">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1759">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1760">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1760">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de49f-1761">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1761">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1762">Код операции `conv.u4` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1762">The `conv.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1763">Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1763">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de49f-1764">Значения с плавающей запятой преобразуются в тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1764">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de49f-1765">Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1765">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de49f-1766">При преобразовании из `float64` в `float32` точность может быть потеряна.</span><span class="sxs-lookup"><span data-stu-id="de49f-1766">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="de49f-1767">Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным).</span><span class="sxs-lookup"><span data-stu-id="de49f-1767">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de49f-1768">Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются.</span><span class="sxs-lookup"><span data-stu-id="de49f-1768">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de49f-1769">Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.</span><span class="sxs-lookup"><span data-stu-id="de49f-1769">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de49f-1770">Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.</span><span class="sxs-lookup"><span data-stu-id="de49f-1770">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de49f-1771">При использовании этого поля исключения никогда не возникают.</span><span class="sxs-lookup"><span data-stu-id="de49f-1771">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de49f-1772">Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1772">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de49f-1773">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.u4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1773">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1774">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1774">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1775">Преобразует верхнее значение в стеке вычислений в <see langword="unsigned int64" />, а затем расширяет его до <see langword="int64" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-1775">Converts the value on top of the evaluation stack to <see langword="unsigned int64" />, and extends it to <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1776">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1776">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1777">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1777">Format</span></span>|<span data-ttu-id="de49f-1778">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1778">Assembly Format</span></span>|<span data-ttu-id="de49f-1779">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1779">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1780">6E</span><span class="sxs-lookup"><span data-stu-id="de49f-1780">6E</span></span>|<span data-ttu-id="de49f-1781">U8</span><span class="sxs-lookup"><span data-stu-id="de49f-1781">conv.u8</span></span>|<span data-ttu-id="de49f-1782">Преобразует в `int64`, отправляя `int64` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1782">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="de49f-1783">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1783">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1784">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1784">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1785">`value` извлекается из стека, и выполняется попытка выполнить операцию преобразования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1785">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="de49f-1786">Если преобразование прошло успешно, полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1786">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1787">Код операции `conv.u8` преобразует `value` поверх стека в тип, указанный в коде операции, и оставляет это преобразованное значение в верхней части стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1787">The `conv.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="de49f-1788">Целочисленные значения менее 4 байт расширяются до `int32`, когда они загружаются в стек вычислений (если не используется `conv.i` или `conv.u`, в этом случае результатом также будет `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1788">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="de49f-1789">Значения с плавающей запятой преобразуются в тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1789">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="de49f-1790">Преобразование чисел с плавающей запятой в целые значения Усекает число до нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1790">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="de49f-1791">При преобразовании из `float64` в `float32` точность может быть потеряна.</span><span class="sxs-lookup"><span data-stu-id="de49f-1791">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="de49f-1792">Если значение `value` слишком велико для `float32 (F)`, положительная бесконечность (если `value` является положительным) или отрицательная бесконечность (если `value` является отрицательным).</span><span class="sxs-lookup"><span data-stu-id="de49f-1792">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="de49f-1793">Если переполнение происходит при преобразовании одного целочисленного типа в другой, биты высокого порядка усекаются.</span><span class="sxs-lookup"><span data-stu-id="de49f-1793">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="de49f-1794">Если результат меньше, чем `int32`, для заполнения слота используется значение, расширенное знаком.</span><span class="sxs-lookup"><span data-stu-id="de49f-1794">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="de49f-1795">Если происходит переполнение при преобразовании типа с плавающей запятой в целое число, возвращаемое значение не определено.</span><span class="sxs-lookup"><span data-stu-id="de49f-1795">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="de49f-1796">При использовании этого поля исключения никогда не возникают.</span><span class="sxs-lookup"><span data-stu-id="de49f-1796">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="de49f-1797">Эквивалентные инструкции, которые вызовут исключение, если тип результата не может правильно представить результирующее значение, см. в разделе <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> и <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1797">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="de49f-1798">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `conv.u8`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1798">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u8` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1799">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1799">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1800">Копирует заданное число байт из исходного адреса в конечный.</span><span class="sxs-lookup"><span data-stu-id="de49f-1800">Copies a specified number bytes from a source address to a destination address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1801">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1801">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1802">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1802">Format</span></span>|<span data-ttu-id="de49f-1803">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1803">Assembly Format</span></span>|<span data-ttu-id="de49f-1804">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1804">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1805">FE 17</span><span class="sxs-lookup"><span data-stu-id="de49f-1805">FE 17</span></span>|<span data-ttu-id="de49f-1806">cpblk</span><span class="sxs-lookup"><span data-stu-id="de49f-1806">cpblk</span></span>|<span data-ttu-id="de49f-1807">Копирование данных из одного блока памяти в другой.</span><span class="sxs-lookup"><span data-stu-id="de49f-1807">Copy data from one memory block to another.</span></span>|  
  
 <span data-ttu-id="de49f-1808">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1808">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1809">Адрес назначения помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1809">The destination address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1810">Исходный адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1810">The source address is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-1811">Число байтов для копирования помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1811">The number of bytes to copy is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de49f-1812">Число байтов, исходный адрес и адрес назначения извлекаются из стека; указанное число байтов копируется из исходного адреса в конечный адрес.</span><span class="sxs-lookup"><span data-stu-id="de49f-1812">The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</span></span>  
  
 <span data-ttu-id="de49f-1813">Инструкция `cpblk` копирует число (тип `unsigned int32`) байтов с исходного адреса (типа `*`, `native int` или `&`) в адрес назначения (типа `*`, `native int` или `&`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1813">The `cpblk` instruction copies a number (type `unsigned int32`) of bytes from a source address (of type `*`, `native int`, or `&`) to a destination address (of type `*`, `native int`, or `&`).</span></span> <span data-ttu-id="de49f-1814">Поведение `cpblk` не указано, если исходная и Целевая области перекрываются.</span><span class="sxs-lookup"><span data-stu-id="de49f-1814">The behavior of `cpblk` is unspecified if the source and destination areas overlap.</span></span>  
  
 <span data-ttu-id="de49f-1815">`cpblk` предполагает, что исходные и целевые адреса выровнены по естественному размеру компьютера.</span><span class="sxs-lookup"><span data-stu-id="de49f-1815">`cpblk` assumes that both the source and destination addressed are aligned to the natural size of the machine.</span></span> <span data-ttu-id="de49f-1816">Инструкция `cpblk` может быть непосредственно перед инструкцией `unaligned.<prefix>`, чтобы указать, что источник или назначение не совпадают.</span><span class="sxs-lookup"><span data-stu-id="de49f-1816">The `cpblk` instruction can be immediately preceded by the `unaligned.<prefix>` instruction to indicate that either the source or the destination is unaligned.</span></span>  
  
 <span data-ttu-id="de49f-1817">Операция `cpblk` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1817">The operation of the `cpblk` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de49f-1818">При обнаружении недопустимого адреса может возникнуть исключение <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1818"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de49f-1819">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `cpblk`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1819">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpblk` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1820">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1820">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1821">Копирует тип значения по адресу объекта (с типом <see langword="&amp;" />, <see langword="*" /> или <see langword="native int" />) и помещает его по адресу конечного объекта (с типом <see langword="&amp;" />, <see langword="*" /> или <see langword="native int" />).</span><span class="sxs-lookup"><span data-stu-id="de49f-1821">Copies the value type located at the address of an object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />) to the address of the destination object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1822">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1822">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1823">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1823">Format</span></span>|<span data-ttu-id="de49f-1824">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1824">Assembly Format</span></span>|<span data-ttu-id="de49f-1825">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1825">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1826">70 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-1826">70 < `T` ></span></span>|<span data-ttu-id="de49f-1827">кпобж `classTok`</span><span class="sxs-lookup"><span data-stu-id="de49f-1827">cpobj `classTok`</span></span>|<span data-ttu-id="de49f-1828">Копирует тип значения из исходного объекта в целевой объект.</span><span class="sxs-lookup"><span data-stu-id="de49f-1828">Copies a value type from a source object to a destination object.</span></span>|  
  
 <span data-ttu-id="de49f-1829">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1829">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1830">Ссылка на целевой объект помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1830">The destination object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1831">Ссылка на исходный объект помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1831">The source object reference is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-1832">Две ссылки на объекты извлекаются из стека; Тип значения по адресу исходного объекта копируется на адрес целевого объекта.</span><span class="sxs-lookup"><span data-stu-id="de49f-1832">The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</span></span>  
  
 <span data-ttu-id="de49f-1833">Поведение `cpobj` не указано, если исходные и целевые ссылки на объекты не являются указателями на экземпляры класса, представленного токеном класса `classTok` (a `typeref` или `typedef`) или если `classTok` не представляет тип значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1833">The behavior of `cpobj` is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token `classTok` (a `typeref` or `typedef`), or if `classTok` does not represent a value type.</span></span>  
  
 <span data-ttu-id="de49f-1834">При обнаружении недопустимого адреса может возникнуть исключение <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1834"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de49f-1835">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `cpobj`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1835">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpobj` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1836">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-1836">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1837">Делит одно значение на другое и помещает результат в стек вычислений как число с плавающей запятой (с типом <see langword="F" />) или как частное (с типом <see langword="int32" />).</span><span class="sxs-lookup"><span data-stu-id="de49f-1837">Divides two values and pushes the result as a floating-point (type <see langword="F" />) or quotient (type <see langword="int32" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1838">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1838">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1839">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1839">Format</span></span>|<span data-ttu-id="de49f-1840">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1840">Assembly Format</span></span>|<span data-ttu-id="de49f-1841">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1841">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1842">5B</span><span class="sxs-lookup"><span data-stu-id="de49f-1842">5B</span></span>|<span data-ttu-id="de49f-1843">div</span><span class="sxs-lookup"><span data-stu-id="de49f-1843">div</span></span>|<span data-ttu-id="de49f-1844">Делит два значения, чтобы вернуть результат частного или с плавающей точкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-1844">Divides two values to return a quotient or floating-point result.</span></span>|  
  
 <span data-ttu-id="de49f-1845">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1845">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1846">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1846">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1847">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1847">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-1848">`value2` и `value1` извлекаются из стека; `value1` делится на `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1848">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="de49f-1849">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1849">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1850">`result` = `value1` div value2 удовлетворяет следующим условиям:</span><span class="sxs-lookup"><span data-stu-id="de49f-1850">`result` = `value1` div value2 satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="de49f-1851">&#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, и:</span><span class="sxs-lookup"><span data-stu-id="de49f-1851">&#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:</span></span>  
  
 <span data-ttu-id="de49f-1852">Sign (`result`) = +, если знак (`value1`) = Sign (`value2`) или-, if знак (`value1`) ~ = Sign (`value2`)</span><span class="sxs-lookup"><span data-stu-id="de49f-1852">sign(`result`) = +, if sign(`value1`) = sign(`value2`), or -, if sign(`value1`) ~= sign(`value2`)</span></span>  
  
 <span data-ttu-id="de49f-1853">Инструкция `div` вычислит результат и помещает его в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1853">The `div` instruction computes the result and pushes it on the stack.</span></span>  
  
 <span data-ttu-id="de49f-1854">Деление целых чисел усекается до нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-1854">Integer division truncates towards zero.</span></span>  
  
 <span data-ttu-id="de49f-1855">Деление конечного числа на ноль приводит к правильному бесконечному значению со знаком.</span><span class="sxs-lookup"><span data-stu-id="de49f-1855">Division of a finite number by zero produces the correctly signed infinite value.</span></span>  
  
 <span data-ttu-id="de49f-1856">Деление нуля на ноль или бесконечность по бесконечности приводит к получению значения NaN (нечисловое).</span><span class="sxs-lookup"><span data-stu-id="de49f-1856">Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value.</span></span> <span data-ttu-id="de49f-1857">Любое число, деленное на бесконечность, приведет к нулевому значению.</span><span class="sxs-lookup"><span data-stu-id="de49f-1857">Any number divided by infinity will produce a zero value.</span></span>  
  
 <span data-ttu-id="de49f-1858">Целочисленные операции создают исключение <xref:System.ArithmeticException>, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-1858">Integral operations throw <xref:System.ArithmeticException> if the result cannot be represented in the result type.</span></span> <span data-ttu-id="de49f-1859">Это может произойти, если `value1` является максимальным отрицательным значением, а `value2` равно-1.</span><span class="sxs-lookup"><span data-stu-id="de49f-1859">This can happen if `value1` is the maximum negative value, and `value2` is -1.</span></span>  
  
 <span data-ttu-id="de49f-1860">Целочисленные операции создают исключение <xref:System.DivideByZeroException>, если `value2` равно нулю.</span><span class="sxs-lookup"><span data-stu-id="de49f-1860">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="de49f-1861">Обратите внимание, что на платформах на базе процессоров Intel при вычислении (minint div-1) создается <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1861">Note that on Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint div -1).</span></span> <span data-ttu-id="de49f-1862">Операции с плавающей запятой никогда не создают исключение (они создают значений NaN или бесконечность).</span><span class="sxs-lookup"><span data-stu-id="de49f-1862">Floating-point operations never throw an exception (they produce NaNs or infinities instead).</span></span>  
  
 <span data-ttu-id="de49f-1863">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `div`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1863">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1864">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1864">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1865">Делит одно целочисленное значение без знака на другое и помещает результат (<see langword="int32" />) в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-1865">Divides two unsigned integer values and pushes the result (<see langword="int32" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1866">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1866">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1867">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1867">Format</span></span>|<span data-ttu-id="de49f-1868">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1868">Assembly Format</span></span>|<span data-ttu-id="de49f-1869">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1869">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1870">5C</span><span class="sxs-lookup"><span data-stu-id="de49f-1870">5C</span></span>|<span data-ttu-id="de49f-1871">Div. un</span><span class="sxs-lookup"><span data-stu-id="de49f-1871">div.un</span></span>|<span data-ttu-id="de49f-1872">Делит два значения без знака, возвращая частное.</span><span class="sxs-lookup"><span data-stu-id="de49f-1872">Divides two values, unsigned, returning a quotient.</span></span>|  
  
 <span data-ttu-id="de49f-1873">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1873">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1874">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1874">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1875">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1875">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-1876">`value2` и `value1` извлекаются из стека; `value1` делится на `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1876">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="de49f-1877">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1877">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1878">Инструкция `div.un` делит `value1` на `value2`, как целые числа без знака, и помещает `result` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1878">The `div.un` instruction computes `value1` divided by `value2`, both taken as unsigned integers, and pushes the `result` on the stack.</span></span>  
  
 <span data-ttu-id="de49f-1879">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `div.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1879">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1880">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1880">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1881">Копирует текущее верхнее значение в стеке вычислений и помещает копию в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-1881">Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1882">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1882">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1883">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1883">Format</span></span>|<span data-ttu-id="de49f-1884">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1884">Assembly Format</span></span>|<span data-ttu-id="de49f-1885">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1885">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1886">25</span><span class="sxs-lookup"><span data-stu-id="de49f-1886">25</span></span>|<span data-ttu-id="de49f-1887">DUP</span><span class="sxs-lookup"><span data-stu-id="de49f-1887">dup</span></span>|<span data-ttu-id="de49f-1888">Дублирует значение в верхней части стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1888">Duplicates the value on the top of the stack.</span></span>|  
  
 <span data-ttu-id="de49f-1889">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1889">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1890">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1890">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1891">`value` извлекается из стека для дублирования.</span><span class="sxs-lookup"><span data-stu-id="de49f-1891">`value` is popped off of the stack for duplication.</span></span>  
  
3.  <span data-ttu-id="de49f-1892">`value` помещается обратно в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1892">`value` is pushed back onto the stack.</span></span>  
  
4.  <span data-ttu-id="de49f-1893">Повторяющееся значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1893">A duplicate value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1894">Инструкция `dup` дублирует верхний элемент стека и оставляет два одинаковых значения на вершине.</span><span class="sxs-lookup"><span data-stu-id="de49f-1894">The `dup` instruction duplicates the top element of the stack, and leaves two identical values atop it.</span></span>  
  
 <span data-ttu-id="de49f-1895">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `dup`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1895">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `dup` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1896">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1896">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1897">Передает управление из предложения <see langword="filter" /> исключения обратно в обработчик исключений CLI.</span><span class="sxs-lookup"><span data-stu-id="de49f-1897">Transfers control from the <see langword="filter" /> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1898">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1899">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1899">Format</span></span>|<span data-ttu-id="de49f-1900">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1900">Assembly Format</span></span>|<span data-ttu-id="de49f-1901">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1902">FE 11</span><span class="sxs-lookup"><span data-stu-id="de49f-1902">FE 11</span></span>|<span data-ttu-id="de49f-1903">Команда endfilter</span><span class="sxs-lookup"><span data-stu-id="de49f-1903">endfilter</span></span>|<span data-ttu-id="de49f-1904">Завершающее предложение фильтра обработки исключений SEH.</span><span class="sxs-lookup"><span data-stu-id="de49f-1904">End filter clause of SEH exception handling.</span></span>|  
  
 <span data-ttu-id="de49f-1905">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1906">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1906">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1907">`value` извлекается из стека; `endfilter` выполняется, и управление передается обработчику исключений.</span><span class="sxs-lookup"><span data-stu-id="de49f-1907">`value` is popped from the stack; `endfilter` is executed and control is transferred to the exception handler.</span></span>  
  
 <span data-ttu-id="de49f-1908">`Value` (который должен иметь тип `int32` и является одним из определенного набора значений) возвращается из предложения Filter.</span><span class="sxs-lookup"><span data-stu-id="de49f-1908">`Value` (which must be of type `int32` and is one of a specific set of values) is returned from the filter clause.</span></span> <span data-ttu-id="de49f-1909">Он должен быть одним из следующих:</span><span class="sxs-lookup"><span data-stu-id="de49f-1909">It should be one of:</span></span>  
  
-   <span data-ttu-id="de49f-1910">`exception_continue_search` (`value` = 0), чтобы продолжить поиск обработчика исключений</span><span class="sxs-lookup"><span data-stu-id="de49f-1910">`exception_continue_search` (`value` = 0) to continue searching for an exception handler</span></span>  
  
-   <span data-ttu-id="de49f-1911">`exception_execute_handler` (`value` = 1), чтобы начать второй этап обработки исключений, в котором блоки finally выполняются до тех пор, пока не будет найден обработчик, связанный с этим предложением фильтра.</span><span class="sxs-lookup"><span data-stu-id="de49f-1911">`exception_execute_handler` (`value` = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located.</span></span> <span data-ttu-id="de49f-1912">После обнаружения выполняется обработчик.</span><span class="sxs-lookup"><span data-stu-id="de49f-1912">Upon discovery, the handler is executed.</span></span>  
  
 <span data-ttu-id="de49f-1913">Другие целочисленные значения приведут к неопределенным результатам.</span><span class="sxs-lookup"><span data-stu-id="de49f-1913">Other integer values will produce unspecified results.</span></span>  
  
 <span data-ttu-id="de49f-1914">Точка входа фильтра, как показано в таблице исключений метода, должна быть первой инструкцией в блоке кода фильтра.</span><span class="sxs-lookup"><span data-stu-id="de49f-1914">The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block.</span></span> <span data-ttu-id="de49f-1915">Инструкция `endfilter` должна быть последней инструкцией в блоке кода фильтра (следовательно, для одного блока фильтра может быть только один `endfilter`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1915">The `endfilter` instruction must be the last instruction in the filter's code block (hence there can only be one `endfilter` for any single filter block).</span></span> <span data-ttu-id="de49f-1916">После выполнения инструкции `endfilter` Управление логически передается обратно механизму обработки исключений CLI.</span><span class="sxs-lookup"><span data-stu-id="de49f-1916">After executing the `endfilter` instruction, control logically flows back to the CLI exception handling mechanism.</span></span>  
  
 <span data-ttu-id="de49f-1917">Управление не может быть передано в блок фильтра, за исключением механизма исключения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1917">Control cannot be transferred into a filter block except through the exception mechanism.</span></span> <span data-ttu-id="de49f-1918">Управление не может быть передано из блока фильтра, за исключением использования инструкции `throw` или выполнения последней инструкции `endfilter`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1918">Control cannot be transferred out of a filter block except through the use of a `throw` instruction or by executing the final `endfilter` instruction.</span></span> <span data-ttu-id="de49f-1919">Нельзя внедрить блок `try` в блок `filter`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1919">You cannot embed a `try` block within a `filter` block.</span></span> <span data-ttu-id="de49f-1920">Если в блоке `filter` возникает исключение, оно перехватывается и возвращается значение 0 (`exception_continue_search`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1920">If an exception is thrown inside the `filter` block, it is intercepted and a value of 0 (`exception_continue_search`) is returned.</span></span>  
  
 <span data-ttu-id="de49f-1921">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `endfilter`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1921">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfilter` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1922">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1922">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1923">Передает управление из предложения <see langword="fault" /> или <see langword="finally" /> блока исключения обратно обработчику исключений CLI.</span><span class="sxs-lookup"><span data-stu-id="de49f-1923">Transfers control from the <see langword="fault" /> or <see langword="finally" /> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1924">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1924">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1925">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1925">Format</span></span>|<span data-ttu-id="de49f-1926">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1926">Assembly Format</span></span>|<span data-ttu-id="de49f-1927">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1927">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1928">DC</span><span class="sxs-lookup"><span data-stu-id="de49f-1928">DC</span></span>|<span data-ttu-id="de49f-1929">Команда endfinally</span><span class="sxs-lookup"><span data-stu-id="de49f-1929">endfinally</span></span><br /><br /> <span data-ttu-id="de49f-1930">ендфаулт</span><span class="sxs-lookup"><span data-stu-id="de49f-1930">endfault</span></span>|<span data-ttu-id="de49f-1931">Завершает предложение `finally` или `fault` блока исключения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1931">Ends the `finally` or `fault` clause of an exception block.</span></span>|  
  
 <span data-ttu-id="de49f-1932">Для этой инструкции нет поведений перехода стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-1932">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="de49f-1933">`Endfinally` и `endfault` обозначают конец предложения `finally` или `fault`, чтобы очистка стека могла продолжаться до вызова обработчика исключений.</span><span class="sxs-lookup"><span data-stu-id="de49f-1933">`Endfinally` and `endfault` signal the end of the `finally` or `fault` clause so that stack unwinding can continue until the exception handler is invoked.</span></span> <span data-ttu-id="de49f-1934">Инструкция `endfinally` или `endfault` передает управление механизму исключения CLI.</span><span class="sxs-lookup"><span data-stu-id="de49f-1934">The `endfinally` or `endfault` instruction transfers control back to the CLI exception mechanism.</span></span> <span data-ttu-id="de49f-1935">Затем механизм выполняет поиск следующего предложения `finally` в цепочке, если защищенный блок был завершен с помощью инструкции leave.</span><span class="sxs-lookup"><span data-stu-id="de49f-1935">The mechanism then searches for the next `finally` clause in the chain if the protected block was exited with a leave instruction.</span></span> <span data-ttu-id="de49f-1936">Если защищенный блок завершился с исключением, интерфейс командной строки выполнит поиск следующего `finally` или `fault` или введите обработчик исключений, выбранный во время первого прохода обработки исключений.</span><span class="sxs-lookup"><span data-stu-id="de49f-1936">If the protected block was exited with an exception, the CLI will search for the next `finally` or `fault`, or enter the exception handler chosen during the first pass of exception handling.</span></span>  
  
 <span data-ttu-id="de49f-1937">Инструкция `endfinally` может отображаться только в блоке `finally`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1937">An `endfinally` instruction might only appear lexically within a `finally` block.</span></span> <span data-ttu-id="de49f-1938">В отличие от инструкции `endfilter`, нет необходимости в конце блока с инструкцией `endfinally`, и в блоке может быть столько инструкций `endfinally`, сколько необходимо.</span><span class="sxs-lookup"><span data-stu-id="de49f-1938">Unlike the `endfilter` instruction, there is no requirement that the block end with an `endfinally` instruction, and there can be as many `endfinally` instructions within the block as required.</span></span> <span data-ttu-id="de49f-1939">Эти же ограничения применяются к инструкциям `endfault` и блоку `fault`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1939">These same restrictions apply to the `endfault` instruction and the `fault` block.</span></span>  
  
 <span data-ttu-id="de49f-1940">Элемент управления не может быть передан в блок `finally` (или `fault`), за исключением механизма исключения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1940">Control cannot be transferred into a `finally` (or `fault`) block except through the exception mechanism.</span></span> <span data-ttu-id="de49f-1941">Элемент управления не может быть передан из блока `finally` (или `fault`), за исключением использования инструкции `throw` или выполнения инструкции `endfinally` (или `endfault`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1941">Control cannot be transferred out of a `finally` (or `fault`) block except through the use of a `throw` instruction or executing the `endfinally` (or `endfault`) instruction.</span></span> <span data-ttu-id="de49f-1942">В частности, нельзя попадать в блок `finally` (или `fault`) или выполнить инструкцию <xref:System.Reflection.Emit.OpCodes.Ret> или <xref:System.Reflection.Emit.OpCodes.Leave> в блоке `finally` (или `fault`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1942">In particular, you cannot "fall out" of a `finally` (or `fault`) block or to execute a <xref:System.Reflection.Emit.OpCodes.Ret> or <xref:System.Reflection.Emit.OpCodes.Leave> instruction within a `finally` (or `fault`) block.</span></span>  
  
 <span data-ttu-id="de49f-1943">Обратите внимание, что инструкции `endfault` и `endfinally` являются псевдонимами, они соответствуют одному коду операции.</span><span class="sxs-lookup"><span data-stu-id="de49f-1943">Note that the `endfault` and `endfinally` instructions are aliases - they correspond to the same opcode.</span></span>  
  
 <span data-ttu-id="de49f-1944">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `endfinally` (`endfault`), а также метод `ILGenerator` <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1944">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfinally` (`endfault`) opcode, as well as the `ILGenerator` method <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.</span></span>  
  
-   <span data-ttu-id="de49f-1945">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1945">ILGenerator.Emit(OpCode)</span></span>  
  
-   <span data-ttu-id="de49f-1946">ILGenerator. Ендексцептионблокк ()</span><span class="sxs-lookup"><span data-stu-id="de49f-1946">ILGenerator.EndExceptionBlock()</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1947">Инициализирует блок памяти с определенным адресом, присваивая его начальному значению с заданным размером.</span><span class="sxs-lookup"><span data-stu-id="de49f-1947">Initializes a specified block of memory at a specific address to a given size and initial value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1948">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1948">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1949">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1949">Format</span></span>|<span data-ttu-id="de49f-1950">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1950">Assembly Format</span></span>|<span data-ttu-id="de49f-1951">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1951">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1952">FE 18</span><span class="sxs-lookup"><span data-stu-id="de49f-1952">FE 18</span></span>|<span data-ttu-id="de49f-1953">initblk</span><span class="sxs-lookup"><span data-stu-id="de49f-1953">initblk</span></span>|<span data-ttu-id="de49f-1954">Установите для каждого расположения в блоке памяти заданное значение.</span><span class="sxs-lookup"><span data-stu-id="de49f-1954">Set each location in a block of memory to a given value.</span></span>|  
  
 <span data-ttu-id="de49f-1955">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1955">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1956">Начальный адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1956">A starting address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1957">Значение инициализации помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1957">An initialization value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-1958">Число байтов для инициализации помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1958">The number of bytes to initialize is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de49f-1959">Число байтов, значение инициализации и начальный адрес извлекаются из стека, а инициализация выполняется в соответствии с их значениями.</span><span class="sxs-lookup"><span data-stu-id="de49f-1959">The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</span></span>  
  
 <span data-ttu-id="de49f-1960">Инструкция `initblk` задает число (`unsigned int32`) байтов, начиная с указанного адреса (типа `native int`, `&` или `*`) к значению инициализации (типа `unsigned int8`).</span><span class="sxs-lookup"><span data-stu-id="de49f-1960">The `initblk` instruction sets the number (`unsigned int32`) of bytes starting at the specified address (of type `native int`, `&`, or `*`) to the initialization value (of type `unsigned int8`).</span></span> <span data-ttu-id="de49f-1961">`initblk` предполагает, что начальный адрес соответствует естественному размеру компьютера.</span><span class="sxs-lookup"><span data-stu-id="de49f-1961">`initblk` assumes that the starting address is aligned to the natural size of the machine.</span></span>  
  
 <span data-ttu-id="de49f-1962">Операция `initblk` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1962">The operation of the `initblk` instructions can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de49f-1963">При обнаружении недопустимого адреса может возникнуть исключение <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1963"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de49f-1964">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `initblk`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1964">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initblk` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1965">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-1965">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1966">Инициализирует каждое поле типа значения с определенным адресом пустой ссылкой или значением 0 соответствующего простого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-1966">Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1967">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1967">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1968">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1968">Format</span></span>|<span data-ttu-id="de49f-1969">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1969">Assembly Format</span></span>|<span data-ttu-id="de49f-1970">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1970">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1971">`T`< FE 15  ></span><span class="sxs-lookup"><span data-stu-id="de49f-1971">FE 15 < `T` ></span></span>|<span data-ttu-id="de49f-1972">`initobj` `typeTok`</span><span class="sxs-lookup"><span data-stu-id="de49f-1972">`initobj` `typeTok`</span></span>|<span data-ttu-id="de49f-1973">Инициализирует тип значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-1973">Initializes a value type.</span></span>|  
  
 <span data-ttu-id="de49f-1974">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1974">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1975">Адрес типа значения для инициализации помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1975">The address of the value type to initialize is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1976">Адрес извлекается из стека; Тип значения по указанному адресу инициализируется как тип `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1976">The address is popped from the stack; the value type at the specified address is initialized as type `typeTok`.</span></span>  
  
 <span data-ttu-id="de49f-1977">Инструкция `initobj` инициализирует каждое поле типа значения, заданное отправленным адресом (типа `native int`, `&` или `*`), на пустую ссылку или 0 соответствующего типа-примитива.</span><span class="sxs-lookup"><span data-stu-id="de49f-1977">The `initobj` instruction initializes each field of the value type specified by the pushed address (of type `native int`, `&`, or `*`) to a null reference or a 0 of the appropriate primitive type.</span></span> <span data-ttu-id="de49f-1978">После вызова этого метода экземпляр готов к вызову метода-конструктора.</span><span class="sxs-lookup"><span data-stu-id="de49f-1978">After this method is called, the instance is ready for a constructor method to be called.</span></span> <span data-ttu-id="de49f-1979">Если `typeTok` является ссылочным типом, эта инструкция имеет тот же результат, что и `ldnull`, за которым следует `stind.ref`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1979">If `typeTok` is a reference type, this instruction has the same effect as `ldnull` followed by `stind.ref`.</span></span>  
  
 <span data-ttu-id="de49f-1980">В отличие от <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` не вызывает метод конструктора.</span><span class="sxs-lookup"><span data-stu-id="de49f-1980">Unlike <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` does not call the constructor method.</span></span> <span data-ttu-id="de49f-1981">`Initobj` предназначен для инициализации типов значений, тогда как `newobj` используется для выделения и инициализации объектов.</span><span class="sxs-lookup"><span data-stu-id="de49f-1981">`Initobj` is intended for initializing value types, while `newobj` is used to allocate and initialize objects.</span></span>  
  
 <span data-ttu-id="de49f-1982">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `initobj`:</span><span class="sxs-lookup"><span data-stu-id="de49f-1982">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initobj` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-1983">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-1983">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-1984">Проверяет, является ли ссылка на объект (с типом <see langword="O" />) экземпляром определенного класса.</span><span class="sxs-lookup"><span data-stu-id="de49f-1984">Tests whether an object reference (type <see langword="O" />) is an instance of a particular class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-1985">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1985">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-1986">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-1986">Format</span></span>|<span data-ttu-id="de49f-1987">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-1987">Assembly Format</span></span>|<span data-ttu-id="de49f-1988">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-1988">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-1989">75 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-1989">75 < `T` ></span></span>|<span data-ttu-id="de49f-1990">исинст `class`</span><span class="sxs-lookup"><span data-stu-id="de49f-1990">isinst `class`</span></span>|<span data-ttu-id="de49f-1991">Проверяет, является ли ссылка на объект экземпляром `class`, возвращая либо пустую ссылку, либо экземпляр этого класса или интерфейса.</span><span class="sxs-lookup"><span data-stu-id="de49f-1991">Tests if an object reference is an instance of `class`, returning either a null reference or an instance of that class or interface.</span></span>|  
  
 <span data-ttu-id="de49f-1992">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-1992">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-1993">Ссылка на объект помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1993">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-1994">Ссылка на объект извлекается из стека и проверяется на наличие экземпляра класса, переданного `class`.</span><span class="sxs-lookup"><span data-stu-id="de49f-1994">The object reference is popped from the stack and tested to see if it is an instance of the class passed in `class`.</span></span>  
  
3.  <span data-ttu-id="de49f-1995">Результат (ссылка на объект или пустая ссылка) помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-1995">The result (either an object reference or a null reference) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-1996">`Class` — это токен метаданных, указывающий нужный класс.</span><span class="sxs-lookup"><span data-stu-id="de49f-1996">`Class` is a metadata token indicating the desired class.</span></span> <span data-ttu-id="de49f-1997">Если класс объекта в верхней части стека реализует `class` (если `class` является интерфейсом) или является производным классом `class` (если `class` является обычным классом), то он приводится к типу `class`, а результат помещается в стек. , как будто было вызвано <xref:System.Reflection.Emit.OpCodes.Castclass>.</span><span class="sxs-lookup"><span data-stu-id="de49f-1997">If the class of the object on the top of the stack implements `class` (if `class` is an interface) or is a derived class of `class` (if `class` is a regular class) then it is cast to type `class` and the result is pushed on the stack, exactly as though <xref:System.Reflection.Emit.OpCodes.Castclass> had been called.</span></span> <span data-ttu-id="de49f-1998">В противном случае в стек помещается пустая ссылка.</span><span class="sxs-lookup"><span data-stu-id="de49f-1998">Otherwise, a null reference is pushed on the stack.</span></span> <span data-ttu-id="de49f-1999">Если ссылка на объект является пустой ссылкой, то `isinst` аналогичным образом возвращает пустую ссылку.</span><span class="sxs-lookup"><span data-stu-id="de49f-1999">If the object reference itself is a null reference, then `isinst` likewise returns a null reference.</span></span>  
  
 <span data-ttu-id="de49f-2000">Если класс не найден, возникает исключение <xref:System.TypeLoadException>.</span><span class="sxs-lookup"><span data-stu-id="de49f-2000"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="de49f-2001">Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-2001">This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="de49f-2002">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `isinst`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2002">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `isinst` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2003">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-2003">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2004">Прекращает выполнение текущего метода и переходит к заданному методу.</span><span class="sxs-lookup"><span data-stu-id="de49f-2004">Exits current method and jumps to specified method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2005">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2005">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2006">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2006">Format</span></span>|<span data-ttu-id="de49f-2007">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2007">Assembly Format</span></span>|<span data-ttu-id="de49f-2008">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2008">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2009">27 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-2009">27 < `T` ></span></span>|<span data-ttu-id="de49f-2010">Переход `method`</span><span class="sxs-lookup"><span data-stu-id="de49f-2010">jmp `method`</span></span>|<span data-ttu-id="de49f-2011">Завершение работы текущего метода и переход к указанному методу.</span><span class="sxs-lookup"><span data-stu-id="de49f-2011">Exit current method and jump to specified method.</span></span>|  
  
 <span data-ttu-id="de49f-2012">Для этой инструкции нет поведений перехода стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-2012">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="de49f-2013">Инструкция `jmp` (переход) передает управление методу, указанному `method`, который является маркером метаданных для ссылки на метод.</span><span class="sxs-lookup"><span data-stu-id="de49f-2013">The `jmp` (jump) instruction transfers control to the method specified by `method`, which is a metadata token for a method reference.</span></span> <span data-ttu-id="de49f-2014">Текущие аргументы передаются в целевой метод.</span><span class="sxs-lookup"><span data-stu-id="de49f-2014">The current arguments are transferred to the destination method.</span></span>  
  
 <span data-ttu-id="de49f-2015">При выполнении этой инструкции стек вычислений должен быть пустым.</span><span class="sxs-lookup"><span data-stu-id="de49f-2015">The evaluation stack must be empty when this instruction is executed.</span></span> <span data-ttu-id="de49f-2016">Соглашение о вызовах, число и тип аргументов в адресе назначения должны соответствовать требованиям текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-2016">The calling convention, number and type of arguments at the destination address must match that of the current method.</span></span>  
  
 <span data-ttu-id="de49f-2017">Инструкция `jmp` не может использоваться для передачи управления из блока `try`, `filter`, `catch` или `finally`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2017">The `jmp` instruction cannot be used to transferred control out of a `try`, `filter`, `catch`, or `finally` block.</span></span>  
  
 <span data-ttu-id="de49f-2018">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `jmp`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2018">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `jmp` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2019">ILGenerator. Emit (код операции, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="de49f-2019">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2020">Загружает аргумент (на который ссылается указанное значение индекса) в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2020">Loads an argument (referenced by a specified index value) onto the stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2021">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2021">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2022">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2022">Format</span></span>|<span data-ttu-id="de49f-2023">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2023">Assembly Format</span></span>|<span data-ttu-id="de49f-2024">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2024">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2025">`unsigned int16`< FE 09  ></span><span class="sxs-lookup"><span data-stu-id="de49f-2025">FE 09 < `unsigned int16` ></span></span>|<span data-ttu-id="de49f-2026">лдарг `index`</span><span class="sxs-lookup"><span data-stu-id="de49f-2026">ldarg `index`</span></span>|<span data-ttu-id="de49f-2027">Загрузка аргумента с `index` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2027">Load argument at `index` onto stack.</span></span>|  
  
 <span data-ttu-id="de49f-2028">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2028">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2029">Значение аргумента в `index` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2029">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2030">Инструкция `ldarg` помещает аргумент, индексируемый по `index`, где аргументы индексируются от 0 до назад в стеке вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2030">The `ldarg` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="de49f-2031">Инструкцию `ldarg` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента.</span><span class="sxs-lookup"><span data-stu-id="de49f-2031">The `ldarg` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="de49f-2032">Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-2032">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="de49f-2033">Для процедур, принимающих список аргументов переменной длины, инструкция `ldarg` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры (Дополнительные сведения см. в инструкции <xref:System.Reflection.Emit.OpCodes.Arglist>).</span><span class="sxs-lookup"><span data-stu-id="de49f-2033">For procedures that take a variable-length argument list, the `ldarg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="de49f-2034">Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2034">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de49f-2035">Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).</span><span class="sxs-lookup"><span data-stu-id="de49f-2035">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de49f-2036">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2036">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2037">ILGenerator. Emit (код операции, короткий)</span><span class="sxs-lookup"><span data-stu-id="de49f-2037">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2038">Загружает аргумент с индексом 0 в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2038">Loads the argument at index 0 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2039">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2039">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2040">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2040">Format</span></span>|<span data-ttu-id="de49f-2041">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2041">Assembly Format</span></span>|<span data-ttu-id="de49f-2042">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2042">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2043">02</span><span class="sxs-lookup"><span data-stu-id="de49f-2043">02</span></span>|<span data-ttu-id="de49f-2044">лдарг. 0</span><span class="sxs-lookup"><span data-stu-id="de49f-2044">ldarg.0</span></span>|<span data-ttu-id="de49f-2045">Загрузить аргумент 0 в стек</span><span class="sxs-lookup"><span data-stu-id="de49f-2045">Load argument 0 onto stack</span></span>|  
  
 <span data-ttu-id="de49f-2046">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2046">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2047">Значение аргумента с индексом 0 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2047">The argument value at index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2048">Инструкция `ldarg.0` является эффективной кодировкой для загрузки значения аргумента по индексу 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-2048">The `ldarg.0` instruction is an efficient encoding for loading the argument value at index 0.</span></span>  
  
 <span data-ttu-id="de49f-2049">Инструкция `ldarg.0` помещает в стек вычислений аргумент с индексом 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-2049">The `ldarg.0` instruction pushes the argument indexed at 0 onto the evaluation stack.</span></span> <span data-ttu-id="de49f-2050">Инструкцию `ldarg.0` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента.</span><span class="sxs-lookup"><span data-stu-id="de49f-2050">The `ldarg.0` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="de49f-2051">Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-2051">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="de49f-2052">Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2052">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de49f-2053">Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).</span><span class="sxs-lookup"><span data-stu-id="de49f-2053">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de49f-2054">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg.0`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2054">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.0` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2055">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2055">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2056">Загружает аргумент с индексом 1 в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2056">Loads the argument at index 1 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2057">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2057">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2058">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2058">Format</span></span>|<span data-ttu-id="de49f-2059">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2059">Assembly Format</span></span>|<span data-ttu-id="de49f-2060">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2060">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2061">03</span><span class="sxs-lookup"><span data-stu-id="de49f-2061">03</span></span>|<span data-ttu-id="de49f-2062">лдарг. 1</span><span class="sxs-lookup"><span data-stu-id="de49f-2062">ldarg.1</span></span>|<span data-ttu-id="de49f-2063">Загрузка аргумента 1 в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2063">Load argument 1 onto stack.</span></span>|  
  
 <span data-ttu-id="de49f-2064">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2064">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2065">Значение аргумента с индексом 1 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2065">The argument value at index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2066">Инструкция `ldarg.1` является эффективной кодировкой для загрузки значения аргумента с индексом 1.</span><span class="sxs-lookup"><span data-stu-id="de49f-2066">The `ldarg.1` instruction is an efficient encoding for loading the argument value at index 1.</span></span>  
  
 <span data-ttu-id="de49f-2067">Инструкция `ldarg.1` помещает в стек вычислений аргумент с индексом 1.</span><span class="sxs-lookup"><span data-stu-id="de49f-2067">The `ldarg.1` instruction pushes the argument indexed at 1 onto the evaluation stack.</span></span> <span data-ttu-id="de49f-2068">Инструкцию `ldarg.1` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента.</span><span class="sxs-lookup"><span data-stu-id="de49f-2068">The `ldarg.1` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="de49f-2069">Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-2069">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="de49f-2070">Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2070">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de49f-2071">Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).</span><span class="sxs-lookup"><span data-stu-id="de49f-2071">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de49f-2072">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg.1`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.1` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2073">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2074">Загружает аргумент с индексом 2 в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2074">Loads the argument at index 2 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2075">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2076">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2076">Format</span></span>|<span data-ttu-id="de49f-2077">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2077">Assembly Format</span></span>|<span data-ttu-id="de49f-2078">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2079">04</span><span class="sxs-lookup"><span data-stu-id="de49f-2079">04</span></span>|<span data-ttu-id="de49f-2080">лдарг. 2</span><span class="sxs-lookup"><span data-stu-id="de49f-2080">ldarg.2</span></span>|<span data-ttu-id="de49f-2081">Загрузка аргумента 2 в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2081">Load argument 2 onto stack.</span></span>|  
  
 <span data-ttu-id="de49f-2082">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2083">Значение аргумента с индексом 2 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2083">The argument value at index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2084">Инструкция `ldarg.2` является эффективной кодировкой для загрузки значения аргумента по индексу 2.</span><span class="sxs-lookup"><span data-stu-id="de49f-2084">The `ldarg.2` instruction is an efficient encoding for loading the argument value at index 2.</span></span>  
  
 <span data-ttu-id="de49f-2085">Инструкция `ldarg.2` помещает аргумент с индексом 2 в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2085">The `ldarg.2` instruction pushes the argument indexed at 2 onto the evaluation stack.</span></span> <span data-ttu-id="de49f-2086">Инструкцию `ldarg.2` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента.</span><span class="sxs-lookup"><span data-stu-id="de49f-2086">The `ldarg.2` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="de49f-2087">Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-2087">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="de49f-2088">Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2088">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de49f-2089">Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).</span><span class="sxs-lookup"><span data-stu-id="de49f-2089">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de49f-2090">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg.2`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2090">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.2` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2091">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2091">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2092">Загружает аргумент с индексом 3 в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2092">Loads the argument at index 3 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2093">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2093">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2094">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2094">Format</span></span>|<span data-ttu-id="de49f-2095">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2095">Assembly Format</span></span>|<span data-ttu-id="de49f-2096">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2096">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2097">05</span><span class="sxs-lookup"><span data-stu-id="de49f-2097">05</span></span>|<span data-ttu-id="de49f-2098">лдарг. 3</span><span class="sxs-lookup"><span data-stu-id="de49f-2098">ldarg.3</span></span>|<span data-ttu-id="de49f-2099">Загрузка аргумента 3 в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2099">Load argument 3 onto stack.</span></span>|  
  
 <span data-ttu-id="de49f-2100">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2100">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2101">Значение аргумента с индексом 3 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2101">The argument value at index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2102">Инструкция `ldarg.3` является эффективной кодировкой для загрузки значения аргумента с индексом 3.</span><span class="sxs-lookup"><span data-stu-id="de49f-2102">The `ldarg.3` instruction is an efficient encoding for loading the argument value at index 3.</span></span>  
  
 <span data-ttu-id="de49f-2103">Инструкция `ldarg.3` помещает аргумент с индексом 3 в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2103">The `ldarg.3` instruction pushes the argument indexed at 3 onto the evaluation stack.</span></span> <span data-ttu-id="de49f-2104">Инструкцию `ldarg.3` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента.</span><span class="sxs-lookup"><span data-stu-id="de49f-2104">The `ldarg.3` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="de49f-2105">Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-2105">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="de49f-2106">Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2106">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de49f-2107">Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).</span><span class="sxs-lookup"><span data-stu-id="de49f-2107">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de49f-2108">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg.3`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2108">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.3` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2109">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2109">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2110">Загружает аргумент (на который ссылается указанное короткое значение индекса) в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2110">Loads the argument (referenced by a specified short form index) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2111">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2111">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2112">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2112">Format</span></span>|<span data-ttu-id="de49f-2113">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2113">Assembly Format</span></span>|<span data-ttu-id="de49f-2114">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2114">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2115">`unsigned int8`0E <  ></span><span class="sxs-lookup"><span data-stu-id="de49f-2115">0E < `unsigned int8` ></span></span>|<span data-ttu-id="de49f-2116">лдарг. s `index`</span><span class="sxs-lookup"><span data-stu-id="de49f-2116">ldarg.s `index`</span></span>|<span data-ttu-id="de49f-2117">Загрузка аргумента с `index` в стек, краткая форма.</span><span class="sxs-lookup"><span data-stu-id="de49f-2117">Load argument at `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="de49f-2118">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2118">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2119">Значение аргумента в `index` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2119">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2120">Инструкция `ldarg.s` — это эффективная кодировка для загрузки аргументов, индексируемых от 4 до 255.</span><span class="sxs-lookup"><span data-stu-id="de49f-2120">The `ldarg.s` instruction is an efficient encoding for loading arguments indexed from 4 through 255.</span></span>  
  
 <span data-ttu-id="de49f-2121">Инструкция `ldarg.s` помещает аргумент, индексируемый по `index`, где аргументы индексируются от 0 до назад в стеке вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2121">The `ldarg.s` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="de49f-2122">Инструкцию `ldarg.s` можно использовать для загрузки типа значения или примитивного значения в стек, скопировав его из входящего аргумента.</span><span class="sxs-lookup"><span data-stu-id="de49f-2122">The `ldarg.s` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="de49f-2123">Тип значения аргумента совпадает с типом аргумента, как указано в сигнатуре текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-2123">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="de49f-2124">Для процедур, принимающих список аргументов переменной длины, инструкция `ldarg.s` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры (Дополнительные сведения см. в инструкции <xref:System.Reflection.Emit.OpCodes.Arglist>).</span><span class="sxs-lookup"><span data-stu-id="de49f-2124">For procedures that take a variable-length argument list, the `ldarg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="de49f-2125">Аргументы, которые содержат целочисленное значение меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2125">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de49f-2126">Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).</span><span class="sxs-lookup"><span data-stu-id="de49f-2126">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de49f-2127">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarg.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2127">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2128">ILGenerator. Emit (код операции, байт)</span><span class="sxs-lookup"><span data-stu-id="de49f-2128">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2129">Загружает адрес аргумента в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2129">Load an argument address onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2130">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2130">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2131">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2131">Format</span></span>|<span data-ttu-id="de49f-2132">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2132">Assembly Format</span></span>|<span data-ttu-id="de49f-2133">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2133">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2134">< FE 0A `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="de49f-2134">FE 0A < `unsigned int16` ></span></span>|<span data-ttu-id="de49f-2135">лдарга `index`</span><span class="sxs-lookup"><span data-stu-id="de49f-2135">ldarga `index`</span></span>|<span data-ttu-id="de49f-2136">Получение адреса аргумента, индексированного по `index`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2136">Fetch the address of argument indexed by `index`.</span></span>|  
  
 <span data-ttu-id="de49f-2137">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2137">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2138">Адрес `addr` аргумента, индексируемого `index`, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2138">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2139">Инструкция `ldarga` извлекает адрес (типа `*`) аргумента, индексируемого `index`, где аргументы индексируются от 0 до.</span><span class="sxs-lookup"><span data-stu-id="de49f-2139">The `ldarga` instruction fetches the address (of type `*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="de49f-2140">Адрес `addr` всегда согласуется с естественной границей на целевом компьютере.</span><span class="sxs-lookup"><span data-stu-id="de49f-2140">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="de49f-2141">Для процедур, принимающих список аргументов переменной длины, инструкция `ldarga` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры.</span><span class="sxs-lookup"><span data-stu-id="de49f-2141">For procedures that take a variable-length argument list, the `ldarga` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="de49f-2142">`ldarga` используется для передачи параметров по ссылке.</span><span class="sxs-lookup"><span data-stu-id="de49f-2142">`ldarga` is used for by-ref parameter passing.</span></span> <span data-ttu-id="de49f-2143">В других случаях следует использовать <xref:System.Reflection.Emit.OpCodes.Ldarg> и <xref:System.Reflection.Emit.OpCodes.Starg>.</span><span class="sxs-lookup"><span data-stu-id="de49f-2143">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg> and <xref:System.Reflection.Emit.OpCodes.Starg> should be used.</span></span>  
  
 <span data-ttu-id="de49f-2144">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarga`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2144">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2145">ILGenerator. Emit (код операции, короткий)</span><span class="sxs-lookup"><span data-stu-id="de49f-2145">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2146">Загружает адрес аргумента (короткая форма) в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2146">Load an argument address, in short form, onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2147">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2147">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2148">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2148">Format</span></span>|<span data-ttu-id="de49f-2149">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2149">Assembly Format</span></span>|<span data-ttu-id="de49f-2150">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2150">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2151">0F < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="de49f-2151">0F < `unsigned int8` ></span></span>|<span data-ttu-id="de49f-2152">лдарга. s `index`</span><span class="sxs-lookup"><span data-stu-id="de49f-2152">ldarga.s `index`</span></span>|<span data-ttu-id="de49f-2153">Получение адреса аргумента, индексированного по `index`, короткая форма.</span><span class="sxs-lookup"><span data-stu-id="de49f-2153">Fetch the address of argument indexed by `index`, short form.</span></span>|  
  
 <span data-ttu-id="de49f-2154">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2154">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2155">Адрес `addr` аргумента, индексируемого `index`, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2155">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2156">`ldarga.s` (краткая форма `ldarga`) следует использовать для номеров аргументов от 0 до 255 и является более эффективной кодировкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-2156">`ldarga.s` (the short form of `ldarga`) should be used for argument numbers 0 through 255, and is a more efficient encoding.</span></span>  
  
 <span data-ttu-id="de49f-2157">Инструкция `ldarga.s` извлекает адрес (типа`*`) аргумента, индексируемого по `index`, где аргументы индексируются от 0 до более поздних.</span><span class="sxs-lookup"><span data-stu-id="de49f-2157">The `ldarga.s` instruction fetches the address (of type`*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="de49f-2158">Адрес `addr` всегда согласуется с естественной границей на целевом компьютере.</span><span class="sxs-lookup"><span data-stu-id="de49f-2158">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="de49f-2159">Для процедур, принимающих список аргументов переменной длины, инструкция `ldarga.s` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры.</span><span class="sxs-lookup"><span data-stu-id="de49f-2159">For procedures that take a variable-length argument list, the `ldarga.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="de49f-2160">`ldarga.s` используется для передачи параметров по ссылке.</span><span class="sxs-lookup"><span data-stu-id="de49f-2160">`ldarga.s` is used for by-ref parameter passing.</span></span> <span data-ttu-id="de49f-2161">В других случаях следует использовать <xref:System.Reflection.Emit.OpCodes.Ldarg_S> и <xref:System.Reflection.Emit.OpCodes.Starg_S>.</span><span class="sxs-lookup"><span data-stu-id="de49f-2161">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> and <xref:System.Reflection.Emit.OpCodes.Starg_S> should be used.</span></span>  
  
 <span data-ttu-id="de49f-2162">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldarga.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2162">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2163">ILGenerator. Emit (код операции, байт)</span><span class="sxs-lookup"><span data-stu-id="de49f-2163">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2164">Помещает переданное значение с типом <see langword="int32" /> в стек вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2164">Pushes a supplied value of type <see langword="int32" /> onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2165">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2165">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2166">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2166">Format</span></span>|<span data-ttu-id="de49f-2167">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2167">Assembly Format</span></span>|<span data-ttu-id="de49f-2168">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2168">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2169">20 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de49f-2169">20 < `int32` ></span></span>|<span data-ttu-id="de49f-2170">LDC. i4 `num`</span><span class="sxs-lookup"><span data-stu-id="de49f-2170">ldc.i4 `num`</span></span>|<span data-ttu-id="de49f-2171">Помещает значение `num` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2171">Pushes the value `num` onto the stack.</span></span>|  
  
 <span data-ttu-id="de49f-2172">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2172">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2173">Значение `num` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2173">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2174">Обратите внимание, что существуют специальные короткие (и, следовательно, более эффективные) кодировки для целых чисел от-128 до 127 и особенно короткие кодировки для-1 – 8.</span><span class="sxs-lookup"><span data-stu-id="de49f-2174">Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8.</span></span> <span data-ttu-id="de49f-2175">Все короткие кодировки помещают в стек 4-байтовые целые числа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2175">All short encodings push 4 byte integers on the stack.</span></span> <span data-ttu-id="de49f-2176">Более длинные кодировки используются для 8-байтовых целых чисел, 4 и 8 байт с плавающей запятой, а также для 4 байтовых значений, которые не помещаются в короткие формы.</span><span class="sxs-lookup"><span data-stu-id="de49f-2176">Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms.</span></span> <span data-ttu-id="de49f-2177">Существует три способа отправки 8-байтовой целочисленной константы в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2177">There are three ways to push an 8 byte integer constant onto the stack</span></span>  
  
 1. <span data-ttu-id="de49f-2178">Используйте инструкцию <xref:System.Reflection.Emit.OpCodes.Ldc_I8> для констант, которые должны быть выражены более чем на 32 бит.</span><span class="sxs-lookup"><span data-stu-id="de49f-2178">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruction for constants that must be expressed in more than 32 bits.</span></span>  
  
 2. <span data-ttu-id="de49f-2179">Используйте инструкцию <xref:System.Reflection.Emit.OpCodes.Ldc_I4>, за которой следует <xref:System.Reflection.Emit.OpCodes.Conv_I8> для констант, требующих от 9 до 32 бит.</span><span class="sxs-lookup"><span data-stu-id="de49f-2179">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that require 9 to 32 bits.</span></span>  
  
 3. <span data-ttu-id="de49f-2180">Используйте краткую инструкцию Form, за которой следует <xref:System.Reflection.Emit.OpCodes.Conv_I8> для констант, которые могут быть выражены в 8 или меньшем количестве битов.</span><span class="sxs-lookup"><span data-stu-id="de49f-2180">Use a short form instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that can be expressed in 8 or fewer bits.</span></span>  
  
 <span data-ttu-id="de49f-2181">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2181">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2182">ILGenerator. Emit (код операции, int)</span><span class="sxs-lookup"><span data-stu-id="de49f-2182">ILGenerator.Emit(OpCode, int)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2183">Помещает целочисленное значение 0 в стек вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2183">Pushes the integer value of 0 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2184">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2184">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2185">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2185">Format</span></span>|<span data-ttu-id="de49f-2186">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2186">Assembly Format</span></span>|<span data-ttu-id="de49f-2187">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2187">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2188">16</span><span class="sxs-lookup"><span data-stu-id="de49f-2188">16</span></span>|<span data-ttu-id="de49f-2189">LDC. i 4.0</span><span class="sxs-lookup"><span data-stu-id="de49f-2189">ldc.i4.0</span></span>|<span data-ttu-id="de49f-2190">Помещает 0 в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2190">Pushes 0 onto the stack.</span></span>|  
  
 <span data-ttu-id="de49f-2191">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2191">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2192">Значение 0 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2192">The value 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2193">Это специальная короткая кодировка для принудительной отправки целого значения 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-2193">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="de49f-2194">Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2194">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de49f-2195">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.0`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2195">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.0` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2196">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2196">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2197">Помещает целочисленное значение 1 в стек вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2197">Pushes the integer value of 1 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2198">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2198">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2199">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2199">Format</span></span>|<span data-ttu-id="de49f-2200">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2200">Assembly Format</span></span>|<span data-ttu-id="de49f-2201">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2201">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2202">17</span><span class="sxs-lookup"><span data-stu-id="de49f-2202">17</span></span>|<span data-ttu-id="de49f-2203">LDC. i 4.1</span><span class="sxs-lookup"><span data-stu-id="de49f-2203">ldc.i4.1</span></span>|<span data-ttu-id="de49f-2204">Помещает 1 в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2204">Pushes 1 onto the stack.</span></span>|  
  
 <span data-ttu-id="de49f-2205">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2205">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2206">Значение 1 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2206">The value 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2207">Это специальная короткая кодировка для принудительной отправки целого значения 1.</span><span class="sxs-lookup"><span data-stu-id="de49f-2207">This is a special short encoding for the push of the integer value 1.</span></span> <span data-ttu-id="de49f-2208">Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2208">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de49f-2209">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.1`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2209">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.1` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2210">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2210">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2211">Помещает целочисленное значение 2 в стек вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2211">Pushes the integer value of 2 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2212">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2212">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2213">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2213">Format</span></span>|<span data-ttu-id="de49f-2214">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2214">Assembly Format</span></span>|<span data-ttu-id="de49f-2215">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2215">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2216">18</span><span class="sxs-lookup"><span data-stu-id="de49f-2216">18</span></span>|<span data-ttu-id="de49f-2217">LDC. i 4.2</span><span class="sxs-lookup"><span data-stu-id="de49f-2217">ldc.i4.2</span></span>|<span data-ttu-id="de49f-2218">Помещает 2 в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2218">Pushes 2 onto the stack.</span></span>|  
  
 <span data-ttu-id="de49f-2219">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2219">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2220">Значение 2 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2220">The value 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2221">Это специальная короткая кодировка для принудительной отправки целочисленного значения 2.</span><span class="sxs-lookup"><span data-stu-id="de49f-2221">This is a special short encoding for the push of the integer value 2.</span></span> <span data-ttu-id="de49f-2222">Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2222">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de49f-2223">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.2`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2223">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.2` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2224">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2224">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2225">Помещает целочисленное значение 3 в стек вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2225">Pushes the integer value of 3 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2226">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2226">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2227">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2227">Format</span></span>|<span data-ttu-id="de49f-2228">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2228">Assembly Format</span></span>|<span data-ttu-id="de49f-2229">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2229">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2230">19</span><span class="sxs-lookup"><span data-stu-id="de49f-2230">19</span></span>|<span data-ttu-id="de49f-2231">LDC. i 4.3</span><span class="sxs-lookup"><span data-stu-id="de49f-2231">ldc.i4.3</span></span>|<span data-ttu-id="de49f-2232">Помещает 3 в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2232">Pushes 3 onto the stack.</span></span>|  
  
 <span data-ttu-id="de49f-2233">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2233">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2234">Значение 3 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2234">The value 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2235">Это специальная короткая кодировка для принудительной отправки целочисленного значения 3.</span><span class="sxs-lookup"><span data-stu-id="de49f-2235">This is a special short encoding for the push of the integer value 3.</span></span> <span data-ttu-id="de49f-2236">Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2236">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de49f-2237">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.3`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2237">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.3` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2238">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2238">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2239">Помещает целочисленное значение 4 в стек вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2239">Pushes the integer value of 4 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2240">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2240">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2241">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2241">Format</span></span>|<span data-ttu-id="de49f-2242">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2242">Assembly Format</span></span>|<span data-ttu-id="de49f-2243">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2243">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2244">Sr1a</span><span class="sxs-lookup"><span data-stu-id="de49f-2244">1A</span></span>|<span data-ttu-id="de49f-2245">LDC. i 4.4</span><span class="sxs-lookup"><span data-stu-id="de49f-2245">ldc.i4.4</span></span>|<span data-ttu-id="de49f-2246">Передает 4 в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2246">Pushes 4 onto the stack.</span></span>|  
  
 <span data-ttu-id="de49f-2247">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2247">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2248">Значение 4 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2248">The value 4 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2249">Это специальная короткая кодировка для принудительной отправки целочисленного значения 4.</span><span class="sxs-lookup"><span data-stu-id="de49f-2249">This is a special short encoding for the push of the integer value 4.</span></span> <span data-ttu-id="de49f-2250">Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2250">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de49f-2251">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2251">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2252">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2252">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2253">Помещает целочисленное значение 5 в стек вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2253">Pushes the integer value of 5 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2254">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2254">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2255">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2255">Format</span></span>|<span data-ttu-id="de49f-2256">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2256">Assembly Format</span></span>|<span data-ttu-id="de49f-2257">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2257">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2258">1B</span><span class="sxs-lookup"><span data-stu-id="de49f-2258">1B</span></span>|<span data-ttu-id="de49f-2259">LDC. i 4.5</span><span class="sxs-lookup"><span data-stu-id="de49f-2259">ldc.i4.5</span></span>|<span data-ttu-id="de49f-2260">Передает 5 в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2260">Pushes 5 onto the stack.</span></span>|  
  
 <span data-ttu-id="de49f-2261">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2261">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2262">Значение 5 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2262">The value 5 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2263">Это специальная короткая кодировка для принудительной отправки целого значения 5.</span><span class="sxs-lookup"><span data-stu-id="de49f-2263">This is a special short encoding for the push of the integer value 5.</span></span> <span data-ttu-id="de49f-2264">Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2264">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de49f-2265">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.5`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2265">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.5` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2266">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2266">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2267">Помещает целочисленное значение 6 в стек вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2267">Pushes the integer value of 6 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2268">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2268">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2269">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2269">Format</span></span>|<span data-ttu-id="de49f-2270">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2270">Assembly Format</span></span>|<span data-ttu-id="de49f-2271">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2271">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2272">1C</span><span class="sxs-lookup"><span data-stu-id="de49f-2272">1C</span></span>|<span data-ttu-id="de49f-2273">LDC. i 4.6</span><span class="sxs-lookup"><span data-stu-id="de49f-2273">ldc.i4.6</span></span>|<span data-ttu-id="de49f-2274">Помещает 6 в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2274">Pushes 6 onto the stack.</span></span>|  
  
 <span data-ttu-id="de49f-2275">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2275">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2276">Значение 6 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2276">The value 6 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2277">Это специальная короткая кодировка для принудительной отправки целого значения 6.</span><span class="sxs-lookup"><span data-stu-id="de49f-2277">This is a special short encoding for the push of the integer value 6.</span></span> <span data-ttu-id="de49f-2278">Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2278">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de49f-2279">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.6`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2279">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.6` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2280">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2280">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2281">Помещает целочисленное значение 7 в стек вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2281">Pushes the integer value of 7 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2282">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2282">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2283">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2283">Format</span></span>|<span data-ttu-id="de49f-2284">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2284">Assembly Format</span></span>|<span data-ttu-id="de49f-2285">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2285">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2286">1д</span><span class="sxs-lookup"><span data-stu-id="de49f-2286">1D</span></span>|<span data-ttu-id="de49f-2287">LDC. i 4.7</span><span class="sxs-lookup"><span data-stu-id="de49f-2287">ldc.i4.7</span></span>|<span data-ttu-id="de49f-2288">Помещает 7 в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2288">Pushes 7 onto the stack.</span></span>|  
  
 <span data-ttu-id="de49f-2289">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2289">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2290">Значение 7 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2290">The value 7 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2291">Это специальная короткая кодировка для принудительной отправки целочисленного значения 7.</span><span class="sxs-lookup"><span data-stu-id="de49f-2291">This is a special short encoding for the push of the integer value 7.</span></span> <span data-ttu-id="de49f-2292">Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2292">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de49f-2293">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.7`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2293">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.7` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2294">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2294">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2295">Помещает целочисленное значение 8 в стек вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2295">Pushes the integer value of 8 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2296">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2296">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2297">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2297">Format</span></span>|<span data-ttu-id="de49f-2298">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2298">Assembly Format</span></span>|<span data-ttu-id="de49f-2299">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2299">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2300">1E</span><span class="sxs-lookup"><span data-stu-id="de49f-2300">1E</span></span>|<span data-ttu-id="de49f-2301">LDC. i 4.8</span><span class="sxs-lookup"><span data-stu-id="de49f-2301">ldc.i4.8</span></span>|<span data-ttu-id="de49f-2302">Отправляет 8 в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2302">Pushes 8 onto the stack.</span></span>|  
  
 <span data-ttu-id="de49f-2303">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2303">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2304">Значение 8 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2304">The value 8 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2305">Это специальная короткая кодировка для принудительной отправки целочисленного значения 8.</span><span class="sxs-lookup"><span data-stu-id="de49f-2305">This is a special short encoding for the push of the integer value 8.</span></span> <span data-ttu-id="de49f-2306">Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2306">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de49f-2307">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.8`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2307">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.8` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2308">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2308">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2309">Помещает целочисленное значение –1 в стек вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2309">Pushes the integer value of -1 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2310">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2310">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2311">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2311">Format</span></span>|<span data-ttu-id="de49f-2312">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2312">Assembly Format</span></span>|<span data-ttu-id="de49f-2313">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2313">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2314">15</span><span class="sxs-lookup"><span data-stu-id="de49f-2314">15</span></span>|<span data-ttu-id="de49f-2315">LDC. i4. M1</span><span class="sxs-lookup"><span data-stu-id="de49f-2315">ldc.i4.m1</span></span>|<span data-ttu-id="de49f-2316">Передает значение 1 в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2316">Pushes -1 onto the stack.</span></span>|  
  
 <span data-ttu-id="de49f-2317">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2317">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2318">Значение-1 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2318">The value -1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2319">Это специальная короткая кодировка для принудительной отправки целого значения-1.</span><span class="sxs-lookup"><span data-stu-id="de49f-2319">This is a special short encoding for the push of the integer value -1.</span></span> <span data-ttu-id="de49f-2320">Все специальные короткие кодировки помещают в стек 4-байтовые целые числа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2320">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="de49f-2321">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i4.m1`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2321">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.m1` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2322">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2322">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2323">Помещает переданное значение с типом <see langword="int8" /> в стек вычислений как <see langword="int32" /> (короткая форма).</span><span class="sxs-lookup"><span data-stu-id="de49f-2323">Pushes the supplied <see langword="int8" /> value onto the evaluation stack as an <see langword="int32" />, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2324">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2324">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2325">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2325">Format</span></span>|<span data-ttu-id="de49f-2326">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2326">Assembly Format</span></span>|<span data-ttu-id="de49f-2327">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2327">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2328">1F < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de49f-2328">1F < `int8` ></span></span>|<span data-ttu-id="de49f-2329">LDC. i4. s `num`</span><span class="sxs-lookup"><span data-stu-id="de49f-2329">ldc.i4.s `num`</span></span>|<span data-ttu-id="de49f-2330">Помещает `num` в стек как `int32`, короткая форма.</span><span class="sxs-lookup"><span data-stu-id="de49f-2330">Pushes `num` onto the stack as `int32`, short form.</span></span>|  
  
 <span data-ttu-id="de49f-2331">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2331">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2332">Значение `num` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2332">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2333">`ldc.i4.s` является более эффективной кодировкой для отправки целых чисел с-128 по 127 в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2333">`ldc.i4.s` is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</span></span>  
  
<span data-ttu-id="de49f-2334">Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `ldc.i4.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2334">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldc.i4.s` opcode:</span></span>
  
- <xref:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Byte)?displayProperty=nameWithType>
- <xref:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.SByte)?displayProperty=nameWithType>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2335">Помещает переданное значение с типом <see langword="int64" /> в стек вычислений как <see langword="int64" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2335">Pushes a supplied value of type <see langword="int64" /> onto the evaluation stack as an <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2336">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2336">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2337">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2337">Format</span></span>|<span data-ttu-id="de49f-2338">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2338">Assembly Format</span></span>|<span data-ttu-id="de49f-2339">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2339">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2340">21 < `int64` ></span><span class="sxs-lookup"><span data-stu-id="de49f-2340">21 < `int64` ></span></span>|<span data-ttu-id="de49f-2341">LDC. i8 `num`</span><span class="sxs-lookup"><span data-stu-id="de49f-2341">ldc.i8 `num`</span></span>|<span data-ttu-id="de49f-2342">Помещает `num` в стек как `int64`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2342">Pushes `num` onto the stack as `int64`.</span></span>|  
  
 <span data-ttu-id="de49f-2343">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2343">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2344">Значение `num` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2344">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2345">Эта кодировка помещает значение `int64` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2345">This encoding pushes an `int64` value onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2346">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.i8`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2346">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i8` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2347">ILGenerator. Emit (код операции, длинный)</span><span class="sxs-lookup"><span data-stu-id="de49f-2347">ILGenerator.Emit(OpCode, long)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2348">Помещает переданное значение с типом <see langword="float32" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</span><span class="sxs-lookup"><span data-stu-id="de49f-2348">Pushes a supplied value of type <see langword="float32" /> onto the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2349">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2349">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2350">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2350">Format</span></span>|<span data-ttu-id="de49f-2351">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2351">Assembly Format</span></span>|<span data-ttu-id="de49f-2352">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2352">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2353">22 < `float32` ></span><span class="sxs-lookup"><span data-stu-id="de49f-2353">22 < `float32` ></span></span>|<span data-ttu-id="de49f-2354">LDC. R4 `num`</span><span class="sxs-lookup"><span data-stu-id="de49f-2354">ldc.r4 `num`</span></span>|<span data-ttu-id="de49f-2355">Помещает `num` в стек как `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2355">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="de49f-2356">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2356">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2357">Значение `num` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2357">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2358">Эта кодировка помещает значение `float32` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2358">This encoding pushes a `float32` value onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2359">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.r4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2359">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2360">ILGenerator. Emit (код операции, одиночный)</span><span class="sxs-lookup"><span data-stu-id="de49f-2360">ILGenerator.Emit(OpCode, single)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2361">Помещает переданное значение с типом <see langword="float64" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</span><span class="sxs-lookup"><span data-stu-id="de49f-2361">Pushes a supplied value of type <see langword="float64" /> onto the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2362">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2362">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2363">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2363">Format</span></span>|<span data-ttu-id="de49f-2364">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2364">Assembly Format</span></span>|<span data-ttu-id="de49f-2365">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2365">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2366">23 < `float64` ></span><span class="sxs-lookup"><span data-stu-id="de49f-2366">23 < `float64` ></span></span>|<span data-ttu-id="de49f-2367">LDC. R8 `num`</span><span class="sxs-lookup"><span data-stu-id="de49f-2367">ldc.r8 `num`</span></span>|<span data-ttu-id="de49f-2368">Помещает `num` в стек как `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2368">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="de49f-2369">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2369">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2370">Значение `num` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2370">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2371">Эта кодировка помещает значение `float64` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2371">This encoding pushes a `float64` value onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2372">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldc.r8`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2372">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r8` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2373">ILGenerator. Emit (код операции, Double)</span><span class="sxs-lookup"><span data-stu-id="de49f-2373">ILGenerator.Emit(OpCode, double)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2374">Загружает элемент с заданным индексом массива на вершину стека вычислений в качестве типа, указанного в инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-2374">Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2375">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2375">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2376">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2376">Format</span></span>|<span data-ttu-id="de49f-2377">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2377">Assembly Format</span></span>|<span data-ttu-id="de49f-2378">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2378">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2379">< A3 `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-2379">A3 < `T` ></span></span>|<span data-ttu-id="de49f-2380">лделем `typeTok`</span><span class="sxs-lookup"><span data-stu-id="de49f-2380">ldelem `typeTok`</span></span>|<span data-ttu-id="de49f-2381">Загружает элемент с `index` на вершину стека как тип `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2381">Loads the element at `index` onto the top of the stack as type `typeTok`.</span></span>|  
  
 <span data-ttu-id="de49f-2382">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2382">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2383">Ссылка на объект `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2383">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2384">Значение индекса `index` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2384">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-2385">`index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2385">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de49f-2386">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2386">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2387">Инструкция `ldelem` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-2387">The `ldelem` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de49f-2388">Массивы являются объектами, поэтому они представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2388">Arrays are objects, and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de49f-2389">Тип возвращаемого значения задается токеном `typeTok` в инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-2389">The type of the return value is specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="de49f-2390"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-2390"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-2391"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем верхняя граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2391"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the upper bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-2392">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2392">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2393">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-2393">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2394">Загружает элемент массива с заданным индексом, имеющий тип <see langword="native int" />, на вершину стека вычислений как <see langword="native int" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2394">Loads the element with type <see langword="native int" /> at a specified array index onto the top of the evaluation stack as a <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2395">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2395">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2396">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2396">Format</span></span>|<span data-ttu-id="de49f-2397">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2397">Assembly Format</span></span>|<span data-ttu-id="de49f-2398">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2398">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2399">97</span><span class="sxs-lookup"><span data-stu-id="de49f-2399">97</span></span>|<span data-ttu-id="de49f-2400">лделем. i</span><span class="sxs-lookup"><span data-stu-id="de49f-2400">ldelem.i</span></span>|<span data-ttu-id="de49f-2401">Загружает элемент с типом `native int` в `index` на вершину стека как `native int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2401">Loads the element with type `native int` at `index` onto the top of the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="de49f-2402">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2402">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2403">Ссылка на объект `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2403">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2404">Значение индекса `index` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2404">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-2405">`index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2405">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de49f-2406">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2406">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2407">Инструкция `ldelem.i` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-2407">The `ldelem.i` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de49f-2408">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2408">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de49f-2409">Возвращаемое значение для `ldelem.i` равно `native int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2409">The return value for `ldelem.i` is `native int`.</span></span>  
  
 <span data-ttu-id="de49f-2410">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2410">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2411"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-2411"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-2412"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2412"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-2413"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2413"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-2414">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.i`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2414">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2415">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2415">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2416">Загружает элемент типа <see langword="int8" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2416">Loads the element with type <see langword="int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2417">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2417">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2418">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2418">Format</span></span>|<span data-ttu-id="de49f-2419">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2419">Assembly Format</span></span>|<span data-ttu-id="de49f-2420">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2420">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2421">90</span><span class="sxs-lookup"><span data-stu-id="de49f-2421">90</span></span>|<span data-ttu-id="de49f-2422">лделем. i1</span><span class="sxs-lookup"><span data-stu-id="de49f-2422">ldelem.i1</span></span>|<span data-ttu-id="de49f-2423">Загружает элемент с типом `int8` в `index` на вершину стека как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2423">Loads the element with type `int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de49f-2424">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2424">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2425">Ссылка на объект `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2425">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2426">Значение индекса `index` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2426">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-2427">`index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2427">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de49f-2428">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2428">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2429">Инструкция `ldelem.i1` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-2429">The `ldelem.i1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de49f-2430">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2430">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de49f-2431">Возвращаемое значение для `ldelem.i1` равно `int8`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2431">The return value for `ldelem.i1` is `int8`.</span></span>  
  
 <span data-ttu-id="de49f-2432">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2432">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2433"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-2433"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-2434"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2434"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-2435"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2435"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-2436">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.i1`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2436">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2437">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2437">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2438">Загружает элемент типа <see langword="int16" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2438">Loads the element with type <see langword="int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2439">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2439">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2440">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2440">Format</span></span>|<span data-ttu-id="de49f-2441">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2441">Assembly Format</span></span>|<span data-ttu-id="de49f-2442">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2442">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2443">92</span><span class="sxs-lookup"><span data-stu-id="de49f-2443">92</span></span>|<span data-ttu-id="de49f-2444">лделем. i2</span><span class="sxs-lookup"><span data-stu-id="de49f-2444">ldelem.i2</span></span>|<span data-ttu-id="de49f-2445">Загружает элемент с типом `int16` в `index` на вершину стека как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2445">Loads the element with type `int16` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de49f-2446">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2446">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2447">Ссылка на объект `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2447">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2448">Значение индекса `index` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2448">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-2449">`index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2449">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de49f-2450">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2450">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2451">Инструкция `ldelem.i2` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-2451">The `ldelem.i2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de49f-2452">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2452">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de49f-2453">Возвращаемое значение для `ldelem.i2` равно `int16`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2453">The return value for `ldelem.i2` is `int16`.</span></span>  
  
 <span data-ttu-id="de49f-2454">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2454">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2455"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-2455"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-2456"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2456"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-2457"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2457"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-2458">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.i2`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2458">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2459">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2459">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2460">Загружает элемент типа <see langword="int32" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2460">Loads the element with type <see langword="int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2461">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2461">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2462">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2462">Format</span></span>|<span data-ttu-id="de49f-2463">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2463">Assembly Format</span></span>|<span data-ttu-id="de49f-2464">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2464">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2465">94</span><span class="sxs-lookup"><span data-stu-id="de49f-2465">94</span></span>|<span data-ttu-id="de49f-2466">лделем. i4</span><span class="sxs-lookup"><span data-stu-id="de49f-2466">ldelem.i4</span></span>|<span data-ttu-id="de49f-2467">Загружает элемент с типом `int32` в `index` на вершину стека как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2467">Loads the element with type `int32` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de49f-2468">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2468">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2469">Ссылка на объект `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2469">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2470">Значение индекса `index` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2470">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-2471">`index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2471">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de49f-2472">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2472">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2473">Инструкция `ldelem.i4` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-2473">The `ldelem.i4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de49f-2474">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2474">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de49f-2475">Возвращаемое значение для `ldelem.i4` равно `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2475">The return value for `ldelem.i4` is `int32`.</span></span>  
  
 <span data-ttu-id="de49f-2476">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2476">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2477"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-2477"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-2478"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2478"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-2479"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2479"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-2480">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.i4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2481">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2481">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2482">Загружает элемент типа <see langword="int64" /> с заданным индексом массива на вершину стека вычислений как <see langword="int64" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2482">Loads the element with type <see langword="int64" /> at a specified array index onto the top of the evaluation stack as an <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2483">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2484">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2484">Format</span></span>|<span data-ttu-id="de49f-2485">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2485">Assembly Format</span></span>|<span data-ttu-id="de49f-2486">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2487">96</span><span class="sxs-lookup"><span data-stu-id="de49f-2487">96</span></span>|<span data-ttu-id="de49f-2488">лделем. i8</span><span class="sxs-lookup"><span data-stu-id="de49f-2488">ldelem.i8</span></span>|<span data-ttu-id="de49f-2489">Загружает элемент с типом `int64` в `index` на вершину стека как `int64`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2489">Loads the element with type `int64` at `index` onto the top of the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="de49f-2490">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2491">Ссылка на объект `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2491">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2492">Значение индекса `index` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2492">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-2493">`index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2493">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de49f-2494">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2494">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2495">Инструкция `ldelem.i8` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-2495">The `ldelem.i8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de49f-2496">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2496">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de49f-2497">Возвращаемое значение для `ldelem.i8` равно `int64`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2497">The return value for `ldelem.i8` is `int64`.</span></span>  
  
 <span data-ttu-id="de49f-2498">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2498">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2499"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-2499"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-2500"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2500"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-2501"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2501"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-2502">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.i8`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2502">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2503">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2503">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2504">Загружает элемент массива с заданным индексом, имеющий тип <see langword="float32" />, на вершину стека вычислений как <see langword="F" /> (число с плавающей запятой).</span><span class="sxs-lookup"><span data-stu-id="de49f-2504">Loads the element with type <see langword="float32" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2505">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2505">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2506">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2506">Format</span></span>|<span data-ttu-id="de49f-2507">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2507">Assembly Format</span></span>|<span data-ttu-id="de49f-2508">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2508">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2509">98</span><span class="sxs-lookup"><span data-stu-id="de49f-2509">98</span></span>|<span data-ttu-id="de49f-2510">лделем. R4</span><span class="sxs-lookup"><span data-stu-id="de49f-2510">ldelem.r4</span></span>|<span data-ttu-id="de49f-2511">Загружает элемент с типом `float32` в `index` на вершину стека как тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2511">Loads the element with type `float32` at `index` onto the top of the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="de49f-2512">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2512">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2513">Ссылка на объект `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2513">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2514">Значение индекса `index` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2514">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-2515">`index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2515">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de49f-2516">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2516">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2517">Инструкция `ldelem.r4` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-2517">The `ldelem.r4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de49f-2518">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2518">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de49f-2519">Возвращаемое значение для `ldelem.r4` равно `float32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2519">The return value for `ldelem.r4` is `float32`.</span></span>  
  
 <span data-ttu-id="de49f-2520">Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2520">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2521"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-2521"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-2522"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2522"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-2523"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2523"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-2524">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.r4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2524">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2525">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2525">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2526">Загружает элемент массива с заданным индексом, имеющий тип <see langword="float64" />, на вершину стека вычислений как <see langword="F" /> (число с плавающей запятой).</span><span class="sxs-lookup"><span data-stu-id="de49f-2526">Loads the element with type <see langword="float64" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2527">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2527">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2528">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2528">Format</span></span>|<span data-ttu-id="de49f-2529">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2529">Assembly Format</span></span>|<span data-ttu-id="de49f-2530">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2530">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2531">99</span><span class="sxs-lookup"><span data-stu-id="de49f-2531">99</span></span>|<span data-ttu-id="de49f-2532">лделем. R8</span><span class="sxs-lookup"><span data-stu-id="de49f-2532">ldelem.r8</span></span>|<span data-ttu-id="de49f-2533">Загружает элемент с типом `float64` в `index` в начало стека как тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2533">Loads the element with type `float64` at `index` onto the top of the stack as type `F`.</span></span>|  
  
 <span data-ttu-id="de49f-2534">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2534">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2535">Ссылка на объект `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2535">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2536">Значение индекса `index` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2536">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-2537">`index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2537">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de49f-2538">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2538">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2539">Инструкция `ldelem.r8` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-2539">The `ldelem.r8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de49f-2540">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2540">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de49f-2541">Возвращаемое значение для `ldelem.r8` равно `float64`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2541">The return value for `ldelem.r8` is `float64`.</span></span>  
  
 <span data-ttu-id="de49f-2542">Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2542">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2543"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-2543"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-2544"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2544"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-2545"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2545"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-2546">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.r8`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2546">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2547">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2547">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2548">Загружает элемент массива с заданным индексом, содержащий ссылку на объект, на вершину стека вычислений как <see langword="O" /> (ссылка на объект).</span><span class="sxs-lookup"><span data-stu-id="de49f-2548">Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <see langword="O" /> (object reference).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2549">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2549">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2550">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2550">Format</span></span>|<span data-ttu-id="de49f-2551">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2551">Assembly Format</span></span>|<span data-ttu-id="de49f-2552">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2552">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2553">9A</span><span class="sxs-lookup"><span data-stu-id="de49f-2553">9A</span></span>|<span data-ttu-id="de49f-2554">лделем. ref</span><span class="sxs-lookup"><span data-stu-id="de49f-2554">ldelem.ref</span></span>|<span data-ttu-id="de49f-2555">Загружает элемент со ссылкой на объект в `index` на вершину стека как тип `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2555">Loads the element with an object reference at `index` onto the top of the stack as type `O`.</span></span>|  
  
 <span data-ttu-id="de49f-2556">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2556">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2557">Ссылка на объект `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2557">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2558">Значение индекса `index` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2558">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-2559">`index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2559">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de49f-2560">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2560">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2561">Инструкция `ldelem.ref` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-2561">The `ldelem.ref` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de49f-2562">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2562">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de49f-2563">Возвращаемое значение для `ldelem.ref` имеет тип `O` (ссылка на объект).</span><span class="sxs-lookup"><span data-stu-id="de49f-2563">The return value for `ldelem.ref` is type `O` (object reference).</span></span>  
  
 <span data-ttu-id="de49f-2564"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-2564"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-2565"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2565"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-2566"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2566"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-2567">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.ref`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2567">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2568">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2568">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2569">Загружает элемент типа <see langword="unsigned int8" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2569">Loads the element with type <see langword="unsigned int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2570">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2570">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2571">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2571">Format</span></span>|<span data-ttu-id="de49f-2572">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2572">Assembly Format</span></span>|<span data-ttu-id="de49f-2573">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2573">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2574">91</span><span class="sxs-lookup"><span data-stu-id="de49f-2574">91</span></span>|<span data-ttu-id="de49f-2575">лделем. U1</span><span class="sxs-lookup"><span data-stu-id="de49f-2575">ldelem.u1</span></span>|<span data-ttu-id="de49f-2576">Загружает элемент с типом `unsigned int8` в `index` на вершину стека как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2576">Loads the element with type `unsigned int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de49f-2577">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2577">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2578">Ссылка на объект `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2578">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2579">Значение индекса `index` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2579">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-2580">`index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2580">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de49f-2581">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2581">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2582">Инструкция `ldelem.u1` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-2582">The `ldelem.u1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de49f-2583">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2583">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de49f-2584">Возвращаемое значение для `ldelem.u1` равно `int8`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2584">The return value for `ldelem.u1` is `int8`.</span></span>  
  
 <span data-ttu-id="de49f-2585">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2585">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2586"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-2586"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-2587"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2587"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-2588"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2588"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-2589">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.u1`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2589">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u1` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2590">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2590">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2591">Загружает элемент типа <see langword="unsigned int16" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2591">Loads the element with type <see langword="unsigned int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2592">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2592">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2593">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2593">Format</span></span>|<span data-ttu-id="de49f-2594">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2594">Assembly Format</span></span>|<span data-ttu-id="de49f-2595">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2595">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2596">93</span><span class="sxs-lookup"><span data-stu-id="de49f-2596">93</span></span>|<span data-ttu-id="de49f-2597">лделем. U2</span><span class="sxs-lookup"><span data-stu-id="de49f-2597">ldelem.u2</span></span>|<span data-ttu-id="de49f-2598">Загружает элемент с типом `unsigned int16` по индексу на вершину стека как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2598">Loads the element with type `unsigned int16` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de49f-2599">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2599">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2600">Ссылка на объект `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2600">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2601">Значение индекса `index` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2601">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-2602">`index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2602">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de49f-2603">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2603">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2604">Инструкция `ldelem.u2` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-2604">The `ldelem.u2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de49f-2605">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2605">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de49f-2606">Возвращаемое значение для `ldelem.u2` равно `int16`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2606">The return value for `ldelem.u2` is `int16`.</span></span>  
  
 <span data-ttu-id="de49f-2607">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2607">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2608"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-2608"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-2609"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2609"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-2610"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2610"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-2611">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.u2`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2611">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u2` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2612">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2612">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2613">Загружает элемент типа <see langword="unsigned int32" /> с заданным индексом массива на вершину стека вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2613">Loads the element with type <see langword="unsigned int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2614">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2614">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2615">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2615">Format</span></span>|<span data-ttu-id="de49f-2616">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2616">Assembly Format</span></span>|<span data-ttu-id="de49f-2617">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2617">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2618">95</span><span class="sxs-lookup"><span data-stu-id="de49f-2618">95</span></span>|<span data-ttu-id="de49f-2619">лделем. U4</span><span class="sxs-lookup"><span data-stu-id="de49f-2619">ldelem.u4</span></span>|<span data-ttu-id="de49f-2620">Загружает элемент с типом `unsigned int32` по индексу на вершину стека как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2620">Loads the element with type `unsigned int32` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de49f-2621">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2621">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2622">Ссылка на объект `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2622">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2623">Значение индекса `index` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2623">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-2624">`index` и `array` извлекаются из стека; выполняется поиск значения, хранящегося в позиции `index` в `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2624">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de49f-2625">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2625">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2626">Инструкция `ldelem.u4` загружает значение элемента с индексом `index` (тип `native int`) в одномерный массив с отсчетом от нуля `array` и помещает его в верхнюю часть стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-2626">The `ldelem.u4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de49f-2627">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2627">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="de49f-2628">Возвращаемое значение для `ldelem.u4` равно `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2628">The return value for `ldelem.u4` is `int32`.</span></span>  
  
 <span data-ttu-id="de49f-2629">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2629">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2630"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-2630"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-2631"><xref:System.ArrayTypeMismatchException> создается, если массив не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2631"><xref:System.ArrayTypeMismatchException> is thrown if array does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-2632"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2632"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-2633">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelem.u4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2633">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2634">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2634">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2635">Загружает адрес элемента массива с заданным индексом на вершину стека вычислений как <see langword="&amp;" /> (управляемый указатель).</span><span class="sxs-lookup"><span data-stu-id="de49f-2635">Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <see langword="&amp;" /> (managed pointer).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2636">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2636">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2637">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2637">Format</span></span>|<span data-ttu-id="de49f-2638">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2638">Assembly Format</span></span>|<span data-ttu-id="de49f-2639">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2639">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2640">8F < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-2640">8F < `T` ></span></span>|<span data-ttu-id="de49f-2641">`class` ldelema</span><span class="sxs-lookup"><span data-stu-id="de49f-2641">ldelema `class`</span></span>|<span data-ttu-id="de49f-2642">Загружает адрес элемента массива с `index` на вершину стека вычислений как тип `&` (управляемый указатель).</span><span class="sxs-lookup"><span data-stu-id="de49f-2642">Loads the address of the array element at `index` onto the top of the evaluation stack as type `&` (managed pointer).</span></span>|  
  
 <span data-ttu-id="de49f-2643">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2643">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2644">Ссылка на объект `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2644">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2645">Значение индекса `index` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2645">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-2646">`index` и `array` извлекаются из стека; выполняется поиск адреса, хранящегося в позиции `index` в `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2646">`index` and `array` are popped from the stack; the address stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="de49f-2647">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2647">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2648">`ldelema` используется для получения адреса объекта по определенному индексу в массиве объектов (типа `class`).</span><span class="sxs-lookup"><span data-stu-id="de49f-2648">The `ldelema` is used to retrieve the address of an object at a particular index in an array of objects (of type `class`).</span></span> <span data-ttu-id="de49f-2649">Инструкция `ldelema` загружает адрес значения по индексу `index` (тип `native int`) в одномерном массиве с отсчетом от нуля `array` и помещает его в верхнюю часть стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-2649">The `ldelema` instruction loads the address of the value at index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="de49f-2650">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2650">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de49f-2651">Значение должно иметь тип `class`, переданный с инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-2651">The value must be of type `class` passed with the instruction.</span></span>  
  
 <span data-ttu-id="de49f-2652">Возвращаемое значение для `ldelema` является управляемым указателем (тип `&`).</span><span class="sxs-lookup"><span data-stu-id="de49f-2652">The return value for `ldelema` is a managed pointer (type `&`).</span></span>  
  
 <span data-ttu-id="de49f-2653">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2653">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2654"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-2654"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-2655"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-2655"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-2656"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2656"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-2657">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldelema`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2657">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelema` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2658">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-2658">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2659">Выполняет поиск значения поля в объекте, ссылка на который находится в стеке вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2659">Finds the value of a field in the object whose reference is currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2660">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2660">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2661">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2661">Format</span></span>|<span data-ttu-id="de49f-2662">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2662">Assembly Format</span></span>|<span data-ttu-id="de49f-2663">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2663">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2664">7B < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-2664">7B < `T` ></span></span>|<span data-ttu-id="de49f-2665">ldfld `field`</span><span class="sxs-lookup"><span data-stu-id="de49f-2665">ldfld `field`</span></span>|<span data-ttu-id="de49f-2666">Помещает значение поля в указанном объекте в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2666">Pushes the value of a field in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="de49f-2667">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2667">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2668">Ссылка на объект (или указатель) помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2668">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2669">Ссылка на объект (или указатель) извлекается из стека; Найдено значение указанного поля в объекте.</span><span class="sxs-lookup"><span data-stu-id="de49f-2669">The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="de49f-2670">Значение, хранящееся в поле, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2670">The value stored in the field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2671">Инструкция `ldfld` помещает значение поля, расположенного в объекте, в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2671">The `ldfld` instruction pushes the value of a field located in an object onto the stack.</span></span> <span data-ttu-id="de49f-2672">Объект должен находиться в стеке как ссылка на объект (тип `O`), управляемый указатель (тип `&`), неуправляемый указатель (тип `native int`), временный указатель (тип `*`) или экземпляр типа значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-2672">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="de49f-2673">Использование неуправляемого указателя в проверяемом коде не допускается.</span><span class="sxs-lookup"><span data-stu-id="de49f-2673">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="de49f-2674">Поле объекта задается маркером метаданных, который должен ссылаться на элемент поля.</span><span class="sxs-lookup"><span data-stu-id="de49f-2674">The object's field is specified by a metadata token that must refer to a field member.</span></span> <span data-ttu-id="de49f-2675">Тип возвращаемого значения совпадает с типом, связанным с полем.</span><span class="sxs-lookup"><span data-stu-id="de49f-2675">The return type is the same as the one associated with the field.</span></span> <span data-ttu-id="de49f-2676">Поле может быть либо полем экземпляра (в этом случае объект не должен быть пустой ссылкой), либо статическим полем.</span><span class="sxs-lookup"><span data-stu-id="de49f-2676">The field may be either an instance field (in which case the object must not be a null reference) or a static field.</span></span>  
  
 <span data-ttu-id="de49f-2677">Оператору `ldfld` может предшествовать один или оба префикса <xref:System.Reflection.Emit.OpCodes.Unaligned> и <xref:System.Reflection.Emit.OpCodes.Volatile>.</span><span class="sxs-lookup"><span data-stu-id="de49f-2677">The `ldfld` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="de49f-2678"><xref:System.NullReferenceException> создается, если объект имеет значение null, а поле не является статическим.</span><span class="sxs-lookup"><span data-stu-id="de49f-2678"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="de49f-2679"><xref:System.MissingFieldException> создается, если указанное поле не найдено в метаданных.</span><span class="sxs-lookup"><span data-stu-id="de49f-2679"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="de49f-2680">Обычно это проверяется при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-2680">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="de49f-2681">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldfld`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2681">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldfld` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2682">ILGenerator. Emit (код операции, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="de49f-2682">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2683">Ищет адрес поля в объекте, ссылка на который находится в стеке вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2683">Finds the address of a field in the object whose reference is currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2684">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2684">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2685">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2685">Format</span></span>|<span data-ttu-id="de49f-2686">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2686">Assembly Format</span></span>|<span data-ttu-id="de49f-2687">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2687">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2688">7C < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-2688">7C < `T` ></span></span>|<span data-ttu-id="de49f-2689">лдфлда `field`</span><span class="sxs-lookup"><span data-stu-id="de49f-2689">ldflda `field`</span></span>|<span data-ttu-id="de49f-2690">Помещает адрес `field` в указанный объект в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2690">Pushes the address of `field` in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="de49f-2691">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2691">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2692">Ссылка на объект (или указатель) помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2692">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2693">Ссылка на объект (или указатель) извлекается из стека; найден адрес указанного поля в объекте.</span><span class="sxs-lookup"><span data-stu-id="de49f-2693">The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="de49f-2694">Адрес указанного поля помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2694">The address of the specified field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2695">Инструкция `ldflda` помещает адрес поля, расположенного в объекте, в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2695">The `ldflda` instruction pushes the address of a field located in an object onto the stack.</span></span> <span data-ttu-id="de49f-2696">Объект должен находиться в стеке как ссылка на объект (тип `O`), управляемый указатель (тип `&`), неуправляемый указатель (тип `native int`), временный указатель (тип `*`) или экземпляр типа значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-2696">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="de49f-2697">Использование неуправляемого указателя в проверяемом коде не допускается.</span><span class="sxs-lookup"><span data-stu-id="de49f-2697">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="de49f-2698">Поле объекта задается маркером метаданных, который должен ссылаться на элемент поля.</span><span class="sxs-lookup"><span data-stu-id="de49f-2698">The object's field is specified by a metadata token that must refer to a field member.</span></span>  
  
 <span data-ttu-id="de49f-2699">Значение, возвращаемое `ldflda`, является управляемым указателем (тип `&`), если только объект не передается в стек как неуправляемый указатель, в этом случае возвращаемый адрес также является неуправляемым указателем (тип `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-2699">The value returned by `ldflda` is a managed pointer (type `&`) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type `native int`).</span></span>  
  
 <span data-ttu-id="de49f-2700">Оператору `ldflda` может предшествовать один или оба префикса <xref:System.Reflection.Emit.OpCodes.Unaligned> и <xref:System.Reflection.Emit.OpCodes.Volatile>.</span><span class="sxs-lookup"><span data-stu-id="de49f-2700">The `ldflda` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="de49f-2701"><xref:System.InvalidOperationException> создается, если объект не находится в домене приложения, из которого осуществляется доступ.</span><span class="sxs-lookup"><span data-stu-id="de49f-2701"><xref:System.InvalidOperationException> is thrown if the object is not within the application domain from which it is being accessed.</span></span> <span data-ttu-id="de49f-2702">Не удается загрузить адрес поля, не находящегося внутри доступного домена приложения.</span><span class="sxs-lookup"><span data-stu-id="de49f-2702">The address of a field that is not inside the accessing application domain cannot be loaded.</span></span>  
  
 <span data-ttu-id="de49f-2703"><xref:System.NullReferenceException> создается, если объект имеет значение null, а поле не является статическим.</span><span class="sxs-lookup"><span data-stu-id="de49f-2703"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="de49f-2704"><xref:System.MissingFieldException> создается, если указанное поле не найдено в метаданных.</span><span class="sxs-lookup"><span data-stu-id="de49f-2704"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="de49f-2705">Обычно это проверяется при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-2705">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="de49f-2706">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldflda`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2706">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldflda` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2707">ILGenerator. Emit (код операции, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="de49f-2707">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2708">Помещает в стек вычислений неуправляемый указатель (с типом <see langword="native int" />) на машинный код, реализующий заданный метод.</span><span class="sxs-lookup"><span data-stu-id="de49f-2708">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a specific method onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2709">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2709">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2710">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2710">Format</span></span>|<span data-ttu-id="de49f-2711">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2711">Assembly Format</span></span>|<span data-ttu-id="de49f-2712">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2712">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2713">`T`< FE 06  ></span><span class="sxs-lookup"><span data-stu-id="de49f-2713">FE 06 < `T` ></span></span>|<span data-ttu-id="de49f-2714">ldftn `method`</span><span class="sxs-lookup"><span data-stu-id="de49f-2714">ldftn `method`</span></span>|<span data-ttu-id="de49f-2715">Помещает указатель на метод, на который ссылается `method` в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-2715">Pushes a pointer to a method referenced by `method` on the stack.</span></span>|  
  
 <span data-ttu-id="de49f-2716">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2716">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2717">Неуправляемый указатель на конкретный метод помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2717">The unmanaged pointer to a specific method is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2718">Конкретный метод (`method`) можно вызывать с помощью инструкции <xref:System.Reflection.Emit.OpCodes.Calli>, если она ссылается на управляемый метод (или на заглушку, переход от управляемого кода к неуправляемому).</span><span class="sxs-lookup"><span data-stu-id="de49f-2718">The specific method (`method`) can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="de49f-2719">Возвращаемое значение указывает на машинный код, используя соглашение о вызовах CLR.</span><span class="sxs-lookup"><span data-stu-id="de49f-2719">The value returned points to native code using the CLR calling convention.</span></span> <span data-ttu-id="de49f-2720">Этот указатель метода не должен передаваться в неуправляемый машинный код в качестве подпрограммы обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="de49f-2720">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="de49f-2721">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldftn`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2721">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldftn` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2722">ILGenerator. Emit (код операции, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="de49f-2722">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2723">Выполняет косвенную загрузку значения с типом <see langword="native int" /> в стек вычислений как <see langword="native int" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2723">Loads a value of type <see langword="native int" /> as a <see langword="native int" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2724">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2724">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2725">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2725">Format</span></span>|<span data-ttu-id="de49f-2726">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2726">Assembly Format</span></span>|<span data-ttu-id="de49f-2727">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2727">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2728">4D</span><span class="sxs-lookup"><span data-stu-id="de49f-2728">4D</span></span>|<span data-ttu-id="de49f-2729">ldind. i</span><span class="sxs-lookup"><span data-stu-id="de49f-2729">ldind.i</span></span>|<span data-ttu-id="de49f-2730">Загружает значение `native int` по адресу `addr` в стек как `native int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2730">Loads the `native int` value at address `addr` onto the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="de49f-2731">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2731">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2732">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2732">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2733">Адрес извлекается из стека; извлекается значение, расположенное по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-2733">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de49f-2734">Полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2734">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2735">Инструкция `ldind.i` выполняет косвенную загрузку значения `native int` из указанного адреса (типа `native int`, `&` или \*) в стек как `native int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2735">The `ldind.i` instruction indirectly loads a `native int` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `native int`.</span></span>  
  
 <span data-ttu-id="de49f-2736">Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-2736">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de49f-2737">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2737">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de49f-2738">Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2738">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2739">Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-2739">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de49f-2740">Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер).</span><span class="sxs-lookup"><span data-stu-id="de49f-2740">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de49f-2741">Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы.</span><span class="sxs-lookup"><span data-stu-id="de49f-2741">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de49f-2742">Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП.</span><span class="sxs-lookup"><span data-stu-id="de49f-2742">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de49f-2743">Код, зависящий от порядка байтов, может выполняться не на всех платформах.</span><span class="sxs-lookup"><span data-stu-id="de49f-2743">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de49f-2744"><xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.</span><span class="sxs-lookup"><span data-stu-id="de49f-2744"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de49f-2745">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.i`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2745">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2746">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2746">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2747">Выполняет косвенную загрузку значения с типом <see langword="int8" /> в стек вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2747">Loads a value of type <see langword="int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2748">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2748">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2749">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2749">Format</span></span>|<span data-ttu-id="de49f-2750">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2750">Assembly Format</span></span>|<span data-ttu-id="de49f-2751">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2751">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2752">46</span><span class="sxs-lookup"><span data-stu-id="de49f-2752">46</span></span>|<span data-ttu-id="de49f-2753">ldind. i1</span><span class="sxs-lookup"><span data-stu-id="de49f-2753">ldind.i1</span></span>|<span data-ttu-id="de49f-2754">Загружает значение `int8` по адресу `addr` в стек как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2754">Loads the `int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de49f-2755">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2755">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2756">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2756">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2757">Адрес извлекается из стека; извлекается значение, расположенное по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-2757">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de49f-2758">Полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2758">The fetched value is pushed onto the stack.</span></span> 
  
 <span data-ttu-id="de49f-2759">Инструкция `ldind.i1` выполняет косвенную загрузку значения `int8` из указанного адреса (типа `native int`, `&` или \*) в стек как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2759">The `ldind.i1` instruction indirectly loads an `int8` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="de49f-2760">Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-2760">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de49f-2761">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2761">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de49f-2762">Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2762">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2763">Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-2763">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de49f-2764">Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер).</span><span class="sxs-lookup"><span data-stu-id="de49f-2764">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de49f-2765">Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы.</span><span class="sxs-lookup"><span data-stu-id="de49f-2765">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de49f-2766">Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП.</span><span class="sxs-lookup"><span data-stu-id="de49f-2766">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de49f-2767">Код, зависящий от порядка байтов, может выполняться не на всех платформах.</span><span class="sxs-lookup"><span data-stu-id="de49f-2767">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de49f-2768"><xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.</span><span class="sxs-lookup"><span data-stu-id="de49f-2768"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de49f-2769">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.i1`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2769">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2770">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2770">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2771">Выполняет косвенную загрузку значения с типом <see langword="int16" /> в стек вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2771">Loads a value of type <see langword="int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2772">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2772">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2773">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2773">Format</span></span>|<span data-ttu-id="de49f-2774">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2774">Assembly Format</span></span>|<span data-ttu-id="de49f-2775">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2775">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2776">48</span><span class="sxs-lookup"><span data-stu-id="de49f-2776">48</span></span>|<span data-ttu-id="de49f-2777">ldind. i2</span><span class="sxs-lookup"><span data-stu-id="de49f-2777">ldind.i2</span></span>|<span data-ttu-id="de49f-2778">Загружает значение `int16` по адресу `addr` в стек как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2778">Loads the `int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de49f-2779">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2779">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2780">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2780">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2781">Адрес извлекается из стека; извлекается значение, расположенное по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-2781">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de49f-2782">Полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2782">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2783">Инструкция `ldind.i2` выполняет косвенную загрузку значения `int16` из указанного адреса (типа `native int`, `&` или \*) в стек как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2783">The `ldind.i2` instruction indirectly loads an `int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="de49f-2784">Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-2784">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de49f-2785">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2785">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de49f-2786">Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2786">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2787">Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-2787">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de49f-2788">Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер).</span><span class="sxs-lookup"><span data-stu-id="de49f-2788">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de49f-2789">Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы.</span><span class="sxs-lookup"><span data-stu-id="de49f-2789">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de49f-2790">Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП.</span><span class="sxs-lookup"><span data-stu-id="de49f-2790">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de49f-2791">Код, зависящий от порядка байтов, может выполняться не на всех платформах.</span><span class="sxs-lookup"><span data-stu-id="de49f-2791">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de49f-2792"><xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.</span><span class="sxs-lookup"><span data-stu-id="de49f-2792"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de49f-2793">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.i2`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2793">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2794">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2794">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2795">Выполняет косвенную загрузку значения с типом <see langword="int32" /> в стек вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2795">Loads a value of type <see langword="int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2796">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2796">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2797">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2797">Format</span></span>|<span data-ttu-id="de49f-2798">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2798">Assembly Format</span></span>|<span data-ttu-id="de49f-2799">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2799">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2800">4A</span><span class="sxs-lookup"><span data-stu-id="de49f-2800">4A</span></span>|<span data-ttu-id="de49f-2801">ldind. i4</span><span class="sxs-lookup"><span data-stu-id="de49f-2801">ldind.i4</span></span>|<span data-ttu-id="de49f-2802">Загружает значение `int32` по адресу `addr` в стек как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2802">Loads the `int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de49f-2803">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2803">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2804">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2804">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2805">Адрес извлекается из стека; извлекается значение, расположенное по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-2805">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de49f-2806">Полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2806">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2807">Инструкция `ldind.i4` выполняет косвенную загрузку значения `int32` из указанного адреса (типа `native int`, `&` или \*) в стек как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2807">The `ldind.i4` instruction indirectly loads an `int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="de49f-2808">Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-2808">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de49f-2809">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2809">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de49f-2810">Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2810">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2811">Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-2811">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de49f-2812">Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер).</span><span class="sxs-lookup"><span data-stu-id="de49f-2812">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de49f-2813">Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы.</span><span class="sxs-lookup"><span data-stu-id="de49f-2813">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de49f-2814">Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП.</span><span class="sxs-lookup"><span data-stu-id="de49f-2814">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de49f-2815">Код, зависящий от порядка байтов, может выполняться не на всех платформах.</span><span class="sxs-lookup"><span data-stu-id="de49f-2815">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de49f-2816"><xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.</span><span class="sxs-lookup"><span data-stu-id="de49f-2816"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de49f-2817">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.i4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2817">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2818">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2818">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2819">Выполняет косвенную загрузку значения с типом <see langword="int64" /> в стек вычислений как <see langword="int64" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2819">Loads a value of type <see langword="int64" /> as an <see langword="int64" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2820">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2820">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2821">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2821">Format</span></span>|<span data-ttu-id="de49f-2822">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2822">Assembly Format</span></span>|<span data-ttu-id="de49f-2823">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2823">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2824">4C</span><span class="sxs-lookup"><span data-stu-id="de49f-2824">4C</span></span>|<span data-ttu-id="de49f-2825">ldind. i8</span><span class="sxs-lookup"><span data-stu-id="de49f-2825">ldind.i8</span></span>|<span data-ttu-id="de49f-2826">Загружает значение `int64` по адресу `addr` в стек как `int64`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2826">Loads the `int64` value at address `addr` onto the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="de49f-2827">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2827">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2828">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2828">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2829">Адрес извлекается из стека; извлекается значение, расположенное по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-2829">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de49f-2830">Полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2830">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2831">Инструкция `ldind.i8` выполняет косвенную загрузку значения `int64` из указанного адреса (типа `native int`, `&` или \*) в стек как `int64`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2831">The `ldind.i8` instruction indirectly loads an `int64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int64`.</span></span>  
  
 <span data-ttu-id="de49f-2832">Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-2832">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de49f-2833">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2833">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de49f-2834">Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2834">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2835">Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-2835">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de49f-2836">Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер).</span><span class="sxs-lookup"><span data-stu-id="de49f-2836">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de49f-2837">Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы.</span><span class="sxs-lookup"><span data-stu-id="de49f-2837">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de49f-2838">Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП.</span><span class="sxs-lookup"><span data-stu-id="de49f-2838">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de49f-2839">Код, зависящий от порядка байтов, может выполняться не на всех платформах.</span><span class="sxs-lookup"><span data-stu-id="de49f-2839">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de49f-2840"><xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.</span><span class="sxs-lookup"><span data-stu-id="de49f-2840"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de49f-2841">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.i8`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2841">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2842">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2842">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2843">Выполняет косвенную загрузку значения с типом <see langword="float32" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</span><span class="sxs-lookup"><span data-stu-id="de49f-2843">Loads a value of type <see langword="float32" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2844">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2844">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2845">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2845">Format</span></span>|<span data-ttu-id="de49f-2846">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2846">Assembly Format</span></span>|<span data-ttu-id="de49f-2847">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2847">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2848">4E</span><span class="sxs-lookup"><span data-stu-id="de49f-2848">4E</span></span>|<span data-ttu-id="de49f-2849">ldind. R4</span><span class="sxs-lookup"><span data-stu-id="de49f-2849">ldind.r4</span></span>|<span data-ttu-id="de49f-2850">Загружает значение `float32` по адресу `addr` в стек как тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2850">Loads the `float32` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="de49f-2851">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2851">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2852">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2852">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2853">Адрес извлекается из стека; извлекается значение, расположенное по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-2853">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de49f-2854">Полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2854">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2855">Инструкция `ldind.r4` выполняет косвенную загрузку значения `float32` из указанного адреса (типа `native int`, `&` или \*) в стек как тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2855">The `ldind.r4` instruction indirectly loads a `float32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a type `F`.</span></span>  
  
 <span data-ttu-id="de49f-2856">Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-2856">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de49f-2857">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2857">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de49f-2858">Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2858">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2859">Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-2859">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de49f-2860">Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер).</span><span class="sxs-lookup"><span data-stu-id="de49f-2860">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de49f-2861">Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы.</span><span class="sxs-lookup"><span data-stu-id="de49f-2861">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de49f-2862">Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП.</span><span class="sxs-lookup"><span data-stu-id="de49f-2862">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de49f-2863">Код, зависящий от порядка байтов, может выполняться не на всех платформах.</span><span class="sxs-lookup"><span data-stu-id="de49f-2863">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de49f-2864"><xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.</span><span class="sxs-lookup"><span data-stu-id="de49f-2864"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de49f-2865">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.r4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2865">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2866">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2866">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2867">Выполняет косвенную загрузку значения с типом <see langword="float64" /> в стек вычислений как <see langword="F" /> (число с плавающей запятой).</span><span class="sxs-lookup"><span data-stu-id="de49f-2867">Loads a value of type <see langword="float64" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2868">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2868">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2869">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2869">Format</span></span>|<span data-ttu-id="de49f-2870">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2870">Assembly Format</span></span>|<span data-ttu-id="de49f-2871">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2871">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2872">4F</span><span class="sxs-lookup"><span data-stu-id="de49f-2872">4F</span></span>|<span data-ttu-id="de49f-2873">ldind. R8</span><span class="sxs-lookup"><span data-stu-id="de49f-2873">ldind.r8</span></span>|<span data-ttu-id="de49f-2874">Загружает значение `float64` по адресу `addr` в стек как тип `F`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2874">Loads the `float64` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="de49f-2875">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2875">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2876">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2876">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2877">Адрес извлекается из стека; извлекается значение, расположенное по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-2877">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de49f-2878">Полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2878">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2879">Инструкция `ldind.r8` выполняет косвенную загрузку значения `float64` из указанного адреса (типа `native int`, `&` или \*) в стек как `float64`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2879">The `ldind.r8` instruction indirectly loads a `float64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `float64`.</span></span>  
  
 <span data-ttu-id="de49f-2880">Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-2880">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de49f-2881">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2881">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de49f-2882">Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2882">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2883">Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-2883">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de49f-2884">Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер).</span><span class="sxs-lookup"><span data-stu-id="de49f-2884">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de49f-2885">Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы.</span><span class="sxs-lookup"><span data-stu-id="de49f-2885">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de49f-2886">Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП.</span><span class="sxs-lookup"><span data-stu-id="de49f-2886">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de49f-2887">Код, зависящий от порядка байтов, может выполняться не на всех платформах.</span><span class="sxs-lookup"><span data-stu-id="de49f-2887">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de49f-2888"><xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.</span><span class="sxs-lookup"><span data-stu-id="de49f-2888"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de49f-2889">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.r8`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2889">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2890">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2890">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2891">Выполняет косвенную загрузку в стек вычислений ссылки на объект как <see langword="O" /> (ссылка на объект).</span><span class="sxs-lookup"><span data-stu-id="de49f-2891">Loads an object reference as a type <see langword="O" /> (object reference) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2892">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2892">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2893">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2893">Format</span></span>|<span data-ttu-id="de49f-2894">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2894">Assembly Format</span></span>|<span data-ttu-id="de49f-2895">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2895">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2896">50</span><span class="sxs-lookup"><span data-stu-id="de49f-2896">50</span></span>|<span data-ttu-id="de49f-2897">ldind. ref</span><span class="sxs-lookup"><span data-stu-id="de49f-2897">ldind.ref</span></span>|<span data-ttu-id="de49f-2898">Загружает ссылку на объект по адресу `addr` в стек как тип `O`</span><span class="sxs-lookup"><span data-stu-id="de49f-2898">Loads the object reference at address `addr` onto the stack as a type `O`</span></span>|  
  
 <span data-ttu-id="de49f-2899">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2899">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2900">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2900">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2901">Адрес извлекается из стека; Ссылка на объект, расположенная по адресу, выбирается.</span><span class="sxs-lookup"><span data-stu-id="de49f-2901">The address is popped from the stack; the object reference located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de49f-2902">Извлеченная ссылка помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2902">The fetched reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2903">Инструкция `ldind.ref` выполняет косвенную загрузку ссылки на объект с указанным адресом (типа `native int`, `&` или \*) в стек как тип `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2903">The `ldind.ref` instruction indirectly loads the object reference the specified address (of type `native int`, `&`, or \*) onto the stack as type `O`.</span></span>  
  
 <span data-ttu-id="de49f-2904">Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-2904">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de49f-2905">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2905">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de49f-2906">Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2906">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2907">Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-2907">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de49f-2908">Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер).</span><span class="sxs-lookup"><span data-stu-id="de49f-2908">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de49f-2909">Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы.</span><span class="sxs-lookup"><span data-stu-id="de49f-2909">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de49f-2910">Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП.</span><span class="sxs-lookup"><span data-stu-id="de49f-2910">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de49f-2911">Код, зависящий от порядка байтов, может выполняться не на всех платформах.</span><span class="sxs-lookup"><span data-stu-id="de49f-2911">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de49f-2912"><xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.</span><span class="sxs-lookup"><span data-stu-id="de49f-2912"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de49f-2913">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.ref`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2913">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2914">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2914">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2915">Выполняет косвенную загрузку значения с типом <see langword="unsigned int8" /> в стек вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2915">Loads a value of type <see langword="unsigned int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2916">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2916">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2917">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2917">Format</span></span>|<span data-ttu-id="de49f-2918">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2918">Assembly Format</span></span>|<span data-ttu-id="de49f-2919">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2919">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2920">47</span><span class="sxs-lookup"><span data-stu-id="de49f-2920">47</span></span>|<span data-ttu-id="de49f-2921">ldind. U1</span><span class="sxs-lookup"><span data-stu-id="de49f-2921">ldind.u1</span></span>|<span data-ttu-id="de49f-2922">Загружает значение `unsigned int8` по адресу `addr` в стек как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2922">Loads the `unsigned int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de49f-2923">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2923">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2924">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2924">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2925">Адрес извлекается из стека; извлекается значение, расположенное по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-2925">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de49f-2926">Полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2926">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2927">Инструкция `ldind.u1` косвенно загружает `unsigned int8` значение из указанного адреса (типа`native int`, `&`или \*) в стек как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2927">The `ldind.u1` instruction indirectly loads an `unsigned int8` value from the specified address (of type`native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="de49f-2928">Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-2928">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de49f-2929">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2929">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de49f-2930">Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2930">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2931">Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-2931">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de49f-2932">Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер).</span><span class="sxs-lookup"><span data-stu-id="de49f-2932">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de49f-2933">Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы.</span><span class="sxs-lookup"><span data-stu-id="de49f-2933">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de49f-2934">Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП.</span><span class="sxs-lookup"><span data-stu-id="de49f-2934">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de49f-2935">Код, зависящий от порядка байтов, может выполняться не на всех платформах.</span><span class="sxs-lookup"><span data-stu-id="de49f-2935">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de49f-2936"><xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.</span><span class="sxs-lookup"><span data-stu-id="de49f-2936"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de49f-2937">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.u1`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u1` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2938">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2939">Выполняет косвенную загрузку значения с типом <see langword="unsigned int16" /> в стек вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2939">Loads a value of type <see langword="unsigned int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2940">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2940">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2941">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2941">Format</span></span>|<span data-ttu-id="de49f-2942">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2942">Assembly Format</span></span>|<span data-ttu-id="de49f-2943">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2943">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2944">49</span><span class="sxs-lookup"><span data-stu-id="de49f-2944">49</span></span>|<span data-ttu-id="de49f-2945">ldind. U2</span><span class="sxs-lookup"><span data-stu-id="de49f-2945">ldind.u2</span></span>|<span data-ttu-id="de49f-2946">Загружает значение `unsigned int16` по адресу `addr` в стек как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2946">Loads the `unsigned int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de49f-2947">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2947">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2948">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2948">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2949">Адрес извлекается из стека; извлекается значение, расположенное по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-2949">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de49f-2950">Полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2950">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2951">Инструкция `ldind.u2` выполняет косвенную загрузку значения `unsigned int16` из указанного адреса (типа `native int`, `&` или \*) в стек как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2951">The `ldind.u2` instruction indirectly loads an `unsigned int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="de49f-2952">Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-2952">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de49f-2953">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2953">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de49f-2954">Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2954">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2955">Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-2955">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de49f-2956">Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер).</span><span class="sxs-lookup"><span data-stu-id="de49f-2956">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de49f-2957">Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы.</span><span class="sxs-lookup"><span data-stu-id="de49f-2957">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de49f-2958">Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП.</span><span class="sxs-lookup"><span data-stu-id="de49f-2958">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de49f-2959">Код, зависящий от порядка байтов, может выполняться не на всех платформах.</span><span class="sxs-lookup"><span data-stu-id="de49f-2959">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de49f-2960"><xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.</span><span class="sxs-lookup"><span data-stu-id="de49f-2960"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de49f-2961">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.u2`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2961">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u2` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2962">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2962">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2963">Выполняет косвенную загрузку значения с типом <see langword="unsigned int32" /> в стек вычислений как <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-2963">Loads a value of type <see langword="unsigned int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2964">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2964">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2965">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2965">Format</span></span>|<span data-ttu-id="de49f-2966">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2966">Assembly Format</span></span>|<span data-ttu-id="de49f-2967">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2967">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2968">4B</span><span class="sxs-lookup"><span data-stu-id="de49f-2968">4B</span></span>|<span data-ttu-id="de49f-2969">ldind. U4</span><span class="sxs-lookup"><span data-stu-id="de49f-2969">ldind.u4</span></span>|<span data-ttu-id="de49f-2970">Загружает значение `unsigned int32` по адресу `addr` в стек как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2970">Loads the `unsigned int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="de49f-2971">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2971">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2972">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2972">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2973">Адрес извлекается из стека; извлекается значение, расположенное по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-2973">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="de49f-2974">Полученное значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2974">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2975">Инструкция `ldind.u4` выполняет косвенную загрузку значения `unsigned int32` из указанного адреса (типа `native int`, `&` или \*) в стек как `int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2975">The `ldind.u4` instruction indirectly loads an `unsigned int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="de49f-2976">Все инструкции `ldind` являются ярлыками для инструкции <xref:System.Reflection.Emit.OpCodes.Ldobj>, указывающей соответствующий встроенный класс значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-2976">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="de49f-2977">Обратите внимание, что целочисленные значения менее 4 байт расширяются до `int32` (не `native int`) при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2977">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="de49f-2978">Значения с плавающей запятой преобразуются в тип `F` при загрузке в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-2978">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-2979">Правильно сформированный язык MSIL гарантирует, что инструкции `ldind` будут использоваться способом, согласованным с типом указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-2979">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="de49f-2980">Адрес, изначально Отправленный в стек, должен быть согласован с естественным размером объектов на компьютере или <xref:System.NullReferenceException> (см. инструкции по префиксу <xref:System.Reflection.Emit.OpCodes.Unaligned> для предупредительных мер).</span><span class="sxs-lookup"><span data-stu-id="de49f-2980">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="de49f-2981">Результаты всех инструкций MSIL, которые возвращают адреса (например, <xref:System.Reflection.Emit.OpCodes.Ldloca> и <xref:System.Reflection.Emit.OpCodes.Ldarga>), безопасно согласованы.</span><span class="sxs-lookup"><span data-stu-id="de49f-2981">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="de49f-2982">Для типов больших значений, превышающих 1 байт, порядок байтов зависит от целевого ЦП.</span><span class="sxs-lookup"><span data-stu-id="de49f-2982">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="de49f-2983">Код, зависящий от порядка байтов, может выполняться не на всех платформах.</span><span class="sxs-lookup"><span data-stu-id="de49f-2983">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="de49f-2984"><xref:System.NullReferenceException> может возникать, если обнаружен недопустимый адрес.</span><span class="sxs-lookup"><span data-stu-id="de49f-2984"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="de49f-2985">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldind.u4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-2985">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-2986">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-2986">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-2987">Помещает в стек вычислений сведения о числе элементов одномерного массива с индексацией от нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-2987">Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-2988">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-2988">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-2989">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-2989">Format</span></span>|<span data-ttu-id="de49f-2990">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-2990">Assembly Format</span></span>|<span data-ttu-id="de49f-2991">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-2991">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-2992">8E</span><span class="sxs-lookup"><span data-stu-id="de49f-2992">8E</span></span>|<span data-ttu-id="de49f-2993">лдлен</span><span class="sxs-lookup"><span data-stu-id="de49f-2993">ldlen</span></span>|<span data-ttu-id="de49f-2994">Помещает длину (типа `natural unsigned int`) массива в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2994">Pushes the length (of type `natural unsigned int`) of an array on the stack.</span></span>|  
  
 <span data-ttu-id="de49f-2995">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-2995">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-2996">Ссылка на объект массива помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2996">An object reference to an array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-2997">Ссылка на массив извлекается из стека, а длина вычислена.</span><span class="sxs-lookup"><span data-stu-id="de49f-2997">The array reference is popped from the stack and the length is computed.</span></span>  
  
3.  <span data-ttu-id="de49f-2998">Длина помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-2998">The length is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-2999">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-2999">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de49f-3000">Длина возвращается как `natural unsigned int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3000">The length is returned as a `natural unsigned int`.</span></span>  
  
 <span data-ttu-id="de49f-3001">Если ссылка на массив является пустой ссылкой, возникает исключение <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="de49f-3001"><xref:System.NullReferenceException> is thrown if the array reference is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-3002">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldlen`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3002">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldlen` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3003">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3003">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3004">Загружает в стек вычислений локальную переменную с указанным индексом.</span><span class="sxs-lookup"><span data-stu-id="de49f-3004">Loads the local variable at a specific index onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3005">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3005">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3006">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3006">Format</span></span>|<span data-ttu-id="de49f-3007">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3007">Assembly Format</span></span>|<span data-ttu-id="de49f-3008">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3008">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3009">< FE 0C `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="de49f-3009">FE 0C < `unsigned int16` ></span></span>|<span data-ttu-id="de49f-3010">требовалась ldloc `index`</span><span class="sxs-lookup"><span data-stu-id="de49f-3010">ldloc `index`</span></span>|<span data-ttu-id="de49f-3011">Загружает локальную переменную с индексом `index` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3011">Loads the local variable at index `index` onto stack.</span></span>|  
  
 <span data-ttu-id="de49f-3012">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3012">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3013">Значение локальной переменной по указанному индексу помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3013">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3014">Инструкция `ldloc` отправляет содержимое номера локальной переменной по переданному индексу в стек вычислений, где локальные переменные нумеруются 0 – назад.</span><span class="sxs-lookup"><span data-stu-id="de49f-3014">The `ldloc` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="de49f-3015">Локальные переменные инициализируются значением 0 перед вводом метода только в том случае, если флаг инициализации метода имеет значение true.</span><span class="sxs-lookup"><span data-stu-id="de49f-3015">Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true.</span></span> <span data-ttu-id="de49f-3016">Возможны локальные переменные 65 535 (2 ^ 16-1) (0 – 65534).</span><span class="sxs-lookup"><span data-stu-id="de49f-3016">There are 65,535 (2^16-1) local variables possible (0-65,534).</span></span> <span data-ttu-id="de49f-3017">Индекс 65 535 является недопустимым, так как вероятные реализации будут использовать 2-байтовое целое число для записи как индекса локального объекта, так и общего числа локальных переменных для данного метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-3017">Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method.</span></span> <span data-ttu-id="de49f-3018">Если индекс 65535 был сделан допустимым, для записи числа локальных переменных в таком методе потребуется более широкое целое число.</span><span class="sxs-lookup"><span data-stu-id="de49f-3018">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="de49f-3019">Инструкции `ldloc.0`, `ldloc.1`, `ldloc.2` и `ldloc.3` обеспечивают эффективную кодировку для доступа к первым четырем локальным переменным.</span><span class="sxs-lookup"><span data-stu-id="de49f-3019">The `ldloc.0`, `ldloc.1`, `ldloc.2`, and `ldloc.3` instructions provide an efficient encoding for accessing the first four local variables.</span></span>  
  
 <span data-ttu-id="de49f-3020">Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-3020">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="de49f-3021">См. раздел I. локальные переменные размером менее 4 байт развернуты до типа `int32` при загрузке в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3021">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de49f-3022">Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).</span><span class="sxs-lookup"><span data-stu-id="de49f-3022">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de49f-3023">Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `ldloc`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3023">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3024">ILGenerator. Emit (код операции, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="de49f-3024">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="de49f-3025">ILGenerator. Emit (код операции, короткий)</span><span class="sxs-lookup"><span data-stu-id="de49f-3025">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3026">Загружает в стек вычислений локальную переменную с индексом 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-3026">Loads the local variable at index 0 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3027">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3027">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3028">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3028">Format</span></span>|<span data-ttu-id="de49f-3029">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3029">Assembly Format</span></span>|<span data-ttu-id="de49f-3030">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3030">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3031">06</span><span class="sxs-lookup"><span data-stu-id="de49f-3031">06</span></span>|<span data-ttu-id="de49f-3032">требовалась ldloc. 0</span><span class="sxs-lookup"><span data-stu-id="de49f-3032">ldloc.0</span></span>|<span data-ttu-id="de49f-3033">Загружает в стек вычислений локальную переменную с индексом 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-3033">Loads the local variable at index 0 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="de49f-3034">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3034">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3035">Значение локальной переменной в индексе 0 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3035">The local variable value at the index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3036">`ldloc.0` является особенно эффективной кодировкой для <xref:System.Reflection.Emit.OpCodes.Ldloc>, что позволяет получить доступ к локальной переменной по индексу 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-3036">`ldloc.0` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 0.</span></span>  
  
 <span data-ttu-id="de49f-3037">Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-3037">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="de49f-3038">Локальные переменные, размер которых меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3038">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de49f-3039">Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).</span><span class="sxs-lookup"><span data-stu-id="de49f-3039">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de49f-3040">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloc.0`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3040">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3041">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3041">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3042">Загружает в стек вычислений локальную переменную с индексом 1.</span><span class="sxs-lookup"><span data-stu-id="de49f-3042">Loads the local variable at index 1 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3043">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3043">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3044">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3044">Format</span></span>|<span data-ttu-id="de49f-3045">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3045">Assembly Format</span></span>|<span data-ttu-id="de49f-3046">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3046">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3047">07</span><span class="sxs-lookup"><span data-stu-id="de49f-3047">07</span></span>|<span data-ttu-id="de49f-3048">требовалась ldloc. 1</span><span class="sxs-lookup"><span data-stu-id="de49f-3048">ldloc.1</span></span>|<span data-ttu-id="de49f-3049">Загружает в стек вычислений локальную переменную с индексом 1.</span><span class="sxs-lookup"><span data-stu-id="de49f-3049">Loads the local variable at index 1 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="de49f-3050">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3050">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3051">Значение локальной переменной в индексе 1 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3051">The local variable value at the index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3052">`ldloc.1` является особенно эффективной кодировкой для <xref:System.Reflection.Emit.OpCodes.Ldloc>, что позволяет получить доступ к локальной переменной по индексу 1.</span><span class="sxs-lookup"><span data-stu-id="de49f-3052">`ldloc.1` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 1.</span></span>  
  
 <span data-ttu-id="de49f-3053">Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-3053">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="de49f-3054">Локальные переменные, размер которых меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3054">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de49f-3055">Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).</span><span class="sxs-lookup"><span data-stu-id="de49f-3055">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de49f-3056">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloc.1`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3056">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3057">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3057">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3058">Загружает в стек вычислений локальную переменную с индексом 2.</span><span class="sxs-lookup"><span data-stu-id="de49f-3058">Loads the local variable at index 2 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3059">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3059">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3060">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3060">Format</span></span>|<span data-ttu-id="de49f-3061">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3061">Assembly Format</span></span>|<span data-ttu-id="de49f-3062">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3062">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3063">08</span><span class="sxs-lookup"><span data-stu-id="de49f-3063">08</span></span>|<span data-ttu-id="de49f-3064">требовалась ldloc. 2</span><span class="sxs-lookup"><span data-stu-id="de49f-3064">ldloc.2</span></span>|<span data-ttu-id="de49f-3065">Загружает в стек вычислений локальную переменную с индексом 2.</span><span class="sxs-lookup"><span data-stu-id="de49f-3065">Loads the local variable at index 2 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="de49f-3066">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3066">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3067">Значение локальной переменной в индексе 2 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3067">The local variable value at the index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3068">`ldloc.2` является особенно эффективной кодировкой для <xref:System.Reflection.Emit.OpCodes.Ldloc>, что позволяет получить доступ к локальной переменной по индексу 2.</span><span class="sxs-lookup"><span data-stu-id="de49f-3068">`ldloc.2` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 2.</span></span>  
  
 <span data-ttu-id="de49f-3069">Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-3069">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="de49f-3070">Локальные переменные, размер которых меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3070">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de49f-3071">Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).</span><span class="sxs-lookup"><span data-stu-id="de49f-3071">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de49f-3072">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloc.2`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3073">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3074">Загружает в стек вычислений локальную переменную с индексом 3.</span><span class="sxs-lookup"><span data-stu-id="de49f-3074">Loads the local variable at index 3 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3075">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3076">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3076">Format</span></span>|<span data-ttu-id="de49f-3077">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3077">Assembly Format</span></span>|<span data-ttu-id="de49f-3078">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3079">09</span><span class="sxs-lookup"><span data-stu-id="de49f-3079">09</span></span>|<span data-ttu-id="de49f-3080">требовалась ldloc. 3</span><span class="sxs-lookup"><span data-stu-id="de49f-3080">ldloc.3</span></span>|<span data-ttu-id="de49f-3081">Загружает в стек вычислений локальную переменную с индексом 3.</span><span class="sxs-lookup"><span data-stu-id="de49f-3081">Loads the local variable at index 3 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="de49f-3082">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3083">Значение локальной переменной в индексе 3 помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3083">The local variable value at the index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3084">`ldloc.3` является особенно эффективной кодировкой для <xref:System.Reflection.Emit.OpCodes.Ldloc>, что позволяет получить доступ к локальной переменной по индексу 3.</span><span class="sxs-lookup"><span data-stu-id="de49f-3084">`ldloc.3` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 3.</span></span>  
  
 <span data-ttu-id="de49f-3085">Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-3085">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="de49f-3086">Локальные переменные, размер которых меньше 4 байт, разворачиваются до типа `int32`, когда они загружаются в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3086">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de49f-3087">Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).</span><span class="sxs-lookup"><span data-stu-id="de49f-3087">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de49f-3088">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloc.3`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3088">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3089">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3089">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3090">Загружает в стек вычислений локальную переменную с указанным индексом (короткая форма).</span><span class="sxs-lookup"><span data-stu-id="de49f-3090">Loads the local variable at a specific index onto the evaluation stack, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3091">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3091">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3092">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3092">Format</span></span>|<span data-ttu-id="de49f-3093">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3093">Assembly Format</span></span>|<span data-ttu-id="de49f-3094">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3094">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3095">11 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="de49f-3095">11 < `unsigned int8` ></span></span>|<span data-ttu-id="de49f-3096">требовалась ldloc. s `index`</span><span class="sxs-lookup"><span data-stu-id="de49f-3096">ldloc.s `index`</span></span>|<span data-ttu-id="de49f-3097">Загружает локальную переменную с индексом `index` в стек, короткую форму.</span><span class="sxs-lookup"><span data-stu-id="de49f-3097">Loads the local variable at index `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="de49f-3098">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3098">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3099">Значение локальной переменной по указанному индексу помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3099">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3100">Инструкция `ldloc.s` отправляет содержимое номера локальной переменной по переданному индексу в стек вычислений, где локальные переменные нумеруются 0 – назад.</span><span class="sxs-lookup"><span data-stu-id="de49f-3100">The `ldloc.s` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="de49f-3101">Локальные переменные инициализируются значением 0 перед входом в метод, если флаг инициализации метода имеет значение true.</span><span class="sxs-lookup"><span data-stu-id="de49f-3101">Local variables are initialized to 0 before entering the method if the initialize flag on the method is true.</span></span> <span data-ttu-id="de49f-3102">В краткой форме имеется 256 (2 ^ 8) локальных переменных (0-255), что является более эффективной кодировкой, чем `ldloc`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3102">There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than `ldloc`.</span></span>  
  
 <span data-ttu-id="de49f-3103">Тип значения совпадает с типом локальной переменной, которая указана в заголовке метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-3103">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="de49f-3104">См. раздел I. локальные переменные размером менее 4 байт развернуты до типа `int32` при загрузке в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3104">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="de49f-3105">Значения с плавающей запятой разворачиваются до их собственного размера (тип `F`).</span><span class="sxs-lookup"><span data-stu-id="de49f-3105">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="de49f-3106">Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `ldloc.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3106">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3107">ILGenerator. Emit (код операции, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="de49f-3107">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="de49f-3108">ILGenerator. Emit (код операции, байт)</span><span class="sxs-lookup"><span data-stu-id="de49f-3108">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3109">Загружает в стек вычислений адрес локальной переменной с указанным индексом.</span><span class="sxs-lookup"><span data-stu-id="de49f-3109">Loads the address of the local variable at a specific index onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3110">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3110">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3111">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3111">Format</span></span>|<span data-ttu-id="de49f-3112">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3112">Assembly Format</span></span>|<span data-ttu-id="de49f-3113">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3113">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3114">`unsigned int16`< FE OD  ></span><span class="sxs-lookup"><span data-stu-id="de49f-3114">FE OD < `unsigned int16` ></span></span>|<span data-ttu-id="de49f-3115">лдлока `index`</span><span class="sxs-lookup"><span data-stu-id="de49f-3115">ldloca `index`</span></span>|<span data-ttu-id="de49f-3116">Загружает адрес локальной переменной с `index` в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3116">Loads the address of the local variable at `index` onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="de49f-3117">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3117">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3118">Адрес, хранящийся в локальной переменной по указанному индексу, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3118">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3119">Инструкция `ldloca` помещает в стек адрес локальной переменной с переданным индексом, где локальные переменные нумеруются 0 – назад.</span><span class="sxs-lookup"><span data-stu-id="de49f-3119">The `ldloca` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="de49f-3120">Значение, помещаемое в стек, уже правильно согласовано для использования с такими инструкциями, как <xref:System.Reflection.Emit.OpCodes.Ldind_I> и <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span><span class="sxs-lookup"><span data-stu-id="de49f-3120">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="de49f-3121">Результатом является временный указатель (тип `*`).</span><span class="sxs-lookup"><span data-stu-id="de49f-3121">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="de49f-3122">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloca`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3122">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3123">ILGenerator. Emit (код операции, короткий)</span><span class="sxs-lookup"><span data-stu-id="de49f-3123">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3124">Загружает в стек вычислений адрес локальной переменной с указанным индексом (короткая форма).</span><span class="sxs-lookup"><span data-stu-id="de49f-3124">Loads the address of the local variable at a specific index onto the evaluation stack, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3125">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3125">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3126">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3126">Format</span></span>|<span data-ttu-id="de49f-3127">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3127">Assembly Format</span></span>|<span data-ttu-id="de49f-3128">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3128">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3129">12 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="de49f-3129">12 < `unsigned int8` ></span></span>|<span data-ttu-id="de49f-3130">лдлока. s `index`</span><span class="sxs-lookup"><span data-stu-id="de49f-3130">ldloca.s `index`</span></span>|<span data-ttu-id="de49f-3131">Загружает адрес локальной переменной с `index` в стек вычислений, короткая форма.</span><span class="sxs-lookup"><span data-stu-id="de49f-3131">Loads the address of the local variable at `index` onto the evaluation stack, short form.</span></span>|  
  
 <span data-ttu-id="de49f-3132">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3132">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3133">Адрес, хранящийся в локальной переменной по указанному индексу, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3133">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3134">Инструкция `ldloca.s` помещает в стек адрес локальной переменной с переданным индексом, где локальные переменные нумеруются 0 – назад.</span><span class="sxs-lookup"><span data-stu-id="de49f-3134">The `ldloca.s` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="de49f-3135">Значение, помещаемое в стек, уже правильно согласовано для использования с такими инструкциями, как <xref:System.Reflection.Emit.OpCodes.Ldind_I> и <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span><span class="sxs-lookup"><span data-stu-id="de49f-3135">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="de49f-3136">Результатом является временный указатель (тип `*`).</span><span class="sxs-lookup"><span data-stu-id="de49f-3136">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="de49f-3137">Инструкция `ldloca.s` обеспечивает эффективную кодировку для использования с локальными переменными от 0 до 255.</span><span class="sxs-lookup"><span data-stu-id="de49f-3137">The `ldloca.s` instruction provides an efficient encoding for use with the local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="de49f-3138">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldloca.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3138">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3139">ILGenerator. Emit (код операции, байт)</span><span class="sxs-lookup"><span data-stu-id="de49f-3139">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3140">Помещает в стек вычислений пустую ссылку (тип <see langword="O" />).</span><span class="sxs-lookup"><span data-stu-id="de49f-3140">Pushes a null reference (type <see langword="O" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3141">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3141">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3142">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3142">Format</span></span>|<span data-ttu-id="de49f-3143">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3143">Assembly Format</span></span>|<span data-ttu-id="de49f-3144">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3144">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3145">14</span><span class="sxs-lookup"><span data-stu-id="de49f-3145">14</span></span>|<span data-ttu-id="de49f-3146">требовался ldnull</span><span class="sxs-lookup"><span data-stu-id="de49f-3146">ldnull</span></span>|<span data-ttu-id="de49f-3147">Отправка пустой ссылки на стек</span><span class="sxs-lookup"><span data-stu-id="de49f-3147">push a null reference onto the stack</span></span>|  
  
 <span data-ttu-id="de49f-3148">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3148">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3149">Ссылка на пустой объект помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3149">A null object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3150">`ldnull` отправляет в стек пустую ссылку (тип `O`).</span><span class="sxs-lookup"><span data-stu-id="de49f-3150">`ldnull` pushes a null reference (type `O`) on the stack.</span></span> <span data-ttu-id="de49f-3151">Используется для инициализации расположений перед заполнением данными или в случае, когда они становятся нерекомендуемыми.</span><span class="sxs-lookup"><span data-stu-id="de49f-3151">This is used to initialize locations before they are populated with data, or when they become deprecated.</span></span>  
  
 <span data-ttu-id="de49f-3152">`ldnull` предоставляет пустую ссылку, которая не зависит от размера.</span><span class="sxs-lookup"><span data-stu-id="de49f-3152">`ldnull` provides a null reference that is size-independent.</span></span>  
  
 <span data-ttu-id="de49f-3153">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldnull`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3153">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldnull` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3154">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3154">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3155">Копирует объект с типом значения, размещенный по указанному адресу, на вершину стека вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3155">Copies the value type object pointed to by an address to the top of the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3156">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3156">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3157">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3157">Format</span></span>|<span data-ttu-id="de49f-3158">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3158">Assembly Format</span></span>|<span data-ttu-id="de49f-3159">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3159">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3160">71 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-3160">71 < `T` ></span></span>|<span data-ttu-id="de49f-3161">ldobj `class`</span><span class="sxs-lookup"><span data-stu-id="de49f-3161">ldobj `class`</span></span>|<span data-ttu-id="de49f-3162">Скопируйте экземпляр типа значения `class` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3162">Copy instance of value type `class` to the stack.</span></span>|  
  
 <span data-ttu-id="de49f-3163">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3163">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3164">Адрес объекта типа значения помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3164">The address of a value type object is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3165">Адрес извлекается из стека, и происходит поиск экземпляра по определенному адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-3165">The address is popped from the stack and the instance at that particular address is looked up.</span></span>  
  
3.  <span data-ttu-id="de49f-3166">Значение объекта, хранящегося в этом адресе, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3166">The value of the object stored at that address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3167">Инструкция `ldobj` используется для передачи типа значения в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="de49f-3167">The `ldobj` instruction is used to pass a value type as a parameter.</span></span>  
  
 <span data-ttu-id="de49f-3168">Инструкция `ldobj` копирует значение, на которое указывает `addrOfValObj` (типа `&`, `*` или `native int`), в верхнюю часть стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-3168">The `ldobj` instruction copies the value pointed to by `addrOfValObj` (of type `&`, `*`, or `native int`) to the top of the stack.</span></span> <span data-ttu-id="de49f-3169">Количество копируемых байтов зависит от размера класса (как указано в параметре `class`).</span><span class="sxs-lookup"><span data-stu-id="de49f-3169">The number of bytes copied depends on the size of the class (as specified by the `class` parameter).</span></span> <span data-ttu-id="de49f-3170">Параметр `class` является маркером метаданных, представляющим тип значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3170">The `class` parameter is a metadata token representing the value type.</span></span>  
  
 <span data-ttu-id="de49f-3171">Операция `ldobj` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.</span><span class="sxs-lookup"><span data-stu-id="de49f-3171">The operation of the `ldobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de49f-3172">Если класс не найден, возникает исключение <xref:System.TypeLoadException>.</span><span class="sxs-lookup"><span data-stu-id="de49f-3172"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="de49f-3173">Обычно это обнаруживается при преобразовании инструкции MSIL в машинный код, а не во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3173">This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="de49f-3174">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldobj`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3174">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldobj` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3175">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-3175">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3176">Помещает в стек вычислений значение статического поля.</span><span class="sxs-lookup"><span data-stu-id="de49f-3176">Pushes the value of a static field onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3177">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3177">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3178">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3178">Format</span></span>|<span data-ttu-id="de49f-3179">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3179">Assembly Format</span></span>|<span data-ttu-id="de49f-3180">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3180">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3181">7E < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-3181">7E < `T` ></span></span>|<span data-ttu-id="de49f-3182">ldsfld `field`</span><span class="sxs-lookup"><span data-stu-id="de49f-3182">ldsfld `field`</span></span>|<span data-ttu-id="de49f-3183">Помещает значение `field` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3183">Push the value of `field` on the stack.</span></span>|  
  
 <span data-ttu-id="de49f-3184">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3184">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3185">Значение конкретного поля помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3185">The value of the specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3186">Инструкция `ldsfld` помещает значение статического (общего для всех экземпляров класса) поля в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-3186">The `ldsfld` instruction pushes the value of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="de49f-3187">Тип возвращаемого значения связан с переданным маркером метаданных `field`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3187">The return type is that associated with the passed metadata token `field`.</span></span>  
  
 <span data-ttu-id="de49f-3188">Инструкция `ldsfld` может иметь префикс <xref:System.Reflection.Emit.OpCodes.Volatile>.</span><span class="sxs-lookup"><span data-stu-id="de49f-3188">The `ldsfld` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="de49f-3189">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldsfld`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3189">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsfld` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3190">ILGenerator. Emit (код операции, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="de49f-3190">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3191">Помещает в стек вычислений адрес статического поля.</span><span class="sxs-lookup"><span data-stu-id="de49f-3191">Pushes the address of a static field onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3192">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3192">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3193">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3193">Format</span></span>|<span data-ttu-id="de49f-3194">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3194">Assembly Format</span></span>|<span data-ttu-id="de49f-3195">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3195">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3196">`T`7F <  ></span><span class="sxs-lookup"><span data-stu-id="de49f-3196">7F < `T` ></span></span>|<span data-ttu-id="de49f-3197">требовался ldsflda `field`</span><span class="sxs-lookup"><span data-stu-id="de49f-3197">ldsflda `field`</span></span>|<span data-ttu-id="de49f-3198">Отправка адреса `field` в стеке</span><span class="sxs-lookup"><span data-stu-id="de49f-3198">Push the address of `field` on the stack</span></span>|  
  
 <span data-ttu-id="de49f-3199">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3199">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3200">Адрес определенного поля помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3200">The address of a specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3201">Инструкция `ldsflda` помещает адрес статического поля (общего для всех экземпляров класса) в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-3201">The `ldsflda` instruction pushes the address of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="de49f-3202">Адрес может быть представлен временным указателем (тип `*`), если маркер метаданных `field` ссылается на тип, управляемый памятью.</span><span class="sxs-lookup"><span data-stu-id="de49f-3202">The address may be represented as a transient pointer (type `*`) if the metadata token `field` refers to a type whose memory is managed.</span></span> <span data-ttu-id="de49f-3203">В противном случае он соответствует неуправляемому указателю (тип `native int`).</span><span class="sxs-lookup"><span data-stu-id="de49f-3203">Otherwise, it corresponds to an unmanaged pointer (type `native int`).</span></span> <span data-ttu-id="de49f-3204">Обратите внимание, что `field` может быть статическим глобальным с назначенным относительным виртуальным адресом (смещение поля от базового адреса, в котором его содержащий PE-файл загружается в память), где память является неуправляемой.</span><span class="sxs-lookup"><span data-stu-id="de49f-3204">Note that `field` may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</span></span>  
  
 <span data-ttu-id="de49f-3205">Инструкция `ldsflda` может иметь префикс <xref:System.Reflection.Emit.OpCodes.Volatile>.</span><span class="sxs-lookup"><span data-stu-id="de49f-3205">The `ldsflda` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="de49f-3206">Если поле не найдено в метаданных, возникает исключение <xref:System.MissingFieldException>.</span><span class="sxs-lookup"><span data-stu-id="de49f-3206"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="de49f-3207">Обычно это проверяется при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3207">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="de49f-3208">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldsflda`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3208">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsflda` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3209">ILGenerator. Emit (код операции, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="de49f-3209">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3210">Помещает в стек ссылку на новый объект, представляющий строковой литерал, хранящийся в метаданных.</span><span class="sxs-lookup"><span data-stu-id="de49f-3210">Pushes a new object reference to a string literal stored in the metadata.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3211">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3211">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3212">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3212">Format</span></span>|<span data-ttu-id="de49f-3213">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3213">Assembly Format</span></span>|<span data-ttu-id="de49f-3214">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3214">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3215">72 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-3215">72 < `T` ></span></span>|<span data-ttu-id="de49f-3216">лдстр `mdToken`</span><span class="sxs-lookup"><span data-stu-id="de49f-3216">ldstr `mdToken`</span></span>|<span data-ttu-id="de49f-3217">Отправляет строковый объект для токена строки метаданных `mdToken`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3217">Pushes a string object for the metadata string token `mdToken`.</span></span>|  
  
 <span data-ttu-id="de49f-3218">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3218">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3219">Ссылка на объект String помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3219">An object reference to a string is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3220">Инструкция `ldstr` помещает ссылку на объект (тип `O`) в новый строковый объект, представляющий конкретный строковый литерал, хранящийся в метаданных.</span><span class="sxs-lookup"><span data-stu-id="de49f-3220">The `ldstr` instruction pushes an object reference (type `O`) to a new string object representing the specific string literal stored in the metadata.</span></span> <span data-ttu-id="de49f-3221">Инструкция `ldstr` выделяет необходимый объем памяти и выполняет любое преобразование формата, необходимое для преобразования строкового литерала из формы, используемой в файле, в формат строки, необходимый во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3221">The `ldstr` instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</span></span>  
  
 <span data-ttu-id="de49f-3222">Common Language Infrastructure (CLI) гарантирует, что результат двух инструкций `ldstr`, которые ссылаются на два токена метаданных с одинаковой последовательностью символов, возвращает один и тот же строковый объект (процесс, известный как «интернирование строк»).</span><span class="sxs-lookup"><span data-stu-id="de49f-3222">The Common Language Infrastructure (CLI) guarantees that the result of two `ldstr` instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as "string interning").</span></span>  
  
 <span data-ttu-id="de49f-3223">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldstr`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3223">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldstr` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3224">ILGenerator. Emit (код операции, строка)</span><span class="sxs-lookup"><span data-stu-id="de49f-3224">ILGenerator.Emit(OpCode, string)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3225">Преобразует токен метаданных в его представление времени выполнения, а затем помещает в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3225">Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3226">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3226">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3227">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3227">Format</span></span>|<span data-ttu-id="de49f-3228">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3228">Assembly Format</span></span>|<span data-ttu-id="de49f-3229">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3229">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3230">`T`< D0  ></span><span class="sxs-lookup"><span data-stu-id="de49f-3230">D0 < `T` ></span></span>|<span data-ttu-id="de49f-3231">коды операций Ldtoken `token`</span><span class="sxs-lookup"><span data-stu-id="de49f-3231">ldtoken `token`</span></span>|<span data-ttu-id="de49f-3232">Преобразует маркер метаданных в представление среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3232">Converts a metadata token to its runtime representation.</span></span>|  
  
 <span data-ttu-id="de49f-3233">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3233">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3234">Переданный токен преобразуется в `RuntimeHandle` и помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3234">The passed token is converted to a `RuntimeHandle` and pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3235">Инструкция `ldtoken` помещает `RuntimeHandle` для указанного маркера метаданных.</span><span class="sxs-lookup"><span data-stu-id="de49f-3235">The `ldtoken` instruction pushes a `RuntimeHandle` for the specified metadata token.</span></span> <span data-ttu-id="de49f-3236">`RuntimeHandle` может быть `fieldref/fielddef`, `methodref/methoddef`или `typeref/typedef`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3236">A `RuntimeHandle` can be a `fieldref/fielddef`, a `methodref/methoddef`, or a `typeref/typedef`.</span></span>  
  
 <span data-ttu-id="de49f-3237">Значение, помещаемое в стек, можно использовать в вызовах методов `Reflection` в библиотеке системных классов.</span><span class="sxs-lookup"><span data-stu-id="de49f-3237">The value pushed on the stack can be used in calls to `Reflection` methods in the system class library.</span></span>  
  
 <span data-ttu-id="de49f-3238">Сведения о дескрипторах среды выполнения см. в следующих классах: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle> и <xref:System.RuntimeMethodHandle>.</span><span class="sxs-lookup"><span data-stu-id="de49f-3238">For information on runtime handles, see the following classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, and <xref:System.RuntimeMethodHandle>.</span></span>  
  
 <span data-ttu-id="de49f-3239">Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `ldtoken`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3239">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldtoken` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3240">ILGenerator. Emit (код операции, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="de49f-3240">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="de49f-3241">ILGenerator. Emit (код операции, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="de49f-3241">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
-   <span data-ttu-id="de49f-3242">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-3242">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3243">Помещает в стек вычислений неуправляемый указатель (с типом <see langword="native int" />) на машинный код, реализующий виртуальный метод, связанный с заданным объектом.</span><span class="sxs-lookup"><span data-stu-id="de49f-3243">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3244">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3244">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3245">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3245">Format</span></span>|<span data-ttu-id="de49f-3246">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3246">Assembly Format</span></span>|<span data-ttu-id="de49f-3247">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3247">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3248">`T`< FE 7  ></span><span class="sxs-lookup"><span data-stu-id="de49f-3248">FE 07 < `T` ></span></span>|<span data-ttu-id="de49f-3249">ldvirtftn `method`</span><span class="sxs-lookup"><span data-stu-id="de49f-3249">ldvirtftn `method`</span></span>|<span data-ttu-id="de49f-3250">Помещает указатель на виртуальный метод объекта `method` в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-3250">Pushes the pointer to an object's virtual method `method` on the stack.</span></span>|  
  
 <span data-ttu-id="de49f-3251">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3251">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3252">Ссылка на объект помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3252">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3253">Ссылка на объект извлекается из стека, а адрес точки входа в метод (как указано маркером метаданных `method`) ищется.</span><span class="sxs-lookup"><span data-stu-id="de49f-3253">The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token `method`) is looked up.</span></span>  
  
3.  <span data-ttu-id="de49f-3254">Указатель на `method` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3254">The pointer to `method` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3255">Результирующий неуправляемый указатель, помещаемый в стек с помощью инструкции `ldvirtftn`, можно вызвать с помощью инструкции <xref:System.Reflection.Emit.OpCodes.Calli>, если она ссылается на управляемый метод (или на заглушку, переход от управляемого кода к неуправляемому).</span><span class="sxs-lookup"><span data-stu-id="de49f-3255">The resulting unmanaged pointer pushed onto the stack by the `ldvirtftn` instruction can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="de49f-3256">Неуправляемый указатель указывает на машинный код, используя соглашение о вызовах CLR.</span><span class="sxs-lookup"><span data-stu-id="de49f-3256">The unmanaged pointer points to native code using the CLR calling convention.</span></span> <span data-ttu-id="de49f-3257">Этот указатель метода не должен передаваться в неуправляемый машинный код в качестве подпрограммы обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="de49f-3257">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="de49f-3258">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ldvirtftn`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3258">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldvirtftn` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3259">ILGenerator. Emit (код операции, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="de49f-3259">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3260">Выполняет выход из защищенной области кода с безусловной передачей управления указанной конечной инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-3260">Exits a protected region of code, unconditionally transferring control to a specific target instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3261">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3261">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3262">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3262">Format</span></span>|<span data-ttu-id="de49f-3263">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3263">Assembly Format</span></span>|<span data-ttu-id="de49f-3264">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3264">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3265">`int32`< DD  ></span><span class="sxs-lookup"><span data-stu-id="de49f-3265">DD < `int32` ></span></span>|<span data-ttu-id="de49f-3266">Оставьте `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-3266">leave `target`</span></span>|<span data-ttu-id="de49f-3267">Выходит из защищенной области кода.</span><span class="sxs-lookup"><span data-stu-id="de49f-3267">Exits a protected region of code.</span></span>|  
  
 <span data-ttu-id="de49f-3268">Для этой инструкции не задано поведение перехода стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-3268">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="de49f-3269">Инструкция `leave` выполняет безусловную передачу управления в определенную целевую инструкцию, представленную в виде смещения со знаком длиной 4 байта от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-3269">The `leave` instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-3270">Инструкция `leave` аналогична инструкции `br`, но ее можно использовать для выхода из блока `try`, `filter` или `catch`, в то время как обычные инструкции ветвления можно использовать только в таком блоке для передачи управления внутри него.</span><span class="sxs-lookup"><span data-stu-id="de49f-3270">The `leave` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="de49f-3271">Инструкция `leave` очищает стек вычислений и обеспечивает выполнение соответствующих блоков `finally`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3271">The `leave` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="de49f-3272">Нельзя использовать инструкцию `leave` для выхода из блока `finally`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3272">You cannot use a `leave` instruction to exit a `finally` block.</span></span> <span data-ttu-id="de49f-3273">Чтобы упростить создание кода для обработчиков исключений, оно допустимо в блоке catch, чтобы использовать инструкцию `leave` для перемещения управления в любую инструкцию в связанном блоке `try`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3273">To ease code generation for exception handlers it is valid from within a catch block to use a `leave` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="de49f-3274">Если инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-3274">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="de49f-3275">Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `leave`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3275">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `leave` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3276">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-3276">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3277">Выполняет выход из защищенной области кода с безусловной передачей управления указанной конечной инструкции (короткая форма).</span><span class="sxs-lookup"><span data-stu-id="de49f-3277">Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3278">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3278">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3279">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3279">Format</span></span>|<span data-ttu-id="de49f-3280">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3280">Assembly Format</span></span>|<span data-ttu-id="de49f-3281">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3281">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3282">DE < `int8` ></span><span class="sxs-lookup"><span data-stu-id="de49f-3282">DE < `int8` ></span></span>|<span data-ttu-id="de49f-3283">Оставьте. s `target`</span><span class="sxs-lookup"><span data-stu-id="de49f-3283">leave.s `target`</span></span>|<span data-ttu-id="de49f-3284">Выйдите из защищенной области кода, короткой формы.</span><span class="sxs-lookup"><span data-stu-id="de49f-3284">Exit a protected region of code, short form.</span></span>|  
  
 <span data-ttu-id="de49f-3285">Для этой инструкции не задано поведение перехода стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-3285">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="de49f-3286">Инструкция `leave.s` выполняет безусловную передачу управления в переданную целевую инструкцию, представленную как смещение со знаком длиной 1 байт от начала инструкции, следующей за текущей инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-3286">The `leave.s` instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="de49f-3287">Инструкция `leave.s` аналогична инструкции `br`, но ее можно использовать для выхода из блока `try`, `filter` или `catch`, в то время как обычные инструкции ветвления можно использовать только в таком блоке для передачи управления внутри него.</span><span class="sxs-lookup"><span data-stu-id="de49f-3287">The `leave.s` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="de49f-3288">Инструкция `leave.s` очищает стек вычислений и обеспечивает выполнение соответствующих блоков `finally`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3288">The `leave.s` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="de49f-3289">Нельзя использовать инструкцию `leave.s` для выхода из блока `finally`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3289">You cannot use a `leave.s` instruction to exit a `finally` block.</span></span> <span data-ttu-id="de49f-3290">Чтобы упростить создание кода для обработчиков исключений, оно допустимо в блоке catch, чтобы использовать инструкцию `leave.s` для перемещения управления в любую инструкцию в связанном блоке `try`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3290">To ease code generation for exception handlers it is valid from within a catch block to use a `leave.s` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="de49f-3291">Если инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-3291">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="de49f-3292">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `leave.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3292">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `leave.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3293">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-3293">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3294">Выделяет определенное количество байтов из пула локальной динамической памяти и помещает в стек вычислений адрес (временный указатель с типом <see langword="*" />) первого выделенного байта.</span><span class="sxs-lookup"><span data-stu-id="de49f-3294">Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <see langword="*" />) of the first allocated byte onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3295">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3295">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3296">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3296">Format</span></span>|<span data-ttu-id="de49f-3297">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3297">Assembly Format</span></span>|<span data-ttu-id="de49f-3298">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3298">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3299">FE 0F</span><span class="sxs-lookup"><span data-stu-id="de49f-3299">FE 0F</span></span>|<span data-ttu-id="de49f-3300">localloc</span><span class="sxs-lookup"><span data-stu-id="de49f-3300">localloc</span></span>|<span data-ttu-id="de49f-3301">Выделение пространства из локальной кучи.</span><span class="sxs-lookup"><span data-stu-id="de49f-3301">Allocate space from the local heap.</span></span>|  
  
 <span data-ttu-id="de49f-3302">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3302">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3303">Число байтов, которое необходимо выделить, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3303">The number of bytes to be allocated is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3304">Число байтов извлекается из стека; объем памяти, соответствующий размеру, выделяется из локальной кучи.</span><span class="sxs-lookup"><span data-stu-id="de49f-3304">The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</span></span>  
  
3.  <span data-ttu-id="de49f-3305">Указатель на первый байт выделенной памяти помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3305">A pointer to the first byte of the allocated memory is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3306">Инструкция `localloc` выделяет `size` (тип `natural unsigned int`) байт из локального пула динамической памяти и возвращает адрес (временный указатель, тип `*`) первого выделенного байта.</span><span class="sxs-lookup"><span data-stu-id="de49f-3306">The `localloc` instruction allocates `size` (type `natural unsigned int`) bytes from the local dynamic memory pool and returns the address (a transient pointer, type `*`) of the first allocated byte.</span></span> <span data-ttu-id="de49f-3307">Возвращаемый блок памяти инициализируется значением 0 только в том случае, если флаг инициализации метода имеет значение `true`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3307">The block of memory returned is initialized to 0 only if the initialize flag on the method is `true`.</span></span> <span data-ttu-id="de49f-3308">Когда текущий метод выполняет <xref:System.Reflection.Emit.OpCodes.Ret>, пул локальной памяти становится доступным для повторного использования.</span><span class="sxs-lookup"><span data-stu-id="de49f-3308">When the current method executes a <xref:System.Reflection.Emit.OpCodes.Ret>, the local memory pool is made available for reuse.</span></span>  
  
 <span data-ttu-id="de49f-3309">Полученный адрес будет согласован таким образом, чтобы любой тип примитива мог храниться в нем с помощью инструкций `stind` (например, <xref:System.Reflection.Emit.OpCodes.Stind_I4>) и загружался с помощью инструкций `ldind` (например, <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).</span><span class="sxs-lookup"><span data-stu-id="de49f-3309">The resulting address is aligned so that any primitive data type can be stored there using the `stind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Stind_I4>) and loaded using the `ldind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).</span></span>  
  
 <span data-ttu-id="de49f-3310">Инструкция `localloc` не может находиться в блоке `filter`, `catch`, `finally` или `fault`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3310">The `localloc` instruction cannot occur within a `filter`, `catch`, `finally`, or `fault` block.</span></span>  
  
 <span data-ttu-id="de49f-3311"><xref:System.StackOverflowException> возникает, если недостаточно памяти для обслуживания запроса.</span><span class="sxs-lookup"><span data-stu-id="de49f-3311"><xref:System.StackOverflowException> is thrown if there is insufficient memory to service the request.</span></span>  
  
 <span data-ttu-id="de49f-3312">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `localloc`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3312">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `localloc` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3313">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3313">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3314">Помещает в стек вычислений ссылку на экземпляр определенного типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-3314">Pushes a typed reference to an instance of a specific type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3315">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3315">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3316">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3316">Format</span></span>|<span data-ttu-id="de49f-3317">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3317">Assembly Format</span></span>|<span data-ttu-id="de49f-3318">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3318">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3319">< C6 `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-3319">C6 < `T` ></span></span>|<span data-ttu-id="de49f-3320">Mkrefany `class`</span><span class="sxs-lookup"><span data-stu-id="de49f-3320">mkrefany `class`</span></span>|<span data-ttu-id="de49f-3321">Помещает в стек типизированную ссылку типа `class`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3321">Pushes a typed reference of type `class` onto the stack.</span></span>|  
  
 <span data-ttu-id="de49f-3322">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3322">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3323">Указатель на фрагмент данных помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3323">A pointer to piece of data is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3324">Указатель извлекается и преобразуется в типизированную ссылку типа `class`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3324">The pointer is popped and converted to a typed reference of type `class`.</span></span>  
  
3.  <span data-ttu-id="de49f-3325">Типизированная ссылка помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3325">The typed reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3326">Инструкция `mkrefany` поддерживает передачу ссылок с динамическим типом.</span><span class="sxs-lookup"><span data-stu-id="de49f-3326">The `mkrefany` instruction supports the passing of dynamically typed references.</span></span> <span data-ttu-id="de49f-3327">Указатель должен иметь тип `&`, `*` или `native int`, а также содержать допустимый адрес фрагмента данных.</span><span class="sxs-lookup"><span data-stu-id="de49f-3327">The pointer must be of type `&`, `*`, or `native int`, and hold the valid address of a piece of data.</span></span> <span data-ttu-id="de49f-3328">`Class` — это маркер класса, описывающий тип данных, на которые ссылается указатель.</span><span class="sxs-lookup"><span data-stu-id="de49f-3328">`Class` is the class token describing the type of the data referenced by the pointer.</span></span> <span data-ttu-id="de49f-3329">`Mkrefany` отправляет типизированную ссылку на стек, предоставляя непрозрачный дескриптор указателя и тип `class`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3329">`Mkrefany` pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type `class`.</span></span>  
  
 <span data-ttu-id="de49f-3330">Единственной допустимой операцией, разрешенной для типизированной ссылки, является передача ее в метод, которому в качестве параметра требуется типизированная ссылка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3330">The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter.</span></span> <span data-ttu-id="de49f-3331">Затем вызываемый объект может использовать инструкции <xref:System.Reflection.Emit.OpCodes.Refanytype> и <xref:System.Reflection.Emit.OpCodes.Refanyval> для получения типа (класса) и адреса соответственно.</span><span class="sxs-lookup"><span data-stu-id="de49f-3331">The callee can then use the <xref:System.Reflection.Emit.OpCodes.Refanytype> and <xref:System.Reflection.Emit.OpCodes.Refanyval> instructions to retrieve the type (class) and the address respectively.</span></span>  
  
 <span data-ttu-id="de49f-3332"><xref:System.TypeLoadException> возникает, если не удается найти `class`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3332"><xref:System.TypeLoadException> is thrown if `class` cannot be found.</span></span> <span data-ttu-id="de49f-3333">Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3333">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="de49f-3334">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `mkrefany`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3334">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mkrefany` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3335">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-3335">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3336">Умножает два значения и помещает результат в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3336">Multiplies two values and pushes the result on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3337">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3337">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3338">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3338">Format</span></span>|<span data-ttu-id="de49f-3339">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3339">Assembly Format</span></span>|<span data-ttu-id="de49f-3340">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3340">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3341">5а</span><span class="sxs-lookup"><span data-stu-id="de49f-3341">5A</span></span>|<span data-ttu-id="de49f-3342">mul</span><span class="sxs-lookup"><span data-stu-id="de49f-3342">mul</span></span>|<span data-ttu-id="de49f-3343">Умножает два значения в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-3343">Multiplies two values on the stack.</span></span>|  
  
 <span data-ttu-id="de49f-3344">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3344">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3345">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3345">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3346">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3346">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3347">`value2` и `value1` извлекаются из стека; `value1` умножается на `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3347">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`.</span></span>  
  
4.  <span data-ttu-id="de49f-3348">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3348">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3349">Инструкция `mul` умножает `value1` на `value2` и помещает результат в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3349">The `mul` instruction multiplies `value1` by `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="de49f-3350">Целочисленные операции автоматически усекаются верхние биты в переполнении.</span><span class="sxs-lookup"><span data-stu-id="de49f-3350">Integer operations silently truncate the upper bits on overflow.</span></span>  
  
 <span data-ttu-id="de49f-3351">Для выполнения операции умножения целого числа на обработку переполнения см. <xref:System.Reflection.Emit.OpCodes.Mul_Ovf>.</span><span class="sxs-lookup"><span data-stu-id="de49f-3351">See <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> for an integer-specific multiply operation with overflow handling.</span></span>  
  
 <span data-ttu-id="de49f-3352">Для типов с плавающей запятой 0 \* Infinity = NaN.</span><span class="sxs-lookup"><span data-stu-id="de49f-3352">For floating-point types, 0 \* infinity = NaN.</span></span>  
  
 <span data-ttu-id="de49f-3353">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `mul`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3353">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3354">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3354">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3355">Умножает два целочисленных значения, выполняет проверку переполнения и помещает результат в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3355">Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3356">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3356">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3357">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3357">Format</span></span>|<span data-ttu-id="de49f-3358">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3358">Assembly Format</span></span>|<span data-ttu-id="de49f-3359">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3359">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3360">D8</span><span class="sxs-lookup"><span data-stu-id="de49f-3360">D8</span></span>|<span data-ttu-id="de49f-3361">mul. ovf</span><span class="sxs-lookup"><span data-stu-id="de49f-3361">mul.ovf</span></span>|<span data-ttu-id="de49f-3362">Умножает два целочисленных значения в стеке с помощью проверки переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3362">Multiplies two integer values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="de49f-3363">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3363">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3364">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3364">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3365">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3365">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3366">`value2` и `value1` извлекаются из стека; `value1` умножается на `value2` с помощью проверки переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3366">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="de49f-3367">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3367">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3368">Инструкция `mul.ovf` умножает целое число `value1` на целое число `value2` и помещает результат в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3368">The `mul.ovf` instruction multiplies integer `value1` by integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="de49f-3369">Если результат не умещается в типе результата, выдается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-3369">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="de49f-3370"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-3370"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-3371">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `mul.ovf`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3371">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3372">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3372">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3373">Умножает два целочисленных значения без знака, выполняет проверку переполнения и помещает результат в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3373">Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3374">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3374">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3375">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3375">Format</span></span>|<span data-ttu-id="de49f-3376">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3376">Assembly Format</span></span>|<span data-ttu-id="de49f-3377">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3377">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3378">D9</span><span class="sxs-lookup"><span data-stu-id="de49f-3378">D9</span></span>|<span data-ttu-id="de49f-3379">mul. ovf. un</span><span class="sxs-lookup"><span data-stu-id="de49f-3379">mul.ovf.un</span></span>|<span data-ttu-id="de49f-3380">Умножает два значения без знака в стеке с помощью проверки переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3380">Multiplies two unsigned values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="de49f-3381">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3381">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3382">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3382">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3383">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3383">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3384">`value2` и `value1` извлекаются из стека; `value1` умножается на `value2` с помощью проверки переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3384">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="de49f-3385">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3385">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3386">Инструкция `mul.ovf.un` умножает целое число без знака `value1` на целое число без знака `value2` и передает результат в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3386">The `mul.ovf.un` instruction multiplies unsigned integer `value1` by unsigned integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="de49f-3387">Если результат не умещается в типе результата, выдается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-3387">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="de49f-3388"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-3388"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-3389">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `mul.ovf.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3389">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3390">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3390">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3391">Отвергает значение и помещает результат в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3391">Negates a value and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3392">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3392">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3393">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3393">Format</span></span>|<span data-ttu-id="de49f-3394">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3394">Assembly Format</span></span>|<span data-ttu-id="de49f-3395">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3395">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3396">65</span><span class="sxs-lookup"><span data-stu-id="de49f-3396">65</span></span>|<span data-ttu-id="de49f-3397">расход</span><span class="sxs-lookup"><span data-stu-id="de49f-3397">neg</span></span>|<span data-ttu-id="de49f-3398">Инвертирует значение, находящегося на вершине стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-3398">Negates the value currently on top of the stack.</span></span>|  
  
 <span data-ttu-id="de49f-3399">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3399">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3400">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3400">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3401">Значение извлекается из стека и инвертируется.</span><span class="sxs-lookup"><span data-stu-id="de49f-3401">A value is popped from the stack and negated.</span></span>  
  
3.  <span data-ttu-id="de49f-3402">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3402">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3403">Инструкция `neg` инвертирует значение и помещает результат поверх стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-3403">The `neg` instruction negates value and pushes the result on top of the stack.</span></span> <span data-ttu-id="de49f-3404">Тип возвращаемого значения совпадает с типом операнда.</span><span class="sxs-lookup"><span data-stu-id="de49f-3404">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="de49f-3405">Отрицание целочисленных значений — это нестандартное отрицание числа единиц.</span><span class="sxs-lookup"><span data-stu-id="de49f-3405">Negation of integral values is standard two's complement negation.</span></span> <span data-ttu-id="de49f-3406">В частности, при инвертировании самого отрицательного числа (которое не имеет положительного аналога) выдается наибольшее отрицательное число.</span><span class="sxs-lookup"><span data-stu-id="de49f-3406">In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number.</span></span> <span data-ttu-id="de49f-3407">Чтобы обнаружить это переполнение, используйте инструкцию <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> (то есть вычтите из 0).</span><span class="sxs-lookup"><span data-stu-id="de49f-3407">To detect this overflow use the <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction instead (that is, subtract from 0).</span></span>  
  
 <span data-ttu-id="de49f-3408">Отрицание числа с плавающей запятой не может быть переполнено и отрицание NaN возвращает NaN.</span><span class="sxs-lookup"><span data-stu-id="de49f-3408">Negating a floating-point number cannot overflow, and negating NaN returns NaN.</span></span>  
  
 <span data-ttu-id="de49f-3409">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `neg`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3409">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `neg` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3410">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3410">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3411">Помещает в стек вычислений ссылку на объект — новый одномерный массив с индексацией от нуля, состоящий из элементов заданного типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-3411">Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3412">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3412">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3413">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3413">Format</span></span>|<span data-ttu-id="de49f-3414">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3414">Assembly Format</span></span>|<span data-ttu-id="de49f-3415">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3415">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3416">8D < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-3416">8D < `T` ></span></span>|<span data-ttu-id="de49f-3417">неварр `etype`</span><span class="sxs-lookup"><span data-stu-id="de49f-3417">newarr `etype`</span></span>|<span data-ttu-id="de49f-3418">Создает новый массив с элементами типа `etype`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3418">Creates a new array with elements of type `etype`.</span></span>|  
  
 <span data-ttu-id="de49f-3419">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3419">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3420">Число элементов в массиве помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3420">The number of elements in the array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3421">Число элементов извлекается из стека и создается массив.</span><span class="sxs-lookup"><span data-stu-id="de49f-3421">The number of elements is popped from the stack and the array is created.</span></span>  
  
3.  <span data-ttu-id="de49f-3422">Ссылка на новый массив помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3422">An object reference to the new array is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3423">Инструкция `newarr` помещает ссылку на объект (тип `O`) в новый одномерный массив, начинающийся с нуля, элементы которого имеют тип `etype` (маркер метаданных, описывающий тип).</span><span class="sxs-lookup"><span data-stu-id="de49f-3423">The `newarr` instruction pushes an object reference (type `O`) to a new zero-based, one-dimensional array whose elements are of type `etype` (a metadata token describing the type).</span></span> <span data-ttu-id="de49f-3424">Число элементов в новом массиве должно быть задано как `native int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3424">The number of elements in the new array should be specified as a `native int`.</span></span> <span data-ttu-id="de49f-3425">Допустимые индексы массива находятся в диапазоне от нуля до максимального числа элементов минус один.</span><span class="sxs-lookup"><span data-stu-id="de49f-3425">Valid array indexes range from zero to the maximum number of elements minus one.</span></span>  
  
 <span data-ttu-id="de49f-3426">Элементы массива могут быть любого типа, включая типы значений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3426">The elements of an array can be any type, including value types.</span></span>  
  
 <span data-ttu-id="de49f-3427">Одномерные массивы чисел с индексацией от нуля создаются с помощью маркера метаданных, ссылающегося на соответствующий тип значения (<xref:System.Int32> и т. д.).</span><span class="sxs-lookup"><span data-stu-id="de49f-3427">Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<xref:System.Int32>, and so on).</span></span> <span data-ttu-id="de49f-3428">Элементы массива инициализируются значением 0 соответствующего типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-3428">Elements of the array are initialized to 0 of the appropriate type.</span></span>  
  
 <span data-ttu-id="de49f-3429">Одномерные массивы с ненулевыми значениями и многомерные массивы создаются с помощью <xref:System.Reflection.Emit.OpCodes.Newobj>, а не `newarr`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3429">Nonzero-based one-dimensional arrays and multidimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newobj> rather than `newarr`.</span></span> <span data-ttu-id="de49f-3430">Чаще всего они создаются с помощью методов класса <xref:System.Array> в .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="de49f-3430">More commonly, they are created using the methods of the <xref:System.Array> class in the .NET Framework.</span></span>  
  
 <span data-ttu-id="de49f-3431"><xref:System.OutOfMemoryException> возникает, если недостаточно памяти для удовлетворения запроса.</span><span class="sxs-lookup"><span data-stu-id="de49f-3431"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="de49f-3432"><xref:System.OverflowException> возникает, если `numElems` меньше 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-3432"><xref:System.OverflowException> is thrown if `numElems` is less than 0.</span></span>  
  
 <span data-ttu-id="de49f-3433">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `newarr`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3433">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newarr` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3434">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-3434">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3435">Создает новый объект или новый экземпляр типа значения и помещает ссылку на объект (тип <see langword="O" />) в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3435">Creates a new object or a new instance of a value type, pushing an object reference (type <see langword="O" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3436">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3436">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3437">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3437">Format</span></span>|<span data-ttu-id="de49f-3438">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3438">Assembly Format</span></span>|<span data-ttu-id="de49f-3439">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3439">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3440">73 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-3440">73 < `T` ></span></span>|<span data-ttu-id="de49f-3441">newobj `ctor`</span><span class="sxs-lookup"><span data-stu-id="de49f-3441">newobj `ctor`</span></span>|<span data-ttu-id="de49f-3442">Выделяет неинициализированный объект или тип значения и вызывает метод конструктора `ctor`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3442">Allocates an uninitialized object or value type and calls the constructor method `ctor`.</span></span>|  
  
 <span data-ttu-id="de49f-3443">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3443">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3444">Аргументы, `arg1` с помощью `argn`, последовательно помещаются в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3444">Arguments `arg1` through `argn` are pushed on the stack in sequence.</span></span>  
  
2.  <span data-ttu-id="de49f-3445">Аргументы, `argn`ные через `arg1`, извлекаются из стека и передаются `ctor` для создания объекта.</span><span class="sxs-lookup"><span data-stu-id="de49f-3445">Arguments `argn` through `arg1` are popped from the stack and passed to `ctor` for object creation.</span></span>  
  
3.  <span data-ttu-id="de49f-3446">Ссылка на новый объект помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3446">A reference to the new object is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3447">Инструкция `newobj` создает новый объект или новый экземпляр типа значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3447">The `newobj` instruction creates a new object or a new instance of a value type.</span></span> <span data-ttu-id="de49f-3448">`Ctor` является маркером метаданных (`methodref` или `methoddef`, который должен быть помечен как конструктор), который указывает имя, класс и сигнатуру вызываемого конструктора.</span><span class="sxs-lookup"><span data-stu-id="de49f-3448">`Ctor` is a metadata token (a `methodref` or `methoddef` that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</span></span>  
  
 <span data-ttu-id="de49f-3449">Инструкция `newobj` выделяет новый экземпляр класса, связанный с `ctor`, и инициализирует все поля в новом экземпляре значением 0 (соответствующего типа) или пустыми ссылками, если это уместно.</span><span class="sxs-lookup"><span data-stu-id="de49f-3449">The `newobj` instruction allocates a new instance of the class associated with `ctor` and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate.</span></span> <span data-ttu-id="de49f-3450">Затем он вызывает конструктор `ctor` с заданными аргументами вместе с созданным экземпляром.</span><span class="sxs-lookup"><span data-stu-id="de49f-3450">It then calls the constructor `ctor` with the given arguments along with the newly created instance.</span></span> <span data-ttu-id="de49f-3451">После вызова конструктора в стек помещается ссылка на инициализированный объект (тип `O`).</span><span class="sxs-lookup"><span data-stu-id="de49f-3451">After the constructor has been called, the now initialized object reference (type `O`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="de49f-3452">С точки зрения конструктора неинициализированный объект является аргументом 0, а остальные аргументы, передаваемые в newobj, следуют по порядку.</span><span class="sxs-lookup"><span data-stu-id="de49f-3452">From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</span></span>  
  
 <span data-ttu-id="de49f-3453">Все одномерные массивы, начинающиеся с нуля, создаются с помощью <xref:System.Reflection.Emit.OpCodes.Newarr>, а не `newobj`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3453">All zero-based, one-dimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newarr>, not `newobj`.</span></span> <span data-ttu-id="de49f-3454">С другой стороны, все остальные массивы (более одного измерения или одномерные, но не основанные на нуле) создаются с помощью `newobj`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3454">On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using `newobj`.</span></span>  
  
 <span data-ttu-id="de49f-3455">Типы значений обычно не создаются с помощью `newobj`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3455">Value types are not usually created using `newobj`.</span></span> <span data-ttu-id="de49f-3456">Обычно они выделяются как аргументы или локальные переменные с помощью `newarr` (для одномерных массивов с индексацией от нуля) или как поля объектов.</span><span class="sxs-lookup"><span data-stu-id="de49f-3456">They are usually allocated either as arguments or local variables, using `newarr` (for zero-based, one-dimensional arrays), or as fields of objects.</span></span> <span data-ttu-id="de49f-3457">После выделения они инициализируются с помощью <xref:System.Reflection.Emit.OpCodes.Initobj>.</span><span class="sxs-lookup"><span data-stu-id="de49f-3457">Once allocated, they are initialized using <xref:System.Reflection.Emit.OpCodes.Initobj>.</span></span> <span data-ttu-id="de49f-3458">Однако инструкцию `newobj` можно использовать для создания нового экземпляра типа значения в стеке, который затем может передаваться в качестве аргумента, храниться в локальной системе и т. д.</span><span class="sxs-lookup"><span data-stu-id="de49f-3458">However, the `newobj` instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</span></span>  
  
 <span data-ttu-id="de49f-3459"><xref:System.OutOfMemoryException> возникает, если недостаточно памяти для удовлетворения запроса.</span><span class="sxs-lookup"><span data-stu-id="de49f-3459"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="de49f-3460"><xref:System.MissingMethodException> возникает, если не удалось найти метод конструктора `ctor` с указанным именем, классом и сигнатурой.</span><span class="sxs-lookup"><span data-stu-id="de49f-3460"><xref:System.MissingMethodException> is thrown if a constructor method `ctor` with the indicated name, class and signature could not be found.</span></span> <span data-ttu-id="de49f-3461">Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3461">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="de49f-3462">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `newobj`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3462">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newobj` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3463">ILGenerator. Emit (код операции, ConstructorInfo)</span><span class="sxs-lookup"><span data-stu-id="de49f-3463">ILGenerator.Emit(OpCode, ConstructorInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3464">Заполняет пространство, если коды операции содержат исправления.</span><span class="sxs-lookup"><span data-stu-id="de49f-3464">Fills space if opcodes are patched.</span></span> <span data-ttu-id="de49f-3465">Никаких значимых операций не выполняется, хотя может быть пройден цикл обработки.</span><span class="sxs-lookup"><span data-stu-id="de49f-3465">No meaningful operation is performed although a processing cycle can be consumed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3466">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3466">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3467">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3467">Format</span></span>|<span data-ttu-id="de49f-3468">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3468">Assembly Format</span></span>|<span data-ttu-id="de49f-3469">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3469">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3470">00</span><span class="sxs-lookup"><span data-stu-id="de49f-3470">00</span></span>|<span data-ttu-id="de49f-3471">NOP</span><span class="sxs-lookup"><span data-stu-id="de49f-3471">nop</span></span>|<span data-ttu-id="de49f-3472">Выполняет операцию без поведения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3472">Performs an operation without behavior.</span></span>|  
  
 <span data-ttu-id="de49f-3473">Для этой инструкции не определено поведение перехода стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-3473">There is no stack transitional behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="de49f-3474">Операция `nop` не выполняет никаких действий.</span><span class="sxs-lookup"><span data-stu-id="de49f-3474">The `nop` operation does nothing.</span></span> <span data-ttu-id="de49f-3475">Он предназначен для заполнения пространства, если исправлены коды операций.</span><span class="sxs-lookup"><span data-stu-id="de49f-3475">It is intended to fill in space if opcodes are patched.</span></span>  
  
 <span data-ttu-id="de49f-3476">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `nop`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3476">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `nop` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3477">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3477">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3478">Вычисляет побитовое дополнение целочисленного значения, находящегося на вершине стека, и помещает результат в стек с тем же типом.</span><span class="sxs-lookup"><span data-stu-id="de49f-3478">Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3479">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3479">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3480">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3480">Format</span></span>|<span data-ttu-id="de49f-3481">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3481">Assembly Format</span></span>|<span data-ttu-id="de49f-3482">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3482">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3483">66</span><span class="sxs-lookup"><span data-stu-id="de49f-3483">66</span></span>|<span data-ttu-id="de49f-3484">not</span><span class="sxs-lookup"><span data-stu-id="de49f-3484">not</span></span>|<span data-ttu-id="de49f-3485">Вычисление побитового дополнения значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3485">Computes the bitwise complement of a value.</span></span>|  
  
 <span data-ttu-id="de49f-3486">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3486">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3487">`value` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3487">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3488">`value` извлекается из стека и вычисленное побитовое дополнение.</span><span class="sxs-lookup"><span data-stu-id="de49f-3488">`value` is popped from the stack and its bitwise complement computed.</span></span>  
  
3.  <span data-ttu-id="de49f-3489">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3489">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3490">Инструкция `not` делит побитовое дополнение целочисленного значения и помещает результат в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3490">The `not` instruction computes the bitwise complement of an integer value and pushes the result onto the stack.</span></span> <span data-ttu-id="de49f-3491">Тип возвращаемого значения совпадает с типом операнда.</span><span class="sxs-lookup"><span data-stu-id="de49f-3491">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="de49f-3492">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `not`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3492">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `not` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3493">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3493">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3494">Вычисляет побитовое дополнение двух целочисленных значений, находящихся на вершине стека, и помещает результат в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3494">Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3495">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3495">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3496">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3496">Format</span></span>|<span data-ttu-id="de49f-3497">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3497">Assembly Format</span></span>|<span data-ttu-id="de49f-3498">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3498">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3499">60</span><span class="sxs-lookup"><span data-stu-id="de49f-3499">60</span></span>|<span data-ttu-id="de49f-3500">или</span><span class="sxs-lookup"><span data-stu-id="de49f-3500">or</span></span>|<span data-ttu-id="de49f-3501">Выполняет побитовое или для двух целочисленных значений, возвращает целое число.</span><span class="sxs-lookup"><span data-stu-id="de49f-3501">Computes the bitwise OR of two integer values, returns an integer.</span></span>|  
  
 <span data-ttu-id="de49f-3502">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3502">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3503">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3503">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3504">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3504">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3505">`value2` и `value1` извлекаются из стека и их побитовые или вычисленные.</span><span class="sxs-lookup"><span data-stu-id="de49f-3505">`value2` and `value1` are popped from the stack and their bitwise OR computed.</span></span>  
  
4.  <span data-ttu-id="de49f-3506">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3506">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3507">Инструкция `or` рассчитывает побитовое или двух значений в стеке, помещая результат в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3507">The `or` instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3508">`Or` является операцией, относящейся к целому числу.</span><span class="sxs-lookup"><span data-stu-id="de49f-3508">`Or` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="de49f-3509">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `or`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3509">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `or` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3510">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3510">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3511">Удаляет значение, находящееся на вершине стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-3511">Removes the value currently on top of the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3512">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3512">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3513">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3513">Format</span></span>|<span data-ttu-id="de49f-3514">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3514">Assembly Format</span></span>|<span data-ttu-id="de49f-3515">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3515">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3516">26</span><span class="sxs-lookup"><span data-stu-id="de49f-3516">26</span></span>|<span data-ttu-id="de49f-3517">pop</span><span class="sxs-lookup"><span data-stu-id="de49f-3517">pop</span></span>|<span data-ttu-id="de49f-3518">Извлекает верхнее значение из стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-3518">Pops the top value from the stack.</span></span>|  
  
 <span data-ttu-id="de49f-3519">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3519">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3520">Верхнее значение извлекается из стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-3520">The top value is popped from the stack.</span></span>  
  
 <span data-ttu-id="de49f-3521">Инструкция `pop` удаляет верхний элемент из стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-3521">The `pop` instruction removes the top element from the stack.</span></span>  
  
 <span data-ttu-id="de49f-3522">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `pop`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3522">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `pop` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3523">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3523">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3524">Эта инструкция зарезервирована.</span><span class="sxs-lookup"><span data-stu-id="de49f-3524">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3525">Эта инструкция зарезервирована.</span><span class="sxs-lookup"><span data-stu-id="de49f-3525">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3526">Эта инструкция зарезервирована.</span><span class="sxs-lookup"><span data-stu-id="de49f-3526">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3527">Эта инструкция зарезервирована.</span><span class="sxs-lookup"><span data-stu-id="de49f-3527">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3528">Эта инструкция зарезервирована.</span><span class="sxs-lookup"><span data-stu-id="de49f-3528">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3529">Эта инструкция зарезервирована.</span><span class="sxs-lookup"><span data-stu-id="de49f-3529">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3530">Эта инструкция зарезервирована.</span><span class="sxs-lookup"><span data-stu-id="de49f-3530">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3531">Эта инструкция зарезервирована.</span><span class="sxs-lookup"><span data-stu-id="de49f-3531">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3532">Указывает, что последующая операция, связанная с адресом массива, не выполняет никаких проверок во время выполнения и возвращает управляемый указатель, изменение которого запрещено.</span><span class="sxs-lookup"><span data-stu-id="de49f-3532">Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3533">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3533">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3534">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3534">Format</span></span>|<span data-ttu-id="de49f-3535">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3535">Assembly Format</span></span>|<span data-ttu-id="de49f-3536">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3536">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3537">FE 1E</span><span class="sxs-lookup"><span data-stu-id="de49f-3537">FE 1E</span></span>|<span data-ttu-id="de49f-3538">доступно.</span><span class="sxs-lookup"><span data-stu-id="de49f-3538">readonly.</span></span>|<span data-ttu-id="de49f-3539">Укажите, что последующие операции с адресом массива не выполняют проверку типа во время выполнения и возвращают управляемый указатель с ограниченными возможностями.</span><span class="sxs-lookup"><span data-stu-id="de49f-3539">Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.</span></span>|  
  
 <span data-ttu-id="de49f-3540">Этот префикс может использоваться только непосредственно перед инструкцией `ldelema` и вызовами специального метода `Address` для массивов.</span><span class="sxs-lookup"><span data-stu-id="de49f-3540">This prefix can only appear immediately preceding the `ldelema` instruction and calls to the special `Address` method on arrays.</span></span> <span data-ttu-id="de49f-3541">Его воздействие на последующую операцию — двойная:</span><span class="sxs-lookup"><span data-stu-id="de49f-3541">Its effect on the subsequent operation is twofold:</span></span>  
  
1.  <span data-ttu-id="de49f-3542">Во время выполнения операция проверки типа не выполняется.</span><span class="sxs-lookup"><span data-stu-id="de49f-3542">At run time, no type check operation is performed.</span></span> <span data-ttu-id="de49f-3543">Обратите внимание, что обычно неявная проверка типа для инструкций `ldelema` и `stelem` при использовании массивов ссылочного типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-3543">Note that there is normally an implicit type check for the `ldelema` and `stelem` instructions when used on reference type arrays.</span></span> <span data-ttu-id="de49f-3544">Для классов значений никогда не выполняется проверка типа во время выполнения, поэтому `readonly` является отсутствием операции в этом случае.</span><span class="sxs-lookup"><span data-stu-id="de49f-3544">There is never a run-time type check for value classes, so `readonly` is a no-op in that case.</span></span>  
  
2.  <span data-ttu-id="de49f-3545">Средство проверки обрабатывает результат операции адреса в качестве управляемого указателя с ограниченными возможностями.</span><span class="sxs-lookup"><span data-stu-id="de49f-3545">The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.</span></span>  
  
 <span data-ttu-id="de49f-3546">Говорят, что указатель имеет ограниченную возможность, так как определяющий тип определяет, можно ли изменить значение.</span><span class="sxs-lookup"><span data-stu-id="de49f-3546">The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated.</span></span> <span data-ttu-id="de49f-3547">Для классов значений, которые не предоставляют открытых полей или методов, которые обновляют значение на месте, указатель доступен только для чтения (следовательно, имя префикса).</span><span class="sxs-lookup"><span data-stu-id="de49f-3547">For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix).</span></span> <span data-ttu-id="de49f-3548">В частности, классы, представляющие простые типы (например, System. Int32), не предоставляют мутатора и, таким образом, доступны только для чтения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3548">In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.</span></span>  
  
 <span data-ttu-id="de49f-3549">Управляемый указатель, ограниченный таким образом, может использоваться только следующими способами:</span><span class="sxs-lookup"><span data-stu-id="de49f-3549">A managed pointer restricted in this fashion can be used only in the following ways:</span></span>  
  
-   <span data-ttu-id="de49f-3550">В качестве параметра `object` для `ldfld`, `ldflda`, `stfld`, `call`или инструкций`constrained callvirt`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3550">As the `object` parameter for the `ldfld`, `ldflda`, `stfld`, `call`, or`constrained callvirt` instructions.</span></span>  
  
-   <span data-ttu-id="de49f-3551">В качестве параметра `pointer` для инструкции `ldobj` или для одной из инструкций `ldind`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3551">As the `pointer` parameter to the `ldobj` instruction or to one of the `ldind` instructions.</span></span>  
  
-   <span data-ttu-id="de49f-3552">В качестве параметра `source` для инструкции `cpobj`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3552">As the `source` parameter to the `cpobj` instruction.</span></span>  
  
 <span data-ttu-id="de49f-3553">Все другие операции запрещены, включая `stobj`, `initobj` или `mkrefany`, или любые инструкции `stind`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3553">All other operations disallowed, including the `stobj`, `initobj`, or `mkrefany` operations, or any of the `stind` instructions.</span></span>  
  
 <span data-ttu-id="de49f-3554">Назначение префикса `readonly` заключается в том, чтобы избежать проверки типа при извлечении элемента из массива в универсальном коде.</span><span class="sxs-lookup"><span data-stu-id="de49f-3554">The purpose of the `readonly` prefix is to avoid a type check when fetching an element from an array in generic code.</span></span> <span data-ttu-id="de49f-3555">Например, выражение `arr[i].m()`, где тип элемента массива `arr` является универсальным типом, который был ограничен интерфейсом с методом `m`, может компилироваться следующим кодом MSIL.</span><span class="sxs-lookup"><span data-stu-id="de49f-3555">For example, the expression `arr[i].m()`, where the element type of the array `arr` is a generic type that has been constrained to have an interface with method `m`, might compile to the following MSIL.</span></span>  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 <span data-ttu-id="de49f-3556">Без префикса `readonly` Инструкция `ldelema` будет выполнять проверку типа, если! 0 является ссылочным типом.</span><span class="sxs-lookup"><span data-stu-id="de49f-3556">Without the `readonly` prefix, the `ldelema` instruction would perform a type check in the case where !0 was a reference type.</span></span> <span data-ttu-id="de49f-3557">Этот тип не только неэффективен, но и семантически неверен.</span><span class="sxs-lookup"><span data-stu-id="de49f-3557">Not only is this type check inefficient, but it is semantically incorrect.</span></span> <span data-ttu-id="de49f-3558">Проверка типа `ldelema` является точным совпадением, что является слишком строгим.</span><span class="sxs-lookup"><span data-stu-id="de49f-3558">The type check for `ldelema` is an exact match, which is too strong.</span></span> <span data-ttu-id="de49f-3559">Если массив удерживал подклассы типа! 0, приведенный выше код не сможет проверить тип.</span><span class="sxs-lookup"><span data-stu-id="de49f-3559">If the array held subclasses of type !0, the code above would fail the type check.</span></span>  
  
 <span data-ttu-id="de49f-3560">Адрес элемента массива извлекается вместо самого элемента, чтобы иметь дескриптор для `arr[i]`, который работает как для типов значений, так и для ссылочных типов и поэтому может быть передан в инструкцию `constrained callvirt`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3560">The address of the array element is fetched, instead of the element itself, in order to have a handle for `arr[i]` that works for both value types and reference types, and thus can be passed to the `constrained callvirt` instruction.</span></span>  
  
 <span data-ttu-id="de49f-3561">Как правило, пропуск проверки во время выполнения может быть незащищенным, если массив удерживает элементы ссылочного типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-3561">In general it would be unsafe to skip the run-time check if the array held elements of a reference type.</span></span> <span data-ttu-id="de49f-3562">Чтобы быть в безопасности, необходимо убедиться, что с помощью этого указателя изменения в массиве не выполняются.</span><span class="sxs-lookup"><span data-stu-id="de49f-3562">To be safe, it is necessary to ensure that no modifications to the array are made through this pointer.</span></span> <span data-ttu-id="de49f-3563">Это гарантируется правилами проверки.</span><span class="sxs-lookup"><span data-stu-id="de49f-3563">The verifier rules ensure this.</span></span> <span data-ttu-id="de49f-3564">Ограниченный управляемый указатель может передаваться как объект для вызовов метода экземпляра, поэтому он не должен строго говорить только для чтения для типов значений, но для типов значений не существует проблем безопасности типов.</span><span class="sxs-lookup"><span data-stu-id="de49f-3564">The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</span></span>  
  
 <span data-ttu-id="de49f-3565">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `readonly`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3565">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `readonly` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3566">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3566">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3567">Извлекает токен типа, внедренный в ссылку с определенным типом.</span><span class="sxs-lookup"><span data-stu-id="de49f-3567">Retrieves the type token embedded in a typed reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3568">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3568">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3569">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3569">Format</span></span>|<span data-ttu-id="de49f-3570">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3570">Assembly Format</span></span>|<span data-ttu-id="de49f-3571">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3571">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3572">FE 1D</span><span class="sxs-lookup"><span data-stu-id="de49f-3572">FE 1D</span></span>|<span data-ttu-id="de49f-3573">рефанитипе</span><span class="sxs-lookup"><span data-stu-id="de49f-3573">refanytype</span></span>|<span data-ttu-id="de49f-3574">Помещает токен типа, хранящийся в типизированной ссылке.</span><span class="sxs-lookup"><span data-stu-id="de49f-3574">Pushes the type token stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="de49f-3575">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3575">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3576">Ссылка на тип значения помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3576">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3577">Типизированная ссылка извлекается из стека и полученного маркера соответствующего типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-3577">The typed reference is popped from the stack and its corresponding type token retrieved.</span></span>  
  
3.  <span data-ttu-id="de49f-3578">Токен типа помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3578">The type token is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3579">Типизированная ссылка содержит токен типа и адрес экземпляра объекта.</span><span class="sxs-lookup"><span data-stu-id="de49f-3579">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="de49f-3580">Инструкция `refanytype` извлекает лексему типа, внедренную в типизированную ссылку.</span><span class="sxs-lookup"><span data-stu-id="de49f-3580">The `refanytype` instruction retrieves the type token embedded in the typed reference.</span></span> <span data-ttu-id="de49f-3581">Сведения о создании типизированных ссылок см. в инструкции <xref:System.Reflection.Emit.OpCodes.Mkrefany>.</span><span class="sxs-lookup"><span data-stu-id="de49f-3581">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for information on creating typed references.</span></span>  
  
 <span data-ttu-id="de49f-3582">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `refanytype`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3582">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanytype` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3583">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3583">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3584">Извлекает адрес (тип <see langword="&amp;" />), внедренный в ссылку с определенным типом.</span><span class="sxs-lookup"><span data-stu-id="de49f-3584">Retrieves the address (type <see langword="&amp;" />) embedded in a typed reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3585">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3585">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3586">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3586">Format</span></span>|<span data-ttu-id="de49f-3587">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3587">Assembly Format</span></span>|<span data-ttu-id="de49f-3588">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3588">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3589">`T`< C2  ></span><span class="sxs-lookup"><span data-stu-id="de49f-3589">C2 < `T` ></span></span>|<span data-ttu-id="de49f-3590">рефанивал `type`</span><span class="sxs-lookup"><span data-stu-id="de49f-3590">refanyval `type`</span></span>|<span data-ttu-id="de49f-3591">Отправляет адрес, хранящийся в типизированной ссылке.</span><span class="sxs-lookup"><span data-stu-id="de49f-3591">Pushes the address stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="de49f-3592">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3592">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3593">Ссылка на тип значения помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3593">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3594">Типизированная ссылка извлекается из стека, и извлекается соответствующий адрес.</span><span class="sxs-lookup"><span data-stu-id="de49f-3594">The typed reference is popped from the stack and the corresponding address retrieved.</span></span>  
  
3.  <span data-ttu-id="de49f-3595">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3595">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3596">Типизированная ссылка содержит токен типа и адрес экземпляра объекта.</span><span class="sxs-lookup"><span data-stu-id="de49f-3596">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="de49f-3597">Инструкция `refanyval` извлекает адрес, внедренный в ссылку с определенным типом.</span><span class="sxs-lookup"><span data-stu-id="de49f-3597">The `refanyval` instruction retrieves the address embedded in the a typed reference.</span></span> <span data-ttu-id="de49f-3598">Тип, внедренный в ссылочную ссылку, предоставленный в стеке, должен соответствовать типу, заданному `type` (маркер метаданных: `typedef` или `typeref`).</span><span class="sxs-lookup"><span data-stu-id="de49f-3598">The type embedded in the typed reference supplied on the stack must match the type specified by `type` (a metadata token, either a `typedef` or a `typeref`).</span></span> <span data-ttu-id="de49f-3599">См. инструкции по <xref:System.Reflection.Emit.OpCodes.Mkrefany> для связанного содержимого.</span><span class="sxs-lookup"><span data-stu-id="de49f-3599">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for related content.</span></span>  
  
 <span data-ttu-id="de49f-3600"><xref:System.InvalidCastException> возникает, если `type` не совпадает с типом, хранящимся в ссылке на тип (в данном случае `type` является классом, переданным в инструкцию <xref:System.Reflection.Emit.OpCodes.Mkrefany>, которая создала произнесенную типизированную ссылку).</span><span class="sxs-lookup"><span data-stu-id="de49f-3600"><xref:System.InvalidCastException> is thrown if `type` is not identical to the type stored in the type reference (in this case, `type` is the class supplied to the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction that constructed said typed reference).</span></span>  
  
 <span data-ttu-id="de49f-3601"><xref:System.TypeLoadException> возникает, если не удается найти `type`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3601"><xref:System.TypeLoadException> is thrown if `type` cannot be found.</span></span>  
  
 <span data-ttu-id="de49f-3602">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `refanyval`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3602">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanyval` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3603">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-3603">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3604">Делит одно значение на другое и помещает остаток в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3604">Divides two values and pushes the remainder onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3605">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3605">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3606">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3606">Format</span></span>|<span data-ttu-id="de49f-3607">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3607">Assembly Format</span></span>|<span data-ttu-id="de49f-3608">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3608">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3609">d</span><span class="sxs-lookup"><span data-stu-id="de49f-3609">5D</span></span>|<span data-ttu-id="de49f-3610">оставшие</span><span class="sxs-lookup"><span data-stu-id="de49f-3610">rem</span></span>|<span data-ttu-id="de49f-3611">Помещает остаток деления `value1` на `value2` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3611">Pushes the remainder of dividing `value1` by `value2` onto the stack.</span></span>|  
  
  
 <span data-ttu-id="de49f-3612">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3612">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3613">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3613">A `value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3614">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3614">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3615">`value2` и `value1` извлекаются из стека, а оставшаяся часть `value1` `div` `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3615">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="de49f-3616">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3616">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3617">`result` = `value1` `rem` `value2` удовлетворяют следующим условиям.</span><span class="sxs-lookup"><span data-stu-id="de49f-3617">`result` = `value1` `rem` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="de49f-3618">`result` = `value1` - `value2` `×` (`value1` `div` `value2`) и:</span><span class="sxs-lookup"><span data-stu-id="de49f-3618">`result` = `value1` - `value2` `×` (`value1` `div` `value2`), and:</span></span>  
  
 <span data-ttu-id="de49f-3619">0 = &#124; `result` &#124; < &#124; `value2` &#124;, знак (`result`) = sign (`value1`), где `div` — это инструкция деления, которая усекается в сторону нуля.</span><span class="sxs-lookup"><span data-stu-id="de49f-3619">0 = &#124; `result` &#124; < &#124; `value2` &#124;, sign(`result`) = sign(`value1`), where `div` is the division instruction that truncates towards zero.</span></span>  
  
 <span data-ttu-id="de49f-3620">Если `value2` равно нулю или `value1` — бесконечность, результатом будет NaN.</span><span class="sxs-lookup"><span data-stu-id="de49f-3620">If `value2` is zero or `value1` is infinity the result is NaN.</span></span> <span data-ttu-id="de49f-3621">Если `value2` — бесконечность, результатом будет `value1` (с отрицанием для `-infinity`).</span><span class="sxs-lookup"><span data-stu-id="de49f-3621">If `value2` is infinity, the result is `value1` (negated for `-infinity`).</span></span>  
  
 <span data-ttu-id="de49f-3622">Целочисленные операции создают исключение <xref:System.DivideByZeroException>, если `value2` равно нулю.</span><span class="sxs-lookup"><span data-stu-id="de49f-3622">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="de49f-3623">Обратите внимание, что на платформах на базе процессоров Intel при вычислениях выдается <xref:System.OverflowException> (minint `rem` -1).</span><span class="sxs-lookup"><span data-stu-id="de49f-3623">Note that on the Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint `rem` -1).</span></span>  
  
 <span data-ttu-id="de49f-3624">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `rem`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3624">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3625">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3625">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3626">Делит одно значение без знака на другое значение без знака и помещает остаток в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3626">Divides two unsigned values and pushes the remainder onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3627">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3627">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3628">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3628">Format</span></span>|<span data-ttu-id="de49f-3629">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3629">Assembly Format</span></span>|<span data-ttu-id="de49f-3630">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3630">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3631">5E</span><span class="sxs-lookup"><span data-stu-id="de49f-3631">5E</span></span>|<span data-ttu-id="de49f-3632">REM. un</span><span class="sxs-lookup"><span data-stu-id="de49f-3632">rem.un</span></span>|<span data-ttu-id="de49f-3633">Помещает оставшуюся часть деления без знака `value1` на `value2` в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3633">Pushes the remainder of dividing unsigned `value1` by unsigned `value2` onto the stack.</span></span>|  
  
 <span data-ttu-id="de49f-3634">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3634">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3635">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3635">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3636">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3636">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3637">`value2` и `value1` извлекаются из стека, а оставшаяся часть `value1` `div` `value2`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3637">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="de49f-3638">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3638">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3639">`result` = `value1` `rem.un` `value2` удовлетворяют следующим условиям.</span><span class="sxs-lookup"><span data-stu-id="de49f-3639">`result` = `value1` `rem.un` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="de49f-3640">`result` = `value1` - `value2` x (`value1` `div.un` `value2`) и:</span><span class="sxs-lookup"><span data-stu-id="de49f-3640">`result` = `value1` - `value2` x(`value1` `div.un` `value2`), and:</span></span>  
  
 <span data-ttu-id="de49f-3641">0 = `result` < `value2`, где `div.un` является неподписанной инструкцией деления.</span><span class="sxs-lookup"><span data-stu-id="de49f-3641">0 = `result` < `value2`, where `div.un` is the unsigned division instruction.</span></span>  
  
 <span data-ttu-id="de49f-3642">Инструкция `rem.un` выполняет вычисление `result` и помещает его в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3642">The `rem.un` instruction computes `result` and pushes it on the stack.</span></span> <span data-ttu-id="de49f-3643">`Rem.un` обрабатывает свои аргументы как целые числа без знака, а <xref:System.Reflection.Emit.OpCodes.Rem> обрабатывает их как целые числа со знаком.</span><span class="sxs-lookup"><span data-stu-id="de49f-3643">`Rem.un` treats its arguments as unsigned integers, while <xref:System.Reflection.Emit.OpCodes.Rem> treats them as signed integers.</span></span>  
  
 <span data-ttu-id="de49f-3644">значение `Rem.un` не указано для чисел с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="de49f-3644">`Rem.un` is unspecified for floating-point numbers.</span></span>  
  
 <span data-ttu-id="de49f-3645">Целочисленные операции создают исключение <xref:System.DivideByZeroException>, если `value2` равно нулю.</span><span class="sxs-lookup"><span data-stu-id="de49f-3645">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="de49f-3646">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `rem.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3646">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3647">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3647">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3648">Выполняет возврат из текущего метода, помещая возвращаемое значение (если имеется) из стека вычислений вызываемого метода в стек вычислений вызывающего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-3648">Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3649">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3649">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3650">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3650">Format</span></span>|<span data-ttu-id="de49f-3651">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3651">Assembly Format</span></span>|<span data-ttu-id="de49f-3652">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3652">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3653">2а</span><span class="sxs-lookup"><span data-stu-id="de49f-3653">2A</span></span>|<span data-ttu-id="de49f-3654">обратно</span><span class="sxs-lookup"><span data-stu-id="de49f-3654">ret</span></span>|<span data-ttu-id="de49f-3655">Возвращает из метода, возможно, возвращающего значение.</span><span class="sxs-lookup"><span data-stu-id="de49f-3655">Returns from method, possibly returning a value.</span></span>|  
  
 <span data-ttu-id="de49f-3656">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3656">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3657">Возвращаемое значение извлекается из стека вычислений вызываемого метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-3657">The return value is popped from the callee evaluation stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3658">Возвращаемое значение, полученное на шаге 1, помещается в стек вычислений вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="de49f-3658">The return value obtained in step 1 is pushed onto the caller evaluation stack.</span></span>  
  
 <span data-ttu-id="de49f-3659">Если возвращаемое значение отсутствует в стеке вычисления вызываемого метода, значение не возвращается (ни одно поведение перехода стека для вызываемого или вызывающего метода не используется).</span><span class="sxs-lookup"><span data-stu-id="de49f-3659">If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</span></span>  
  
 <span data-ttu-id="de49f-3660">Тип возвращаемого значения (если таковой имеется) текущего метода определяет тип значения, которое будет выбрано из верхней части стека и скопировано в стек метода, который вызвал текущий метод.</span><span class="sxs-lookup"><span data-stu-id="de49f-3660">The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method.</span></span> <span data-ttu-id="de49f-3661">Стек вычислений для текущего метода должен быть пустым, за исключением возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3661">The evaluation stack for the current method must be empty except for the value to be returned.</span></span>  
  
 <span data-ttu-id="de49f-3662">Инструкцию `ret` нельзя использовать для перемещения управления из`try`, `filter`, `catch`или блока `finally`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3662">The `ret` instruction cannot be used to transfer control out of a`try`, `filter`, `catch`, or `finally` block.</span></span> <span data-ttu-id="de49f-3663">В `try` или `catch` используйте инструкцию <xref:System.Reflection.Emit.OpCodes.Leave> с назначением инструкции `ret`, которая находится за пределами всех охватывающих блоков исключений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3663">From within a `try` or `catch`, use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction with a destination of a `ret` instruction that is outside all enclosing exception blocks.</span></span> <span data-ttu-id="de49f-3664">Поскольку блоки `filter` и `finally` логически являются частью обработки исключений, а не метода, в котором внедрен их код, правильно сформированные инструкции языка MSIL не выполняют возврат метода из `filter` или `finally`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3664">Because the `filter` and `finally` blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a `filter` or `finally`.</span></span>  
  
 <span data-ttu-id="de49f-3665">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `ret`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3665">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ret` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3666">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3666">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3667">Возвращает текущее исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-3667">Rethrows the current exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3668">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3668">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3669">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3669">Format</span></span>|<span data-ttu-id="de49f-3670">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3670">Assembly Format</span></span>|<span data-ttu-id="de49f-3671">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3671">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3672">FE 1A</span><span class="sxs-lookup"><span data-stu-id="de49f-3672">FE 1A</span></span>|<span data-ttu-id="de49f-3673">Rethrow</span><span class="sxs-lookup"><span data-stu-id="de49f-3673">rethrow</span></span>|<span data-ttu-id="de49f-3674">Повторная генерация текущего исключения</span><span class="sxs-lookup"><span data-stu-id="de49f-3674">Rethrows the current exception</span></span>|  
  
 <span data-ttu-id="de49f-3675">Для этой инструкции не определено поведение перехода стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-3675">No stack transition behavior is defined for this instruction.</span></span>  
  
 <span data-ttu-id="de49f-3676">Инструкция `rethrow` разрешена только в теле обработчика `catch`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3676">The `rethrow` instruction is only permitted within the body of a `catch` handler.</span></span> <span data-ttu-id="de49f-3677">Он создает то же исключение, которое было перехвачено этим обработчиком.</span><span class="sxs-lookup"><span data-stu-id="de49f-3677">It throws the same exception that was caught by this handler.</span></span>  
  
 <span data-ttu-id="de49f-3678">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `rethrow`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3678">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rethrow` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3679">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3679">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3680">Смещает целочисленное значение влево (с заполнением нулями) на заданное число бит и помещает результат в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3680">Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3681">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3681">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3682">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3682">Format</span></span>|<span data-ttu-id="de49f-3683">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3683">Assembly Format</span></span>|<span data-ttu-id="de49f-3684">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3684">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3685">62</span><span class="sxs-lookup"><span data-stu-id="de49f-3685">62</span></span>|<span data-ttu-id="de49f-3686">шл</span><span class="sxs-lookup"><span data-stu-id="de49f-3686">shl</span></span>|<span data-ttu-id="de49f-3687">Сдвигает целое число влево (сдвиг в нули).</span><span class="sxs-lookup"><span data-stu-id="de49f-3687">Shifts an integer to the left (shifting in zeros).</span></span>|  
  
 <span data-ttu-id="de49f-3688">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3688">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3689">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3689">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3690">Количество битов для сдвига помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3690">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3691">Число битов, которые необходимо сдвинуть, и значение, извлекаемое из стека; значение смещается влево на указанное число битов.</span><span class="sxs-lookup"><span data-stu-id="de49f-3691">The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="de49f-3692">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3692">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3693">Инструкция `shl` Сдвигает значение (Type `int32`, `int64` или `native int`) влево на указанное число битов.</span><span class="sxs-lookup"><span data-stu-id="de49f-3693">The `shl` instruction shifts the value (type `int32`, `int64` or `native int`) left by the specified number of bits.</span></span> <span data-ttu-id="de49f-3694">Число битов является значением типа `int32` или `native int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3694">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="de49f-3695">Возвращаемое значение не указано, если число битов, которые необходимо сдвинуть, больше или равно ширине (в битах) указанного значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3695">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="de49f-3696">`Shl` вставляет нулевой бит в нижнюю точку при каждой смене.</span><span class="sxs-lookup"><span data-stu-id="de49f-3696">`Shl` inserts a zero bit in the lowest position on each shift.</span></span>  
  
 <span data-ttu-id="de49f-3697">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `shl`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3697">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shl` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3698">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3698">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3699">Смещает целочисленное значение вправо (с знаковым битом) на заданное число бит и помещает результат в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3699">Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3700">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3700">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3701">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3701">Format</span></span>|<span data-ttu-id="de49f-3702">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3702">Assembly Format</span></span>|<span data-ttu-id="de49f-3703">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3703">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3704">63</span><span class="sxs-lookup"><span data-stu-id="de49f-3704">63</span></span>|<span data-ttu-id="de49f-3705">SHR</span><span class="sxs-lookup"><span data-stu-id="de49f-3705">shr</span></span>|<span data-ttu-id="de49f-3706">Сдвигает целое число вправо (сдвиг в знак).</span><span class="sxs-lookup"><span data-stu-id="de49f-3706">Shifts an integer to the right (shifting in sign).</span></span>|  
  
 <span data-ttu-id="de49f-3707">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3707">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3708">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3708">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3709">Количество битов для сдвига помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3709">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3710">Число битов, которые необходимо сдвинуть, и значение, извлекаемое из стека; значение смещается вправо на указанное число битов.</span><span class="sxs-lookup"><span data-stu-id="de49f-3710">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="de49f-3711">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3711">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3712">Инструкция `shr.un` Сдвигает значение (Type `int32`, `int64` или `native int`) вправо на указанное число битов.</span><span class="sxs-lookup"><span data-stu-id="de49f-3712">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="de49f-3713">Число битов является значением типа `int32` или `native int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3713">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="de49f-3714">Возвращаемое значение не указано, если число битов, которые необходимо сдвинуть, больше или равно ширине (в битах) указанного значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3714">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="de49f-3715">`Shr` реплицирует бит высокого порядка при каждой смене, сохраняя знак исходного значения в `result`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3715">`Shr` replicates the high order bit on each shift, preserving the sign of the original value in the `result`.</span></span>  
  
 <span data-ttu-id="de49f-3716">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `shr`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3716">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3717">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3717">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3718">Смещает целочисленное значение без знака вправо (с заполнением нулями) на заданное число бит и помещает результат в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3718">Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3719">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3719">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3720">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3720">Format</span></span>|<span data-ttu-id="de49f-3721">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3721">Assembly Format</span></span>|<span data-ttu-id="de49f-3722">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3722">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3723">64</span><span class="sxs-lookup"><span data-stu-id="de49f-3723">64</span></span>|<span data-ttu-id="de49f-3724">SHR. un</span><span class="sxs-lookup"><span data-stu-id="de49f-3724">shr.un</span></span>|<span data-ttu-id="de49f-3725">Сдвигает целое число вправо (с сдвигом в нули).</span><span class="sxs-lookup"><span data-stu-id="de49f-3725">Shifts an integer to the right (shifting in zeroes).</span></span>|  
  
 <span data-ttu-id="de49f-3726">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3726">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3727">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3727">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3728">Количество битов для сдвига помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3728">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3729">Число битов, которые необходимо сдвинуть, и значение, извлекаемое из стека; значение смещается вправо на указанное число битов.</span><span class="sxs-lookup"><span data-stu-id="de49f-3729">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="de49f-3730">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3730">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3731">Инструкция `shr.un` Сдвигает значение (Type `int32`, `int64` или `native int`) вправо на указанное число битов.</span><span class="sxs-lookup"><span data-stu-id="de49f-3731">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="de49f-3732">Число битов является значением типа `int32`, `int64` или `native int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3732">The number of bits is a value of type `int32`, `int64` or `native int`.</span></span> <span data-ttu-id="de49f-3733">Возвращаемое значение не указано, если число битов, которые необходимо сдвинуть, больше или равно ширине (в битах) указанного значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3733">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="de49f-3734">`Shr.un` вставляет нулевой бит в самую верхнюю точку при каждой смене.</span><span class="sxs-lookup"><span data-stu-id="de49f-3734">`Shr.un` inserts a zero bit in the highest position on each shift.</span></span>  
  
 <span data-ttu-id="de49f-3735">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `shr.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3735">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3736">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3736">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3737">Помещает в стек вычислений сведения о размере (в байтах) заданного типа значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3737">Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3738">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3738">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3739">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3739">Format</span></span>|<span data-ttu-id="de49f-3740">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3740">Assembly Format</span></span>|<span data-ttu-id="de49f-3741">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3741">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3742">`T`< FE 1C  ></span><span class="sxs-lookup"><span data-stu-id="de49f-3742">FE 1C < `T` ></span></span>|<span data-ttu-id="de49f-3743">sizeof `valType`</span><span class="sxs-lookup"><span data-stu-id="de49f-3743">sizeof `valType`</span></span>|<span data-ttu-id="de49f-3744">Отправка размера (в байтах) типа значения в качестве `unsigned int32`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3744">Push the size, in bytes, of a value type as an `unsigned int32`.</span></span>|  
  
 <span data-ttu-id="de49f-3745">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3745">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3746">Размер (в байтах) заданного типа значения (`valType`) помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3746">The size (in bytes) of the supplied value type (`valType`) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3747">`valType` должен быть токеном метаданных (`typeref` или `typedef`), который указывает тип значения, ссылочный тип или параметр универсального типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-3747">`valType` must be a metadata token (a `typeref` or `typedef`) that specifies a value type, reference type, or generic type parameter.</span></span>  
  
 <span data-ttu-id="de49f-3748">Для ссылочного типа возвращаемый размер — это размер ссылочного значения соответствующего типа (4 байта в 32-разрядных системах), а не размер данных, хранящихся в объектах, на которые ссылается ссылочное значение.</span><span class="sxs-lookup"><span data-stu-id="de49f-3748">For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value.</span></span> <span data-ttu-id="de49f-3749">Параметр универсального типа может использоваться только в теле типа или метода, который его определяет.</span><span class="sxs-lookup"><span data-stu-id="de49f-3749">A generic type parameter can be used only in the body of the type or method that defines it.</span></span> <span data-ttu-id="de49f-3750">При создании экземпляра этого типа или метода параметр универсального типа заменяется типом значения или ссылочным типом.</span><span class="sxs-lookup"><span data-stu-id="de49f-3750">When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.</span></span>  
  
 <span data-ttu-id="de49f-3751">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `sizeof`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3751">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sizeof` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3752">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-3752">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3753">Сохраняет значение, находящееся на вершине стека вычислений, в ячейке аргумента с заданным индексом.</span><span class="sxs-lookup"><span data-stu-id="de49f-3753">Stores the value on top of the evaluation stack in the argument slot at a specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3754">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3754">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3755">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3755">Format</span></span>|<span data-ttu-id="de49f-3756">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3756">Assembly Format</span></span>|<span data-ttu-id="de49f-3757">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3757">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3758">< FE 0B `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="de49f-3758">FE 0B < `unsigned int16` ></span></span>|<span data-ttu-id="de49f-3759">СТАРГ `num`</span><span class="sxs-lookup"><span data-stu-id="de49f-3759">starg `num`</span></span>|<span data-ttu-id="de49f-3760">Извлекает верхнее значение из стека и сохраняет его в ячейке аргумента `num`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3760">Pops the top value from the stack and stores it in argument slot `num`.</span></span>|  
  
 <span data-ttu-id="de49f-3761">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3761">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3762">Значение, находящегося на вершине стека, извлекается и помещается в ячейку аргумента `num`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3762">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="de49f-3763">Инструкция `starg` извлекает значение из стека и помещает его в ячейку аргумента `num`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3763">The `starg` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="de49f-3764">Тип значения должен соответствовать типу аргумента, как указано в сигнатуре текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-3764">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="de49f-3765">Для процедур, принимающих переменный список аргументов, инструкция `starg` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры.</span><span class="sxs-lookup"><span data-stu-id="de49f-3765">For procedures that take a variable argument list, the `starg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="de49f-3766">Выполнение хранилища в аргументах, содержащих целочисленное значение менее 4 байт, усекает значение при перемещении из стека в аргумент.</span><span class="sxs-lookup"><span data-stu-id="de49f-3766">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="de49f-3767">Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.</span><span class="sxs-lookup"><span data-stu-id="de49f-3767">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="de49f-3768">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `starg`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3768">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3769">ILGenerator. Emit (код операции, короткий)</span><span class="sxs-lookup"><span data-stu-id="de49f-3769">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3770">Сохраняет значение, находящееся на вершине стека вычислений, в ячейке аргумента с заданным индексом (короткая форма).</span><span class="sxs-lookup"><span data-stu-id="de49f-3770">Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3771">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3771">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3772">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3772">Format</span></span>|<span data-ttu-id="de49f-3773">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3773">Assembly Format</span></span>|<span data-ttu-id="de49f-3774">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3774">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3775">10 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="de49f-3775">10 < `unsigned int8` ></span></span>|<span data-ttu-id="de49f-3776">СТАРГ. s `num`</span><span class="sxs-lookup"><span data-stu-id="de49f-3776">starg.s `num`</span></span>|<span data-ttu-id="de49f-3777">Извлекает верхнее значение из стека и сохраняет его в ячейке аргумента `num` (краткая форма).</span><span class="sxs-lookup"><span data-stu-id="de49f-3777">Pops the top value from the stack and stores it in argument slot `num`, short form.</span></span>|  
  
 <span data-ttu-id="de49f-3778">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3778">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3779">Значение, находящегося на вершине стека, извлекается и помещается в ячейку аргумента `num`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3779">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="de49f-3780">Инструкция `starg.s` извлекает значение из стека и помещает его в ячейку аргумента `num`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3780">The `starg.s` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="de49f-3781">Тип значения должен соответствовать типу аргумента, как указано в сигнатуре текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-3781">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="de49f-3782">Инструкция `starg.s` обеспечивает эффективную кодировку для использования с первыми аргументами 256.</span><span class="sxs-lookup"><span data-stu-id="de49f-3782">The `starg.s` instruction provides an efficient encoding for use with the first 256 arguments.</span></span>  
  
 <span data-ttu-id="de49f-3783">Для процедур, принимающих переменный список аргументов, инструкция `starg.s` может использоваться только для начальных фиксированных аргументов, а не в переменной части сигнатуры.</span><span class="sxs-lookup"><span data-stu-id="de49f-3783">For procedures that take a variable argument list, the `starg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="de49f-3784">Выполнение хранилища в аргументах, содержащих целочисленное значение менее 4 байт, усекает значение при перемещении из стека в аргумент.</span><span class="sxs-lookup"><span data-stu-id="de49f-3784">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="de49f-3785">Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.</span><span class="sxs-lookup"><span data-stu-id="de49f-3785">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="de49f-3786">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `starg.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3786">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3787">ILGenerator. Emit (код операции, байт)</span><span class="sxs-lookup"><span data-stu-id="de49f-3787">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3788">Заменяет элемент массива с заданным индексом на значение в стеке вычислений, тип которого указан в инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-3788">Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3789">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3789">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3790">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3790">Format</span></span>|<span data-ttu-id="de49f-3791">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3791">Assembly Format</span></span>|<span data-ttu-id="de49f-3792">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3792">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3793">`T`< A4  ></span><span class="sxs-lookup"><span data-stu-id="de49f-3793">A4 < `T` ></span></span>|<span data-ttu-id="de49f-3794">стелем `typeTok`</span><span class="sxs-lookup"><span data-stu-id="de49f-3794">stelem `typeTok`</span></span>|<span data-ttu-id="de49f-3795">Заменяет элемент массива с заданным индексом на значение типа `typeTok` в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-3795">Replaces the array element at the supplied index with a value of type `typeTok` on the stack.</span></span>|  
  
 <span data-ttu-id="de49f-3796">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3796">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3797">Ссылка на объект Array, `array`, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3797">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3798">Значение индекса, `index`, в элемент в `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3798">An index value, `index`, to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3799">Значение типа, указанное в инструкции, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3799">A value of the type specified in the instruction is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de49f-3800">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.</span><span class="sxs-lookup"><span data-stu-id="de49f-3800">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de49f-3801">Инструкция `stelem` заменяет значение элемента в указанном индексе, начинающемся с нуля, в одномерном массиве `array` со значением.</span><span class="sxs-lookup"><span data-stu-id="de49f-3801">The `stelem` instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array `array` with the value.</span></span> <span data-ttu-id="de49f-3802">Значение имеет тип, заданный токеном `typeTok` в инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-3802">The value has the type specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="de49f-3803">Массивы являются объектами, поэтому они представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3803">Arrays are objects, and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de49f-3804">Индекс имеет тип `native int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3804">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de49f-3805"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-3805"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-3806"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3806"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-3807"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-3807"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-3808">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3808">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3809">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-3809">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3810">Заменяет элемент массива с заданным индексом на значение <see langword="native int" />, находящееся в стеке вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3810">Replaces the array element at a given index with the <see langword="native int" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3811">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3811">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3812">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3812">Format</span></span>|<span data-ttu-id="de49f-3813">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3813">Assembly Format</span></span>|<span data-ttu-id="de49f-3814">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3814">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3815">9Б</span><span class="sxs-lookup"><span data-stu-id="de49f-3815">9B</span></span>|<span data-ttu-id="de49f-3816">стелем. i</span><span class="sxs-lookup"><span data-stu-id="de49f-3816">stelem.i</span></span>|<span data-ttu-id="de49f-3817">Заменяет элемент массива с заданным индексом на значение `native int` в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-3817">Replaces an array element at the supplied index with the `native int` value on the stack.</span></span>|  
  
 <span data-ttu-id="de49f-3818">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3818">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3819">Ссылка на объект Array, `array`, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3819">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3820">Допустимый индекс элемента в `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3820">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3821">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3821">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de49f-3822">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.</span><span class="sxs-lookup"><span data-stu-id="de49f-3822">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de49f-3823">Инструкция `stelem.i` заменяет значение элемента `index` в одномерным массиве `array` на значение `native int`, помещаемое в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3823">The `stelem.i` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `native int` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3824">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3824">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de49f-3825">Индекс имеет тип `native int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3825">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de49f-3826"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-3826"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-3827"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3827"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-3828"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-3828"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-3829">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.i`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3829">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3830">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3830">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3831">Заменяет элемент массива с заданным индексом на значение <see langword="int8" />, находящееся в стеке вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3831">Replaces the array element at a given index with the <see langword="int8" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3832">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3832">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3833">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3833">Format</span></span>|<span data-ttu-id="de49f-3834">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3834">Assembly Format</span></span>|<span data-ttu-id="de49f-3835">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3835">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3836">9C</span><span class="sxs-lookup"><span data-stu-id="de49f-3836">9C</span></span>|<span data-ttu-id="de49f-3837">стелем. i1</span><span class="sxs-lookup"><span data-stu-id="de49f-3837">stelem.i1</span></span>|<span data-ttu-id="de49f-3838">Заменяет элемент массива с заданным индексом на значение `int8` в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-3838">Replaces an array element at the supplied index with the `int8` value on the stack.</span></span>|  
  
 <span data-ttu-id="de49f-3839">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3839">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3840">Ссылка на объект Array, `array`, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3840">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3841">Допустимый индекс элемента в `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3841">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3842">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3842">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de49f-3843">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.</span><span class="sxs-lookup"><span data-stu-id="de49f-3843">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de49f-3844">Инструкция `stelem.i1` заменяет значение элемента `index` в одномерным массиве `array` на значение `int8`, помещаемое в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3844">The `stelem.i1` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int8` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3845">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3845">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de49f-3846">Индекс имеет тип `native int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3846">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de49f-3847"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-3847"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-3848"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3848"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-3849"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-3849"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-3850">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.i1`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3850">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3851">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3851">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3852">Заменяет элемент массива с заданным индексом на значение <see langword="int16" />, находящееся в стеке вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3852">Replaces the array element at a given index with the <see langword="int16" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3853">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3853">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3854">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3854">Format</span></span>|<span data-ttu-id="de49f-3855">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3855">Assembly Format</span></span>|<span data-ttu-id="de49f-3856">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3856">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3857">9D</span><span class="sxs-lookup"><span data-stu-id="de49f-3857">9D</span></span>|<span data-ttu-id="de49f-3858">стелем. i2</span><span class="sxs-lookup"><span data-stu-id="de49f-3858">stelem.i2</span></span>|<span data-ttu-id="de49f-3859">Заменяет элемент массива с заданным индексом на значение `int16` в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-3859">Replaces an array element at the supplied index with the `int16` value on the stack.</span></span>|  
  
 <span data-ttu-id="de49f-3860">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3860">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3861">Ссылка на объект Array, `array`, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3861">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3862">Допустимый индекс элемента в `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3862">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3863">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3863">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de49f-3864">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.</span><span class="sxs-lookup"><span data-stu-id="de49f-3864">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de49f-3865">Инструкция `stelem.i2` заменяет значение элемента `index` в одномерным массиве `array` на значение `int16`, помещаемое в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3865">The `stelem.i2` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int16` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3866">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3866">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de49f-3867">Индекс имеет тип `native int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3867">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de49f-3868"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-3868"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-3869"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3869"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-3870"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-3870"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-3871">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.i2`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3871">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3872">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3872">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3873">Заменяет элемент массива с заданным индексом на значение <see langword="int32" />, находящееся в стеке вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3873">Replaces the array element at a given index with the <see langword="int32" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3874">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3874">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3875">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3875">Format</span></span>|<span data-ttu-id="de49f-3876">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3876">Assembly Format</span></span>|<span data-ttu-id="de49f-3877">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3877">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3878">9E</span><span class="sxs-lookup"><span data-stu-id="de49f-3878">9E</span></span>|<span data-ttu-id="de49f-3879">стелем. i4</span><span class="sxs-lookup"><span data-stu-id="de49f-3879">stelem.i4</span></span>|<span data-ttu-id="de49f-3880">Заменяет элемент массива с заданным индексом на значение `int32` в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-3880">Replaces an array element at the supplied index with the `int32` value on the stack.</span></span>|  
  
 <span data-ttu-id="de49f-3881">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3881">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3882">Ссылка на объект Array, `array`, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3882">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3883">Допустимый индекс элемента в `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3883">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3884">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3884">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de49f-3885">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.</span><span class="sxs-lookup"><span data-stu-id="de49f-3885">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de49f-3886">Инструкция `stelem.i4` заменяет значение элемента `index` в одномерным массиве `array` на значение `int32`, помещаемое в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3886">The `stelem.i4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3887">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3887">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de49f-3888">Индекс имеет тип `native int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3888">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de49f-3889"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-3889"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-3890"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3890"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-3891"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-3891"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-3892">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.i4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3892">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3893">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3893">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3894">Заменяет элемент массива с заданным индексом на значение <see langword="int64" />, находящееся в стеке вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3894">Replaces the array element at a given index with the <see langword="int64" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3895">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3895">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3896">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3896">Format</span></span>|<span data-ttu-id="de49f-3897">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3897">Assembly Format</span></span>|<span data-ttu-id="de49f-3898">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3898">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3899">9F</span><span class="sxs-lookup"><span data-stu-id="de49f-3899">9F</span></span>|<span data-ttu-id="de49f-3900">стелем. i8</span><span class="sxs-lookup"><span data-stu-id="de49f-3900">stelem.i8</span></span>|<span data-ttu-id="de49f-3901">Заменяет элемент массива с заданным индексом на значение `int64` в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-3901">Replaces an array element at the supplied index with the `int64` value on the stack.</span></span>|  
  
 <span data-ttu-id="de49f-3902">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3902">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3903">Ссылка на объект Array, `array`, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3903">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3904">Допустимый индекс элемента в `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3904">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3905">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3905">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de49f-3906">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.</span><span class="sxs-lookup"><span data-stu-id="de49f-3906">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de49f-3907">Инструкция `stelem.i8` заменяет значение элемента `index` в одномерным массиве `array` на значение `int64`, помещаемое в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3907">The `stelem.i8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3908">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3908">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de49f-3909">Индекс имеет тип `native int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3909">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de49f-3910"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-3910"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-3911"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3911"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-3912"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-3912"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-3913">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.i8`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3913">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3914">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3914">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3915">Заменяет элемент массива с заданным индексом на значение <see langword="float32" />, находящееся в стеке вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3915">Replaces the array element at a given index with the <see langword="float32" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3916">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3916">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3917">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3917">Format</span></span>|<span data-ttu-id="de49f-3918">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3918">Assembly Format</span></span>|<span data-ttu-id="de49f-3919">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3919">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3920">A0</span><span class="sxs-lookup"><span data-stu-id="de49f-3920">A0</span></span>|<span data-ttu-id="de49f-3921">стелем. R4</span><span class="sxs-lookup"><span data-stu-id="de49f-3921">stelem.r4</span></span>|<span data-ttu-id="de49f-3922">Заменяет элемент массива с заданным индексом на значение `float32` в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-3922">Replaces an array element at the supplied index with the `float32` value on the stack.</span></span>|  
  
 <span data-ttu-id="de49f-3923">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3923">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3924">Ссылка на объект Array, `array`, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3924">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3925">Допустимый индекс элемента в `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3925">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3926">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3926">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de49f-3927">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.</span><span class="sxs-lookup"><span data-stu-id="de49f-3927">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de49f-3928">Инструкция `stelem.r4` заменяет значение элемента `index` в одномерным массиве `array` на значение `float32`, помещаемое в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3928">The `stelem.r4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3929">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3929">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de49f-3930">Индекс имеет тип `native int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3930">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de49f-3931"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-3931"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-3932"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3932"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-3933"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-3933"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-3934">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.r4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3934">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3935">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3935">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3936">Заменяет элемент массива с заданным индексом на значение <see langword="float64" />, находящееся в стеке вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3936">Replaces the array element at a given index with the <see langword="float64" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3937">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3937">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3938">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3938">Format</span></span>|<span data-ttu-id="de49f-3939">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3939">Assembly Format</span></span>|<span data-ttu-id="de49f-3940">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3940">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3941">A1</span><span class="sxs-lookup"><span data-stu-id="de49f-3941">A1</span></span>|<span data-ttu-id="de49f-3942">стелем. R8</span><span class="sxs-lookup"><span data-stu-id="de49f-3942">stelem.r8</span></span>|<span data-ttu-id="de49f-3943">Заменяет элемент массива с заданным индексом на значение `float64` в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-3943">Replaces an array element at the supplied index with the `float64` value on the stack.</span></span>|  
  
 <span data-ttu-id="de49f-3944">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3944">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3945">Ссылка на объект Array, `array`, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3945">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3946">Допустимый индекс элемента в `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3946">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3947">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3947">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de49f-3948">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.</span><span class="sxs-lookup"><span data-stu-id="de49f-3948">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de49f-3949">Инструкция `stelem.r8` заменяет значение элемента `index` в одномерным массиве `array` на значение `float64`, помещаемое в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3949">The `stelem.r8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3950">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3950">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de49f-3951">Индекс имеет тип `native int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3951">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de49f-3952"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-3952"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-3953"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3953"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-3954"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-3954"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-3955">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.r8`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3955">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3956">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3956">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3957">Заменяет элемент массива с заданным индексом на значение object ref (тип <see langword="O" />), находящееся в стеке вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-3957">Replaces the array element at a given index with the object ref value (type <see langword="O" />) on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3958">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3958">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3959">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3959">Format</span></span>|<span data-ttu-id="de49f-3960">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3960">Assembly Format</span></span>|<span data-ttu-id="de49f-3961">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3961">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3962">A2</span><span class="sxs-lookup"><span data-stu-id="de49f-3962">A2</span></span>|<span data-ttu-id="de49f-3963">стелем. ref</span><span class="sxs-lookup"><span data-stu-id="de49f-3963">stelem.ref</span></span>|<span data-ttu-id="de49f-3964">Заменяет элемент массива с заданным индексом на значение `ref` (тип `O`) в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-3964">Replaces an array element at the supplied index with the `ref` value (type `O`) on the stack.</span></span>|  
  
 <span data-ttu-id="de49f-3965">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3965">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3966">Ссылка на объект Array, `array`, помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3966">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3967">Допустимый индекс элемента в `array` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3967">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3968">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3968">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="de49f-3969">Значение, индекс и ссылка на массив извлекаются из стека; значение помещается в элемент массива по заданному индексу.</span><span class="sxs-lookup"><span data-stu-id="de49f-3969">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="de49f-3970">Инструкция `stelem.ref` заменяет значение элемента по указанному индексу в одномерном массиве `array` на значение `ref` (тип `O`), помещаемое в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3970">The `stelem.ref` instruction replaces the value of the element at the supplied index in the one-dimensional array `array` with the `ref` (type `O`) value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-3971">Массивы являются объектами и поэтому представлены значением типа `O`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3971">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="de49f-3972">Индекс имеет тип `native int`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3972">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="de49f-3973">Обратите внимание, что `stelem.ref` неявно приводит заданное значение к типу элемента `array` перед присваиванием значения элементу массива.</span><span class="sxs-lookup"><span data-stu-id="de49f-3973">Note that `stelem.ref` implicitly casts the supplied value to the element type of `array` before assigning the value to the array element.</span></span> <span data-ttu-id="de49f-3974">Это приведение может завершиться ошибкой даже для проверенного кода.</span><span class="sxs-lookup"><span data-stu-id="de49f-3974">This cast can fail, even for verified code.</span></span> <span data-ttu-id="de49f-3975">Поэтому инструкция `stelem.ref` может вызвать <xref:System.InvalidCastException>.</span><span class="sxs-lookup"><span data-stu-id="de49f-3975">Thus the `stelem.ref` instruction can throw <xref:System.InvalidCastException>.</span></span> <span data-ttu-id="de49f-3976">Для одномерных массивов без индексации от нуля и для многомерных массивов класс <xref:System.Array> предоставляет метод <xref:System.Array.SetValue%2A>.</span><span class="sxs-lookup"><span data-stu-id="de49f-3976">For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <xref:System.Array> class provides a <xref:System.Array.SetValue%2A> method.</span></span>  
  
 <span data-ttu-id="de49f-3977"><xref:System.NullReferenceException> возникает, если `array` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-3977"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-3978"><xref:System.IndexOutOfRangeException> возникает, если `index` отрицательный или больше, чем граница `array`.</span><span class="sxs-lookup"><span data-stu-id="de49f-3978"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="de49f-3979"><xref:System.ArrayTypeMismatchException> возникает, если `array` не содержит элементов требуемого типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-3979"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="de49f-3980">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stelem.ref`:</span><span class="sxs-lookup"><span data-stu-id="de49f-3980">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-3981">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-3981">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-3982">Заменяет значение в поле объекта, по ссылке на объект или указателю, на новое значение.</span><span class="sxs-lookup"><span data-stu-id="de49f-3982">Replaces the value stored in the field of an object reference or pointer with a new value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-3983">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-3983">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-3984">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-3984">Format</span></span>|<span data-ttu-id="de49f-3985">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-3985">Assembly Format</span></span>|<span data-ttu-id="de49f-3986">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-3986">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-3987">7D < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-3987">7D < `T` ></span></span>|<span data-ttu-id="de49f-3988">stfld `field`</span><span class="sxs-lookup"><span data-stu-id="de49f-3988">stfld `field`</span></span>|<span data-ttu-id="de49f-3989">Заменяет значение `field` объекта на новое значение.</span><span class="sxs-lookup"><span data-stu-id="de49f-3989">Replaces the value of `field` of the object with a new value.</span></span>|  
  
 <span data-ttu-id="de49f-3990">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-3990">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-3991">Ссылка на объект или указатель помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3991">An object reference or pointer is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-3992">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-3992">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-3993">Значение и ссылка на объект (указатель) извлекаются из стека; значение `field` в объекте заменяется на заданное значение.</span><span class="sxs-lookup"><span data-stu-id="de49f-3993">The value and the object reference/pointer are popped from the stack; the value of `field` in the object is replaced with the supplied value.</span></span>  
  
 <span data-ttu-id="de49f-3994">Инструкция `stfld` заменяет значение поля объекта (тип `O`) или через указатель (тип `native int`, `&` или `*`) с заданным значением.</span><span class="sxs-lookup"><span data-stu-id="de49f-3994">The `stfld` instruction replaces the value of a field of an object (type `O`) or via a pointer (type `native int`, `&`, or `*`) with a given value.</span></span> <span data-ttu-id="de49f-3995">`Field` — это маркер метаданных, который ссылается на ссылку на поле.</span><span class="sxs-lookup"><span data-stu-id="de49f-3995">`Field` is a metadata token that refers to a field member reference.</span></span> <span data-ttu-id="de49f-3996">Инструкция `stfld` может иметь префикс либо для <xref:System.Reflection.Emit.OpCodes.Unaligned>, и для <xref:System.Reflection.Emit.OpCodes.Volatile>.</span><span class="sxs-lookup"><span data-stu-id="de49f-3996">The `stfld` instruction can have a prefix of either or both of <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="de49f-3997"><xref:System.NullReferenceException> создается, если ссылка на объект или указатель является пустой ссылкой, а поле не является статическим.</span><span class="sxs-lookup"><span data-stu-id="de49f-3997"><xref:System.NullReferenceException> is thrown if the object reference or pointer is a null reference and the field isn't static.</span></span>  
  
 <span data-ttu-id="de49f-3998"><xref:System.MissingFieldException> возникает, если `field` не найден в метаданных.</span><span class="sxs-lookup"><span data-stu-id="de49f-3998"><xref:System.MissingFieldException> is thrown if `field` is not found in the metadata.</span></span> <span data-ttu-id="de49f-3999">Обычно это проверяется при преобразовании инструкции MSIL в машинный код, а не во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-3999">This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="de49f-4000">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stfld`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4000">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stfld` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4001">ILGenerator. Emit (код операции, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="de49f-4001">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4002">Сохраняет значение с типом <see langword="native int" /> по указанному адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4002">Stores a value of type <see langword="native int" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4003">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4003">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4004">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4004">Format</span></span>|<span data-ttu-id="de49f-4005">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4005">Assembly Format</span></span>|<span data-ttu-id="de49f-4006">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4006">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4007">DF</span><span class="sxs-lookup"><span data-stu-id="de49f-4007">DF</span></span>|<span data-ttu-id="de49f-4008">stind. i</span><span class="sxs-lookup"><span data-stu-id="de49f-4008">stind.i</span></span>|<span data-ttu-id="de49f-4009">Сохраняет значение `native int` по указанному адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4009">Stores a `native int` value at a given address.</span></span>|  
  
 <span data-ttu-id="de49f-4010">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4010">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4011">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4011">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4012">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4012">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-4013">Значение и адрес извлекаются из стека; значение хранится по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4013">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="de49f-4014">Инструкция `stind.i` сохраняет значение `native int` по указанному адресу (тип `native int`, `*` или `&`).</span><span class="sxs-lookup"><span data-stu-id="de49f-4014">The `stind.i` instruction stores a `native int` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="de49f-4015">Для операции с типом "безопасно" требуется, чтобы инструкция `stind.i` соответствовала типу указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-4015">Type safe operation requires that the `stind.i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="de49f-4016">Операция `stind.i` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4016">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de49f-4017"><xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом с типом аргумента, подразумеваемым суффиксом инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-4017"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="de49f-4018">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.i`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4018">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4019">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4019">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4020">Сохраняет значение с типом <see langword="int8" /> по указанному адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4020">Stores a value of type <see langword="int8" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4021">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4021">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4022">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4022">Format</span></span>|<span data-ttu-id="de49f-4023">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4023">Assembly Format</span></span>|<span data-ttu-id="de49f-4024">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4024">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4025">52</span><span class="sxs-lookup"><span data-stu-id="de49f-4025">52</span></span>|<span data-ttu-id="de49f-4026">stind. i1</span><span class="sxs-lookup"><span data-stu-id="de49f-4026">stind.i1</span></span>|<span data-ttu-id="de49f-4027">Сохраняет значение `int8` по заданному адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4027">Stores an `int8` value at a given address.</span></span>|  
  
 <span data-ttu-id="de49f-4028">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4028">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4029">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4029">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4030">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4030">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-4031">Значение и адрес извлекаются из стека; значение хранится по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4031">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="de49f-4032">Инструкция `stind.i1` сохраняет значение `int8` по указанному адресу (тип `native int`, `*` или `&`).</span><span class="sxs-lookup"><span data-stu-id="de49f-4032">The `stind.i1` instruction stores an `int8` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="de49f-4033">Для операции с типом "безопасно" требуется, чтобы инструкция `stind.i1` соответствовала типу указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-4033">Type safe operation requires that the `stind.i1` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="de49f-4034">Операция `stind.i1` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4034">The operation of the `stind.i1` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de49f-4035"><xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом с типом аргумента, подразумеваемым суффиксом инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-4035"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="de49f-4036">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.i1`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4036">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4037">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4037">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4038">Сохраняет значение с типом <see langword="int16" /> по указанному адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4038">Stores a value of type <see langword="int16" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4039">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4039">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4040">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4040">Format</span></span>|<span data-ttu-id="de49f-4041">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4041">Assembly Format</span></span>|<span data-ttu-id="de49f-4042">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4042">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4043">53</span><span class="sxs-lookup"><span data-stu-id="de49f-4043">53</span></span>|<span data-ttu-id="de49f-4044">stind. i2</span><span class="sxs-lookup"><span data-stu-id="de49f-4044">stind.i2</span></span>|<span data-ttu-id="de49f-4045">Сохраняет значение `int16` по заданному адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4045">Stores an `int16` value at a given address.</span></span>|  
  
 <span data-ttu-id="de49f-4046">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4046">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4047">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4047">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4048">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4048">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-4049">Значение и адрес извлекаются из стека; значение хранится по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4049">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="de49f-4050">Инструкция `stind.i2` сохраняет значение `int16` по указанному адресу (тип `native int`, `*` или `&`).</span><span class="sxs-lookup"><span data-stu-id="de49f-4050">The `stind.i2` instruction stores an `int16` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="de49f-4051">Для операции с типом "безопасно" требуется, чтобы инструкция `stind.2i` соответствовала типу указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-4051">Type safe operation requires that the `stind.2i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="de49f-4052">Операция `stind.i2` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4052">The operation of the `stind.i2` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de49f-4053"><xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом с типом аргумента, подразумеваемым суффиксом инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-4053"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="de49f-4054">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.i2`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4054">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4055">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4055">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4056">Сохраняет значение с типом <see langword="int32" /> по указанному адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4056">Stores a value of type <see langword="int32" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4057">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4057">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4058">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4058">Format</span></span>|<span data-ttu-id="de49f-4059">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4059">Assembly Format</span></span>|<span data-ttu-id="de49f-4060">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4060">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4061">54</span><span class="sxs-lookup"><span data-stu-id="de49f-4061">54</span></span>|<span data-ttu-id="de49f-4062">stind. i4</span><span class="sxs-lookup"><span data-stu-id="de49f-4062">stind.i4</span></span>|<span data-ttu-id="de49f-4063">Сохраняет значение `int32` по заданному адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4063">Stores an `int32` value at a given address.</span></span>|  
  
 <span data-ttu-id="de49f-4064">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4064">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4065">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4065">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4066">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4066">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-4067">Значение и адрес извлекаются из стека; значение хранится по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4067">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="de49f-4068">Инструкция `stind.i4` сохраняет значение `int32` по указанному адресу (тип `native int`, `*` или `&`).</span><span class="sxs-lookup"><span data-stu-id="de49f-4068">The `stind.i4` instruction stores an `int32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="de49f-4069">Для операции с типом "безопасно" требуется, чтобы инструкция `stind.i4` соответствовала типу указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-4069">Type safe operation requires that the `stind.i4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="de49f-4070">Операция `stind.i4` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4070">The operation of the `stind.i4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de49f-4071"><xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом с типом аргумента, подразумеваемым суффиксом инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-4071"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="de49f-4072">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.i4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4073">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4074">Сохраняет значение с типом <see langword="int64" /> по указанному адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4074">Stores a value of type <see langword="int64" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4075">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4076">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4076">Format</span></span>|<span data-ttu-id="de49f-4077">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4077">Assembly Format</span></span>|<span data-ttu-id="de49f-4078">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4079">55</span><span class="sxs-lookup"><span data-stu-id="de49f-4079">55</span></span>|<span data-ttu-id="de49f-4080">stind. i8</span><span class="sxs-lookup"><span data-stu-id="de49f-4080">stind.i8</span></span>|<span data-ttu-id="de49f-4081">Сохраняет значение `int64` по заданному адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4081">Stores an `int64` value at a given address.</span></span>|  
  
 <span data-ttu-id="de49f-4082">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4083">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4083">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4084">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4084">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-4085">Значение и адрес извлекаются из стека; значение хранится по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4085">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="de49f-4086">Инструкция `stind.i8` сохраняет значение `int64` по указанному адресу (тип `native int`, `*` или `&`).</span><span class="sxs-lookup"><span data-stu-id="de49f-4086">The `stind.i8` instruction stores an `int64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="de49f-4087">Для операции с типом "безопасно" требуется, чтобы инструкция `stind.i8` соответствовала типу указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-4087">Type safe operation requires that the `stind.i8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="de49f-4088">Операция `stind.i` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4088">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de49f-4089"><xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом с типом аргумента, подразумеваемым суффиксом инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-4089"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="de49f-4090">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.i8`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4090">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4091">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4091">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4092">Сохраняет значение с типом <see langword="float32" /> по указанному адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4092">Stores a value of type <see langword="float32" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4093">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4093">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4094">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4094">Format</span></span>|<span data-ttu-id="de49f-4095">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4095">Assembly Format</span></span>|<span data-ttu-id="de49f-4096">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4096">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4097">56</span><span class="sxs-lookup"><span data-stu-id="de49f-4097">56</span></span>|<span data-ttu-id="de49f-4098">stind. R4</span><span class="sxs-lookup"><span data-stu-id="de49f-4098">stind.r4</span></span>|<span data-ttu-id="de49f-4099">Сохраняет значение `float32` по указанному адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4099">Stores a `float32` value at a given address.</span></span>|  
  
 <span data-ttu-id="de49f-4100">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4100">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4101">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4101">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4102">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4102">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-4103">Значение и адрес извлекаются из стека; значение хранится по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4103">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="de49f-4104">Инструкция `stind.r4` сохраняет значение `float32` по указанному адресу (тип `native int`, `*` или `&`).</span><span class="sxs-lookup"><span data-stu-id="de49f-4104">The `stind.r4` instruction stores a `float32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="de49f-4105">Для операции с типом "безопасно" требуется, чтобы инструкция `stind.r4` соответствовала типу указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-4105">Type safe operation requires that the `stind.r4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="de49f-4106">Операция `stind.r4` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4106">The operation of the `stind.r4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de49f-4107"><xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом с типом аргумента, подразумеваемым суффиксом инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-4107"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="de49f-4108">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.r4`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4108">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4109">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4109">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4110">Сохраняет значение с типом <see langword="float64" /> по указанному адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4110">Stores a value of type <see langword="float64" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4111">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4111">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4112">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4112">Format</span></span>|<span data-ttu-id="de49f-4113">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4113">Assembly Format</span></span>|<span data-ttu-id="de49f-4114">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4114">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4115">57</span><span class="sxs-lookup"><span data-stu-id="de49f-4115">57</span></span>|<span data-ttu-id="de49f-4116">stind. R8</span><span class="sxs-lookup"><span data-stu-id="de49f-4116">stind.r8</span></span>|<span data-ttu-id="de49f-4117">Сохраняет значение `float64` по указанному адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4117">Stores a `float64` value at a given address.</span></span>|  
  
 <span data-ttu-id="de49f-4118">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4118">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4119">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4119">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4120">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4120">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-4121">Значение и адрес извлекаются из стека; значение хранится по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4121">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="de49f-4122">Инструкция `stind.r8` сохраняет значение `float64` по указанному адресу (тип `native int`, `*` или `&`).</span><span class="sxs-lookup"><span data-stu-id="de49f-4122">The `stind.r8` instruction stores a `float64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="de49f-4123">Для операции с типом "безопасно" требуется, чтобы инструкция `stind.r8` соответствовала типу указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-4123">Type safe operation requires that the `stind.r8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="de49f-4124">Операция `stind.r8` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4124">The operation of the `stind.r8` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de49f-4125"><xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом с типом аргумента, подразумеваемым суффиксом инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-4125"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="de49f-4126">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.r8`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4126">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4127">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4127">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4128">Сохраняет значение ссылки на объект по указанному адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4128">Stores a object reference value at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4129">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4129">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4130">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4130">Format</span></span>|<span data-ttu-id="de49f-4131">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4131">Assembly Format</span></span>|<span data-ttu-id="de49f-4132">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4132">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4133">51</span><span class="sxs-lookup"><span data-stu-id="de49f-4133">51</span></span>|<span data-ttu-id="de49f-4134">stind. ref</span><span class="sxs-lookup"><span data-stu-id="de49f-4134">stind.ref</span></span>|<span data-ttu-id="de49f-4135">Сохраняет ссылку на объект (тип `O`) по указанному адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4135">Stores an object reference (type `O`) value at a given address.</span></span>|  
  
 <span data-ttu-id="de49f-4136">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4136">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4137">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4137">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4138">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4138">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-4139">Значение и адрес извлекаются из стека; значение хранится по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4139">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="de49f-4140">Инструкция `stind.ref` сохраняет значение ссылки на объект по указанному адресу (тип `native int`, `*` или `&`).</span><span class="sxs-lookup"><span data-stu-id="de49f-4140">The `stind.ref` instruction stores an object reference value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="de49f-4141">Для операции с типом "безопасно" требуется, чтобы инструкция `stind.ref` соответствовала типу указателя.</span><span class="sxs-lookup"><span data-stu-id="de49f-4141">Type safe operation requires that the `stind.ref` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="de49f-4142">Операция `stind.ref` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4142">The operation of the `stind.ref` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de49f-4143"><xref:System.NullReferenceException> возникает, если `addr` не согласуется естественным образом с типом аргумента, подразумеваемым суффиксом инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-4143"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="de49f-4144">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stind.ref`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4144">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4145">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4145">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4146">Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с заданным индексом.</span><span class="sxs-lookup"><span data-stu-id="de49f-4146">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4147">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4147">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4148">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4148">Format</span></span>|<span data-ttu-id="de49f-4149">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4149">Assembly Format</span></span>|<span data-ttu-id="de49f-4150">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4150">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4151">FE 0E < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="de49f-4151">FE 0E < `unsigned int16` ></span></span>|<span data-ttu-id="de49f-4152">требовалась stloc `index`</span><span class="sxs-lookup"><span data-stu-id="de49f-4152">stloc `index`</span></span>|<span data-ttu-id="de49f-4153">Извлекает значение из стека и сохраняет его в локальной переменной `index`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4153">Pops a value from the stack and stores it in local variable `index`.</span></span>|  
  
 <span data-ttu-id="de49f-4154">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4154">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4155">Значение извлекается из стека и помещается в локальную переменную `index`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4155">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="de49f-4156">Инструкция `stloc` выводит верхнее значение из стека вычислений и перемещает его в локальную переменную с номером `index`, где локальные переменные нумеруются 0 – назад.</span><span class="sxs-lookup"><span data-stu-id="de49f-4156">The `stloc` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="de49f-4157">Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-4157">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="de49f-4158">При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную.</span><span class="sxs-lookup"><span data-stu-id="de49f-4158">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="de49f-4159">Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.</span><span class="sxs-lookup"><span data-stu-id="de49f-4159">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="de49f-4160">Для правильных инструкций промежуточного языка MSIL требуется, чтобы `index` был допустимым локальным индексом.</span><span class="sxs-lookup"><span data-stu-id="de49f-4160">Correct Microsoft Intermediate Language (MSIL) instructions require that `index` be a valid local index.</span></span> <span data-ttu-id="de49f-4161">Для инструкции `stloc` `index` должно находиться в диапазоне от 0 до 65534 включительно (в частности, 65535 является недопустимым).</span><span class="sxs-lookup"><span data-stu-id="de49f-4161">For the `stloc` instruction, `index` must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid).</span></span> <span data-ttu-id="de49f-4162">Исключение 65535 является практичным: вероятные реализации будут использовать 2-байтовое целое число для трассировки как индекса локальной версии, так и общего числа локальных переменных для данного метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-4162">The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method.</span></span> <span data-ttu-id="de49f-4163">Если индекс 65535 был сделан допустимым, для записи числа локальных переменных в таком методе потребуется более широкое целое число.</span><span class="sxs-lookup"><span data-stu-id="de49f-4163">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="de49f-4164">Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `stloc`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4164">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4165">ILGenerator. Emit (код операции, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="de49f-4165">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="de49f-4166">ILGenerator. Emit (код операции, короткий)</span><span class="sxs-lookup"><span data-stu-id="de49f-4166">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4167">Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-4167">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4168">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4168">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4169">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4169">Format</span></span>|<span data-ttu-id="de49f-4170">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4170">Assembly Format</span></span>|<span data-ttu-id="de49f-4171">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4171">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4172">0A</span><span class="sxs-lookup"><span data-stu-id="de49f-4172">0A</span></span>|<span data-ttu-id="de49f-4173">требовалась stloc. 0</span><span class="sxs-lookup"><span data-stu-id="de49f-4173">stloc.0</span></span>|<span data-ttu-id="de49f-4174">Извлекает значение из стека в локальную переменную 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-4174">Pops a value from the stack into local variable 0.</span></span>|  
  
 <span data-ttu-id="de49f-4175">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4175">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4176">Значение извлекается из стека и помещается в локальную переменную с индексом 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-4176">A value is popped off of the stack and placed in the local variable indexed by 0.</span></span>  
  
 <span data-ttu-id="de49f-4177">Инструкция `stloc.0` извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-4177">The `stloc.0` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0.</span></span> <span data-ttu-id="de49f-4178">Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-4178">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="de49f-4179">`stloc.0` является особенно эффективным кодированием для хранения значений в локальной переменной 0.</span><span class="sxs-lookup"><span data-stu-id="de49f-4179">`stloc.0` is an especially efficient encoding for storing values in local variable 0.</span></span>  
  
 <span data-ttu-id="de49f-4180">При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную.</span><span class="sxs-lookup"><span data-stu-id="de49f-4180">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="de49f-4181">Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.</span><span class="sxs-lookup"><span data-stu-id="de49f-4181">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="de49f-4182">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stloc.0`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4182">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4183">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4183">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4184">Извлекает верхнее значение из стека вычислений и сохраняет его в списке локальных переменных с индексом 1.</span><span class="sxs-lookup"><span data-stu-id="de49f-4184">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4185">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4185">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4186">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4186">Format</span></span>|<span data-ttu-id="de49f-4187">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4187">Assembly Format</span></span>|<span data-ttu-id="de49f-4188">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4188">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4189">0B</span><span class="sxs-lookup"><span data-stu-id="de49f-4189">0B</span></span>|<span data-ttu-id="de49f-4190">требовалась stloc. 1</span><span class="sxs-lookup"><span data-stu-id="de49f-4190">stloc.1</span></span>|<span data-ttu-id="de49f-4191">Извлекает значение из стека в локальную переменную 1.</span><span class="sxs-lookup"><span data-stu-id="de49f-4191">Pops a value from the stack into local variable 1.</span></span>|  
  
 <span data-ttu-id="de49f-4192">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4192">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4193">Значение извлекается из стека и помещается в локальную переменную с индексом 1.</span><span class="sxs-lookup"><span data-stu-id="de49f-4193">A value is popped off of the stack and placed in the local variable indexed by 1.</span></span>  
  
 <span data-ttu-id="de49f-4194">Инструкция `stloc.1` извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 1.</span><span class="sxs-lookup"><span data-stu-id="de49f-4194">The `stloc.1` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1.</span></span> <span data-ttu-id="de49f-4195">Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-4195">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="de49f-4196">`stloc.1` является особенно эффективным кодированием для хранения значений в локальной переменной 1.</span><span class="sxs-lookup"><span data-stu-id="de49f-4196">`stloc.1` is an especially efficient encoding for storing values in local variable 1.</span></span>  
  
 <span data-ttu-id="de49f-4197">При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную.</span><span class="sxs-lookup"><span data-stu-id="de49f-4197">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="de49f-4198">Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.</span><span class="sxs-lookup"><span data-stu-id="de49f-4198">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="de49f-4199">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stloc.1`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4199">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4200">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4200">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4201">Извлекает верхнее значение из стека вычислений и сохраняет его в списке локальных переменных с индексом 2.</span><span class="sxs-lookup"><span data-stu-id="de49f-4201">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4202">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4202">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4203">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4203">Format</span></span>|<span data-ttu-id="de49f-4204">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4204">Assembly Format</span></span>|<span data-ttu-id="de49f-4205">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4205">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4206">0C</span><span class="sxs-lookup"><span data-stu-id="de49f-4206">0C</span></span>|<span data-ttu-id="de49f-4207">требовалась stloc. 2</span><span class="sxs-lookup"><span data-stu-id="de49f-4207">stloc.2</span></span>|<span data-ttu-id="de49f-4208">Извлекает значение из стека в локальную переменную 2</span><span class="sxs-lookup"><span data-stu-id="de49f-4208">Pops a value from the stack into local variable 2</span></span>|  
  
 <span data-ttu-id="de49f-4209">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4209">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4210">Значение извлекается из стека и помещается в локальную переменную с индексом 2.</span><span class="sxs-lookup"><span data-stu-id="de49f-4210">A value is popped off of the stack and placed in the local variable indexed by 2.</span></span>  
  
 <span data-ttu-id="de49f-4211">Инструкция `stloc.2` извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 2.</span><span class="sxs-lookup"><span data-stu-id="de49f-4211">The `stloc.2` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2.</span></span> <span data-ttu-id="de49f-4212">Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-4212">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="de49f-4213">`stloc.2` является особенно эффективным кодированием для хранения значений в локальной переменной 2.</span><span class="sxs-lookup"><span data-stu-id="de49f-4213">`stloc.2` is an especially efficient encoding for storing values in local variable 2.</span></span>  
  
 <span data-ttu-id="de49f-4214">При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную.</span><span class="sxs-lookup"><span data-stu-id="de49f-4214">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="de49f-4215">Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.</span><span class="sxs-lookup"><span data-stu-id="de49f-4215">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="de49f-4216">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stloc.2`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4216">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4217">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4217">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4218">Извлекает верхнее значение из стека вычислений и сохраняет его в списке локальных переменных с индексом 3.</span><span class="sxs-lookup"><span data-stu-id="de49f-4218">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4219">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4219">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4220">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4220">Format</span></span>|<span data-ttu-id="de49f-4221">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4221">Assembly Format</span></span>|<span data-ttu-id="de49f-4222">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4222">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4223">0D</span><span class="sxs-lookup"><span data-stu-id="de49f-4223">0D</span></span>|<span data-ttu-id="de49f-4224">требовалась stloc. 3</span><span class="sxs-lookup"><span data-stu-id="de49f-4224">stloc.3</span></span>|<span data-ttu-id="de49f-4225">Извлекает значение из стека в локальную переменную 3</span><span class="sxs-lookup"><span data-stu-id="de49f-4225">Pops a value from the stack into local variable 3</span></span>|  
  
 <span data-ttu-id="de49f-4226">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4226">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4227">Значение извлекается из стека и помещается в локальную переменную с индексом 3.</span><span class="sxs-lookup"><span data-stu-id="de49f-4227">A value is popped off of the stack and placed in the local variable indexed by 3.</span></span>  
  
 <span data-ttu-id="de49f-4228">Инструкция `stloc.3` извлекает верхнее значение из стека вычислений и перемещает его в локальную переменную с индексом 3.</span><span class="sxs-lookup"><span data-stu-id="de49f-4228">The `stloc.3` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3.</span></span> <span data-ttu-id="de49f-4229">Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-4229">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="de49f-4230">`stloc.3` является особенно эффективным кодированием для хранения значений в локальной переменной 3.</span><span class="sxs-lookup"><span data-stu-id="de49f-4230">`stloc.3` is an especially efficient encoding for storing values in local variable 3.</span></span>  
  
 <span data-ttu-id="de49f-4231">При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную.</span><span class="sxs-lookup"><span data-stu-id="de49f-4231">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="de49f-4232">Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.</span><span class="sxs-lookup"><span data-stu-id="de49f-4232">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="de49f-4233">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stloc.3`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4233">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4234">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4234">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4235">Извлекает верхнее значение в стеке вычислений и сохраняет его в списке локальных переменных с индексом <paramref name="index" /> (короткая форма).</span><span class="sxs-lookup"><span data-stu-id="de49f-4235">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <paramref name="index" /> (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4236">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4236">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4237">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4237">Format</span></span>|<span data-ttu-id="de49f-4238">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4238">Assembly Format</span></span>|<span data-ttu-id="de49f-4239">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4239">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4240">13 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="de49f-4240">13 < `unsigned int8` ></span></span>|<span data-ttu-id="de49f-4241">требовалась stloc. s `index`</span><span class="sxs-lookup"><span data-stu-id="de49f-4241">stloc.s `index`</span></span>|<span data-ttu-id="de49f-4242">Извлекает значение из стека и сохраняет его в локальной переменной `index` (краткая форма).</span><span class="sxs-lookup"><span data-stu-id="de49f-4242">Pops a value from the stack and stores it in local variable `index`, short form.</span></span>|  
  
 <span data-ttu-id="de49f-4243">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4243">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4244">Значение извлекается из стека и помещается в локальную переменную `index`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4244">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="de49f-4245">Инструкция `stloc.s` выводит верхнее значение из стека вычислений и перемещает его в локальную переменную с номером `index`, где локальные переменные нумеруются 0 – назад.</span><span class="sxs-lookup"><span data-stu-id="de49f-4245">The `stloc.s` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="de49f-4246">Тип значения должен соответствовать типу локальной переменной, как указано в локальной сигнатуре текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-4246">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="de49f-4247">Инструкция `stloc.s` обеспечивает эффективную кодировку для локальных переменных от 0 до 255.</span><span class="sxs-lookup"><span data-stu-id="de49f-4247">The `stloc.s` instruction provides an efficient encoding for local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="de49f-4248">При хранении в локальных переменных, содержащих целочисленное значение менее 4 байт, происходит усечение значения при перемещении из стека в локальную переменную.</span><span class="sxs-lookup"><span data-stu-id="de49f-4248">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="de49f-4249">Значения с плавающей запятой округляются от их собственного размера (тип `F`) до размера, связанного с аргументом.</span><span class="sxs-lookup"><span data-stu-id="de49f-4249">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="de49f-4250">Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `stloc.s`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4251">ILGenerator. Emit (код операции, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="de49f-4251">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="de49f-4252">ILGenerator. Emit (код операции, байт)</span><span class="sxs-lookup"><span data-stu-id="de49f-4252">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4253">Копирует значение с заданным типом из стека вычислений в указанный адрес памяти.</span><span class="sxs-lookup"><span data-stu-id="de49f-4253">Copies a value of a specified type from the evaluation stack into a supplied memory address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4254">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4254">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4255">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4255">Format</span></span>|<span data-ttu-id="de49f-4256">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4256">Assembly Format</span></span>|<span data-ttu-id="de49f-4257">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4257">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4258">81 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-4258">81 < `T` ></span></span>|<span data-ttu-id="de49f-4259">stobj `class`</span><span class="sxs-lookup"><span data-stu-id="de49f-4259">stobj `class`</span></span>|<span data-ttu-id="de49f-4260">Сохраняет значение типа `class` из стека в память.</span><span class="sxs-lookup"><span data-stu-id="de49f-4260">Stores a value of type `class` from the stack into memory.</span></span>|  
  
 <span data-ttu-id="de49f-4261">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4261">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4262">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4262">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4263">Объект типа значения типа `class` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4263">A value type object of type `class` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-4264">Объект и адрес извлекаются из стека; Объект типа значения хранится по адресу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4264">The object and the address are popped from the stack; the value type object is stored at the address.</span></span>  
  
 <span data-ttu-id="de49f-4265">Инструкция `stobj` копирует объект типа значения в адрес, указанный в адресе (указатель типа `native int`, `*` или `&`).</span><span class="sxs-lookup"><span data-stu-id="de49f-4265">The `stobj` instruction copies the value type object into the address specified by the address (a pointer of type `native int`, `*`, or `&`).</span></span> <span data-ttu-id="de49f-4266">Число копируемых байтов зависит от размера класса, представленного `class`, маркера метаданных, представляющего тип значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-4266">The number of bytes copied depends on the size of the class represented by `class`, a metadata token representing a value type.</span></span>  
  
 <span data-ttu-id="de49f-4267">Операция `stobj` может быть изменена непосредственно перед инструкциями префикса <xref:System.Reflection.Emit.OpCodes.Volatile> или <xref:System.Reflection.Emit.OpCodes.Unaligned>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4267">The operation of the `stobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="de49f-4268">Если класс не найден, возникает исключение <xref:System.TypeLoadException>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4268"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="de49f-4269">Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-4269">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
 <span data-ttu-id="de49f-4270">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stobj`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4270">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stobj` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4271">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-4271">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4272">Заменяет значение статического поля на значение из стека вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-4272">Replaces the value of a static field with a value from the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4273">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4273">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4274">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4274">Format</span></span>|<span data-ttu-id="de49f-4275">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4275">Assembly Format</span></span>|<span data-ttu-id="de49f-4276">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4276">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4277">80 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-4277">80 < `T` ></span></span>|<span data-ttu-id="de49f-4278">stsfld `field`</span><span class="sxs-lookup"><span data-stu-id="de49f-4278">stsfld `field`</span></span>|<span data-ttu-id="de49f-4279">Заменяет значение в `field` на заданное значение.</span><span class="sxs-lookup"><span data-stu-id="de49f-4279">Replaces the value in `field` with a supplied value.</span></span>|  
  
 <span data-ttu-id="de49f-4280">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4280">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4281">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4281">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4282">Значение извлекается из стека и сохраняется в `field`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4282">A value is popped from the stack and stored in `field`.</span></span>  
  
 <span data-ttu-id="de49f-4283">Инструкция `stsfld` заменяет значение статического поля значением из стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-4283">The `stsfld` instruction replaces the value of a static field with a value from the stack.</span></span> <span data-ttu-id="de49f-4284">`field` является маркером метаданных, который должен ссылаться на член статического поля.</span><span class="sxs-lookup"><span data-stu-id="de49f-4284">`field` is a metadata token that must refer to a static field member.</span></span>  
  
 <span data-ttu-id="de49f-4285">Инструкция `stsfld` может иметь префикс <xref:System.Reflection.Emit.OpCodes.Volatile>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4285">The `stsfld` instruction may be prefixed by <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="de49f-4286">Если поле не найдено в метаданных, возникает исключение <xref:System.MissingFieldException>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4286"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="de49f-4287">Обычно это проверяется при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-4287">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="de49f-4288">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `stsfld`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4288">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stsfld` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4289">ILGenerator. Emit (код операции, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="de49f-4289">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4290">Вычитает одно значение из другого и помещает результат в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-4290">Subtracts one value from another and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4291">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4291">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4292">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4292">Format</span></span>|<span data-ttu-id="de49f-4293">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4293">Assembly Format</span></span>|<span data-ttu-id="de49f-4294">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4294">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4295">59</span><span class="sxs-lookup"><span data-stu-id="de49f-4295">59</span></span>|<span data-ttu-id="de49f-4296">sub</span><span class="sxs-lookup"><span data-stu-id="de49f-4296">sub</span></span>|<span data-ttu-id="de49f-4297">Вычитает одно значение из другого, возвращая новое числовое значение.</span><span class="sxs-lookup"><span data-stu-id="de49f-4297">Subtracts one value from another, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="de49f-4298">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4298">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4299">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4299">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4300">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4300">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-4301">`value2` и `value1` извлекаются из стека; `value2` вычитается из `value1`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4301">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1`.</span></span>  
  
4.  <span data-ttu-id="de49f-4302">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4302">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-4303">Переполнение не обнаружено для целочисленных операций (для правильной обработки переполнения см. <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span><span class="sxs-lookup"><span data-stu-id="de49f-4303">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span></span>  
  
 <span data-ttu-id="de49f-4304">Вычитание целых чисел заключается в переносе, а не в насыщенность.</span><span class="sxs-lookup"><span data-stu-id="de49f-4304">Integer subtraction wraps, rather than saturates.</span></span> <span data-ttu-id="de49f-4305">Например, если предположить 8-разрядные целые числа, где `value1` имеет значение 0, а `value2` имеет значение 1, то "упакованный" результат будет 255.</span><span class="sxs-lookup"><span data-stu-id="de49f-4305">For example: assuming 8-bit integers, where `value1` is set to 0 and `value2` is set to 1, the "wrapped" result will be 255.</span></span>  
  
 <span data-ttu-id="de49f-4306">Переполнение с плавающей точкой возвращает `+inf` (`PositiveInfinity`) или `-inf` (`NegativeInfinity`).</span><span class="sxs-lookup"><span data-stu-id="de49f-4306">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="de49f-4307">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `sub`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4307">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4308">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4308">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4309">Вычитает одно целочисленное значение из другого, выполняет проверку переполнения и помещает результат в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-4309">Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4310">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4310">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4311">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4311">Format</span></span>|<span data-ttu-id="de49f-4312">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4312">Assembly Format</span></span>|<span data-ttu-id="de49f-4313">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4313">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4314">DA</span><span class="sxs-lookup"><span data-stu-id="de49f-4314">DA</span></span>|<span data-ttu-id="de49f-4315">подovf</span><span class="sxs-lookup"><span data-stu-id="de49f-4315">sub.ovf</span></span>|<span data-ttu-id="de49f-4316">Вычитает одно целочисленное значение из другого с помощью проверки переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-4316">Subtracts one integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="de49f-4317">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4317">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4318">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4318">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4319">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4319">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-4320">`value2` и `value1` извлекаются из стека; `value2` вычитается из `value1` с помощью проверки переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-4320">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="de49f-4321">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4321">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-4322"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-4322"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-4323">Эта операция выполняется над целыми числами со знаком. для значений с плавающей запятой используйте <xref:System.Reflection.Emit.OpCodes.Sub>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4323">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="de49f-4324">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `sub.ovf`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4324">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4325">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4325">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4326">Вычитает одно целочисленное значение без знака из другого, выполняет проверку переполнения и помещает результат в стек вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-4326">Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4327">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4327">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4328">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4328">Format</span></span>|<span data-ttu-id="de49f-4329">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4329">Assembly Format</span></span>|<span data-ttu-id="de49f-4330">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4330">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4331">DB</span><span class="sxs-lookup"><span data-stu-id="de49f-4331">DB</span></span>|<span data-ttu-id="de49f-4332">ovf. un</span><span class="sxs-lookup"><span data-stu-id="de49f-4332">sub.ovf.un</span></span>|<span data-ttu-id="de49f-4333">Вычитает одно целочисленное значение без знака из другого с помощью проверки переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-4333">Subtracts one unsigned integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="de49f-4334">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4334">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4335">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4335">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4336">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4336">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-4337">`value2` и `value1` извлекаются из стека; `value2` вычитается из `value1` с помощью проверки переполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-4337">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="de49f-4338">Результат помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4338">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-4339"><xref:System.OverflowException> создается, если результат не может быть представлен типом результата.</span><span class="sxs-lookup"><span data-stu-id="de49f-4339"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="de49f-4340">Эта операция выполняется над целыми числами со знаком. для значений с плавающей запятой используйте <xref:System.Reflection.Emit.OpCodes.Sub>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4340">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="de49f-4341">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `sub.ovf.un`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4341">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4342">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4342">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4343">Реализует таблицу переходов.</span><span class="sxs-lookup"><span data-stu-id="de49f-4343">Implements a jump table.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4344">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4344">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4345">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4345">Format</span></span>|<span data-ttu-id="de49f-4346">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4346">Assembly Format</span></span>|<span data-ttu-id="de49f-4347">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4347">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4348">45 < `unsigned int32` > < `int32` >... < `int32` ></span><span class="sxs-lookup"><span data-stu-id="de49f-4348">45 < `unsigned int32` > < `int32` >... < `int32` ></span></span>|<span data-ttu-id="de49f-4349">Switch (`N`, `t1`, `t2`... `tN`)</span><span class="sxs-lookup"><span data-stu-id="de49f-4349">switch (`N`, `t1`, `t2`... `tN`)</span></span>|<span data-ttu-id="de49f-4350">Переходит к одному из значений `N`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4350">Jumps to one of `N` values.</span></span>|  
  
 <span data-ttu-id="de49f-4351">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4351">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4352">Значение помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4352">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4353">Значение извлекается из стека, и выполнение передается в инструкцию со смещением, индексированным по значению, где значение меньше `N`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4353">The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than `N`.</span></span>  
  
 <span data-ttu-id="de49f-4354">Инструкция `switch` реализует таблицу переходов.</span><span class="sxs-lookup"><span data-stu-id="de49f-4354">The `switch` instruction implements a jump table.</span></span> <span data-ttu-id="de49f-4355">Инструкция имеет следующий формат: `unsigned int32`, представляющее количество целевых объектов `N`, за которыми следуют значения `N` Int32, указывающие цели перехода.</span><span class="sxs-lookup"><span data-stu-id="de49f-4355">The format of the instruction is an `unsigned int32` representing the number of targets `N`, followed by `N` int32 values specifying jump targets.</span></span> <span data-ttu-id="de49f-4356">Эти целевые объекты представлены в виде смещений (положительных или отрицательных) от начала инструкции, следующей за инструкцией `switch`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4356">These targets are represented as offsets (positive or negative) from the beginning of the instruction following this `switch` instruction.</span></span>  
  
 <span data-ttu-id="de49f-4357">Инструкция `switch` извлекает значение из стека и сравнивает его как целое число без знака с `N`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4357">The `switch` instruction pops a value off the stack and compares it, as an unsigned integer, to `N`.</span></span> <span data-ttu-id="de49f-4358">Если значение меньше `N`, выполнение передается в целевой индекс по значению, где конечные объекты нумеруются от 0 (например, значение 0 принимает первый целевой объект, значение 1 принимает второй целевой объект и т. д.).</span><span class="sxs-lookup"><span data-stu-id="de49f-4358">If value is less than `N`, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on).</span></span> <span data-ttu-id="de49f-4359">Если значение больше или равно `N`, выполнение продолжится в следующей инструкции (с переходом).</span><span class="sxs-lookup"><span data-stu-id="de49f-4359">If the value is greater than or equal to `N`, execution continues at the next instruction (fall through).</span></span>  
  
 <span data-ttu-id="de49f-4360">Если целевая инструкция имеет один или несколько префиксных кодов, управление может быть передано только первому из этих префиксов.</span><span class="sxs-lookup"><span data-stu-id="de49f-4360">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="de49f-4361">Управление передачей в блоки `try`, `catch`, `filter` и `finally` не может быть выполнено этой инструкцией.</span><span class="sxs-lookup"><span data-stu-id="de49f-4361">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span> <span data-ttu-id="de49f-4362">(Такие передачи сильно ограничены и должны использовать инструкцию Leave).</span><span class="sxs-lookup"><span data-stu-id="de49f-4362">(Such transfers are severely restricted and must use the leave instruction instead).</span></span>  
  
 <span data-ttu-id="de49f-4363">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `switch`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4363">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `switch` opcode.</span></span> <span data-ttu-id="de49f-4364">Аргумент `Label[]` является массивом меток, представляющих 32-разрядные смещения.</span><span class="sxs-lookup"><span data-stu-id="de49f-4364">The `Label[]` argument is an array of Labels representing 32-bit offsets.</span></span>  
  
-   <span data-ttu-id="de49f-4365">ILGenerator. Emit (код операции, метка [])</span><span class="sxs-lookup"><span data-stu-id="de49f-4365">ILGenerator.Emit(OpCode, Label[])</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="de49f-4366">В следующем образце кода показано использование кода операции `Switch` для создания таблицы переходов с помощью массива <xref:System.Reflection.Emit.Label>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4366">The following code sample illustrates the use of the `Switch` opcode to generate a jump table using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4367">Выполняет инструкцию вызова метода (префиксом которой является), предварительно удаляя кадр стека текущего метода.</span><span class="sxs-lookup"><span data-stu-id="de49f-4367">Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4368">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4368">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4369">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4369">Format</span></span>|<span data-ttu-id="de49f-4370">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4370">Assembly Format</span></span>|<span data-ttu-id="de49f-4371">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4371">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4372">FE 14</span><span class="sxs-lookup"><span data-stu-id="de49f-4372">FE 14</span></span>|<span data-ttu-id="de49f-4373">односторонне.</span><span class="sxs-lookup"><span data-stu-id="de49f-4373">tail.</span></span>|<span data-ttu-id="de49f-4374">Последующий вызов завершает текущие методы</span><span class="sxs-lookup"><span data-stu-id="de49f-4374">Subsequent call terminates current methods</span></span>|  
  
 <span data-ttu-id="de49f-4375">Для этой инструкции не определено поведение перехода стека.</span><span class="sxs-lookup"><span data-stu-id="de49f-4375">There is no stack transition behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="de49f-4376">Инструкция префикса `tail` должна находиться непосредственно перед инструкцией <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli> или <xref:System.Reflection.Emit.OpCodes.Callvirt>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4376">The `tail` prefix instruction must immediately precede a <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, or <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction.</span></span> <span data-ttu-id="de49f-4377">Указывает, что кадр стека текущего метода должен быть удален перед выполнением инструкции вызова.</span><span class="sxs-lookup"><span data-stu-id="de49f-4377">It indicates that the current method's stack frame should be removed before the call instruction is executed.</span></span> <span data-ttu-id="de49f-4378">Также подразумевается, что значение, возвращаемое из следующего вызова, является также значением, возвращаемым текущим методом, и поэтому вызов может быть преобразован в переход между методами.</span><span class="sxs-lookup"><span data-stu-id="de49f-4378">It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</span></span>  
  
 <span data-ttu-id="de49f-4379">Стек должен быть пустым, за исключением аргументов, передаваемых следующим вызовом.</span><span class="sxs-lookup"><span data-stu-id="de49f-4379">The stack must be empty except for the arguments being transferred by the following call.</span></span> <span data-ttu-id="de49f-4380">Инструкция, следующая за инструкцией Call, должна быть Ret. Таким образом, единственной допустимой последовательностью кода является `tail. call` (или `calli` или `callvirt`).</span><span class="sxs-lookup"><span data-stu-id="de49f-4380">The instruction following the call instruction must be a ret. Thus the only valid code sequence is `tail. call` (or `calli` or `callvirt`).</span></span> <span data-ttu-id="de49f-4381">Правильные инструкции промежуточного языка MSIL не должны выполнять переход к инструкции `call`, но они могут выполнять переход к последующей <xref:System.Reflection.Emit.OpCodes.Ret>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4381">Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the `call` instruction, but they may branch to the subsequent <xref:System.Reflection.Emit.OpCodes.Ret>.</span></span>  
  
 <span data-ttu-id="de49f-4382">Текущий кадр не может быть отклонен, если управление передается из ненадежного кода в доверенный код, так как это может подвергнуть риску безопасность идентификации кода.</span><span class="sxs-lookup"><span data-stu-id="de49f-4382">The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security.</span></span> <span data-ttu-id="de49f-4383">Таким образом, .NET Framework проверки безопасности могут вызвать игнорирование `tail`, при этом будет использоваться стандартная инструкция <xref:System.Reflection.Emit.OpCodes.Call>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4383">The .NET Framework security checks can therefore cause the `tail` to be ignored, leaving a standard <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span> <span data-ttu-id="de49f-4384">Аналогично, чтобы выйти из синхронизированной области после возврата вызова, префикс `tail` игнорируется при использовании для выхода из метода, помеченного как синхронизированный.</span><span class="sxs-lookup"><span data-stu-id="de49f-4384">Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the `tail` prefix is ignored when used to exit a method that is marked synchronized.</span></span>  
  
 <span data-ttu-id="de49f-4385">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `tail`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4385">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `tail` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4386">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4386">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst"><span data-ttu-id="de49f-4387">Экземпляр объекта Opcode.</span><span class="sxs-lookup"><span data-stu-id="de49f-4387">An instance of an Opcode object.</span></span></param>
        <summary><span data-ttu-id="de49f-4388">Возвращает true или false, в зависимости от того, принимает ли заданный код операции однобайтовый аргумент.</span><span class="sxs-lookup"><span data-stu-id="de49f-4388">Returns true or false if the supplied opcode takes a single byte argument.</span></span></summary>
        <returns><span data-ttu-id="de49f-4389"><see langword="true" /> или <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-4389"><see langword="true" /> or <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4390">Этот метод можно использовать для определения того, какие коды MSIL являются "короткими формами", для использования в оптимизированном коде.</span><span class="sxs-lookup"><span data-stu-id="de49f-4390">This method can be used to find which MSIL opcodes are "short form", for use in optimized code.</span></span>  
  
 <span data-ttu-id="de49f-4391">`TakesSingleByteArgument` возвращает значение `true`, если экземпляр <xref:System.Reflection.Emit.OpCode> принимает один байтовый аргумент в следующих случаях:</span><span class="sxs-lookup"><span data-stu-id="de49f-4391">`TakesSingleByteArgument` returns `true` if the <xref:System.Reflection.Emit.OpCode> instance takes a single byte argument in the following cases:</span></span>  
  
-   <span data-ttu-id="de49f-4392">Код операции выполняет инструкцию ветвления с адресом в байтовой кодировке (например, <xref:System.Reflection.Emit.OpCodes.Br_S> и <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span><span class="sxs-lookup"><span data-stu-id="de49f-4392">The opcode performs a branch instruction to a byte-sized address (for example, <xref:System.Reflection.Emit.OpCodes.Br_S> and <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span></span>  
  
-   <span data-ttu-id="de49f-4393">Код операции помещает значение байта в стек (например, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span><span class="sxs-lookup"><span data-stu-id="de49f-4393">The opcode pushes a byte value onto the stack (for example, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span></span>  
  
-   <span data-ttu-id="de49f-4394">Код операции ссылается на переменную или аргумент с помощью короткой формы размером байта (например, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> и <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span><span class="sxs-lookup"><span data-stu-id="de49f-4394">The opcode references a variable or argument via the byte-sized "short form" (for example, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> and <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span></span>  
  
 <span data-ttu-id="de49f-4395">В противном случае она возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4395">Otherwise, it returns `false`.</span></span>  
  
 <span data-ttu-id="de49f-4396">В приведенном ниже примере показано использование `TakesSingleByteArgument` в соответствии с классом `OpCodes` и тестированием, чтобы определить, принимает ли каждое поле `OpCode` однобайтовый аргумент.</span><span class="sxs-lookup"><span data-stu-id="de49f-4396">The example below demonstrates the use of `TakesSingleByteArgument` by reflecting on to the `OpCodes` class and testing to see whether each `OpCode` field takes a single-byte argument.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4397">Создает объект исключения, находящийся в стеке вычислений.</span><span class="sxs-lookup"><span data-stu-id="de49f-4397">Throws the exception object currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4398">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4398">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4399">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4399">Format</span></span>|<span data-ttu-id="de49f-4400">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4400">Assembly Format</span></span>|<span data-ttu-id="de49f-4401">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4401">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4402">7а</span><span class="sxs-lookup"><span data-stu-id="de49f-4402">7A</span></span>|<span data-ttu-id="de49f-4403">throw</span><span class="sxs-lookup"><span data-stu-id="de49f-4403">throw</span></span>|<span data-ttu-id="de49f-4404">Создает исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-4404">Throws an exception.</span></span>|  
  
 <span data-ttu-id="de49f-4405">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4405">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4406">Ссылка на объект (исключение) помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4406">An object reference (to an exception) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4407">Ссылка на объект извлекается из стека и вызывается исключение.</span><span class="sxs-lookup"><span data-stu-id="de49f-4407">The object reference is popped from the stack and the exception thrown.</span></span>  
  
 <span data-ttu-id="de49f-4408">Инструкция `throw` создает объект исключения (тип `O`) в данный момент в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-4408">The `throw` instruction throws the exception object (type `O`) currently on the stack.</span></span>  
  
 <span data-ttu-id="de49f-4409"><xref:System.NullReferenceException> создается, если ссылка на объект является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-4409"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-4410">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `throw`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4410">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `throw` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4411">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4411">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4412">Указывает, что адрес на вершине стека, возможно, не выровнен по естественному размеру следующей непосредственно за ним инструкции <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" /> или <see langword="cpblk" />.</span><span class="sxs-lookup"><span data-stu-id="de49f-4412">Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" />, or <see langword="cpblk" /> instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4413">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4413">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4414">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4414">Format</span></span>|<span data-ttu-id="de49f-4415">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4415">Assembly Format</span></span>|<span data-ttu-id="de49f-4416">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4416">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4417">`unsigned int8`< FE 12  ></span><span class="sxs-lookup"><span data-stu-id="de49f-4417">FE 12 < `unsigned int8` ></span></span>|<span data-ttu-id="de49f-4418">невыровненным.</span><span class="sxs-lookup"><span data-stu-id="de49f-4418">unaligned.</span></span> `alignment`|<span data-ttu-id="de49f-4419">Указывает, что последующая инструкция указателя может быть несогласованной.</span><span class="sxs-lookup"><span data-stu-id="de49f-4419">Indicates that the subsequent pointer instruction may be unaligned.</span></span>|  
  
 <span data-ttu-id="de49f-4420">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4420">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4421">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4421">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-4422">`Unaligned` указывает, что адрес (неуправляемый указатель, `native int`) в стеке может не соответствовать естественному размеру сразу после `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk` или `cpblk`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4422">`Unaligned` specifies that the address (an unmanaged pointer, `native int`) on the stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="de49f-4423">То есть для инструкции <xref:System.Reflection.Emit.OpCodes.Ldind_I4> выравнивание адреса может не доставлять 4 байта.</span><span class="sxs-lookup"><span data-stu-id="de49f-4423">That is, for a <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instruction the alignment of the address may not be to a 4-byte boundary.</span></span> <span data-ttu-id="de49f-4424">Для `initblk` и `cpblk` выравнивание по умолчанию зависит от архитектуры (4-байтный на 32-разрядных ЦП, 8-байт на 64-разрядных ЦП).</span><span class="sxs-lookup"><span data-stu-id="de49f-4424">For `initblk` and `cpblk` the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs).</span></span> <span data-ttu-id="de49f-4425">Генераторы кода, которые не ограничивают свои выходные данные размером 32-разрядного слова, должны использовать `unaligned`, если во время компиляции неизвестно 8-байтное выравнивание.</span><span class="sxs-lookup"><span data-stu-id="de49f-4425">Code generators that do not restrict their output to a 32-bit word size must use `unaligned` if the alignment is not known at compile time to be 8-byte.</span></span>  
  
 <span data-ttu-id="de49f-4426">Значение выравнивания должно быть равно 1, 2 или 4 и означает, что созданный код должен предположить, что адрес имеет тип Byte, двухбайтовые или четыре байта соответственно.</span><span class="sxs-lookup"><span data-stu-id="de49f-4426">The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively.</span></span> <span data-ttu-id="de49f-4427">Обратите внимание, что временные указатели (тип `*`) всегда согласовываются.</span><span class="sxs-lookup"><span data-stu-id="de49f-4427">Note that transient pointers (type `*`) are always aligned.</span></span>  
  
 <span data-ttu-id="de49f-4428">Хотя выравнивание для инструкции `cpblk` логически потребовало два числа (одно для источника и одно для назначения), не существует заметного влияния на производительность, если указано только меньшее число.</span><span class="sxs-lookup"><span data-stu-id="de49f-4428">While the alignment for a `cpblk` instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</span></span>  
  
 <span data-ttu-id="de49f-4429">Префиксы `unaligned` и `volatile` можно объединять в любом порядке.</span><span class="sxs-lookup"><span data-stu-id="de49f-4429">The `unaligned` and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="de49f-4430">Они должны непосредственно предшествовать инструкциям `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`или `cpblk`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4430">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="de49f-4431">Только префикс <xref:System.Reflection.Emit.OpCodes.Volatile> разрешен для инструкций <xref:System.Reflection.Emit.OpCodes.Ldsfld> и <xref:System.Reflection.Emit.OpCodes.Stsfld>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4431">Only the <xref:System.Reflection.Emit.OpCodes.Volatile> prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="de49f-4432">Следующие перегрузки метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> могут использовать код операции `unaligned`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4432">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `unaligned` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4433">ILGenerator. Emit (код операции, метка)</span><span class="sxs-lookup"><span data-stu-id="de49f-4433">ILGenerator.Emit(OpCode, Label)</span></span>  
  
-   <span data-ttu-id="de49f-4434">ILGenerator. Emit (код операции, байт)</span><span class="sxs-lookup"><span data-stu-id="de49f-4434">ILGenerator.Emit(Opcode, Byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4435">Преобразует тип значения из упакованной формы в распакованную.</span><span class="sxs-lookup"><span data-stu-id="de49f-4435">Converts the boxed representation of a value type to its unboxed form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4436">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4436">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4437">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4437">Format</span></span>|<span data-ttu-id="de49f-4438">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4438">Assembly Format</span></span>|<span data-ttu-id="de49f-4439">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4439">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4440">79 < `T` ></span><span class="sxs-lookup"><span data-stu-id="de49f-4440">79 < `T` ></span></span>|<span data-ttu-id="de49f-4441">Распаковка `valType`</span><span class="sxs-lookup"><span data-stu-id="de49f-4441">unbox `valType`</span></span>|<span data-ttu-id="de49f-4442">Извлекает данные типа значения из `obj`, его упакованного представления.</span><span class="sxs-lookup"><span data-stu-id="de49f-4442">Extracts the value type data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="de49f-4443">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4443">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4444">Ссылка на объект помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4444">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4445">Ссылка на объект извлекается из стека и распаковывается в указатель типа значения.</span><span class="sxs-lookup"><span data-stu-id="de49f-4445">The object reference is popped from the stack and unboxed to a value type pointer.</span></span>  
  
3.  <span data-ttu-id="de49f-4446">Указатель типа значения помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4446">The value type pointer is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-4447">Тип значения имеет два отдельных представления в Common Language Infrastructure (CLI):</span><span class="sxs-lookup"><span data-stu-id="de49f-4447">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="de49f-4448">Необработанная форма, используемая при внедрении типа значения в другой объект.</span><span class="sxs-lookup"><span data-stu-id="de49f-4448">A 'raw' form used when a value type is embedded within another object.</span></span>  
  
-   <span data-ttu-id="de49f-4449">"Упакованная" форма, в которой данные в типе значения упаковываются (упаковываются) в объект, поэтому он может существовать как независимая сущность.</span><span class="sxs-lookup"><span data-stu-id="de49f-4449">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="de49f-4450">Инструкция `unbox` преобразует ссылку на объект (тип `O`), упакованное представление типа значения в указатель типа значения (управляемый указатель, тип `&`), его неупакованную форму.</span><span class="sxs-lookup"><span data-stu-id="de49f-4450">The `unbox` instruction converts the object reference (type `O`), the boxed representation of a value type, to a value type pointer (a managed pointer, type `&`), its unboxed form.</span></span> <span data-ttu-id="de49f-4451">Указанный тип значения (`valType`) является маркером метаданных, указывающим тип значения, содержащегося в упакованном объекте.</span><span class="sxs-lookup"><span data-stu-id="de49f-4451">The supplied value type (`valType`) is a metadata token indicating the type of value type contained within the boxed object.</span></span>  
  
 <span data-ttu-id="de49f-4452">В отличие от <xref:System.Reflection.Emit.OpCodes.Box>, которое требуется для создания копии типа значения для использования в объекте, `unbox` не требуется копировать тип значения из объекта.</span><span class="sxs-lookup"><span data-stu-id="de49f-4452">Unlike <xref:System.Reflection.Emit.OpCodes.Box>, which is required to make a copy of a value type for use in the object, `unbox` is not required to copy the value type from the object.</span></span> <span data-ttu-id="de49f-4453">Обычно он просто выполняет вычисление адреса типа значения, уже присутствующего внутри упакованного объекта.</span><span class="sxs-lookup"><span data-stu-id="de49f-4453">Typically it simply computes the address of the value type that is already present inside of the boxed object.</span></span>  
  
 <span data-ttu-id="de49f-4454"><xref:System.InvalidCastException> создается, если объект не упакован как `valType`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4454"><xref:System.InvalidCastException> is thrown if the object is not boxed as `valType`.</span></span>  
  
 <span data-ttu-id="de49f-4455"><xref:System.NullReferenceException> создается, если ссылка на объект является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-4455"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-4456"><xref:System.TypeLoadException> возникает, если не удается найти тип значения `valType`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4456"><xref:System.TypeLoadException> is thrown if the value type `valType` cannot be found.</span></span> <span data-ttu-id="de49f-4457">Обычно это обнаруживается при преобразовании инструкций промежуточного языка MSIL в машинный код, а не во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="de49f-4457">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="de49f-4458">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `unbox`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4458">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4459">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-4459">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4460">Преобразует тип, указанный в инструкции, из упакованной формы в распакованную.</span><span class="sxs-lookup"><span data-stu-id="de49f-4460">Converts the boxed representation of a type specified in the instruction to its unboxed form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4461">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4461">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4462">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4462">Format</span></span>|<span data-ttu-id="de49f-4463">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4463">Assembly Format</span></span>|<span data-ttu-id="de49f-4464">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4464">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4465">`T`< A5  ></span><span class="sxs-lookup"><span data-stu-id="de49f-4465">A5 < `T` ></span></span>|<span data-ttu-id="de49f-4466">Распаковка. любой `typeTok`</span><span class="sxs-lookup"><span data-stu-id="de49f-4466">unbox.any `typeTok`</span></span>|<span data-ttu-id="de49f-4467">Извлеките данные из `obj`, их упакованного представления.</span><span class="sxs-lookup"><span data-stu-id="de49f-4467">Extract the data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="de49f-4468">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4468">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4469">Ссылка на объект `obj` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4469">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4470">Ссылка на объект извлекается из стека и распаковывается в тип, указанный в инструкции.</span><span class="sxs-lookup"><span data-stu-id="de49f-4470">The object reference is popped from the stack and unboxed to the type specified in the instruction.</span></span>  
  
3.  <span data-ttu-id="de49f-4471">Результирующая ссылка на объект или тип значения помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4471">The resulting object reference or value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-4472">При применении к упакованной форме типа значения инструкция `unbox.any` извлекает значение, содержащееся в `obj` (типа `O`), и, следовательно, эквивалентно `unbox`, за которым следует `ldobj`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4472">When applied to the boxed form of a value type, the `unbox.any` instruction extracts the value contained within `obj` (of type `O`), and is therefore equivalent to `unbox` followed by `ldobj`.</span></span>  
  
 <span data-ttu-id="de49f-4473">При применении к ссылочному типу инструкция `unbox.any` действует так же, как `castclass` `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4473">When applied to a reference type, the `unbox.any` instruction has the same effect as `castclass` `typeTok`.</span></span>  
  
 <span data-ttu-id="de49f-4474">Если операнд `typeTok` является параметром универсального типа, то поведение среды выполнения определяется типом, указанным для этого параметра универсального типа.</span><span class="sxs-lookup"><span data-stu-id="de49f-4474">If the operand `typeTok` is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</span></span>  
  
 <span data-ttu-id="de49f-4475"><xref:System.InvalidCastException> возникает, если `obj` не является упакованным типом.</span><span class="sxs-lookup"><span data-stu-id="de49f-4475"><xref:System.InvalidCastException> is thrown if `obj` is not a boxed type.</span></span>  
  
 <span data-ttu-id="de49f-4476"><xref:System.NullReferenceException> возникает, если `obj` является пустой ссылкой.</span><span class="sxs-lookup"><span data-stu-id="de49f-4476"><xref:System.NullReferenceException> is thrown if `obj` is a null reference.</span></span>  
  
 <span data-ttu-id="de49f-4477">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `unbox.any`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4477">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox.any` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4478">ILGenerator. Emit (код операции, тип)</span><span class="sxs-lookup"><span data-stu-id="de49f-4478">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4479">Указывает, что адрес на вершине стека вычислений, возможно, является изменяемым и результаты чтения данной области невозможно кэшировать либо невозможно запретить множественные сохранения в эту область.</span><span class="sxs-lookup"><span data-stu-id="de49f-4479">Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4480">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4480">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4481">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4481">Format</span></span>|<span data-ttu-id="de49f-4482">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4482">Assembly Format</span></span>|<span data-ttu-id="de49f-4483">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4483">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4484">FE 13</span><span class="sxs-lookup"><span data-stu-id="de49f-4484">FE 13</span></span>|<span data-ttu-id="de49f-4485">независимо.</span><span class="sxs-lookup"><span data-stu-id="de49f-4485">volatile.</span></span>|<span data-ttu-id="de49f-4486">Указывает, что последующая ссылка на указатель является временной.</span><span class="sxs-lookup"><span data-stu-id="de49f-4486">Indicates that the subsequent pointer reference is volatile.</span></span>|  
  
 <span data-ttu-id="de49f-4487">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4487">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4488">Адрес помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4488">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-4489">`volatile`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4489">`volatile`.</span></span> <span data-ttu-id="de49f-4490">Указывает, что адрес является временным адресом (т. е. на него может ссылаться извне на текущий поток выполнения), и результаты чтения этого расположения не могут быть кэшированы или нельзя подавлять несколько магазинов в этом расположении.</span><span class="sxs-lookup"><span data-stu-id="de49f-4490">specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span> <span data-ttu-id="de49f-4491">Пометка доступа как `volatile` влияет только на этот единственный доступ. другие методы доступа к тому же расположению должны быть помечены отдельно.</span><span class="sxs-lookup"><span data-stu-id="de49f-4491">Marking an access as `volatile` affects only that single access; other accesses to the same location must be marked separately.</span></span> <span data-ttu-id="de49f-4492">Доступ к временным расположениям не должен выполняться атомарно.</span><span class="sxs-lookup"><span data-stu-id="de49f-4492">Access to volatile locations need not be performed atomically.</span></span>  
  
 <span data-ttu-id="de49f-4493">Префиксы <xref:System.Reflection.Emit.OpCodes.Unaligned> и `volatile` можно объединять в любом порядке.</span><span class="sxs-lookup"><span data-stu-id="de49f-4493">The <xref:System.Reflection.Emit.OpCodes.Unaligned> and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="de49f-4494">Они должны непосредственно предшествовать инструкциям `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`или `cpblk`.</span><span class="sxs-lookup"><span data-stu-id="de49f-4494">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="de49f-4495">Только префикс `volatile` разрешен для инструкций <xref:System.Reflection.Emit.OpCodes.Ldsfld> и <xref:System.Reflection.Emit.OpCodes.Stsfld>.</span><span class="sxs-lookup"><span data-stu-id="de49f-4495">Only the `volatile` prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="de49f-4496">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `volatile`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4496">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `volatile` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4497">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4497">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="de49f-4498">Вычисляет побитовое исключающее ИЛИ двух верхних значений в стеке вычислений и помещает результат обратно в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4498">Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de49f-4499">В следующей таблице приводится список шестнадцатеричных и форматных сборок инструкций языка MSIL, а также краткая сводка.</span><span class="sxs-lookup"><span data-stu-id="de49f-4499">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="de49f-4500">Формат</span><span class="sxs-lookup"><span data-stu-id="de49f-4500">Format</span></span>|<span data-ttu-id="de49f-4501">Формат сборки</span><span class="sxs-lookup"><span data-stu-id="de49f-4501">Assembly Format</span></span>|<span data-ttu-id="de49f-4502">Описание</span><span class="sxs-lookup"><span data-stu-id="de49f-4502">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="de49f-4503">61</span><span class="sxs-lookup"><span data-stu-id="de49f-4503">61</span></span>|<span data-ttu-id="de49f-4504">xor</span><span class="sxs-lookup"><span data-stu-id="de49f-4504">xor</span></span>|<span data-ttu-id="de49f-4505">Выполняет побитовое ИСКЛЮЧАЮЩее или двух целочисленных значений и возвращает целое число.</span><span class="sxs-lookup"><span data-stu-id="de49f-4505">Computes the bitwise XOR of two integer values and returns an integer.</span></span>|  
  
 <span data-ttu-id="de49f-4506">Переход в стек в последовательном порядке имеет следующие особенности:</span><span class="sxs-lookup"><span data-stu-id="de49f-4506">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="de49f-4507">`value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4507">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="de49f-4508">`value2` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4508">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="de49f-4509">`value2` и `value1` извлекаются из стека и их побитовое исключающее XOR.</span><span class="sxs-lookup"><span data-stu-id="de49f-4509">`value2` and `value1` are popped from the stack and their bitwise XOR computed.</span></span>  
  
4.  <span data-ttu-id="de49f-4510">Побитовое ИСКЛЮЧАЮЩее или `value2` и `value1` помещается в стек.</span><span class="sxs-lookup"><span data-stu-id="de49f-4510">The bitwise XOR of `value2` and `value1` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="de49f-4511">Инструкция `xor` рассчитывает побитовое ИСКЛЮЧАЮЩее и два верхних значения в стеке и оставляет результат в стеке.</span><span class="sxs-lookup"><span data-stu-id="de49f-4511">The `xor` instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="de49f-4512">`Xor` является операцией, относящейся к целому числу.</span><span class="sxs-lookup"><span data-stu-id="de49f-4512">`Xor` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="de49f-4513">Следующая перегрузка метода <xref:System.Reflection.Emit.ILGenerator.Emit%2A> может использовать код операции `xor`:</span><span class="sxs-lookup"><span data-stu-id="de49f-4513">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `xor` opcode:</span></span>  
  
-   <span data-ttu-id="de49f-4514">ILGenerator. Emit (код операции)</span><span class="sxs-lookup"><span data-stu-id="de49f-4514">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
