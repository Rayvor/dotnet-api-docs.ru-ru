<Type Name="TypeBuilder" FullName="System.Reflection.Emit.TypeBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="087934f42bbda10272039034f742d058e16d3227" /><Meta Name="ms.sourcegitcommit" Value="c573d537afba2d4c1463538f1095f2f155025464" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/16/2019" /><Meta Name="ms.locfileid" Value="72409072" /></Metadata><TypeSignature Language="C#" Value="public sealed class TypeBuilder : System.Reflection.TypeInfo, System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit TypeBuilder extends System.Reflection.TypeInfo implements class System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.TypeBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeBuilder&#xA;Inherits TypeInfo&#xA;Implements _TypeBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeBuilder sealed : System::Reflection::TypeInfo, System::Runtime::InteropServices::_TypeBuilder" />
  <TypeSignature Language="F#" Value="type TypeBuilder = class&#xA;    inherit TypeInfo&#xA;    interface _TypeBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-2.0">System.Type</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._TypeBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._TypeBuilder))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="15a0e-101">Определяет и создает новые экземпляры классов во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-101">Defines and creates new instances of classes during run time.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-102"><xref:System.Reflection.Emit.TypeBuilder> является корневым классом, используемым для управления созданием динамических классов в среде выполнения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-102"><xref:System.Reflection.Emit.TypeBuilder> is the root class used to control the creation of dynamic classes in the runtime.</span></span> <span data-ttu-id="15a0e-103">Он предоставляет набор подпрограмм, которые используются для определения классов, добавления методов и полей и создания класса внутри модуля.</span><span class="sxs-lookup"><span data-stu-id="15a0e-103">It provides a set of routines that are used to define classes, add methods and fields, and create the class inside a module.</span></span> <span data-ttu-id="15a0e-104">Новый <xref:System.Reflection.Emit.TypeBuilder> можно создать из динамического модуля, вызвав метод <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType>, который возвращает объект <xref:System.Reflection.Emit.TypeBuilder>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-104">A new <xref:System.Reflection.Emit.TypeBuilder> can be created from a dynamic module by calling the <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> method, which returns a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="15a0e-105">Отражательная эмиссия предоставляет следующие возможности для определения типов:</span><span class="sxs-lookup"><span data-stu-id="15a0e-105">Reflection emit provides the following options for defining types:</span></span>  
  
-   <span data-ttu-id="15a0e-106">Определите класс или интерфейс с заданным именем.</span><span class="sxs-lookup"><span data-stu-id="15a0e-106">Define a class or interface with the given name.</span></span>  
  
-   <span data-ttu-id="15a0e-107">Определите класс или интерфейс с заданными именем и атрибутами.</span><span class="sxs-lookup"><span data-stu-id="15a0e-107">Define a class or interface with the given name and attributes.</span></span>  
  
-   <span data-ttu-id="15a0e-108">Определите класс с заданным именем, атрибутами и базовым классом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-108">Define a class with the given name, attributes, and base class.</span></span>  
  
-   <span data-ttu-id="15a0e-109">Определите класс с заданным именем, атрибутами, базовым классом и набором интерфейсов, реализуемых классом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-109">Define a class with the given name, attributes, base class, and the set of interfaces that the class implements.</span></span>  
  
-   <span data-ttu-id="15a0e-110">Определите класс с заданным именем, атрибутами, базовым классом и размером упаковки.</span><span class="sxs-lookup"><span data-stu-id="15a0e-110">Define a class with the given name, attributes, base class, and packing size.</span></span>  
  
-   <span data-ttu-id="15a0e-111">Определите класс с заданным именем, атрибутами, базовым классом и размером класса в целом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-111">Define a class with the given name, attributes, base class, and the class size as a whole.</span></span>  
  
-   <span data-ttu-id="15a0e-112">Определите класс с заданным именем, атрибутами, базовым классом, размером упаковки и размером класса в целом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-112">Define a class with the given name, attributes, base class, packing size, and the class size as a whole.</span></span>  
  
 <span data-ttu-id="15a0e-113">Чтобы создать тип массива, тип указателя или тип ByRef для неполного типа, представленного объектом <xref:System.Reflection.Emit.TypeBuilder>, используйте метод <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A>, метод <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> или метод <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> соответственно.</span><span class="sxs-lookup"><span data-stu-id="15a0e-113">To create an array type, pointer type, or byref type for an incomplete type that is represented by a <xref:System.Reflection.Emit.TypeBuilder> object, use the <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> method, or <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> method, respectively.</span></span>  
  
 <span data-ttu-id="15a0e-114">Перед использованием типа необходимо вызвать метод <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-114">Before a type is used, the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> method must be called.</span></span> <span data-ttu-id="15a0e-115">**CreateType** завершает создание типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-115">**CreateType** completes the creation of the type.</span></span> <span data-ttu-id="15a0e-116">После вызова **CreateType**вызывающий объект может создать экземпляр типа с помощью метода <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> и вызвать члены типа с помощью метода <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-116">Following the call to **CreateType**, the caller can instantiate the type by using the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and invoke members of the type by using the <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="15a0e-117">Вызов методов, изменяющих реализацию типа после вызова **CreateType** , является ошибкой.</span><span class="sxs-lookup"><span data-stu-id="15a0e-117">It is an error to invoke methods that change the implementation of a type after **CreateType** has been called.</span></span> <span data-ttu-id="15a0e-118">Например, среда CLR создает исключение, если вызывающий объект пытается добавить новые члены к типу.</span><span class="sxs-lookup"><span data-stu-id="15a0e-118">For example, the common language runtime throws an exception if the caller tries to add new members to a type.</span></span>  
  
 <span data-ttu-id="15a0e-119">Инициализатор класса создается с помощью метода <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-119">A class initializer is created by using the <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="15a0e-120">**Дефинетипеинитиализер** возвращает объект <xref:System.Reflection.Emit.ConstructorBuilder>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-120">**DefineTypeInitializer** returns a <xref:System.Reflection.Emit.ConstructorBuilder> object.</span></span>  
  
 <span data-ttu-id="15a0e-121">Вложенные типы определяются путем вызова одного из методов <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-121">Nested types are defined by calling one of the <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> methods.</span></span>  
  
## <a name="attributes"></a><span data-ttu-id="15a0e-122">Атрибуты</span><span class="sxs-lookup"><span data-stu-id="15a0e-122">Attributes</span></span>  
 <span data-ttu-id="15a0e-123">Класс <xref:System.Reflection.Emit.TypeBuilder> использует перечисление <xref:System.Reflection.TypeAttributes>, чтобы дополнительно указать характеристики создаваемого типа:</span><span class="sxs-lookup"><span data-stu-id="15a0e-123">The <xref:System.Reflection.Emit.TypeBuilder> class uses the <xref:System.Reflection.TypeAttributes> enumeration to further specify the characteristics of the type to be created:</span></span>  
  
-   <span data-ttu-id="15a0e-124">Интерфейсы задаются с помощью атрибутов <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> и <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-124">Interfaces are specified using the <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> and <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType> attributes.</span></span>  
  
-   <span data-ttu-id="15a0e-125">Конкретные классы (классы, которые не могут быть расширены) задаются с помощью атрибута <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-125">Concrete classes (classes that cannot be extended) are specified using the <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="15a0e-126">Видимость типа определяется несколькими атрибутами.</span><span class="sxs-lookup"><span data-stu-id="15a0e-126">Several attributes determine type visibility.</span></span> <span data-ttu-id="15a0e-127">См. описание перечисления <xref:System.Reflection.TypeAttributes>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-127">See the description of the <xref:System.Reflection.TypeAttributes> enumeration.</span></span>  
  
-   <span data-ttu-id="15a0e-128">Если задано значение <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>, загрузчик классов размещает поля в том порядке, в котором они считываются из метаданных.</span><span class="sxs-lookup"><span data-stu-id="15a0e-128">If <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is specified, the class loader lays out fields in the order they are read from metadata.</span></span> <span data-ttu-id="15a0e-129">Загрузчик класса считает заданный размер упаковки, но игнорирует все заданные смещения полей.</span><span class="sxs-lookup"><span data-stu-id="15a0e-129">The class loader considers the specified packing size but ignores any specified field offsets.</span></span> <span data-ttu-id="15a0e-130">Метаданные сохраняют порядок, в котором создаются определения полей.</span><span class="sxs-lookup"><span data-stu-id="15a0e-130">The metadata preserves the order in which the field definitions are emitted.</span></span> <span data-ttu-id="15a0e-131">Даже при слиянии метаданные не будут переупорядочивать определения полей.</span><span class="sxs-lookup"><span data-stu-id="15a0e-131">Even across a merge, the metadata will not reorder the field definitions.</span></span> <span data-ttu-id="15a0e-132">Загрузчик будет учитывать указанные смещения полей только в том случае, если задано значение <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-132">The loader will honor the specified field offsets only if <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is specified.</span></span>  
  
## <a name="known-issues"></a><span data-ttu-id="15a0e-133">Известные проблемы</span><span class="sxs-lookup"><span data-stu-id="15a0e-133">Known Issues</span></span>  
  
-   <span data-ttu-id="15a0e-134">Отражательная эмиссия не проверяет, реализовал ли неабстрактный класс, реализующий интерфейс, все методы, объявленные в интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="15a0e-134">Reflection emit does not verify whether a non-abstract class that implements an interface has implemented all the methods declared in the interface.</span></span> <span data-ttu-id="15a0e-135">Однако если класс не реализует все методы, объявленные в интерфейсе, среда выполнения не загружает класс.</span><span class="sxs-lookup"><span data-stu-id="15a0e-135">However, if the class does not implement all the methods declared in an interface, the runtime does not load the class.</span></span>  
  
-   <span data-ttu-id="15a0e-136">Хотя <xref:System.Reflection.Emit.TypeBuilder> является производным от <xref:System.Type>, некоторые абстрактные методы, определенные в классе <xref:System.Type>, не полностью реализованы в классе <xref:System.Reflection.Emit.TypeBuilder>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-136">Although <xref:System.Reflection.Emit.TypeBuilder> is derived from <xref:System.Type>, some of the abstract methods defined in the <xref:System.Type> class are not fully implemented in the <xref:System.Reflection.Emit.TypeBuilder> class.</span></span> <span data-ttu-id="15a0e-137">Вызовы этих методов <xref:System.Reflection.Emit.TypeBuilder> вызывают исключение <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-137">Calls to these <xref:System.Reflection.Emit.TypeBuilder> methods throw a <xref:System.NotSupportedException> exception.</span></span> <span data-ttu-id="15a0e-138">Требуемую функциональность можно получить, извлекая созданный тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и отражая полученный тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-138">The desired functionality can be obtained by retrieving the created type using the <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and reflecting on the retrieved type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-139">Этот раздел содержит два примера кода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-139">This section contains two code examples.</span></span> <span data-ttu-id="15a0e-140">В первом примере показано, как создать динамический тип с полем, конструктором, свойством и методом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-140">The first example shows how to create a dynamic type with a field, constructor, property, and method.</span></span> <span data-ttu-id="15a0e-141">Во втором примере метод динамически строится на основе вводимых пользователем данных.</span><span class="sxs-lookup"><span data-stu-id="15a0e-141">The second example builds a method dynamically from user input.</span></span>  
  
 <span data-ttu-id="15a0e-142">**Пример 1**</span><span class="sxs-lookup"><span data-stu-id="15a0e-142">**Example one**</span></span>  
  
 <span data-ttu-id="15a0e-143">В следующем примере кода показано, как определить динамическую сборку с одним модулем.</span><span class="sxs-lookup"><span data-stu-id="15a0e-143">The following code example shows how to define a dynamic assembly with one module.</span></span> <span data-ttu-id="15a0e-144">Модуль в примере сборки содержит один тип, `MyDynamicType`, который имеет закрытое поле, свойство, которое получает и задает закрытое поле, конструкторы, которые инициализируют закрытое поле, и метод, который умножает предоставленное пользователем число на значение закрытого поля. и возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="15a0e-144">The module in the example assembly contains one type, `MyDynamicType`, which has a private field, a property that gets and sets the private field, constructors that initialize the private field, and a method that multiplies a user-supplied number by the private field value and returns the result.</span></span>  
  
 <span data-ttu-id="15a0e-145">Поле <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> указывается при создании сборки.</span><span class="sxs-lookup"><span data-stu-id="15a0e-145">The <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> field is specified when the assembly is created.</span></span> <span data-ttu-id="15a0e-146">Код сборки используется немедленно, а сборка также сохраняется на диск, чтобы ее можно было исследовать с помощью [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) или использовать в другой программе.</span><span class="sxs-lookup"><span data-stu-id="15a0e-146">The assembly code is used immediately, and the assembly is also saved to disk so that it can be examined with [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) or used in another program.</span></span>  
  
 [!code-cpp[AssemblyBuilderClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilderClass/cpp/24895.cpp#1)]
 [!code-csharp[AssemblyBuilderClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilderClass/cs/24895.cs#1)]
 [!code-vb[AssemblyBuilderClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilderClass/vb/24895.vb#1)]  
  
 <span data-ttu-id="15a0e-147">**Пример 2**</span><span class="sxs-lookup"><span data-stu-id="15a0e-147">**Example two**</span></span>  
  
 <span data-ttu-id="15a0e-148">В следующем примере кода показано, как создать динамический тип с помощью `TypeBuilder`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-148">The following code sample demonstrates how to build a dynamic type by using `TypeBuilder`.</span></span>  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07d5f01a-7b5b-40ea-9b15-f21561098fe4"><span data-ttu-id="15a0e-149">Практическое руководство. Определение универсального типа с порождаемым отражением</span><span class="sxs-lookup"><span data-stu-id="15a0e-149">How to: Define a Generic Type with Reflection Emit</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBuilder ();" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.#ctor" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeBuilder();" FrameworkAlternate="xamarinios-10.8" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberSignature Language="F#" Value="member this.AddDeclarativeSecurity : System.Security.Permissions.SecurityAction * System.Security.PermissionSet -&gt; unit" Usage="typeBuilder.AddDeclarativeSecurity (action, pset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="15a0e-150">Выполняемое действие безопасности, например Demand, Assert и т. д.</span><span class="sxs-lookup"><span data-stu-id="15a0e-150">The security action to be taken such as Demand, Assert, and so on.</span></span></param>
        <param name="pset"><span data-ttu-id="15a0e-151">Набор разрешений, к которому применяется действие.</span><span class="sxs-lookup"><span data-stu-id="15a0e-151">The set of permissions the action applies to.</span></span></param>
        <summary><span data-ttu-id="15a0e-152">Добавляет декларативную безопасность в этот тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-152">Adds declarative security to this type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-153">`AddDeclarativeSecurity` может вызываться несколько раз при каждом вызове с указанием действия безопасности (например, Demand, Assert или Deny) и набора разрешений, которые применяются к действию.</span><span class="sxs-lookup"><span data-stu-id="15a0e-153">`AddDeclarativeSecurity` may be called several times with each call specifying a security action (such as Demand, Assert, or Deny) and a set of permissions that apply to the action.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-154">В .NET Framework версиях 1,0, 1,1 и 2,0 декларативные атрибуты безопасности, применяемые к типу с помощью этого метода, хранятся в старом формате метаданных XML.</span><span class="sxs-lookup"><span data-stu-id="15a0e-154">In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a type by using this method are stored in the old XML metadata format.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-155">В следующем примере показано использование метода `AddDeclarativeSecurity` для добавления требования безопасности для <xref:System.Security.Permissions.SecurityPermission> с флагом <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> к динамическому типу с именем `MyDynamicClass` в сборке с именем Емиттедексампле. dll.</span><span class="sxs-lookup"><span data-stu-id="15a0e-155">The following example demonstrates the use of the `AddDeclarativeSecurity` method to add a security demand for <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag to a dynamic type named `MyDynamicClass`, in an assembly named EmittedExample.dll.</span></span> <span data-ttu-id="15a0e-156">В этом примере не создаются выходные данные консоли. После запуска можно использовать [Ildasm. exe (ДИЗАССЕМБЛЕР IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) для проверки емиттедексампле. dll.</span><span class="sxs-lookup"><span data-stu-id="15a0e-156">The example produces no console output; after you run it, you can use [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine EmittedExample.dll.</span></span> <span data-ttu-id="15a0e-157">В `MyDynamicClass` откройте инструкцию `.class public auto ansi`, чтобы увидеть декларативное разрешение.</span><span class="sxs-lookup"><span data-stu-id="15a0e-157">In `MyDynamicClass`, open the `.class public auto ansi` statement to see the declarative permission.</span></span>  
  
 [!code-cpp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CPP/typebuilder_adddeclarativesecurity.cpp#1)]
 [!code-csharp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CS/typebuilder_adddeclarativesecurity.cs#1)]
 [!code-vb[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/VB/typebuilder_adddeclarativesecurity.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="15a0e-158"><paramref name="action" /> является недопустимым (<see langword="RequestMinimum" />, <see langword="RequestOptional" /> и <see langword="RequestRefuse" /> являются недопустимыми).</span><span class="sxs-lookup"><span data-stu-id="15a0e-158">The <paramref name="action" /> is invalid (<see langword="RequestMinimum" />, <see langword="RequestOptional" />, and <see langword="RequestRefuse" /> are invalid).</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-159">Содержащий тип был создан с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-159">The containing type has been created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="15a0e-160">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-160">-or-</span></span> 
<span data-ttu-id="15a0e-161">Набор разрешений <paramref name="pset" /> содержит действие, добавленное ранее с помощью <see langword="AddDeclarativeSecurity" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-161">The permission set <paramref name="pset" /> contains an action that was added earlier by <see langword="AddDeclarativeSecurity" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-162"><paramref name="pset" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-162"><paramref name="pset" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AddInterfaceImplementation">
      <MemberSignature Language="C#" Value="public void AddInterfaceImplementation (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInterfaceImplementation(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddInterfaceImplementation (interfaceType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddInterfaceImplementation(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="member this.AddInterfaceImplementation : Type -&gt; unit" Usage="typeBuilder.AddInterfaceImplementation interfaceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType"><span data-ttu-id="15a0e-163">Интерфейс, реализуемый данным типом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-163">The interface that this type implements.</span></span></param>
        <summary><span data-ttu-id="15a0e-164">Добавляет интерфейс, реализуемый данным типом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-164">Adds an interface that this type implements.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="15a0e-165">В следующем примере кода демонстрируется реализация интерфейса для динамически созданного типа с помощью `AddInterfaceImplementation`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-165">The following code sample demonstrates the implementation of an interface on a dynamically created type using `AddInterfaceImplementation`.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#3)]
 [!code-csharp[TypeBuilder_Sample_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#3)]
 [!code-vb[TypeBuilder_Sample_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-166">Свойство <paramref name="interfaceType" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-166"><paramref name="interfaceType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-167">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-167">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-168">Извлекает динамическую сборку, которая содержит определение данного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-168">Retrieves the dynamic assembly that contains this type definition.</span></span></summary>
        <value><span data-ttu-id="15a0e-169">Только для чтения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-169">Read-only.</span></span> <span data-ttu-id="15a0e-170">Извлекает динамическую сборку, которая содержит определение данного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-170">Retrieves the dynamic assembly that contains this type definition.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-171">Возвращает полное имя этого типа, дополненное отображаемым именем сборки.</span><span class="sxs-lookup"><span data-stu-id="15a0e-171">Returns the full name of this type qualified by the display name of the assembly.</span></span></summary>
        <value><span data-ttu-id="15a0e-172">Только для чтения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-172">Read-only.</span></span> <span data-ttu-id="15a0e-173">Полное имя этого типа, дополненное отображаемым именем сборки.</span><span class="sxs-lookup"><span data-stu-id="15a0e-173">The full name of this type qualified by the display name of the assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-174">Формат возвращаемой строки — это объединение полного имени типа (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) и отображаемого имени сборки (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), разделенных запятыми и пробелом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-174">The format of the returned string is the concatenation of the full name of the type (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) and the display name of the assembly (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), separated by a comma and a space.</span></span>  
  
 <span data-ttu-id="15a0e-175">Описание формата отображаемого имени сборки см. в разделе <xref:System.Reflection.AssemblyName>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-175">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="15a0e-176">Сведения о версии</span><span class="sxs-lookup"><span data-stu-id="15a0e-176">Version Information</span></span>  
 <span data-ttu-id="15a0e-177">В .NET Framework версиях 1,0 и 1,1 значение этого свойства не включает в себя культуру или открытый ключ.</span><span class="sxs-lookup"><span data-stu-id="15a0e-177">In the .NET Framework versions 1.0 and 1.1, the value of this property does not include the culture or public key.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-178">Возвращает базовый тип этого типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-178">Retrieves the base type of this type.</span></span></summary>
        <value><span data-ttu-id="15a0e-179">Только для чтения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-179">Read-only.</span></span> <span data-ttu-id="15a0e-180">Возвращает базовый тип этого типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-180">Retrieves the base type of this type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateType">
      <MemberSignature Language="C#" Value="public Type CreateType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type CreateType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateType" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ CreateType();" />
      <MemberSignature Language="F#" Value="member this.CreateType : unit -&gt; Type" Usage="typeBuilder.CreateType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="15a0e-181">Создает объект <see cref="T:System.Type" /> для этого класса.</span><span class="sxs-lookup"><span data-stu-id="15a0e-181">Creates a <see cref="T:System.Type" /> object for the class.</span></span> <span data-ttu-id="15a0e-182">После определения полей и методов в классе вызывается метод <see langword="CreateType" /> для загрузки его объекта <see langword="Type" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-182">After defining fields and methods on the class, <see langword="CreateType" /> is called in order to load its <see langword="Type" /> object.</span></span></summary>
        <returns><span data-ttu-id="15a0e-183">Возвращает новый объект <see cref="T:System.Type" /> для этого класса.</span><span class="sxs-lookup"><span data-stu-id="15a0e-183">Returns the new <see cref="T:System.Type" /> object for this class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-184">Если этот тип является вложенным, то перед вызовом для вложенного типа необходимо вызвать метод <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для включающего типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-184">If this type is a nested type, the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method must be called on the enclosing type before it is called on the nested type.</span></span>  
  
 <span data-ttu-id="15a0e-185">Если текущий тип является производным от неполного типа или реализует неполные интерфейсы, вызовите метод <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для родительского типа и типов интерфейса, прежде чем вызывать его для текущего типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-185">If the current type derives from an incomplete type or implements incomplete interfaces, call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on the parent type and the interface types before calling it on the current type.</span></span>  
  
 <span data-ttu-id="15a0e-186">Если включающий тип содержит поле, которое является типом значения, определенным как вложенный тип (например, поле, которое является перечислением, определенным как вложенный тип), вызов метода <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для включающего типа создаст событие <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-186">If the enclosing type contains a field that is a value type defined as a nested type (for example, a field that is an enumeration defined as a nested type), calling the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on the enclosing type will generate a <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="15a0e-187">Это обусловлено тем, что загрузчик не может определить размер вмещающего типа до тех пор, пока вложенный тип не будет завершен.</span><span class="sxs-lookup"><span data-stu-id="15a0e-187">This is because the loader cannot determine the size of the enclosing type until the nested type has been completed.</span></span> <span data-ttu-id="15a0e-188">Вызывающий объект должен определить обработчик для события <xref:System.AppDomain.TypeResolve>, чтобы завершить определение вложенного типа путем вызова <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для объекта <xref:System.Reflection.Emit.TypeBuilder>, представляющего вложенный тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-188">The caller should define a handler for the <xref:System.AppDomain.TypeResolve> event to complete the definition of the nested type by calling <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> on the <xref:System.Reflection.Emit.TypeBuilder> object that represents the nested type.</span></span> <span data-ttu-id="15a0e-189">В примере кода для этого раздела показано, как определить такой обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="15a0e-189">The code example for this topic shows how to define such an event handler.</span></span>  
  
 <span data-ttu-id="15a0e-190">Тип создается только один раз, независимо от того, сколько раз вызывается метод <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-190">A type is created only once, no matter how many times the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span> <span data-ttu-id="15a0e-191">Все вызовы возвращают один и тот же объект <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-191">All calls return the same <xref:System.Type> object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-192">В следующем примере кода показано, как определить обработчик событий для события <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType>, чтобы вызвать метод <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для вложенного типа во время вызова <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для включающего типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-192">The following code example shows how to define an event handler for the <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> event, in order to call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on a nested type during a <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> call on the enclosing type.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CPP/nestedenum.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CS/nestedenum.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/VB/nestedenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-193">Включающий тип не создан.</span><span class="sxs-lookup"><span data-stu-id="15a0e-193">The enclosing type has not been created.</span></span>  
  
 <span data-ttu-id="15a0e-194">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-194">-or-</span></span>  
  
 <span data-ttu-id="15a0e-195">Этот тип не является абстрактным, а содержит абстрактный метод.</span><span class="sxs-lookup"><span data-stu-id="15a0e-195">This type is non-abstract and contains an abstract method.</span></span>  
  
 <span data-ttu-id="15a0e-196">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-196">-or-</span></span>  
  
 <span data-ttu-id="15a0e-197">Этот тип не является абстрактным классом или интерфейсом, а содержит метод без тела метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-197">This type is not an abstract class or an interface and has a method without a method body.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-198">Неправильное содержимое метки в <see cref="T:System.Reflection.Emit.ILGenerator" />: Вы определили метку без вызова <see cref="M:System.Reflection.Emit.ILGenerator.MarkLabel(System.Reflection.Emit.Label)" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-198">Bad label content in <see cref="T:System.Reflection.Emit.ILGenerator" />: You have defined a label without calling <see cref="M:System.Reflection.Emit.ILGenerator.MarkLabel(System.Reflection.Emit.Label)" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-199">Тип содержит неверный код на языке MSIL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-199">The type contains invalid Microsoft intermediate language (MSIL) code.</span></span>  
  
 <span data-ttu-id="15a0e-200">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-200">-or-</span></span>  
  
 <span data-ttu-id="15a0e-201">Конечный адрес ветвления задан с использованием однобайтового смещения, но он находится на расстоянии более 127 байт от ветви.</span><span class="sxs-lookup"><span data-stu-id="15a0e-201">The branch target is specified using a 1-byte offset, but the target is at a distance greater than 127 bytes from the branch.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="15a0e-202">Не удалось загрузить тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-202">The type cannot be loaded.</span></span> <span data-ttu-id="15a0e-203">Например, он содержит метод <see langword="static" />, имеющий соглашение о вызовах <see cref="F:System.Reflection.CallingConventions.HasThis" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-203">For example, it contains a <see langword="static" /> method that has the calling convention <see cref="F:System.Reflection.CallingConventions.HasThis" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTypeInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeInfo CreateTypeInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.TypeInfo CreateTypeInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateTypeInfo () As TypeInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::TypeInfo ^ CreateTypeInfo();" />
      <MemberSignature Language="F#" Value="member this.CreateTypeInfo : unit -&gt; System.Reflection.TypeInfo" Usage="typeBuilder.CreateTypeInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="15a0e-204">Получает объект <see cref="T:System.Reflection.TypeInfo" />, представляющий этот тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-204">Gets a <see cref="T:System.Reflection.TypeInfo" /> object that represents this type.</span></span></summary>
        <returns><span data-ttu-id="15a0e-205">Объект, представляющий этот тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-205">An object that represents this type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-206">Возвращает метод, который объявил текущий параметр универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-206">Gets the method that declared the current generic type parameter.</span></span></summary>
        <value><span data-ttu-id="15a0e-207">Объект <see cref="T:System.Reflection.MethodBase" />, представляющий метод, который объявил текущий тип, если текущий тип является параметром универсального типа; в противном случае — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-207">A <see cref="T:System.Reflection.MethodBase" /> that represents the method that declared the current type, if the current type is a generic type parameter; otherwise, <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-208">При выдаче кода параметр универсального типа представлен объектом <xref:System.Reflection.Emit.GenericTypeParameterBuilder>, а не объектом <xref:System.Reflection.Emit.TypeBuilder>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-208">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-209">Возвращает тип, объявивший этот тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-209">Returns the type that declared this type.</span></span></summary>
        <value><span data-ttu-id="15a0e-210">Только для чтения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-210">Read-only.</span></span> <span data-ttu-id="15a0e-211">Тип, объявивший этот тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-211">The type that declared this type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineConstructor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="15a0e-212">Добавляет новый конструктор в динамический тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-212">Adds a new constructor to the dynamic type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineConstructor : System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type[] -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineConstructor (attributes, callingConvention, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="attributes"><span data-ttu-id="15a0e-213">Атрибуты конструктора.</span><span class="sxs-lookup"><span data-stu-id="15a0e-213">The attributes of the constructor.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="15a0e-214">Соглашение о вызовах конструктора.</span><span class="sxs-lookup"><span data-stu-id="15a0e-214">The calling convention of the constructor.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="15a0e-215">Типы параметров конструктора.</span><span class="sxs-lookup"><span data-stu-id="15a0e-215">The parameter types of the constructor.</span></span></param>
        <summary><span data-ttu-id="15a0e-216">Добавляет в тип новый конструктор с заданными атрибутами и сигнатурой.</span><span class="sxs-lookup"><span data-stu-id="15a0e-216">Adds a new constructor to the type, with the given attributes and signature.</span></span></summary>
        <returns><span data-ttu-id="15a0e-217">Определенный конструктор.</span><span class="sxs-lookup"><span data-stu-id="15a0e-217">The defined constructor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-218">Если не определить конструктор для динамического типа, конструктор без параметров предоставляется автоматически и вызывает конструктор без параметров базового класса.</span><span class="sxs-lookup"><span data-stu-id="15a0e-218">If you do not define a constructor for your dynamic type, a parameterless constructor is provided automatically, and it calls the parameterless constructor of the base class.</span></span>  
  
 <span data-ttu-id="15a0e-219">При определении конструктора для динамического типа конструктор без параметров не предоставляется.</span><span class="sxs-lookup"><span data-stu-id="15a0e-219">If you define a constructor for your dynamic type, a parameterless constructor is not provided.</span></span> <span data-ttu-id="15a0e-220">В дополнение к определенному конструктору доступны следующие варианты предоставления конструктора без параметров:</span><span class="sxs-lookup"><span data-stu-id="15a0e-220">You have the following options for providing a parameterless constructor in addition to the constructor you defined:</span></span>  
  
-   <span data-ttu-id="15a0e-221">Если нужен конструктор без параметров, который просто вызывает конструктор без параметров базового класса, можно использовать метод <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A>, чтобы создать его (и при необходимости ограничить доступ к нему).</span><span class="sxs-lookup"><span data-stu-id="15a0e-221">If you want a parameterless constructor that simply calls the parameterless constructor of the base class, you can use the <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> method to create one (and optionally restrict access to it).</span></span> <span data-ttu-id="15a0e-222">Не предоставляющих реализацию для этого конструктора без параметров.</span><span class="sxs-lookup"><span data-stu-id="15a0e-222">Do not provide an implementation for this parameterless constructor.</span></span> <span data-ttu-id="15a0e-223">В этом случае при попытке использовать конструктор выдается исключение.</span><span class="sxs-lookup"><span data-stu-id="15a0e-223">If you do, an exception is thrown when you try to use the constructor.</span></span> <span data-ttu-id="15a0e-224">При вызове метода <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> исключение не создается.</span><span class="sxs-lookup"><span data-stu-id="15a0e-224">No exception is thrown when the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span>  
  
-   <span data-ttu-id="15a0e-225">Если нужен конструктор без параметров, который выполняет нечто большее, чем просто вызов конструктора без параметров базового класса или вызовет другой конструктор базового класса или который полностью делает что-то еще, необходимо использовать метод <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> для создания один и предоставить собственную реализацию.</span><span class="sxs-lookup"><span data-stu-id="15a0e-225">If you want a parameterless constructor that does something more than simply calling the parameterless constructor of the base class, or that calls another constructor of the base class, or that does something else entirely, you must use the <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> method to create one, and provide your own implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-226">В следующем примере кода показано использование `DefineConstructor` для задания определенной сигнатуры и атрибутов конструктора для динамического типа и возврата соответствующего <xref:System.Reflection.Emit.ConstructorBuilder> для заполнения MSIL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-226">The following code sample demonstrates the use of `DefineConstructor` to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref:System.Reflection.Emit.ConstructorBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-227">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-227">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes, class System.Type[][] requiredCustomModifiers, class System.Type[][] optionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type(), requiredCustomModifiers As Type()(), optionalCustomModifiers As Type()()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ requiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ optionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineConstructor : System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineConstructor (attributes, callingConvention, parameterTypes, requiredCustomModifiers, optionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[][]" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[][]" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="attributes"><span data-ttu-id="15a0e-228">Атрибуты конструктора.</span><span class="sxs-lookup"><span data-stu-id="15a0e-228">The attributes of the constructor.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="15a0e-229">Соглашение о вызовах конструктора.</span><span class="sxs-lookup"><span data-stu-id="15a0e-229">The calling convention of the constructor.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="15a0e-230">Типы параметров конструктора.</span><span class="sxs-lookup"><span data-stu-id="15a0e-230">The parameter types of the constructor.</span></span></param>
        <param name="requiredCustomModifiers"><span data-ttu-id="15a0e-231">Массив массивов типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-231">An array of arrays of types.</span></span> <span data-ttu-id="15a0e-232">Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-232">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="15a0e-233">Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-233">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="15a0e-234">Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-234">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="optionalCustomModifiers"><span data-ttu-id="15a0e-235">Массив массивов типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-235">An array of arrays of types.</span></span> <span data-ttu-id="15a0e-236">Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-236">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="15a0e-237">Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-237">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="15a0e-238">Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-238">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <summary><span data-ttu-id="15a0e-239">Добавляет в тип новый конструктор с заданными атрибутами, сигнатурой и настраиваемыми модификаторами.</span><span class="sxs-lookup"><span data-stu-id="15a0e-239">Adds a new constructor to the type, with the given attributes, signature, and custom modifiers.</span></span></summary>
        <returns><span data-ttu-id="15a0e-240">Определенный конструктор.</span><span class="sxs-lookup"><span data-stu-id="15a0e-240">The defined constructor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-241">Эта перегрузка предоставляется для конструкторов управляемых компиляторов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-241">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-242">Дополнительные сведения о пользовательских модификаторах см. в документации по метаданным раздела в ECMA Partition II.</span><span class="sxs-lookup"><span data-stu-id="15a0e-242">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="15a0e-243">Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.</span><span class="sxs-lookup"><span data-stu-id="15a0e-243">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-244">Размер <paramref name="requiredCustomModifiers" /> или <paramref name="optionalCustomModifiers" /> не равен размеру <paramref name="parameterTypes" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-244">The size of <paramref name="requiredCustomModifiers" /> or <paramref name="optionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-245">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-245">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="15a0e-246">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-246">-or-</span></span> 
<span data-ttu-id="15a0e-247">Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-247">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDefaultConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor (System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor(valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDefaultConstructor (attributes As MethodAttributes) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineDefaultConstructor(System::Reflection::MethodAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDefaultConstructor : System.Reflection.MethodAttributes -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineDefaultConstructor attributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes"><span data-ttu-id="15a0e-248">Объект <see langword="MethodAttributes" />, представляющий атрибуты, применяемые к конструктору.</span><span class="sxs-lookup"><span data-stu-id="15a0e-248">A <see langword="MethodAttributes" /> object representing the attributes to be applied to the constructor.</span></span></param>
        <summary><span data-ttu-id="15a0e-249">Определяет конструктор без параметров.</span><span class="sxs-lookup"><span data-stu-id="15a0e-249">Defines the parameterless constructor.</span></span> <span data-ttu-id="15a0e-250">Определенный здесь конструктор просто вызовет конструктор без параметров родительского элемента.</span><span class="sxs-lookup"><span data-stu-id="15a0e-250">The constructor defined here will simply call the parameterless constructor of the parent.</span></span></summary>
        <returns><span data-ttu-id="15a0e-251">Возвращает конструктор.</span><span class="sxs-lookup"><span data-stu-id="15a0e-251">Returns the constructor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-252">Поскольку конструктор без параметров определяется автоматически, необходимо вызывать этот метод только в следующих ситуациях:</span><span class="sxs-lookup"><span data-stu-id="15a0e-252">Because the parameterless constructor is automatically defined, it is necessary to call this method only in the following situations:</span></span>  
  
-   <span data-ttu-id="15a0e-253">Вы определили другой конструктор, а также хотите использовать конструктор без параметров, который просто вызывает конструктор базового класса.</span><span class="sxs-lookup"><span data-stu-id="15a0e-253">You have defined another constructor and you also want a parameterless constructor that simply calls the base class constructor.</span></span>  
  
-   <span data-ttu-id="15a0e-254">Необходимо установить атрибуты конструктора без параметров в значение, отличное от <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName> и <xref:System.Reflection.MethodAttributes.RTSpecialName>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-254">You want to set the attributes on the parameterless constructor to something other than <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName>, and <xref:System.Reflection.MethodAttributes.RTSpecialName>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-255">В следующем примере кода показано использование `DefineConstructor` для задания определенной сигнатуры и атрибутов конструктора для динамического типа и возврата соответствующего <xref:System.Reflection.Emit.ConstructorBuilder> для заполнения MSIL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-255">The following code sample demonstrates the use of `DefineConstructor` to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref:System.Reflection.Emit.ConstructorBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-256">У родительского типа (базового типа) нет конструктора без параметров.</span><span class="sxs-lookup"><span data-stu-id="15a0e-256">The parent type (base type) does not have a parameterless constructor.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-257">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-257">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="15a0e-258">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-258">-or-</span></span> 
<span data-ttu-id="15a0e-259">Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-259">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EventBuilder DefineEvent (string name, System.Reflection.EventAttributes attributes, Type eventtype);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EventBuilder DefineEvent(string name, valuetype System.Reflection.EventAttributes attributes, class System.Type eventtype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineEvent (name As String, attributes As EventAttributes, eventtype As Type) As EventBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::EventBuilder ^ DefineEvent(System::String ^ name, System::Reflection::EventAttributes attributes, Type ^ eventtype);" />
      <MemberSignature Language="F#" Value="member this.DefineEvent : string * System.Reflection.EventAttributes * Type -&gt; System.Reflection.Emit.EventBuilder" Usage="typeBuilder.DefineEvent (name, attributes, eventtype)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EventBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.EventAttributes" />
        <Parameter Name="eventtype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-260">Имя события.</span><span class="sxs-lookup"><span data-stu-id="15a0e-260">The name of the event.</span></span> <span data-ttu-id="15a0e-261">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-261"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="15a0e-262">Атрибуты события.</span><span class="sxs-lookup"><span data-stu-id="15a0e-262">The attributes of the event.</span></span></param>
        <param name="eventtype"><span data-ttu-id="15a0e-263">Тип события.</span><span class="sxs-lookup"><span data-stu-id="15a0e-263">The type of the event.</span></span></param>
        <summary><span data-ttu-id="15a0e-264">Добавляет новое событие в тип с заданным именем, атрибутами и типом события.</span><span class="sxs-lookup"><span data-stu-id="15a0e-264">Adds a new event to the type, with the given name, attributes and event type.</span></span></summary>
        <returns><span data-ttu-id="15a0e-265">Определенное событие.</span><span class="sxs-lookup"><span data-stu-id="15a0e-265">The defined event.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-266">Длина параметра <paramref name="name" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-266">The length of <paramref name="name" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-267">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-267"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="15a0e-268">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-268">-or-</span></span> 
 <span data-ttu-id="15a0e-269">Свойство <paramref name="eventtype" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-269"><paramref name="eventtype" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-270">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-270">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="15a0e-271">Добавляет новое поле к динамическому типу.</span><span class="sxs-lookup"><span data-stu-id="15a0e-271">Adds a new field to the dynamic type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineField : string * Type * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineField (fieldName, type, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName"><span data-ttu-id="15a0e-272">Имя поля.</span><span class="sxs-lookup"><span data-stu-id="15a0e-272">The name of the field.</span></span> <span data-ttu-id="15a0e-273">Параметр <paramref name="fieldName" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-273"><paramref name="fieldName" /> cannot contain embedded nulls.</span></span></param>
        <param name="type"><span data-ttu-id="15a0e-274">Тип поля.</span><span class="sxs-lookup"><span data-stu-id="15a0e-274">The type of the field</span></span></param>
        <param name="attributes"><span data-ttu-id="15a0e-275">Атрибуты поля.</span><span class="sxs-lookup"><span data-stu-id="15a0e-275">The attributes of the field.</span></span></param>
        <summary><span data-ttu-id="15a0e-276">Добавляет новое поле в тип с заданным именем, атрибутами и типом поля.</span><span class="sxs-lookup"><span data-stu-id="15a0e-276">Adds a new field to the type, with the given name, attributes, and field type.</span></span></summary>
        <returns><span data-ttu-id="15a0e-277">Определенное поле.</span><span class="sxs-lookup"><span data-stu-id="15a0e-277">The defined field.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-278">Длина параметра <paramref name="fieldName" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-278">The length of <paramref name="fieldName" /> is zero.</span></span>  
  
<span data-ttu-id="15a0e-279">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-279">-or-</span></span> 
 <span data-ttu-id="15a0e-280">Параметр <paramref name="type" /> имеет значение System.Void.</span><span class="sxs-lookup"><span data-stu-id="15a0e-280"><paramref name="type" /> is System.Void.</span></span>  
  
<span data-ttu-id="15a0e-281">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-281">-or-</span></span> 
<span data-ttu-id="15a0e-282">Общий размер был указан для родительского класса этого поля.</span><span class="sxs-lookup"><span data-stu-id="15a0e-282">A total size was specified for the parent class of this field.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-283"><paramref name="fieldName" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-283"><paramref name="fieldName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-284">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-284">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, class System.Type[] requiredCustomModifiers, class System.Type[] optionalCustomModifiers, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, cli::array &lt;Type ^&gt; ^ requiredCustomModifiers, cli::array &lt;Type ^&gt; ^ optionalCustomModifiers, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineField : string * Type * Type[] * Type[] * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineField (fieldName, type, requiredCustomModifiers, optionalCustomModifiers, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fieldName"><span data-ttu-id="15a0e-285">Имя поля.</span><span class="sxs-lookup"><span data-stu-id="15a0e-285">The name of the field.</span></span> <span data-ttu-id="15a0e-286">Параметр <paramref name="fieldName" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-286"><paramref name="fieldName" /> cannot contain embedded nulls.</span></span></param>
        <param name="type"><span data-ttu-id="15a0e-287">Тип поля.</span><span class="sxs-lookup"><span data-stu-id="15a0e-287">The type of the field</span></span></param>
        <param name="requiredCustomModifiers"><span data-ttu-id="15a0e-288">Массив типов, представляющих обязательные настраиваемые модификаторы для поля, например <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-288">An array of types representing the required custom modifiers for the field, such as <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span></span></param>
        <param name="optionalCustomModifiers"><span data-ttu-id="15a0e-289">Массив типов, представляющих необязательные настраиваемые модификаторы для поля, например <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-289">An array of types representing the optional custom modifiers for the field, such as <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span></span></param>
        <param name="attributes"><span data-ttu-id="15a0e-290">Атрибуты поля.</span><span class="sxs-lookup"><span data-stu-id="15a0e-290">The attributes of the field.</span></span></param>
        <summary><span data-ttu-id="15a0e-291">Добавляет новое поле в тип с заданным именем, атрибутами, типом поля и настраиваемыми модификаторами.</span><span class="sxs-lookup"><span data-stu-id="15a0e-291">Adds a new field to the type, with the given name, attributes, field type, and custom modifiers.</span></span></summary>
        <returns><span data-ttu-id="15a0e-292">Определенное поле.</span><span class="sxs-lookup"><span data-stu-id="15a0e-292">The defined field.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-293">Эта перегрузка предоставляется для конструкторов управляемых компиляторов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-293">This overload is provided for designers of managed compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-294">Длина параметра <paramref name="fieldName" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-294">The length of <paramref name="fieldName" /> is zero.</span></span>  
  
<span data-ttu-id="15a0e-295">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-295">-or-</span></span> 
 <span data-ttu-id="15a0e-296">Параметр <paramref name="type" /> имеет значение System.Void.</span><span class="sxs-lookup"><span data-stu-id="15a0e-296"><paramref name="type" /> is System.Void.</span></span>  
  
<span data-ttu-id="15a0e-297">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-297">-or-</span></span> 
<span data-ttu-id="15a0e-298">Общий размер был указан для родительского класса этого поля.</span><span class="sxs-lookup"><span data-stu-id="15a0e-298">A total size was specified for the parent class of this field.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-299">Свойство <paramref name="fieldName" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-299"><paramref name="fieldName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-300">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-300">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.DefineGenericParameters : string[] -&gt; System.Reflection.Emit.GenericTypeParameterBuilder[]" Usage="typeBuilder.DefineGenericParameters names" />
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (string[] names);" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (names As String()) As GenericTypeParameterBuilder()" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(cli::array &lt;System::String ^&gt; ^ names);" FrameworkAlternate="xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-1.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names"><span data-ttu-id="15a0e-301">Массив имен для параметров универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-301">An array of names for the generic type parameters.</span></span></param>
        <summary><span data-ttu-id="15a0e-302">Определяет параметры универсального типа для текущего типа, указывая их количество и имена, и возвращает массив объектов <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />, которые можно использовать для задания их ограничений.</span><span class="sxs-lookup"><span data-stu-id="15a0e-302">Defines the generic type parameters for the current type, specifying their number and their names, and returns an array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that can be used to set their constraints.</span></span></summary>
        <returns><span data-ttu-id="15a0e-303">Массив объектов <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />, которые можно использовать для определения ограничений параметров универсального типа для текущего типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-303">An array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that can be used to define the constraints of the generic type parameters for the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-304">Вызов этого метода делает текущий тип универсальным.</span><span class="sxs-lookup"><span data-stu-id="15a0e-304">Calling this method makes the current type a generic type.</span></span> <span data-ttu-id="15a0e-305">Если метод вызывается повторно для того же типа, выдается <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-305">If the method is called again on the same type, an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-306">В следующем примере кода создается универсальный тип с двумя параметрами типа и сохраняется в сборке GenericEmitExample1. dll.</span><span class="sxs-lookup"><span data-stu-id="15a0e-306">The following code example creates a generic type with two type parameters and saves them in the assembly GenericEmitExample1.dll.</span></span> <span data-ttu-id="15a0e-307">Для просмотра созданных типов можно использовать программу [Ildasm. exe (ДИЗАССЕМБЛЕР IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) .</span><span class="sxs-lookup"><span data-stu-id="15a0e-307">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to view the generated types.</span></span> <span data-ttu-id="15a0e-308">Более подробное описание действий, связанных с определением динамического универсального типа, см. в разделе [How: Определение универсального типа с порождаемым отражением](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)</span><span class="sxs-lookup"><span data-stu-id="15a0e-308">For a more detailed explanation of the steps involved in defining a dynamic generic type, see [How to: Define a Generic Type with Reflection Emit](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).</span></span>  
  
 [!code-cpp[EmitGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#1)]
 [!code-csharp[EmitGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#1)]
 [!code-vb[EmitGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-309">Для этого типа уже были определены параметры универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-309">Generic type parameters have already been defined for this type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-310"><paramref name="names" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-310"><paramref name="names" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="15a0e-311">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-311">-or-</span></span> 
<span data-ttu-id="15a0e-312">Элемент <paramref name="names" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-312">An element of <paramref name="names" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-313"><paramref name="names" /> является пустым массивом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-313"><paramref name="names" /> is an empty array.</span></span></exception>
        <altmember cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
        <related type="Article" href="https://msdn.microsoft.com/library/07d5f01a-7b5b-40ea-9b15-f21561098fe4"><span data-ttu-id="15a0e-314">Практическое руководство. Определение универсального типа с порождаемым отражением</span><span class="sxs-lookup"><span data-stu-id="15a0e-314">How to: Define a Generic Type with Reflection Emit</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineInitializedData (name As String, data As Byte(), attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineInitializedData(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineInitializedData : string * byte[] * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineInitializedData (name, data, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-315">Имя, используемое для ссылки на данные.</span><span class="sxs-lookup"><span data-stu-id="15a0e-315">The name used to refer to the data.</span></span> <span data-ttu-id="15a0e-316">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-316"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="data"><span data-ttu-id="15a0e-317">Большой двоичный объект данных.</span><span class="sxs-lookup"><span data-stu-id="15a0e-317">The blob of data.</span></span></param>
        <param name="attributes"><span data-ttu-id="15a0e-318">Атрибуты поля.</span><span class="sxs-lookup"><span data-stu-id="15a0e-318">The attributes for the field.</span></span></param>
        <summary><span data-ttu-id="15a0e-319">Определяет инициализированное поле данных в разделе .sdata переносимого исполняемого (PE) файла.</span><span class="sxs-lookup"><span data-stu-id="15a0e-319">Defines initialized data field in the .sdata section of the portable executable (PE) file.</span></span></summary>
        <returns><span data-ttu-id="15a0e-320">Поле для ссылки на данные.</span><span class="sxs-lookup"><span data-stu-id="15a0e-320">A field to reference the data.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-321">Поле, создаваемое с помощью этого метода, будет `static`, даже если в параметре `attributes` не включено `FieldAttributes.Static`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-321">The field that you create with this method will be `static`, even if you do not include `FieldAttributes.Static` in the `attributes` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-322">Длина параметра <paramref name="name" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-322">Length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="15a0e-323">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-323">-or-</span></span> 
<span data-ttu-id="15a0e-324">Размер данных не больше нуля либо не меньше 0x3f0000.</span><span class="sxs-lookup"><span data-stu-id="15a0e-324">The size of the data is less than or equal to zero, or greater than or equal to 0x3f0000.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-325">Значение параметра <paramref name="name" /> или <paramref name="data" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-325"><paramref name="name" /> or <paramref name="data" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-326"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> был вызван ранее.</span><span class="sxs-lookup"><span data-stu-id="15a0e-326"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> has been previously called.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="15a0e-327">Добавляет метод к типу.</span><span class="sxs-lookup"><span data-stu-id="15a0e-327">Adds a method to the type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-328">Имя метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-328">The name of the method.</span></span> <span data-ttu-id="15a0e-329">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-329"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="15a0e-330">Атрибуты метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-330">The attributes of the method.</span></span></param>
        <summary><span data-ttu-id="15a0e-331">Добавляет новый метод в тип с указанным именем и атрибутами метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-331">Adds a new method to the type, with the specified name and method attributes.</span></span></summary>
        <returns><span data-ttu-id="15a0e-332">Объект <see cref="T:System.Reflection.Emit.MethodBuilder" />, представляющий вновь определенный метод.</span><span class="sxs-lookup"><span data-stu-id="15a0e-332">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-333">Используйте эту перегрузку метода, если подпись метода не известна во время определения метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-333">Use this method overload when you do not know the method signature at the time you define the method.</span></span> <span data-ttu-id="15a0e-334">Например, типы параметров и возвращаемый тип универсального метода могут быть заданы параметрами универсального типа метода, которые должны быть определены после добавления метода к типу.</span><span class="sxs-lookup"><span data-stu-id="15a0e-334">For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</span></span> <span data-ttu-id="15a0e-335">Параметры и возвращаемый тип метода можно задать позже с помощью метода <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-335">The parameters and return type of the method can be set later using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="15a0e-336">Этот перегруженный метод определяет метод с <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-336">This method overload defines a method with <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.</span></span> <span data-ttu-id="15a0e-337">Если необходимо определить метод без сигнатуры с другим соглашением о вызовах, используйте перегрузку метода <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-337">If you need to define a method without a signature, with a different calling convention, use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-338">В следующем примере кода определяется универсальный метод с именем `DemoMethod`, тип параметра и тип возвращаемого значения которого задаются параметрами универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-338">The following code example defines a generic method named `DemoMethod` whose parameter type and return type are specified by its generic type parameters.</span></span> <span data-ttu-id="15a0e-339">Метод определяется без сигнатуры с использованием стандартного соглашения о вызовах.</span><span class="sxs-lookup"><span data-stu-id="15a0e-339">The method is defined without a signature, using the standard calling convention.</span></span> <span data-ttu-id="15a0e-340">Метод <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> используется для создания `DemoMethod` универсального метода, а вновь определенные параметры типа используются для сигнатуры и типа возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-340">The <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method is used to make `DemoMethod` a generic method, and the newly defined type parameters are then used for the signature and return type.</span></span>  
  
 <span data-ttu-id="15a0e-341">Этот пример кода является частью большого примера, приведенного для метода <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-341">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#4](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#4)]
 [!code-csharp[GenericMethodBuilder#4](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#4)]
 [!code-vb[GenericMethodBuilder#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#4)]  
[!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
[!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
[!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-342">Длина параметра <paramref name="name" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-342">The length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="15a0e-343">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-343">-or-</span></span> 
<span data-ttu-id="15a0e-344">Тип родительского элемента данного метода — интерфейс, и этот метод не является виртуальным (<see langword="Overridable" /> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="15a0e-344">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-345">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-345"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-346">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-346">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="15a0e-347">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-347">-or-</span></span> 
<span data-ttu-id="15a0e-348">Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-348">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-349">Имя метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-349">The name of the method.</span></span> <span data-ttu-id="15a0e-350">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-350"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="15a0e-351">Атрибуты метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-351">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="15a0e-352">Соглашение о вызовах метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-352">The calling convention of the method.</span></span></param>
        <summary><span data-ttu-id="15a0e-353">Добавляет новый метод в тип с указанным именем, атрибутами метода, соглашением о вызовах.</span><span class="sxs-lookup"><span data-stu-id="15a0e-353">Adds a new method to the type, with the specified name, method attributes, and calling convention.</span></span></summary>
        <returns><span data-ttu-id="15a0e-354">Объект <see cref="T:System.Reflection.Emit.MethodBuilder" />, представляющий вновь определенный метод.</span><span class="sxs-lookup"><span data-stu-id="15a0e-354">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-355">Используйте эту перегрузку метода, если подпись метода не известна во время определения метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-355">Use this method overload when you do not know the method signature at the time you define the method.</span></span> <span data-ttu-id="15a0e-356">Например, типы параметров и возвращаемый тип универсального метода могут быть заданы параметрами универсального типа метода, которые должны быть определены после добавления метода к типу.</span><span class="sxs-lookup"><span data-stu-id="15a0e-356">For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</span></span> <span data-ttu-id="15a0e-357">Параметры и возвращаемый тип метода можно задать позже с помощью метода <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-357">The parameters and return type of the method can be set later using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-358">Длина параметра <paramref name="name" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-358">The length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="15a0e-359">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-359">-or-</span></span> 
<span data-ttu-id="15a0e-360">Тип родительского элемента данного метода является интерфейсом, и этот метод не является виртуальным (<see langword="Overridable" /> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="15a0e-360">The type of the parent of this method is an interface and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-361"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-361"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-362">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-362">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="15a0e-363">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-363">-or-</span></span> 
<span data-ttu-id="15a0e-364">Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-364">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-365">Имя метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-365">The name of the method.</span></span> <span data-ttu-id="15a0e-366">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-366"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="15a0e-367">Атрибуты метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-367">The attributes of the method.</span></span></param>
        <param name="returnType"><span data-ttu-id="15a0e-368">Тип возвращаемых данных метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-368">The return type of the method.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="15a0e-369">Типы параметров метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-369">The types of the parameters of the method.</span></span></param>
        <summary><span data-ttu-id="15a0e-370">Добавляет новый метод в тип с указанным именем, атрибутами метода и сигнатурой метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-370">Adds a new method to the type, with the specified name, method attributes, and method signature.</span></span></summary>
        <returns><span data-ttu-id="15a0e-371">Определенный метод.</span><span class="sxs-lookup"><span data-stu-id="15a0e-371">The defined method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="15a0e-372">В следующем примере кода показано использование `DefineMethod` для задания определенной сигнатуры и атрибутов конструктора для динамического типа и возврата соответствующего <xref:System.Reflection.Emit.MethodBuilder> для заполнения MSIL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-372">The following code sample demonstrates the use of `DefineMethod` to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref:System.Reflection.Emit.MethodBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-373">Длина параметра <paramref name="name" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-373">The length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="15a0e-374">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-374">-or-</span></span> 
<span data-ttu-id="15a0e-375">Тип родительского элемента данного метода — интерфейс, и этот метод не является виртуальным (<see langword="Overridable" /> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="15a0e-375">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-376">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-376"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-377">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-377">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="15a0e-378">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-378">-or-</span></span> 
<span data-ttu-id="15a0e-379">Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-379">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-380">Имя метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-380">The name of the method.</span></span> <span data-ttu-id="15a0e-381">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-381"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="15a0e-382">Атрибуты метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-382">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="15a0e-383">Соглашение о вызовах метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-383">The calling convention of the method.</span></span></param>
        <param name="returnType"><span data-ttu-id="15a0e-384">Тип возвращаемых данных метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-384">The return type of the method.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="15a0e-385">Типы параметров метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-385">The types of the parameters of the method.</span></span></param>
        <summary><span data-ttu-id="15a0e-386">Добавляет новый метод в тип с указанным именем, атрибутами метода, соглашением о вызовах и сигнатурой метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-386">Adds a new method to the type, with the specified name, method attributes, calling convention, and method signature.</span></span></summary>
        <returns><span data-ttu-id="15a0e-387">Объект <see cref="T:System.Reflection.Emit.MethodBuilder" />, представляющий вновь определенный метод.</span><span class="sxs-lookup"><span data-stu-id="15a0e-387">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="15a0e-388">В следующем примере кода показано использование `DefineMethod` для задания определенной сигнатуры и атрибутов конструктора для динамического типа и возврата соответствующего <xref:System.Reflection.Emit.MethodBuilder> для заполнения MSIL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-388">The following code sample demonstrates the use of `DefineMethod` to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref:System.Reflection.Emit.MethodBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-389">Длина параметра <paramref name="name" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-389">The length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="15a0e-390">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-390">-or-</span></span> 
<span data-ttu-id="15a0e-391">Тип родительского элемента данного метода — интерфейс, и этот метод не является виртуальным (<see langword="Overridable" /> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="15a0e-391">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-392">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-392"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-393">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-393">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="15a0e-394">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-394">-or-</span></span> 
<span data-ttu-id="15a0e-395">Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-395">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="6" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" Index="7" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" Index="8" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-396">Имя метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-396">The name of the method.</span></span> <span data-ttu-id="15a0e-397">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-397"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="15a0e-398">Атрибуты метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-398">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="15a0e-399">Соглашение о вызовах метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-399">The calling convention of the method.</span></span></param>
        <param name="returnType"><span data-ttu-id="15a0e-400">Тип возвращаемых данных метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-400">The return type of the method.</span></span></param>
        <param name="returnTypeRequiredCustomModifiers"><span data-ttu-id="15a0e-401">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-401">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span></span> <span data-ttu-id="15a0e-402">Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-402">If the return type has no required custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="returnTypeOptionalCustomModifiers"><span data-ttu-id="15a0e-403">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-403">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span></span> <span data-ttu-id="15a0e-404">Если возвращаемый тип не содержит необязательные настраиваемые модификаторы, укажите <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-404">If the return type has no optional custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="15a0e-405">Типы параметров метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-405">The types of the parameters of the method.</span></span></param>
        <param name="parameterTypeRequiredCustomModifiers"><span data-ttu-id="15a0e-406">Массив массивов типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-406">An array of arrays of types.</span></span> <span data-ttu-id="15a0e-407">Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-407">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="15a0e-408">Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-408">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="15a0e-409">Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-409">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="parameterTypeOptionalCustomModifiers"><span data-ttu-id="15a0e-410">Массив массивов типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-410">An array of arrays of types.</span></span> <span data-ttu-id="15a0e-411">Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-411">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="15a0e-412">Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-412">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="15a0e-413">Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-413">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <summary><span data-ttu-id="15a0e-414">Добавляет новый метод в тип с указанным именем, атрибутами метода, соглашением о вызовах, сигнатурой метода и настраиваемыми модификаторами.</span><span class="sxs-lookup"><span data-stu-id="15a0e-414">Adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers.</span></span></summary>
        <returns><span data-ttu-id="15a0e-415">Объект <see cref="T:System.Reflection.Emit.MethodBuilder" />, представляющий добавленный метод.</span><span class="sxs-lookup"><span data-stu-id="15a0e-415">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> object representing the newly added method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-416">Используйте эту перегрузку, если необходимо указать настраиваемые модификаторы.</span><span class="sxs-lookup"><span data-stu-id="15a0e-416">Use this overload if you need to specify custom modifiers.</span></span> <span data-ttu-id="15a0e-417">Если после создания метода необходимо указать пользовательские модификаторы, как, например, с универсальным методом, типы параметров которого указываются с помощью параметров универсального типа, можно использовать перегрузки методов <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> или <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29>, чтобы определить метод и затем используйте метод <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>, чтобы определить параметры и возвращаемые типы с помощью настраиваемых модификаторов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-417">If you need to specify custom modifiers after the method has been created, as you would, for example, with a generic method whose parameter types are specified by its generic type parameters, you can use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> or <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> method overloads to define the method and then use the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method to define the parameter and return types with custom modifiers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-418">Дополнительные сведения о пользовательских модификаторах см. в документации по метаданным раздела в ECMA Partition II.</span><span class="sxs-lookup"><span data-stu-id="15a0e-418">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="15a0e-419">Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.</span><span class="sxs-lookup"><span data-stu-id="15a0e-419">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-420">Длина параметра <paramref name="name" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-420">The length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="15a0e-421">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-421">-or-</span></span> 
<span data-ttu-id="15a0e-422">Тип родительского элемента данного метода — интерфейс, и этот метод не является виртуальным (<see langword="Overridable" /> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="15a0e-422">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span></span>  
  
<span data-ttu-id="15a0e-423">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-423">-or-</span></span> 
<span data-ttu-id="15a0e-424">Размер <paramref name="parameterTypeRequiredCustomModifiers" /> или <paramref name="parameterTypeOptionalCustomModifiers" /> не равен размеру <paramref name="parameterTypes" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-424">The size of <paramref name="parameterTypeRequiredCustomModifiers" /> or <paramref name="parameterTypeOptionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-425">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-425"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-426">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-426">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="15a0e-427">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-427">-or-</span></span> 
<span data-ttu-id="15a0e-428">Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-428">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethodOverride">
      <MemberSignature Language="C#" Value="public void DefineMethodOverride (System.Reflection.MethodInfo methodInfoBody, System.Reflection.MethodInfo methodInfoDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineMethodOverride(class System.Reflection.MethodInfo methodInfoBody, class System.Reflection.MethodInfo methodInfoDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineMethodOverride (methodInfoBody As MethodInfo, methodInfoDeclaration As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineMethodOverride(System::Reflection::MethodInfo ^ methodInfoBody, System::Reflection::MethodInfo ^ methodInfoDeclaration);" />
      <MemberSignature Language="F#" Value="member this.DefineMethodOverride : System.Reflection.MethodInfo * System.Reflection.MethodInfo -&gt; unit" Usage="typeBuilder.DefineMethodOverride (methodInfoBody, methodInfoDeclaration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodInfoBody" Type="System.Reflection.MethodInfo" />
        <Parameter Name="methodInfoDeclaration" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="methodInfoBody"><span data-ttu-id="15a0e-429">Тело метода, которое будет использоваться.</span><span class="sxs-lookup"><span data-stu-id="15a0e-429">The method body to be used.</span></span> <span data-ttu-id="15a0e-430">Должно быть объектом <see langword="MethodBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-430">This should be a <see langword="MethodBuilder" /> object.</span></span></param>
        <param name="methodInfoDeclaration"><span data-ttu-id="15a0e-431">Метод, объявление которого будет использоваться.</span><span class="sxs-lookup"><span data-stu-id="15a0e-431">The method whose declaration is to be used.</span></span></param>
        <summary><span data-ttu-id="15a0e-432">Задает тело данного метода, реализующее объявление данного метода, возможно, с другим именем.</span><span class="sxs-lookup"><span data-stu-id="15a0e-432">Specifies a given method body that implements a given method declaration, potentially with a different name.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-433">Не используйте этот метод для выдачи переопределений методов или реализаций интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-433">Do not use this method to emit method overrides or interface implementations.</span></span> <span data-ttu-id="15a0e-434">Чтобы переопределить метод базового класса или реализовать метод интерфейса, просто выпустите метод с тем же именем и сигнатурой, что и у метода, который необходимо переопределить или реализовать, как показано в примере кода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-434">To override a method of a base class or to implement a method of an interface, simply emit a method with the same name and signature as the method to be overridden or implemented, as demonstrated in the code example.</span></span>  
  
 <span data-ttu-id="15a0e-435">Метод <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> используется, когда тело метода и объявление метода имеют разные имена.</span><span class="sxs-lookup"><span data-stu-id="15a0e-435">The <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method is used when a method body and a method declaration have different names.</span></span> <span data-ttu-id="15a0e-436">Например, класс может переопределить метод базового класса, а также предоставить отдельную реализацию для члена интерфейса с тем же именем, как показано в примере кода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-436">For example, a class might override a base class method and also provide a separate implementation for an interface member with the same name, as demonstrated in the code example.</span></span>  
  
 <span data-ttu-id="15a0e-437">`DefineMethodOverride` определяет `methodimpl`, который состоит из пары токенов метаданных.</span><span class="sxs-lookup"><span data-stu-id="15a0e-437">`DefineMethodOverride` defines a `methodimpl`, which consists of a pair of metadata tokens.</span></span> <span data-ttu-id="15a0e-438">Один маркер указывает на реализацию, а другой токен указывает на объявление, которое реализуется телом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-438">One token points to an implementation, and the other token points to a declaration that the body implements.</span></span> <span data-ttu-id="15a0e-439">Текст должен быть определен в типе, для которого определен метод Impl, а текст должен быть виртуальным (`Overridable` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="15a0e-439">The body must be defined on the type the method impl is defined on, and the body must be virtual (`Overridable` in Visual Basic).</span></span> <span data-ttu-id="15a0e-440">Объявление может быть выполнено для метода, определенного в интерфейсе, реализованном с помощью типа, метода в производном классе или в методе, определенном в типе.</span><span class="sxs-lookup"><span data-stu-id="15a0e-440">The declaration can be made to a method defined on an interface implemented by the type, a method on a derived class, or a method defined in the type.</span></span> <span data-ttu-id="15a0e-441">Если объявление размещается только в интерфейсе, изменяется слот, определенный для интерфейса.</span><span class="sxs-lookup"><span data-stu-id="15a0e-441">If the declaration is on an interface only, the slot defined for the interface is altered.</span></span> <span data-ttu-id="15a0e-442">Если объявление выполняется в метод базового типа, то область для метода переопределяется и все дубликаты переопределенного метода также заменяются.</span><span class="sxs-lookup"><span data-stu-id="15a0e-442">If the declaration is made to a method on a base type, the slot for the method is overridden and any duplicates for the overridden method are also replaced.</span></span> <span data-ttu-id="15a0e-443">Переопределенный метод не может быть фактически объявленным методом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-443">The overridden method cannot be the actual method that is declared.</span></span> <span data-ttu-id="15a0e-444">Если метод относится к тому же типу, слот заменяется, а все дубликаты для замененных методов переопределяются.</span><span class="sxs-lookup"><span data-stu-id="15a0e-444">If the method is on the same type, the slot is replaced and any duplicates for the replaced methods are overridden.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-445">Дополнительные сведения о методе реализация WriteEvent см. в разделе `MethodImpl` в документации по метаданным в разделе ECMA Partition II.</span><span class="sxs-lookup"><span data-stu-id="15a0e-445">For more information about method impls, see `MethodImpl` in the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="15a0e-446">Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.</span><span class="sxs-lookup"><span data-stu-id="15a0e-446">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="15a0e-447">После вызова метода <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> некоторые функции `methodInfoBody` нельзя изменить.</span><span class="sxs-lookup"><span data-stu-id="15a0e-447">After the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method is called, some features of `methodInfoBody` cannot be changed.</span></span> <span data-ttu-id="15a0e-448">Например, атрибут нельзя применить к параметру универсального типа `methodInfoBody` с помощью метода <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-448">For example, you cannot apply an attribute to a generic type parameter of `methodInfoBody` by using the <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> method.</span></span> <span data-ttu-id="15a0e-449">Если необходимо использовать метод <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A>, сделайте это после определения всех характеристик `methodInfoBody`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-449">If you must use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method, do so after all characteristics of `methodInfoBody` have been defined.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-450">Следующий пример кода содержит интерфейс `I` с методом `M()`, базовый класс `A`, который реализует интерфейс, и производный класс `C`, который переопределяет реализацию базового класса `M()`, а также предоставляет отдельный явный Реализация `I.M()`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-450">The following code example contains an interface `I` with a method `M()`, a base class `A` that implements the interface, and a derived class `C` that overrides the base class implementation of `M()` and also provides a separate explicit implementation of `I.M()`.</span></span>  
  
 <span data-ttu-id="15a0e-451">Метод `main()` в примере кода показывает, как выдавать производный класс `C`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-451">The `main()` method of the code example shows how to emit the derived class `C`.</span></span> <span data-ttu-id="15a0e-452">Переопределение `A.M()` выполняется просто путем выпуска метода `M()` с той же сигнатурой.</span><span class="sxs-lookup"><span data-stu-id="15a0e-452">The override of `A.M()` is accomplished simply by emitting a method `M()` with the same signature.</span></span> <span data-ttu-id="15a0e-453">Однако для предоставления отдельной реализации `I.M()` необходимо определить тело метода, а затем использовать метод <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> для связывания тела метода с <xref:System.Reflection.MethodInfo>, представляющего `I.M()`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-453">However, to provide a separate implementation of `I.M()`, you must define a method body and then use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method to associate that method body with a <xref:System.Reflection.MethodInfo> representing `I.M()`.</span></span> <span data-ttu-id="15a0e-454">Имя тела метода не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-454">The name of the method body does not matter.</span></span>  
  
 <span data-ttu-id="15a0e-455">В примере кода создается экземпляр выпущенного класса.</span><span class="sxs-lookup"><span data-stu-id="15a0e-455">The code example creates an instance of the emitted class.</span></span> <span data-ttu-id="15a0e-456">Он получает объект <xref:System.Reflection.MethodInfo> для `I.M()` и использует его для вызова явной реализации интерфейса порожденного класса.</span><span class="sxs-lookup"><span data-stu-id="15a0e-456">It obtains a <xref:System.Reflection.MethodInfo> object for `I.M()`, and uses it to invoke the emitted class's explicit interface implementation.</span></span> <span data-ttu-id="15a0e-457">Затем он получает объект <xref:System.Reflection.MethodInfo> для `A.M()` и использует его для вызова переопределения переданного метода класса.</span><span class="sxs-lookup"><span data-stu-id="15a0e-457">It then obtains a <xref:System.Reflection.MethodInfo> object for `A.M()`, and uses it to invoke the emitted class's override of that method.</span></span>  
  
 [!code-cpp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cpp/source.cpp#1)]
 [!code-csharp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cs/source.cs#1)]
 [!code-vb[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-458">Объект <paramref name="methodInfoBody" /> не принадлежит к этому классу.</span><span class="sxs-lookup"><span data-stu-id="15a0e-458"><paramref name="methodInfoBody" /> does not belong to this class.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-459">Значение параметра <paramref name="methodInfoBody" /> или <paramref name="methodInfoDeclaration" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-459"><paramref name="methodInfoBody" /> or <paramref name="methodInfoDeclaration" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-460">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-460">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="15a0e-461">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-461">-or-</span></span> 
<span data-ttu-id="15a0e-462">Объявляющий тип <paramref name="methodInfoBody" /> не является типом, представленным этим <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-462">The declaring type of <paramref name="methodInfoBody" /> is not the type represented by this <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineNestedType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="15a0e-463">Определяет вложенный тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-463">Defines a nested type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-464">Краткое имя объекта.</span><span class="sxs-lookup"><span data-stu-id="15a0e-464">The short name of the type.</span></span> <span data-ttu-id="15a0e-465">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-465"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <summary><span data-ttu-id="15a0e-466">Определяет вложенный тип с заданным именем.</span><span class="sxs-lookup"><span data-stu-id="15a0e-466">Defines a nested type, given its name.</span></span></summary>
        <returns><span data-ttu-id="15a0e-467">Определенный вложенный тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-467">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-468">Этот метод можно использовать для создания вложенных типов даже после вызова метода <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для включающего типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-468">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="15a0e-469">Вложенный тип должен быть завершен, прежде чем его можно будет отразить с помощью <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A> или <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-469">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="15a0e-470">Порядок, в котором должны быть выполнены вложенные типы и вложенные типы, см. в описании <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-470">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="15a0e-471">Повторяющееся имя не обязательно создается, если `name` совпадает с именем ранее определенного типа или вложенного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-471">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="15a0e-472">Для дублирования полные имена должны быть одинаковыми, включая пространство имен и все типы вложенности.</span><span class="sxs-lookup"><span data-stu-id="15a0e-472">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-473">Длина <paramref name="name" /> равна нулю или больше 1023.</span><span class="sxs-lookup"><span data-stu-id="15a0e-473">Length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="15a0e-474">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-474">-or-</span></span> 
<span data-ttu-id="15a0e-475">Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</span><span class="sxs-lookup"><span data-stu-id="15a0e-475">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-476"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-476"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-477">Краткое имя объекта.</span><span class="sxs-lookup"><span data-stu-id="15a0e-477">The short name of the type.</span></span> <span data-ttu-id="15a0e-478">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-478"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attr"><span data-ttu-id="15a0e-479">Атрибуты типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-479">The attributes of the type.</span></span></param>
        <summary><span data-ttu-id="15a0e-480">Определяет вложенный тип с заданным именем и атрибутами.</span><span class="sxs-lookup"><span data-stu-id="15a0e-480">Defines a nested type, given its name and attributes.</span></span></summary>
        <returns><span data-ttu-id="15a0e-481">Определенный вложенный тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-481">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-482">Этот метод можно использовать для создания вложенных типов даже после вызова метода <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для включающего типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-482">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="15a0e-483">Вложенный тип должен быть завершен, прежде чем его можно будет отразить с помощью <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A> или <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-483">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="15a0e-484">Порядок, в котором должны быть выполнены вложенные типы и вложенные типы, см. в описании <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-484">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="15a0e-485">Повторяющееся имя не обязательно создается, если `name` совпадает с именем ранее определенного типа или вложенного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-485">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="15a0e-486">Для дублирования полные имена должны быть одинаковыми, включая пространство имен и все типы вложенности.</span><span class="sxs-lookup"><span data-stu-id="15a0e-486">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-487">Не указан вложенный атрибут.</span><span class="sxs-lookup"><span data-stu-id="15a0e-487">The nested attribute is not specified.</span></span>  
  
<span data-ttu-id="15a0e-488">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-488">-or-</span></span> 
<span data-ttu-id="15a0e-489">Этот тип запечатан.</span><span class="sxs-lookup"><span data-stu-id="15a0e-489">This type is sealed.</span></span>  
  
<span data-ttu-id="15a0e-490">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-490">-or-</span></span> 
<span data-ttu-id="15a0e-491">Этот тип является массивом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-491">This type is an array.</span></span>  
  
<span data-ttu-id="15a0e-492">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-492">-or-</span></span> 
<span data-ttu-id="15a0e-493">Этот тип является интерфейсом, а вложенный тип не является интерфейсом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-493">This type is an interface, but the nested type is not an interface.</span></span>  
  
<span data-ttu-id="15a0e-494">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-494">-or-</span></span> 
<span data-ttu-id="15a0e-495">Длина <paramref name="name" /> равна нулю или больше 1023.</span><span class="sxs-lookup"><span data-stu-id="15a0e-495">The length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="15a0e-496">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-496">-or-</span></span> 
<span data-ttu-id="15a0e-497">Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</span><span class="sxs-lookup"><span data-stu-id="15a0e-497">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-498"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-498"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-499">Краткое имя объекта.</span><span class="sxs-lookup"><span data-stu-id="15a0e-499">The short name of the type.</span></span> <span data-ttu-id="15a0e-500">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-500"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attr"><span data-ttu-id="15a0e-501">Атрибуты типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-501">The attributes of the type.</span></span></param>
        <param name="parent"><span data-ttu-id="15a0e-502">Тип, который вложенный тип расширяет.</span><span class="sxs-lookup"><span data-stu-id="15a0e-502">The type that the nested type extends.</span></span></param>
        <summary><span data-ttu-id="15a0e-503">Определяет вложенный тип на основе его имени, атрибутов и типа, который он расширяет.</span><span class="sxs-lookup"><span data-stu-id="15a0e-503">Defines a nested type, given its name, attributes, and the type that it extends.</span></span></summary>
        <returns><span data-ttu-id="15a0e-504">Определенный вложенный тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-504">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-505">Этот метод можно использовать для создания вложенных типов даже после вызова метода <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для включающего типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-505">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="15a0e-506">Вложенный тип должен быть завершен, прежде чем его можно будет отразить с помощью <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A> или <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-506">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="15a0e-507">Порядок, в котором должны быть выполнены вложенные типы и вложенные типы, см. в описании <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-507">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="15a0e-508">Повторяющееся имя не обязательно создается, если `name` совпадает с именем ранее определенного типа или вложенного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-508">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="15a0e-509">Для дублирования полные имена должны быть одинаковыми, включая пространство имен и все типы вложенности.</span><span class="sxs-lookup"><span data-stu-id="15a0e-509">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-510">Не указан вложенный атрибут.</span><span class="sxs-lookup"><span data-stu-id="15a0e-510">The nested attribute is not specified.</span></span>  
  
<span data-ttu-id="15a0e-511">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-511">-or-</span></span> 
<span data-ttu-id="15a0e-512">Этот тип запечатан.</span><span class="sxs-lookup"><span data-stu-id="15a0e-512">This type is sealed.</span></span>  
  
<span data-ttu-id="15a0e-513">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-513">-or-</span></span> 
<span data-ttu-id="15a0e-514">Этот тип является массивом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-514">This type is an array.</span></span>  
  
<span data-ttu-id="15a0e-515">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-515">-or-</span></span> 
<span data-ttu-id="15a0e-516">Этот тип является интерфейсом, а вложенный тип не является интерфейсом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-516">This type is an interface, but the nested type is not an interface.</span></span>  
  
<span data-ttu-id="15a0e-517">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-517">-or-</span></span> 
<span data-ttu-id="15a0e-518">Длина <paramref name="name" /> равна нулю или больше 1023.</span><span class="sxs-lookup"><span data-stu-id="15a0e-518">The length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="15a0e-519">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-519">-or-</span></span> 
<span data-ttu-id="15a0e-520">Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</span><span class="sxs-lookup"><span data-stu-id="15a0e-520">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-521">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-521"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, int typeSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, typeSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-522">Краткое имя объекта.</span><span class="sxs-lookup"><span data-stu-id="15a0e-522">The short name of the type.</span></span> <span data-ttu-id="15a0e-523">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-523"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attr"><span data-ttu-id="15a0e-524">Атрибуты типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-524">The attributes of the type.</span></span></param>
        <param name="parent"><span data-ttu-id="15a0e-525">Тип, который вложенный тип расширяет.</span><span class="sxs-lookup"><span data-stu-id="15a0e-525">The type that the nested type extends.</span></span></param>
        <param name="typeSize"><span data-ttu-id="15a0e-526">Общий размер типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-526">The total size of the type.</span></span></param>
        <summary><span data-ttu-id="15a0e-527">Определяет вложенный тип по заданным имени, атрибутам, общему размеру типа и типу, который он расширяет.</span><span class="sxs-lookup"><span data-stu-id="15a0e-527">Defines a nested type, given its name, attributes, the total size of the type, and the type that it extends.</span></span></summary>
        <returns><span data-ttu-id="15a0e-528">Определенный вложенный тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-528">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-529">Этот метод можно использовать для создания вложенных типов даже после вызова метода <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для включающего типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-529">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="15a0e-530">Вложенный тип должен быть завершен, прежде чем его можно будет отразить с помощью <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A> или <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-530">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="15a0e-531">Порядок, в котором должны быть выполнены вложенные типы и вложенные типы, см. в описании <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-531">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="15a0e-532">Повторяющееся имя не обязательно создается, если `name` совпадает с именем ранее определенного типа или вложенного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-532">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="15a0e-533">Для дублирования полные имена должны быть одинаковыми, включая пространство имен и все типы вложенности.</span><span class="sxs-lookup"><span data-stu-id="15a0e-533">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-534">Не указан вложенный атрибут.</span><span class="sxs-lookup"><span data-stu-id="15a0e-534">The nested attribute is not specified.</span></span>  
  
<span data-ttu-id="15a0e-535">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-535">-or-</span></span> 
<span data-ttu-id="15a0e-536">Этот тип запечатан.</span><span class="sxs-lookup"><span data-stu-id="15a0e-536">This type is sealed.</span></span>  
  
<span data-ttu-id="15a0e-537">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-537">-or-</span></span> 
<span data-ttu-id="15a0e-538">Этот тип является массивом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-538">This type is an array.</span></span>  
  
<span data-ttu-id="15a0e-539">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-539">-or-</span></span> 
<span data-ttu-id="15a0e-540">Этот тип является интерфейсом, а вложенный тип не является интерфейсом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-540">This type is an interface, but the nested type is not an interface.</span></span>  
  
<span data-ttu-id="15a0e-541">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-541">-or-</span></span> 
<span data-ttu-id="15a0e-542">Длина <paramref name="name" /> равна нулю или больше 1023.</span><span class="sxs-lookup"><span data-stu-id="15a0e-542">The length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="15a0e-543">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-543">-or-</span></span> 
<span data-ttu-id="15a0e-544">Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</span><span class="sxs-lookup"><span data-stu-id="15a0e-544">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-545">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-545"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, packSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-546">Краткое имя объекта.</span><span class="sxs-lookup"><span data-stu-id="15a0e-546">The short name of the type.</span></span> <span data-ttu-id="15a0e-547">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-547"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attr"><span data-ttu-id="15a0e-548">Атрибуты типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-548">The attributes of the type.</span></span></param>
        <param name="parent"><span data-ttu-id="15a0e-549">Тип, который вложенный тип расширяет.</span><span class="sxs-lookup"><span data-stu-id="15a0e-549">The type that the nested type extends.</span></span></param>
        <param name="packSize"><span data-ttu-id="15a0e-550">Размер упаковки типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-550">The packing size of the type.</span></span></param>
        <summary><span data-ttu-id="15a0e-551">Определяет вложенный тип по заданным имени, атрибутам, типу, который он расширяет, и размеру упаковки.</span><span class="sxs-lookup"><span data-stu-id="15a0e-551">Defines a nested type, given its name, attributes, the type that it extends, and the packing size.</span></span></summary>
        <returns><span data-ttu-id="15a0e-552">Определенный вложенный тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-552">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-553">Этот метод можно использовать для создания вложенных типов даже после вызова метода <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для включающего типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-553">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="15a0e-554">Вложенный тип должен быть завершен, прежде чем его можно будет отразить с помощью <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A> или <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-554">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="15a0e-555">Порядок, в котором должны быть выполнены вложенные типы и вложенные типы, см. в описании <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-555">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="15a0e-556">Повторяющееся имя не обязательно создается, если `name` совпадает с именем ранее определенного типа или вложенного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-556">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="15a0e-557">Для дублирования полные имена должны быть одинаковыми, включая пространство имен и все типы вложенности.</span><span class="sxs-lookup"><span data-stu-id="15a0e-557">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-558">Не указан вложенный атрибут.</span><span class="sxs-lookup"><span data-stu-id="15a0e-558">The nested attribute is not specified.</span></span>  
  
<span data-ttu-id="15a0e-559">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-559">-or-</span></span> 
<span data-ttu-id="15a0e-560">Этот тип запечатан.</span><span class="sxs-lookup"><span data-stu-id="15a0e-560">This type is sealed.</span></span>  
  
<span data-ttu-id="15a0e-561">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-561">-or-</span></span> 
<span data-ttu-id="15a0e-562">Этот тип является массивом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-562">This type is an array.</span></span>  
  
<span data-ttu-id="15a0e-563">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-563">-or-</span></span> 
<span data-ttu-id="15a0e-564">Этот тип является интерфейсом, а вложенный тип не является интерфейсом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-564">This type is an interface, but the nested type is not an interface.</span></span>  
  
<span data-ttu-id="15a0e-565">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-565">-or-</span></span> 
<span data-ttu-id="15a0e-566">Длина <paramref name="name" /> равна нулю или больше 1023.</span><span class="sxs-lookup"><span data-stu-id="15a0e-566">The length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="15a0e-567">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-567">-or-</span></span> 
<span data-ttu-id="15a0e-568">Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</span><span class="sxs-lookup"><span data-stu-id="15a0e-568">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-569">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-569"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, interfaces As Type()) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, cli::array &lt;Type ^&gt; ^ interfaces);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * Type[] -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, interfaces)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-570">Краткое имя объекта.</span><span class="sxs-lookup"><span data-stu-id="15a0e-570">The short name of the type.</span></span> <span data-ttu-id="15a0e-571">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-571"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attr"><span data-ttu-id="15a0e-572">Атрибуты типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-572">The attributes of the type.</span></span></param>
        <param name="parent"><span data-ttu-id="15a0e-573">Тип, который вложенный тип расширяет.</span><span class="sxs-lookup"><span data-stu-id="15a0e-573">The type that the nested type extends.</span></span></param>
        <param name="interfaces"><span data-ttu-id="15a0e-574">Интерфейсы, реализуемые вложенным типом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-574">The interfaces that the nested type implements.</span></span></param>
        <summary><span data-ttu-id="15a0e-575">Определяет вложенный тип по заданным имени, атрибутам, типу, который он расширяет, и интерфейсам, которые он реализует.</span><span class="sxs-lookup"><span data-stu-id="15a0e-575">Defines a nested type, given its name, attributes, the type that it extends, and the interfaces that it implements.</span></span></summary>
        <returns><span data-ttu-id="15a0e-576">Определенный вложенный тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-576">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-577">Этот метод можно использовать для создания вложенных типов даже после вызова метода <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> для включающего типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-577">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="15a0e-578">Вложенный тип должен быть завершен, прежде чем его можно будет отразить с помощью <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A> или <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-578">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="15a0e-579">Порядок, в котором должны быть выполнены вложенные типы и вложенные типы, см. в описании <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-579">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="15a0e-580">Повторяющееся имя не обязательно создается, если `name` совпадает с именем ранее определенного типа или вложенного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-580">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="15a0e-581">Для дублирования полные имена должны быть одинаковыми, включая пространство имен и все типы вложенности.</span><span class="sxs-lookup"><span data-stu-id="15a0e-581">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-582">Не указан вложенный атрибут.</span><span class="sxs-lookup"><span data-stu-id="15a0e-582">The nested attribute is not specified.</span></span>  
  
<span data-ttu-id="15a0e-583">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-583">-or-</span></span> 
<span data-ttu-id="15a0e-584">Этот тип запечатан.</span><span class="sxs-lookup"><span data-stu-id="15a0e-584">This type is sealed.</span></span>  
  
<span data-ttu-id="15a0e-585">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-585">-or-</span></span> 
<span data-ttu-id="15a0e-586">Этот тип является массивом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-586">This type is an array.</span></span>  
  
<span data-ttu-id="15a0e-587">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-587">-or-</span></span> 
<span data-ttu-id="15a0e-588">Этот тип является интерфейсом, а вложенный тип не является интерфейсом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-588">This type is an interface, but the nested type is not an interface.</span></span>  
  
<span data-ttu-id="15a0e-589">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-589">-or-</span></span> 
<span data-ttu-id="15a0e-590">Длина <paramref name="name" /> равна нулю или больше 1023.</span><span class="sxs-lookup"><span data-stu-id="15a0e-590">The length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="15a0e-591">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-591">-or-</span></span> 
<span data-ttu-id="15a0e-592">Эта операция создаст тип с повторяющимся <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> в текущей сборке.</span><span class="sxs-lookup"><span data-stu-id="15a0e-592">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-593">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-593"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="15a0e-594">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-594">-or-</span></span> 
<span data-ttu-id="15a0e-595">Элемент массива <paramref name="interfaces" /> является <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-595">An element of the <paramref name="interfaces" /> array is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize, int typeSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, packSize, typeSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parent" Type="System.Type" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeSize" Type="System.Int32" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-596">Краткое имя объекта.</span><span class="sxs-lookup"><span data-stu-id="15a0e-596">The short name of the type.</span></span> <span data-ttu-id="15a0e-597">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-597"><paramref name="name" /> cannot contain embedded null values.</span></span></param>
        <param name="attr"><span data-ttu-id="15a0e-598">Атрибуты типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-598">The attributes of the type.</span></span></param>
        <param name="parent"><span data-ttu-id="15a0e-599">Тип, который вложенный тип расширяет.</span><span class="sxs-lookup"><span data-stu-id="15a0e-599">The type that the nested type extends.</span></span></param>
        <param name="packSize"><span data-ttu-id="15a0e-600">Размер упаковки типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-600">The packing size of the type.</span></span></param>
        <param name="typeSize"><span data-ttu-id="15a0e-601">Общий размер типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-601">The total size of the type.</span></span></param>
        <summary><span data-ttu-id="15a0e-602">Определяет вложенный тип на основе его имени, атрибутов, размера и типа, который он расширяет.</span><span class="sxs-lookup"><span data-stu-id="15a0e-602">Defines a nested type, given its name, attributes, size, and the type that it extends.</span></span></summary>
        <returns><span data-ttu-id="15a0e-603">Определенный вложенный тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-603">The defined nested type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefinePInvokeMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="15a0e-604">Определяет метод <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-604">Defines a <see langword="PInvoke" /> method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="dllName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="4" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" Index="6" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" Index="7" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-605">Имя метода <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-605">The name of the <see langword="PInvoke" /> method.</span></span> <span data-ttu-id="15a0e-606">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-606"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="dllName"><span data-ttu-id="15a0e-607">Имя библиотеки DLL, в которой определен метод <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-607">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span></span></param>
        <param name="attributes"><span data-ttu-id="15a0e-608">Атрибуты метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-608">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="15a0e-609">Соглашение о вызове метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-609">The method's calling convention.</span></span></param>
        <param name="returnType"><span data-ttu-id="15a0e-610">Возвращаемый тип метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-610">The method's return type.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="15a0e-611">Типы параметров метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-611">The types of the method's parameters.</span></span></param>
        <param name="nativeCallConv"><span data-ttu-id="15a0e-612">Собственное соглашение о вызове.</span><span class="sxs-lookup"><span data-stu-id="15a0e-612">The native calling convention.</span></span></param>
        <param name="nativeCharSet"><span data-ttu-id="15a0e-613">Собственная кодировка метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-613">The method's native character set.</span></span></param>
        <summary><span data-ttu-id="15a0e-614">Определяет метод <see langword="PInvoke" /> с учетом его имени, имени библиотеки DLL, в которой определен метод, атрибутов метода, соглашения о вызове метода, возвращаемого типа метода, типов параметров метода и флагов <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-614">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <see langword="PInvoke" /> flags.</span></span></summary>
        <returns><span data-ttu-id="15a0e-615">Определенный метод <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-615">The defined <see langword="PInvoke" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-616">Некоторые атрибуты импорта DLL (см. Описание <xref:System.Runtime.InteropServices.DllImportAttribute>) не могут быть указаны в качестве аргументов для этого метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-616">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="15a0e-617">Например, атрибут импорта DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> должен быть добавлен после создания метода `PInvoke`, если метод возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="15a0e-617">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="15a0e-618">В примере показано, как это сделать.</span><span class="sxs-lookup"><span data-stu-id="15a0e-618">The example shows how to do this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-619">В следующем примере демонстрируется использование метода <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> для создания метода `PInvoke` и добавления флага <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> к флагам реализации метода после создания <xref:System.Reflection.Emit.MethodBuilder> с помощью методов <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> и <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-619">The following example demonstrates how to use the <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="15a0e-620">Чтобы получить Ненулевое возвращаемое значение, необходимо добавить флаг <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-620">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="15a0e-621">В примере создается динамическая сборка с одним динамическим модулем и одним типом, `MyType`, который содержит метод `PInvoke`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-621">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="15a0e-622">Метод `PInvoke` представляет функцию Win32 `GetTickCount`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-622">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
 <span data-ttu-id="15a0e-623">При выполнении примера он выполняет метод `PInvoke`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-623">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="15a0e-624">Она также сохраняет динамическую сборку как Пинвокетест. dll.</span><span class="sxs-lookup"><span data-stu-id="15a0e-624">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="15a0e-625">Для проверки класса `MyType` и `static` (`Shared` in Visual Basic) `PInvoke`, который он содержит, можно использовать программу [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) .</span><span class="sxs-lookup"><span data-stu-id="15a0e-625">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="15a0e-626">Можно скомпилировать Visual Basic или C# программу, использующую статический метод `MyType.GetTickCount`, включив ссылку на библиотеку DLL при запуске CSC. exe или Vbc. exe; Например, `/r:PInvokeTest.dll`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-626">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-627">Метод не является статическим.</span><span class="sxs-lookup"><span data-stu-id="15a0e-627">The method is not static.</span></span>  
  
<span data-ttu-id="15a0e-628">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-628">-or-</span></span> 
<span data-ttu-id="15a0e-629">Родительский тип является интерфейсом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-629">The parent type is an interface.</span></span>  
  
<span data-ttu-id="15a0e-630">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-630">-or-</span></span> 
<span data-ttu-id="15a0e-631">Метод является абстрактным.</span><span class="sxs-lookup"><span data-stu-id="15a0e-631">The method is abstract.</span></span>  
  
<span data-ttu-id="15a0e-632">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-632">-or-</span></span> 
<span data-ttu-id="15a0e-633">Метод был определен ранее.</span><span class="sxs-lookup"><span data-stu-id="15a0e-633">The method was previously defined.</span></span>  
  
<span data-ttu-id="15a0e-634">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-634">-or-</span></span> 
<span data-ttu-id="15a0e-635">Длина параметра <paramref name="name" /> или <paramref name="dllName" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-635">The length of <paramref name="name" /> or <paramref name="dllName" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-636">Значение параметра <paramref name="name" /> или <paramref name="dllName" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-636"><paramref name="name" /> or <paramref name="dllName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-637">Содержащий тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-637">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="dllName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="entryName" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" Index="3" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="5" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="6" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" Index="7" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" Index="8" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-638">Имя метода <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-638">The name of the <see langword="PInvoke" /> method.</span></span> <span data-ttu-id="15a0e-639">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-639"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="dllName"><span data-ttu-id="15a0e-640">Имя библиотеки DLL, в которой определен метод <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-640">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span></span></param>
        <param name="entryName"><span data-ttu-id="15a0e-641">Имя точки входа в библиотеке DLL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-641">The name of the entry point in the DLL.</span></span></param>
        <param name="attributes"><span data-ttu-id="15a0e-642">Атрибуты метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-642">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="15a0e-643">Соглашение о вызове метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-643">The method's calling convention.</span></span></param>
        <param name="returnType"><span data-ttu-id="15a0e-644">Возвращаемый тип метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-644">The method's return type.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="15a0e-645">Типы параметров метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-645">The types of the method's parameters.</span></span></param>
        <param name="nativeCallConv"><span data-ttu-id="15a0e-646">Собственное соглашение о вызове.</span><span class="sxs-lookup"><span data-stu-id="15a0e-646">The native calling convention.</span></span></param>
        <param name="nativeCharSet"><span data-ttu-id="15a0e-647">Собственная кодировка метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-647">The method's native character set.</span></span></param>
        <summary><span data-ttu-id="15a0e-648">Определяет метод <see langword="PInvoke" /> с учетом его имени, имени библиотеки DLL, в которой определен метод, имени точки входа, атрибутов метода, соглашения о вызове метода, возвращаемого типа метода, типов параметров метода и флагов <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-648">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <see langword="PInvoke" /> flags.</span></span></summary>
        <returns><span data-ttu-id="15a0e-649">Определенный метод <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-649">The defined <see langword="PInvoke" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-650">Некоторые атрибуты импорта DLL (см. Описание <xref:System.Runtime.InteropServices.DllImportAttribute>) не могут быть указаны в качестве аргументов для этого метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-650">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="15a0e-651">Например, атрибут импорта DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> должен быть добавлен после создания метода `PInvoke`, если метод возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="15a0e-651">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="15a0e-652">В примере показано, как это сделать.</span><span class="sxs-lookup"><span data-stu-id="15a0e-652">The example shows how to do this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-653">В следующем примере кода демонстрируется использование метода <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> для создания метода `PInvoke` и добавления флага <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> к флагам реализации метода после создания <xref:System.Reflection.Emit.MethodBuilder> с помощью методов <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> и <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-653">The following code example demonstrates how to use the <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="15a0e-654">Чтобы получить Ненулевое возвращаемое значение, необходимо добавить флаг <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-654">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="15a0e-655">В примере создается динамическая сборка с одним динамическим модулем и одним типом, `MyType`, который содержит метод `PInvoke`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-655">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="15a0e-656">Метод `PInvoke` представляет функцию Win32 `GetTickCount`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-656">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
 <span data-ttu-id="15a0e-657">При выполнении примера он выполняет метод `PInvoke`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-657">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="15a0e-658">Она также сохраняет динамическую сборку как Пинвокетест. dll.</span><span class="sxs-lookup"><span data-stu-id="15a0e-658">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="15a0e-659">Для проверки класса `MyType` и `static` (`Shared` in Visual Basic) `PInvoke`, который он содержит, можно использовать программу [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) .</span><span class="sxs-lookup"><span data-stu-id="15a0e-659">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="15a0e-660">Можно скомпилировать Visual Basic или C# программу, использующую статический метод `MyType.GetTickCount`, включив ссылку на библиотеку DLL при запуске CSC. exe или Vbc. exe; Например, `/r:PInvokeTest.dll`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-660">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-661">Метод не является статическим.</span><span class="sxs-lookup"><span data-stu-id="15a0e-661">The method is not static.</span></span>  
  
<span data-ttu-id="15a0e-662">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-662">-or-</span></span> 
<span data-ttu-id="15a0e-663">Родительский тип является интерфейсом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-663">The parent type is an interface.</span></span>  
  
<span data-ttu-id="15a0e-664">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-664">-or-</span></span> 
<span data-ttu-id="15a0e-665">Метод является абстрактным.</span><span class="sxs-lookup"><span data-stu-id="15a0e-665">The method is abstract.</span></span>  
  
<span data-ttu-id="15a0e-666">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-666">-or-</span></span> 
<span data-ttu-id="15a0e-667">Метод был определен ранее.</span><span class="sxs-lookup"><span data-stu-id="15a0e-667">The method was previously defined.</span></span>  
  
<span data-ttu-id="15a0e-668">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-668">-or-</span></span> 
<span data-ttu-id="15a0e-669">Длина параметра <paramref name="name" />, <paramref name="dllName" /> или <paramref name="entryName" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-669">The length of <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-670">Значение параметра <paramref name="name" />, <paramref name="dllName" /> или <paramref name="entryName" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-670"><paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-671">Содержащий тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-671">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="dllName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="entryName" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" Index="3" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="5" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" Index="6" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="8" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" Index="9" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" Index="10" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" Index="11" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" Index="12" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-672">Имя метода <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-672">The name of the <see langword="PInvoke" /> method.</span></span> <span data-ttu-id="15a0e-673">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-673"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="dllName"><span data-ttu-id="15a0e-674">Имя библиотеки DLL, в которой определен метод <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-674">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span></span></param>
        <param name="entryName"><span data-ttu-id="15a0e-675">Имя точки входа в библиотеке DLL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-675">The name of the entry point in the DLL.</span></span></param>
        <param name="attributes"><span data-ttu-id="15a0e-676">Атрибуты метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-676">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="15a0e-677">Соглашение о вызове метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-677">The method's calling convention.</span></span></param>
        <param name="returnType"><span data-ttu-id="15a0e-678">Возвращаемый тип метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-678">The method's return type.</span></span></param>
        <param name="returnTypeRequiredCustomModifiers"><span data-ttu-id="15a0e-679">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-679">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span></span> <span data-ttu-id="15a0e-680">Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-680">If the return type has no required custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="returnTypeOptionalCustomModifiers"><span data-ttu-id="15a0e-681">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-681">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span></span> <span data-ttu-id="15a0e-682">Если возвращаемый тип не содержит необязательные настраиваемые модификаторы, укажите <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-682">If the return type has no optional custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="15a0e-683">Типы параметров метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-683">The types of the method's parameters.</span></span></param>
        <param name="parameterTypeRequiredCustomModifiers"><span data-ttu-id="15a0e-684">Массив массивов типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-684">An array of arrays of types.</span></span> <span data-ttu-id="15a0e-685">Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-685">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="15a0e-686">Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-686">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="15a0e-687">Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-687">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="parameterTypeOptionalCustomModifiers"><span data-ttu-id="15a0e-688">Массив массивов типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-688">An array of arrays of types.</span></span> <span data-ttu-id="15a0e-689">Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-689">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="15a0e-690">Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-690">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="15a0e-691">Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-691">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="nativeCallConv"><span data-ttu-id="15a0e-692">Собственное соглашение о вызове.</span><span class="sxs-lookup"><span data-stu-id="15a0e-692">The native calling convention.</span></span></param>
        <param name="nativeCharSet"><span data-ttu-id="15a0e-693">Собственная кодировка метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-693">The method's native character set.</span></span></param>
        <summary><span data-ttu-id="15a0e-694">Определяет метод <see langword="PInvoke" /> с учетом его имени, имени библиотеки DLL, в которой определен метод, имени точки входа, атрибутов метода, соглашения о вызове метода, возвращаемого типа метода, типов параметров метода, флагов <see langword="PInvoke" /> и настраиваемых модификаторов для параметров и возвращаемого типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-694">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, the <see langword="PInvoke" /> flags, and custom modifiers for the parameters and return type.</span></span></summary>
        <returns><span data-ttu-id="15a0e-695">Объект <see cref="T:System.Reflection.Emit.MethodBuilder" />, представляющий определенный метод <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-695">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the defined <see langword="PInvoke" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-696">Некоторые атрибуты импорта DLL (см. Описание <xref:System.Runtime.InteropServices.DllImportAttribute>) не могут быть указаны в качестве аргументов для этого метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-696">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="15a0e-697">Например, атрибут импорта DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> должен быть добавлен после создания метода `PInvoke`, если метод возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="15a0e-697">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="15a0e-698">В примере показано, как это сделать.</span><span class="sxs-lookup"><span data-stu-id="15a0e-698">The example shows how to do this.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-699">Дополнительные сведения о пользовательских модификаторах см. в документации по метаданным раздела в ECMA Partition II.</span><span class="sxs-lookup"><span data-stu-id="15a0e-699">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="15a0e-700">Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.</span><span class="sxs-lookup"><span data-stu-id="15a0e-700">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-701">В следующем примере кода показано, как использовать [\], Type @ no__t-1 @ no__t-2, Type @ no__t-3 @ no__t-4, Type @ no__t-5 @ no__t-6 @ no__t-7 @ no__t-8, Type @ no__t-9 @ no__t-10 @ no__t-11xref: System. Reflection. Emit. TypeBuilder. Дефинепинвокемесод% 2A > метод для создания метода \[2 и добавления флага 3 к флагам реализации метода после создания 4 с помощью методов 5 и 6.</span><span class="sxs-lookup"><span data-stu-id="15a0e-701">The following code example demonstrates how to use the [\], Type\[\], Type\[\], Type\[\]\[\], Type\[\]\<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="15a0e-702">В примере создается динамическая сборка с одним динамическим модулем и одним типом, `MyType`, который содержит метод `PInvoke`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-702">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="15a0e-703">Метод `PInvoke` представляет функцию Win32 `GetTickCount`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-703">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="15a0e-704">Чтобы получить Ненулевое возвращаемое значение, необходимо добавить флаг <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-704">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-705">В примере используется перегрузка, которая не задает настраиваемые модификаторы.</span><span class="sxs-lookup"><span data-stu-id="15a0e-705">The example uses an overload that does not specify custom modifiers.</span></span> <span data-ttu-id="15a0e-706">Чтобы указать пользовательские модификаторы, измените код примера, чтобы использовать эту перегрузку метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-706">To specify custom modifiers, change the example code to use this method overload instead.</span></span>  
  
 <span data-ttu-id="15a0e-707">При выполнении примера он выполняет метод `PInvoke`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-707">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="15a0e-708">Она также сохраняет динамическую сборку как Пинвокетест. dll.</span><span class="sxs-lookup"><span data-stu-id="15a0e-708">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="15a0e-709">Для проверки класса `MyType` и `static` (`Shared` in Visual Basic) `PInvoke`, который он содержит, можно использовать программу [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) .</span><span class="sxs-lookup"><span data-stu-id="15a0e-709">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="15a0e-710">Можно скомпилировать Visual Basic или C# программу, использующую статический метод `MyType.GetTickCount`, включив ссылку на библиотеку DLL при запуске CSC. exe или Vbc. exe; Например, `/r:PInvokeTest.dll`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-710">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-711">Метод не является статическим.</span><span class="sxs-lookup"><span data-stu-id="15a0e-711">The method is not static.</span></span>  
  
<span data-ttu-id="15a0e-712">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-712">-or-</span></span> 
<span data-ttu-id="15a0e-713">Родительский тип является интерфейсом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-713">The parent type is an interface.</span></span>  
  
<span data-ttu-id="15a0e-714">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-714">-or-</span></span> 
<span data-ttu-id="15a0e-715">Метод является абстрактным.</span><span class="sxs-lookup"><span data-stu-id="15a0e-715">The method is abstract.</span></span>  
  
<span data-ttu-id="15a0e-716">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-716">-or-</span></span> 
<span data-ttu-id="15a0e-717">Метод был определен ранее.</span><span class="sxs-lookup"><span data-stu-id="15a0e-717">The method was previously defined.</span></span>  
  
<span data-ttu-id="15a0e-718">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-718">-or-</span></span> 
<span data-ttu-id="15a0e-719">Длина параметра <paramref name="name" />, <paramref name="dllName" /> или <paramref name="entryName" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-719">The length of <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is zero.</span></span>  
  
<span data-ttu-id="15a0e-720">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-720">-or-</span></span> 
<span data-ttu-id="15a0e-721">Размер <paramref name="parameterTypeRequiredCustomModifiers" /> или <paramref name="parameterTypeOptionalCustomModifiers" /> не равен размеру <paramref name="parameterTypes" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-721">The size of <paramref name="parameterTypeRequiredCustomModifiers" /> or <paramref name="parameterTypeOptionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-722">Значение параметра <paramref name="name" />, <paramref name="dllName" /> или <paramref name="entryName" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-722"><paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-723">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-723">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="15a0e-724">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-724">-or-</span></span> 
<span data-ttu-id="15a0e-725">Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-725">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineProperty">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="15a0e-726">Добавляет новое свойство в тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-726">Adds a new property to the type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * Type * Type[] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-727">Имя свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-727">The name of the property.</span></span> <span data-ttu-id="15a0e-728">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-728"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="15a0e-729">Атрибуты свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-729">The attributes of the property.</span></span></param>
        <param name="returnType"><span data-ttu-id="15a0e-730">Возвращаемый тип свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-730">The return type of the property.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="15a0e-731">Типы параметров свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-731">The types of the parameters of the property.</span></span></param>
        <summary><span data-ttu-id="15a0e-732">Добавляет новое свойство в тип с заданным именем и сигнатурой свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-732">Adds a new property to the type, with the given name and property signature.</span></span></summary>
        <returns><span data-ttu-id="15a0e-733">Заданное свойство.</span><span class="sxs-lookup"><span data-stu-id="15a0e-733">The defined property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="15a0e-734">В следующем примере кода показано, как определить динамическое свойство и получить <xref:System.Reflection.Emit.PropertyBuilder> для спецификации.</span><span class="sxs-lookup"><span data-stu-id="15a0e-734">The following code sample demonstrates how to define a dynamic property and obtain a <xref:System.Reflection.Emit.PropertyBuilder> for specification.</span></span> <span data-ttu-id="15a0e-735">Обратите внимание, что `PropertyBuilder` должен также иметь соответствующий <xref:System.Reflection.Emit.MethodBuilder>, который будет использовать логику IL для свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-735">Note that a `PropertyBuilder` must also have a corresponding <xref:System.Reflection.Emit.MethodBuilder>, which will house the IL logic for the property.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-736">Длина параметра <paramref name="name" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-736">The length of <paramref name="name" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-737">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-737"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="15a0e-738">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-738">-or-</span></span> 
<span data-ttu-id="15a0e-739">Один из элементов массива <paramref name="parameterTypes" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-739">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-740">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-740">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-741">Имя свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-741">The name of the property.</span></span> <span data-ttu-id="15a0e-742">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-742"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="15a0e-743">Атрибуты свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-743">The attributes of the property.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="15a0e-744">Соглашение о вызовах методов доступа свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-744">The calling convention of the property accessors.</span></span></param>
        <param name="returnType"><span data-ttu-id="15a0e-745">Возвращаемый тип свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-745">The return type of the property.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="15a0e-746">Типы параметров свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-746">The types of the parameters of the property.</span></span></param>
        <summary><span data-ttu-id="15a0e-747">Добавляет новое свойство в тип с заданным именем, атрибутами, соглашением о вызове и сигнатурой свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-747">Adds a new property to the type, with the given name, attributes, calling convention, and property signature.</span></span></summary>
        <returns><span data-ttu-id="15a0e-748">Заданное свойство.</span><span class="sxs-lookup"><span data-stu-id="15a0e-748">The defined property.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-749">Длина параметра <paramref name="name" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-749">The length of <paramref name="name" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-750"><paramref name="name" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-750"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="15a0e-751">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-751">-or-</span></span> 
<span data-ttu-id="15a0e-752">Один из элементов массива <paramref name="parameterTypes" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-752">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-753">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-753">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnType" Type="System.Type" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" Index="6" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" Index="7" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-754">Имя свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-754">The name of the property.</span></span> <span data-ttu-id="15a0e-755">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-755"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="15a0e-756">Атрибуты свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-756">The attributes of the property.</span></span></param>
        <param name="returnType"><span data-ttu-id="15a0e-757">Возвращаемый тип свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-757">The return type of the property.</span></span></param>
        <param name="returnTypeRequiredCustomModifiers"><span data-ttu-id="15a0e-758">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-758">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span></span> <span data-ttu-id="15a0e-759">Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-759">If the return type has no required custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="returnTypeOptionalCustomModifiers"><span data-ttu-id="15a0e-760">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для типа возвращаемого значения свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-760">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span></span> <span data-ttu-id="15a0e-761">Если возвращаемый тип не содержит необязательные настраиваемые модификаторы, укажите <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-761">If the return type has no optional custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="15a0e-762">Типы параметров свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-762">The types of the parameters of the property.</span></span></param>
        <param name="parameterTypeRequiredCustomModifiers"><span data-ttu-id="15a0e-763">Массив массивов типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-763">An array of arrays of types.</span></span> <span data-ttu-id="15a0e-764">Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-764">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="15a0e-765">Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-765">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="15a0e-766">Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-766">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="parameterTypeOptionalCustomModifiers"><span data-ttu-id="15a0e-767">Массив массивов типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-767">An array of arrays of types.</span></span> <span data-ttu-id="15a0e-768">Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-768">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="15a0e-769">Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-769">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="15a0e-770">Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-770">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <summary><span data-ttu-id="15a0e-771">Добавляет новое свойство в тип с заданным именем, сигнатурой свойства и настраиваемыми модификаторами.</span><span class="sxs-lookup"><span data-stu-id="15a0e-771">Adds a new property to the type, with the given name, property signature, and custom modifiers.</span></span></summary>
        <returns><span data-ttu-id="15a0e-772">Заданное свойство.</span><span class="sxs-lookup"><span data-stu-id="15a0e-772">The defined property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-773">Эта перегрузка предоставляется для конструкторов управляемых компиляторов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-773">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-774">Дополнительные сведения о пользовательских модификаторах см. в документации по метаданным раздела в ECMA Partition II.</span><span class="sxs-lookup"><span data-stu-id="15a0e-774">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="15a0e-775">Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.</span><span class="sxs-lookup"><span data-stu-id="15a0e-775">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-776">Длина параметра <paramref name="name" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-776">The length of <paramref name="name" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-777"><paramref name="name" /> равно <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="15a0e-777"><paramref name="name" /> is <see langword="null" /></span></span>  
  
<span data-ttu-id="15a0e-778">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-778">-or-</span></span> 
<span data-ttu-id="15a0e-779">Один из элементов массива <paramref name="parameterTypes" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-779">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" /></span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-780">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-780">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="6" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" Index="7" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" Index="8" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-781">Имя свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-781">The name of the property.</span></span> <span data-ttu-id="15a0e-782">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-782"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="15a0e-783">Атрибуты свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-783">The attributes of the property.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="15a0e-784">Соглашение о вызовах методов доступа свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-784">The calling convention of the property accessors.</span></span></param>
        <param name="returnType"><span data-ttu-id="15a0e-785">Возвращаемый тип свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-785">The return type of the property.</span></span></param>
        <param name="returnTypeRequiredCustomModifiers"><span data-ttu-id="15a0e-786">Массив типов, представляющих обязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для возвращаемого типа свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-786">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span></span> <span data-ttu-id="15a0e-787">Если возвращаемый тип не содержит требуемых настраиваемых модификаторов, укажите <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-787">If the return type has no required custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="returnTypeOptionalCustomModifiers"><span data-ttu-id="15a0e-788">Массив типов, представляющих необязательные настраиваемые модификаторы, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />, для типа возвращаемого значения свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-788">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span></span> <span data-ttu-id="15a0e-789">Если возвращаемый тип не содержит необязательные настраиваемые модификаторы, укажите <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-789">If the return type has no optional custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="15a0e-790">Типы параметров свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-790">The types of the parameters of the property.</span></span></param>
        <param name="parameterTypeRequiredCustomModifiers"><span data-ttu-id="15a0e-791">Массив массивов типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-791">An array of arrays of types.</span></span> <span data-ttu-id="15a0e-792">Каждый массив типов представляет обязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-792">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="15a0e-793">Если определенный параметр не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-793">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="15a0e-794">Если ни один из параметров не имеет обязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-794">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="parameterTypeOptionalCustomModifiers"><span data-ttu-id="15a0e-795">Массив массивов типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-795">An array of arrays of types.</span></span> <span data-ttu-id="15a0e-796">Каждый массив типов представляет необязательные настраиваемые модификаторы для соответствующего параметра, такие как <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-796">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="15a0e-797">Если определенный параметр не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива массивов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-797">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="15a0e-798">Если ни один из параметров не имеет необязательных настраиваемых модификаторов, укажите <see langword="null" /> вместо массива типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-798">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <summary><span data-ttu-id="15a0e-799">Добавляет новое свойство в тип с заданным именем, соглашением о вызовах, сигнатурой свойства и настраиваемыми модификаторами.</span><span class="sxs-lookup"><span data-stu-id="15a0e-799">Adds a new property to the type, with the given name, calling convention, property signature, and custom modifiers.</span></span></summary>
        <returns><span data-ttu-id="15a0e-800">Заданное свойство.</span><span class="sxs-lookup"><span data-stu-id="15a0e-800">The defined property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-801">Эта перегрузка предоставляется для конструкторов управляемых компиляторов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-801">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-802">Дополнительные сведения о пользовательских модификаторах см. в документации по метаданным раздела в ECMA Partition II.</span><span class="sxs-lookup"><span data-stu-id="15a0e-802">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="15a0e-803">Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.</span><span class="sxs-lookup"><span data-stu-id="15a0e-803">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="15a0e-804">Эта перегрузка метода появилась в [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="15a0e-804">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-805">Длина параметра <paramref name="name" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-805">The length of <paramref name="name" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-806">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-806"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="15a0e-807">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-807">-or-</span></span> 
<span data-ttu-id="15a0e-808">Один из элементов массива <paramref name="parameterTypes" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-808">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-809">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-809">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineTypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineTypeInitializer () As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineTypeInitializer();" />
      <MemberSignature Language="F#" Value="member this.DefineTypeInitializer : unit -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineTypeInitializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="15a0e-810">Определяет инициализатор для этого типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-810">Defines the initializer for this type.</span></span></summary>
        <returns><span data-ttu-id="15a0e-811">Возвращает инициализатор типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-811">Returns a type initializer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-812">Созданный инициализатор всегда является открытым.</span><span class="sxs-lookup"><span data-stu-id="15a0e-812">The initializer created is always public.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-813">В следующем примере кода показано, как создать конструктор инициализации с помощью `DefineTypeInitializer`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-813">The following code sample demonstrates how to create an initialization constructor using `DefineTypeInitializer`.</span></span>  
  
 [!code-cpp[TypeBuilder_Properties1#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Properties1/CPP/typebuilder_properties.cpp#3)]
 [!code-csharp[TypeBuilder_Properties1#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Properties1/CS/typebuilder_properties.cs#3)]
 [!code-vb[TypeBuilder_Properties1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Properties1/VB/typebuilder_properties.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-814">Содержащий тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-814">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineUninitializedData (name As String, size As Integer, attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineUninitializedData(System::String ^ name, int size, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineUninitializedData : string * int * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineUninitializedData (name, size, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-815">Имя, используемое для ссылки на данные.</span><span class="sxs-lookup"><span data-stu-id="15a0e-815">The name used to refer to the data.</span></span> <span data-ttu-id="15a0e-816">Параметр <paramref name="name" /> не может содержать внедренные значения NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-816"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="size"><span data-ttu-id="15a0e-817">Размер поля данных.</span><span class="sxs-lookup"><span data-stu-id="15a0e-817">The size of the data field.</span></span></param>
        <param name="attributes"><span data-ttu-id="15a0e-818">Атрибуты поля.</span><span class="sxs-lookup"><span data-stu-id="15a0e-818">The attributes for the field.</span></span></param>
        <summary><span data-ttu-id="15a0e-819">Определяет неинициализированное поле данных в разделе <see langword=".sdata" /> переносимого исполняемого (PE) файла.</span><span class="sxs-lookup"><span data-stu-id="15a0e-819">Defines an uninitialized data field in the <see langword=".sdata" /> section of the portable executable (PE) file.</span></span></summary>
        <returns><span data-ttu-id="15a0e-820">Поле для ссылки на данные.</span><span class="sxs-lookup"><span data-stu-id="15a0e-820">A field to reference the data.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-821">Поле, создаваемое с помощью этого метода, будет `static`, даже если в параметре `attributes` не включено `FieldAttributes.Static`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-821">The field that you create with this method will be `static`, even if you do not include `FieldAttributes.Static` in the `attributes` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-822">В следующем примере кода показано использование `DefineUninitializedData` для создания неинициализированного поля данных в динамическом типе:</span><span class="sxs-lookup"><span data-stu-id="15a0e-822">The following code sample demonstrates the use of `DefineUninitializedData` to create an uninitialized data field in a dynamic type:</span></span>  
  
 [!code-cpp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CPP/typebuilder_defineuninitializeddata.cpp#1)]
 [!code-csharp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CS/typebuilder_defineuninitializeddata.cs#1)]
 [!code-vb[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/VB/typebuilder_defineuninitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-823">Длина параметра <paramref name="name" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-823">Length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="15a0e-824">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-824">-or-</span></span> 
 <span data-ttu-id="15a0e-825">Значение <paramref name="size" /> меньше или равно нулю либо больше или равно 0x003f0000.</span><span class="sxs-lookup"><span data-stu-id="15a0e-825"><paramref name="size" /> is less than or equal to zero, or greater than or equal to 0x003f0000.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-826">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-826"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-827">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-827">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-828">Извлекает полный путь данного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-828">Retrieves the full path of this type.</span></span></summary>
        <value><span data-ttu-id="15a0e-829">Только для чтения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-829">Read-only.</span></span> <span data-ttu-id="15a0e-830">Извлекает полный путь данного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-830">Retrieves the full path of this type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-831">Возвращаемый формат — "Енклосингтипефуллнаме + Нестедтипенаме" для вложенных типов и "typeName" для невложенных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-831">The returned format is "enclosingTypeFullName+nestedTypeName" for nested types and "typeName" for non-nested types.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-832">Получает значение, указывающее ковариацию и особые ограничения текущего параметра универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-832">Gets a value that indicates the covariance and special constraints of the current generic type parameter.</span></span></summary>
        <value><span data-ttu-id="15a0e-833">Побитовое сочетание значений <see cref="T:System.Reflection.GenericParameterAttributes" />, которое описывает ковариацию и особые ограничения текущего параметра универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-833">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-834">При выдаче кода параметр универсального типа представлен объектом <xref:System.Reflection.Emit.GenericTypeParameterBuilder>, а не объектом <xref:System.Reflection.Emit.TypeBuilder>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-834">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public override int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-835">Возвращает позицию параметра типа в списке параметров типа универсального типа, в котором объявлен этот параметр.</span><span class="sxs-lookup"><span data-stu-id="15a0e-835">Gets the position of a type parameter in the type parameter list of the generic type that declared the parameter.</span></span></summary>
        <value><span data-ttu-id="15a0e-836">Если текущий объект <see cref="T:System.Reflection.Emit.TypeBuilder" /> представляет параметр универсального типа, позиция параметра типа в списке параметров типа универсального типа, который объявил параметр. В противном случае — не определено.</span><span class="sxs-lookup"><span data-stu-id="15a0e-836">If the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type parameter, the position of the type parameter in the type parameter list of the generic type that declared the parameter; otherwise, undefined.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-837">При выдаче кода параметр универсального типа представлен объектом <xref:System.Reflection.Emit.GenericTypeParameterBuilder>, а не объектом <xref:System.Reflection.Emit.TypeBuilder>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-837">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="15a0e-838">Если текущий <xref:System.Reflection.Emit.TypeBuilder> не представляет параметр универсального типа, значение этого свойства не определено.</span><span class="sxs-lookup"><span data-stu-id="15a0e-838">If the current <xref:System.Reflection.Emit.TypeBuilder> does not represent a generic type parameter, the value of this property is undefined.</span></span> <span data-ttu-id="15a0e-839">Используйте свойство <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A>, чтобы определить, представляет ли текущий <xref:System.Reflection.Emit.TypeBuilder> параметр универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-839">Use the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> property to determine whether the current <xref:System.Reflection.Emit.TypeBuilder> represents a generic type parameter.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public override Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public override int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetArrayRank();" />
      <MemberSignature Language="F#" Value="override this.GetArrayRank : unit -&gt; int" Usage="typeBuilder.GetArrayRank " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="override this.GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="typeBuilder.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public static System.Reflection.ConstructorInfo GetConstructor (Type type, System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.ConstructorInfo GetConstructor(class System.Type type, class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::ConstructorInfo ^ GetConstructor(Type ^ type, System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberSignature Language="F#" Value="static member GetConstructor : Type * System.Reflection.ConstructorInfo -&gt; System.Reflection.ConstructorInfo" Usage="System.Reflection.Emit.TypeBuilder.GetConstructor (type, constructor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="15a0e-840">Сконструированный универсальный тип, конструктор которого возвращается.</span><span class="sxs-lookup"><span data-stu-id="15a0e-840">The constructed generic type whose constructor is returned.</span></span></param>
        <param name="constructor"><span data-ttu-id="15a0e-841">Конструктор в определении универсального типа <paramref name="type" />, который указывает, какой конструктор <paramref name="type" /> следует вернуть.</span><span class="sxs-lookup"><span data-stu-id="15a0e-841">A constructor on the generic type definition of <paramref name="type" />, which specifies which constructor of <paramref name="type" /> to return.</span></span></param>
        <summary><span data-ttu-id="15a0e-842">Возвращает конструктор указанного сконструированного универсального типа, соответствующего указанному конструктору определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-842">Returns the constructor of the specified constructed generic type that corresponds to the specified constructor of the generic type definition.</span></span></summary>
        <returns><span data-ttu-id="15a0e-843">Объект <see cref="T:System.Reflection.ConstructorInfo" />, представляющий конструктор <paramref name="type" />, соответствующий <paramref name="constructor" />, который указывает конструктор, принадлежащий определению универсального типа <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-843">A <see cref="T:System.Reflection.ConstructorInfo" /> object that represents the constructor of <paramref name="type" /> corresponding to <paramref name="constructor" />, which specifies a constructor belonging to the generic type definition of <paramref name="type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-844">Метод <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> предоставляет способ получения объекта <xref:System.Reflection.ConstructorInfo>, представляющего конструктор сконструированного универсального типа, определение универсального типа которого представлено объектом <xref:System.Reflection.Emit.TypeBuilder>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-844">The <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method provides a way to get a <xref:System.Reflection.ConstructorInfo> object that represents a constructor of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="15a0e-845">Например, предположим, что имеется объект <xref:System.Reflection.Emit.TypeBuilder>, представляющий тип `G<T>` в C# синтаксисе (`G(Of T)` в Visual Basic, `generic <T> ref class G` в C++) и объект <xref:System.Reflection.Emit.ConstructorBuilder>, представляющий конструктор `G<T>`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-845">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.ConstructorBuilder> object that represents a constructor of `G<T>`.</span></span> <span data-ttu-id="15a0e-846">Предположим, что `G<T>` имеет универсальный метод с параметром типа `U`, который создает экземпляр сконструированного типа `G<U>`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-846">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>`.</span></span> <span data-ttu-id="15a0e-847">Чтобы создать код для создания экземпляра сконструированного типа, необходим объект <xref:System.Reflection.ConstructorInfo>, представляющий конструктор этого сконструированного типа, иными словами, который создает экземпляр `G<U>`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-847">In order to emit the code to create an instance of the constructed type, you need a <xref:System.Reflection.ConstructorInfo> object that represents the constructor of this constructed type - in other words, that creates an instance of `G<U>`.</span></span> <span data-ttu-id="15a0e-848">Для этого сначала вызовите метод <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> для объекта <xref:System.Reflection.Emit.TypeBuilder>, указав объект <xref:System.Reflection.Emit.GenericTypeParameterBuilder>, представляющий `U` в качестве аргумента типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-848">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="15a0e-849">Затем вызовите метод <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> с возвращаемым значением метода <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> в качестве параметра `type` и объектом <xref:System.Reflection.Emit.ConstructorBuilder>, который представляет конструктор `G<U>` в качестве параметра `constructor`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-849">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.ConstructorBuilder> object that represents the constructor of `G<U>` as parameter `constructor`.</span></span> <span data-ttu-id="15a0e-850">Возвращаемое значение — это объект <xref:System.Reflection.ConstructorInfo>, для которого необходимо выдать вызов функции.</span><span class="sxs-lookup"><span data-stu-id="15a0e-850">The return value is the <xref:System.Reflection.ConstructorInfo> object you need to emit the function call.</span></span> <span data-ttu-id="15a0e-851">Этот сценарий показан в примере кода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-851">The code example demonstrates this scenario.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-852">Следующий пример кода содержит исходный код для универсального класса с именем `Sample`, который имеет параметр типа с именем `T`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-852">The following code example contains source code for a generic class named `Sample` that has a type parameter named `T`.</span></span> <span data-ttu-id="15a0e-853">Класс содержит поле с именем `Field`, типа `T` и универсальный метод с именем `GM` с собственным параметром типа с именем `U`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-853">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="15a0e-854">Метод `GM` создает экземпляр `Sample`, подставив свой собственный параметр типа `U` для параметра типа `Sample` и сохраняет свой входной параметр в `Field`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-854">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="15a0e-855">Этот исходный код скомпилирован, но не используется; можно просмотреть его с помощью программы [Ildasm. exe (ДИЗАССЕМБЛЕР IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) и сравнить его с кодом, созданным классом `Example`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-855">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="15a0e-856">Код в классе `Example` демонстрирует использование метода <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> для выдачи универсального кода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-856">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method to emit generic code.</span></span> <span data-ttu-id="15a0e-857">Метод `Main` класса `Example` создает динамическую сборку, содержащую класс с именем `Sample`, и использует метод <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>, чтобы сделать его универсальным, добавив параметр типа с именем `T`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-857">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample` and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="15a0e-858">Конструктор без параметров и поле с именем `Field` типа `T` добавляются в класс `Sample`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-858">A parameterless constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="15a0e-859">Метод `GM` добавляется и превращается в универсальный метод с помощью метода <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-859">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="15a0e-860">Параметр типа `GM` имеет имя `U`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-860">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="15a0e-861">После определения параметра типа сигнатура `GM` добавляется с помощью метода <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-861">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="15a0e-862">Отсутствует тип возвращаемого значения, а также обязательные или настраиваемые модификаторы, поэтому все параметры этого метода имеют `null`, за исключением `parameterTypes`; `parameterTypes` задает тип единственного параметра метода равным `U`, параметр универсального типа метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-862">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="15a0e-863">Тело метода создает экземпляр сконструированного типа `Sample<U>` (`Sample(Of U)` в Visual Basic), присваивает параметр метода `Field`, а затем выводит значение `Field`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-863">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="15a0e-864">Метод <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> используется для создания <xref:System.Reflection.ConstructorInfo>, представляющего конструктор без параметров сконструированного универсального типа `Sample<U>` в инструкции <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType>, которая создает экземпляр.</span><span class="sxs-lookup"><span data-stu-id="15a0e-864">The <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method is used to create a <xref:System.Reflection.ConstructorInfo> that represents the parameterless constructor of the constructed generic type `Sample<U>` in the <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> instruction that creates the instance.</span></span>  
  
 <span data-ttu-id="15a0e-865">Фиктивный тип определяется для хранения метода точки входа `Main`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-865">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="15a0e-866">В теле `Main` статический метод `GM` вызывается для сконструированного универсального типа `Sample<int>` (`Sample(Of Integer)` в Visual Basic) с типом <xref:System.String>, который заменяется на `U`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-866">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span>  
  
 <span data-ttu-id="15a0e-867">Когда выполняется пример кода, выпущенная сборка сохраняется как Типебуилдержетфиелдексампле. exe.</span><span class="sxs-lookup"><span data-stu-id="15a0e-867">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="15a0e-868">Вы можете запустить Типебуилдержетфиелдексампле. exe, и вы можете использовать программу [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) , чтобы сравнить созданный код с кодом для класса `Sample`, который компилируется в самом примере кода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-868">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-869"><paramref name="type" /> не представляет универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-869"><paramref name="type" /> does not represent a generic type.</span></span>  
  
<span data-ttu-id="15a0e-870">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-870">-or-</span></span> 
 <span data-ttu-id="15a0e-871">Параметр<paramref name="type" /> не является параметром типа <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-871"><paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span>  
  
<span data-ttu-id="15a0e-872">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-872">-or-</span></span> 
<span data-ttu-id="15a0e-873">Объявляющий тип <paramref name="constructor" /> не является определением универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-873">The declaring type of <paramref name="constructor" /> is not a generic type definition.</span></span>  
  
<span data-ttu-id="15a0e-874">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-874">-or-</span></span> 
<span data-ttu-id="15a0e-875">Объявляющий тип <paramref name="constructor" /> не является определением универсального типа <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-875">The declaring type of <paramref name="constructor" /> is not the generic type definition of <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="typeBuilder.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="typeBuilder.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="15a0e-876">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />, как в <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</span><span class="sxs-lookup"><span data-stu-id="15a0e-876">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="15a0e-877">Возвращает массив объектов <see cref="T:System.Reflection.ConstructorInfo" />, представляющих открытые и закрытые конструкторы, определенные для этого класса, как указано.</span><span class="sxs-lookup"><span data-stu-id="15a0e-877">Returns an array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing the public and non-public constructors defined for this class, as specified.</span></span></summary>
        <returns><span data-ttu-id="15a0e-878">Возвращает массив объектов <see cref="T:System.Reflection.ConstructorInfo" />, представляющих указанные конструкторы, определенные для этого класса.</span><span class="sxs-lookup"><span data-stu-id="15a0e-878">Returns an array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing the specified constructors defined for this class.</span></span> <span data-ttu-id="15a0e-879">Если конструкторы не определены, возвращается пустой массив.</span><span class="sxs-lookup"><span data-stu-id="15a0e-879">If no constructors are defined, an empty array is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-880">Получите тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-880">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-881">Этот метод не реализован для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-881">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="15a0e-882">Возвращает настраиваемые атрибуты, определенные для данного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-882">Returns the custom attributes defined for this type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="typeBuilder.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="inherit"><span data-ttu-id="15a0e-883">Указывает, следует ли выполнять поиск в цепочке наследования этого члена для нахождения атрибутов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-883">Specifies whether to search this member's inheritance chain to find the attributes.</span></span></param>
        <summary><span data-ttu-id="15a0e-884">Возвращает все настраиваемые атрибуты, определенные для данного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-884">Returns all the custom attributes defined for this type.</span></span></summary>
        <returns><span data-ttu-id="15a0e-885">Возвращает массив объектов, представляющих все настраиваемые атрибуты этого типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-885">Returns an array of objects representing all the custom attributes of this type.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-886">В настоящее время этот метод не поддерживается для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-886">This method is not currently supported for incomplete types.</span></span> <span data-ttu-id="15a0e-887">Извлеките тип с помощью <see cref="M:System.Type.GetType" /> и вызовите <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> в возвращенном типе <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-887">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="typeBuilder.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="15a0e-888">Тип атрибута для поиска.</span><span class="sxs-lookup"><span data-stu-id="15a0e-888">The type of attribute to search for.</span></span> <span data-ttu-id="15a0e-889">Возвращаются только те атрибуты, которые можно назначить этому типу.</span><span class="sxs-lookup"><span data-stu-id="15a0e-889">Only attributes that are assignable to this type are returned.</span></span></param>
        <param name="inherit"><span data-ttu-id="15a0e-890">Указывает, следует ли выполнять поиск в цепочке наследования этого члена для нахождения атрибутов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-890">Specifies whether to search this member's inheritance chain to find the attributes.</span></span></param>
        <summary><span data-ttu-id="15a0e-891">Возвращает все настраиваемые атрибуты текущего типа, которые можно назначить указанному типу.</span><span class="sxs-lookup"><span data-stu-id="15a0e-891">Returns all the custom attributes of the current type that are assignable to a specified type.</span></span></summary>
        <returns><span data-ttu-id="15a0e-892">Массив настраиваемых атрибутов, определенных для текущего типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-892">An array of custom attributes defined on the current type.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-893">В настоящее время этот метод не поддерживается для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-893">This method is not currently supported for incomplete types.</span></span> <span data-ttu-id="15a0e-894">Извлеките тип с помощью <see cref="M:System.Type.GetType" /> и вызовите <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> в возвращенном типе <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-894">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-895">Свойство <paramref name="attributeType" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-895"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-896">Тип должен быть типом, предоставленным базовой системой среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-896">The type must be a type provided by the underlying runtime system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="override this.GetElementType : unit -&gt; Type" Usage="typeBuilder.GetElementType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="15a0e-897">При вызове этого метода всегда возникает исключение <see cref="T:System.NotSupportedException" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-897">Calling this method always throws <see cref="T:System.NotSupportedException" />.</span></span></summary>
        <returns><span data-ttu-id="15a0e-898">Этот метод не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="15a0e-898">This method is not supported.</span></span> <span data-ttu-id="15a0e-899">Возвращаемое значение отсутствует.</span><span class="sxs-lookup"><span data-stu-id="15a0e-899">No value is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-900">Получите тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-900">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-901">Этот метод не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="15a0e-901">This method is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="typeBuilder.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-902">Имя искомого события.</span><span class="sxs-lookup"><span data-stu-id="15a0e-902">The name of the event to search for.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="15a0e-903">Битовая комбинация значений <see cref="T:System.Reflection.BindingFlags" />, определяющая границы поиска.</span><span class="sxs-lookup"><span data-stu-id="15a0e-903">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limits the search.</span></span></param>
        <summary><span data-ttu-id="15a0e-904">Возвращает событие с указанным именем.</span><span class="sxs-lookup"><span data-stu-id="15a0e-904">Returns the event with the specified name.</span></span></summary>
        <returns><span data-ttu-id="15a0e-905">Объект <see cref="T:System.Reflection.EventInfo" />, представляющий событие, объявленное или наследованное этим типом с указанным именем; или значение <see langword="null" />, если совпадений не обнаружено.</span><span class="sxs-lookup"><span data-stu-id="15a0e-905">An <see cref="T:System.Reflection.EventInfo" /> object representing the event declared or inherited by this type with the specified name, or <see langword="null" /> if there are no matches.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-906">Получите тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-906">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-907">Этот метод не реализован для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-907">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="15a0e-908">Возвращает событие, определенное текущим построителем <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-908">Returns the events defined by the current <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="typeBuilder.GetEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="15a0e-909">Возвращает открытые события, объявленные или наследованные данным типом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-909">Returns the public events declared or inherited by this type.</span></span></summary>
        <returns><span data-ttu-id="15a0e-910">Возвращает массив объектов <see cref="T:System.Reflection.EventInfo" /> , представляющих открытые события, объявленные или наследуемые этим типом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-910">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing the public events declared or inherited by this type.</span></span> <span data-ttu-id="15a0e-911">Если открытые события отсутствуют, возвращается пустой массив.</span><span class="sxs-lookup"><span data-stu-id="15a0e-911">An empty array is returned if there are no public events.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-912">Получите тип с помощью <xref:System.Type.GetType%2A> или <xref:System.Reflection.Assembly.GetType%2A> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-912">Retrieve the type using <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetType%2A> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-913">Этот метод не реализован для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-913">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="typeBuilder.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="15a0e-914">Битовая комбинация значений <see cref="T:System.Reflection.BindingFlags" />, определяющая границы поиска.</span><span class="sxs-lookup"><span data-stu-id="15a0e-914">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limits the search.</span></span></param>
        <summary><span data-ttu-id="15a0e-915">Возвращает открытые и не являющиеся открытыми события, объявленные данным типом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-915">Returns the public and non-public events that are declared by this type.</span></span></summary>
        <returns><span data-ttu-id="15a0e-916">Возвращает массив объектов <see cref="T:System.Reflection.EventInfo" />, представляющих события, которые объявлены или унаследованы этим типом и удовлетворяют указанным флагам привязки.</span><span class="sxs-lookup"><span data-stu-id="15a0e-916">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing the events declared or inherited by this type that match the specified binding flags.</span></span> <span data-ttu-id="15a0e-917">Если соответствующие события отсутствуют, возвращается пустой массив.</span><span class="sxs-lookup"><span data-stu-id="15a0e-917">An empty array is returned if there are no matching events.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-918">Получите тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-918">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-919">Этот метод не реализован для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-919">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="15a0e-920">Возвращает поле, определенное текущим <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-920">Returns a field defined by the current <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="typeBuilder.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-921">Имя получаемого поля.</span><span class="sxs-lookup"><span data-stu-id="15a0e-921">The name of the field to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="15a0e-922">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />, как в <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</span><span class="sxs-lookup"><span data-stu-id="15a0e-922">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="15a0e-923">Возвращает поле, указанное данным именем.</span><span class="sxs-lookup"><span data-stu-id="15a0e-923">Returns the field specified by the given name.</span></span></summary>
        <returns><span data-ttu-id="15a0e-924">Возвращает объект <see cref="T:System.Reflection.FieldInfo" />, представляющий поле, объявленное или наследуемое этим типом, с указанным именем и открытым или закрытым модификатором.</span><span class="sxs-lookup"><span data-stu-id="15a0e-924">Returns the <see cref="T:System.Reflection.FieldInfo" /> object representing the field declared or inherited by this type with the specified name and public or non-public modifier.</span></span> <span data-ttu-id="15a0e-925">Если совпадений нет, возвращается значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-925">If there are no matches then <see langword="null" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-926">Получите тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-926">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-927">Этот метод не реализован для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-927">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetField (Type type, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetField(class System.Type type, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetField(Type ^ type, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="static member GetField : Type * System.Reflection.FieldInfo -&gt; System.Reflection.FieldInfo" Usage="System.Reflection.Emit.TypeBuilder.GetField (type, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="15a0e-928">Сконструированный универсальный тип, поле которого возвращается.</span><span class="sxs-lookup"><span data-stu-id="15a0e-928">The constructed generic type whose field is returned.</span></span></param>
        <param name="field"><span data-ttu-id="15a0e-929">Поле определения универсального типа <paramref name="type" />, которое указывает, какое поле <paramref name="type" /> следует вернуть.</span><span class="sxs-lookup"><span data-stu-id="15a0e-929">A field on the generic type definition of <paramref name="type" />, which specifies which field of <paramref name="type" /> to return.</span></span></param>
        <summary><span data-ttu-id="15a0e-930">Возвращает поле указанного сконструированного универсального типа, соответствующее указанному полю определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-930">Returns the field of the specified constructed generic type that corresponds to the specified field of the generic type definition.</span></span></summary>
        <returns><span data-ttu-id="15a0e-931">Объект <see cref="T:System.Reflection.FieldInfo" />, представляющий поле <paramref name="type" />, соответствующее <paramref name="field" />, который указывает поле, принадлежащее определению универсального типа <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-931">A <see cref="T:System.Reflection.FieldInfo" /> object that represents the field of <paramref name="type" /> corresponding to <paramref name="field" />, which specifies a field belonging to the generic type definition of <paramref name="type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-932">Метод <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> предоставляет способ получения объекта <xref:System.Reflection.FieldInfo>, представляющего поле сконструированного универсального типа, определение универсального типа которого представлено объектом <xref:System.Reflection.Emit.TypeBuilder>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-932">The <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method provides a way to get a <xref:System.Reflection.FieldInfo> object that represents a field of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="15a0e-933">Например, предположим, что имеется объект <xref:System.Reflection.Emit.TypeBuilder>, представляющий тип `G<T>` в C# синтаксисе (`G(Of T)` в Visual Basic, `generic <T> ref class G` в C++) и объект <xref:System.Reflection.Emit.FieldBuilder>, представляющий поле `public T F` в C# синтаксисе (`Public F As T` в Visual Basic, 0 в C++), определяемый 2.</span><span class="sxs-lookup"><span data-stu-id="15a0e-933">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.FieldBuilder> object that represents a field `public T F` in C# syntax (`Public F As T` in Visual Basic, `public: T F` in C++) that is defined by `G<T>`.</span></span> <span data-ttu-id="15a0e-934">Предположим, что `G<T>` имеет универсальный метод с параметром типа `U`, который создает экземпляр сконструированного типа `G<U>` и вызывает поле `F` на этом экземпляре.</span><span class="sxs-lookup"><span data-stu-id="15a0e-934">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>` and calls field `F` on that instance.</span></span> <span data-ttu-id="15a0e-935">Чтобы выдать вызов функции, необходим объект <xref:System.Reflection.FieldInfo>, представляющий `F` для сконструированного типа, иными словами, имеет тип `U`, а не тип `T`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-935">In order to emit the function call, you need a <xref:System.Reflection.FieldInfo> object that represents `F` on the constructed type - in other words, that is of type `U` rather than type `T`.</span></span> <span data-ttu-id="15a0e-936">Для этого сначала вызовите метод <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> для объекта <xref:System.Reflection.Emit.TypeBuilder>, указав объект <xref:System.Reflection.Emit.GenericTypeParameterBuilder>, представляющий `U` в качестве аргумента типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-936">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="15a0e-937">Затем вызовите метод <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> с возвращаемым значением метода <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> в качестве параметра `type` и объектом <xref:System.Reflection.Emit.FieldBuilder>, представляющим `F` в качестве параметра `field`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-937">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.FieldBuilder> object that represents `F` as parameter `field`.</span></span> <span data-ttu-id="15a0e-938">Возвращаемое значение — это объект <xref:System.Reflection.FieldInfo>, для которого необходимо выдать вызов функции.</span><span class="sxs-lookup"><span data-stu-id="15a0e-938">The return value is the <xref:System.Reflection.FieldInfo> object you need to emit the function call.</span></span> <span data-ttu-id="15a0e-939">Этот сценарий показан в примере кода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-939">The code example demonstrates this scenario.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-940">Следующий пример кода содержит исходный код для универсального класса с именем Sample, имеющий параметр типа с именем `T`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-940">The following code example contains source code for a generic class named Sample that has a type parameter named `T`.</span></span> <span data-ttu-id="15a0e-941">Класс содержит поле с именем `Field`, типа `T` и универсальный метод с именем `GM` с собственным параметром типа с именем `U`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-941">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="15a0e-942">Метод `GM` создает экземпляр `Sample`, подставив свой собственный параметр типа `U` для параметра типа `Sample` и сохраняет свой входной параметр в `Field`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-942">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="15a0e-943">Этот исходный код скомпилирован, но не используется; можно просмотреть его с помощью программы [Ildasm. exe (ДИЗАССЕМБЛЕР IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) и сравнить его с кодом, созданным классом `Example`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-943">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="15a0e-944">Код в классе `Example` демонстрирует использование метода <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> для выдачи универсального кода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-944">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method to emit generic code.</span></span> <span data-ttu-id="15a0e-945">Метод `Main` класса `Example` создает динамическую сборку, содержащую класс с именем `Sample`, и использует метод <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>, чтобы сделать его универсальным, добавив параметр типа с именем `T`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-945">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample`, and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="15a0e-946">Конструктор без параметров и поле с именем `Field` типа `T` добавляются в класс `Sample`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-946">A parameterless constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="15a0e-947">Метод `GM` добавляется и превращается в универсальный метод с помощью метода <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-947">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="15a0e-948">Параметр типа `GM` имеет имя `U`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-948">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="15a0e-949">После определения параметра типа сигнатура `GM` добавляется с помощью метода <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-949">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="15a0e-950">Отсутствует тип возвращаемого значения, а также обязательные или настраиваемые модификаторы, поэтому все параметры этого метода имеют `null`, за исключением `parameterTypes`; `parameterTypes` задает тип единственного параметра метода равным `U`, параметр универсального типа метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-950">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="15a0e-951">Тело метода создает экземпляр сконструированного типа `Sample<U>` (`Sample(Of U)` в Visual Basic), присваивает параметр метода `Field`, а затем выводит значение `Field`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-951">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="15a0e-952">Метод <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> используется для создания <xref:System.Reflection.FieldInfo>, представляющего поле сконструированного универсального типа `Sample<U>` в инструкциях <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> и <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-952">The <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method is used to create a <xref:System.Reflection.FieldInfo> that represents the field of the constructed generic type `Sample<U>` in the <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> and <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> instructions.</span></span>  
  
 <span data-ttu-id="15a0e-953">Фиктивный тип определяется для хранения метода точки входа `Main`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-953">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="15a0e-954">В теле `Main` статический метод `GM` вызывается для сконструированного универсального типа `Sample<int>` (`Sample(Of Integer)` в Visual Basic) с типом <xref:System.String>, который заменяется на `U`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-954">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span>  
  
 <span data-ttu-id="15a0e-955">Когда выполняется пример кода, выпущенная сборка сохраняется как Типебуилдержетфиелдексампле. exe.</span><span class="sxs-lookup"><span data-stu-id="15a0e-955">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="15a0e-956">Вы можете запустить Типебуилдержетфиелдексампле. exe, и вы можете использовать программу [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) , чтобы сравнить созданный код с кодом для класса `Sample`, который компилируется в самом примере кода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-956">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-957"><paramref name="type" /> не представляет универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-957"><paramref name="type" /> does not represent a generic type.</span></span>  
  
<span data-ttu-id="15a0e-958">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-958">-or-</span></span> 
 <span data-ttu-id="15a0e-959">Параметр<paramref name="type" /> не является параметром типа <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-959"><paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span>  
  
<span data-ttu-id="15a0e-960">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-960">-or-</span></span> 
<span data-ttu-id="15a0e-961">Объявляющий тип <paramref name="field" /> не является определением универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-961">The declaring type of <paramref name="field" /> is not a generic type definition.</span></span>  
  
<span data-ttu-id="15a0e-962">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-962">-or-</span></span> 
<span data-ttu-id="15a0e-963">Объявляющий тип <paramref name="field" /> не является определением универсального типа <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-963">The declaring type of <paramref name="field" /> is not the generic type definition of <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="typeBuilder.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="15a0e-964">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</span><span class="sxs-lookup"><span data-stu-id="15a0e-964">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="15a0e-965">Возвращает открытые и не являющиеся открытыми поля, объявленные данным типом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-965">Returns the public and non-public fields that are declared by this type.</span></span></summary>
        <returns><span data-ttu-id="15a0e-966">Возвращает массив объектов <see cref="T:System.Reflection.FieldInfo" />, представляющих открытые и не являющиеся открытыми поля, объявленные или наследованные этим типом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-966">Returns an array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the public and non-public fields declared or inherited by this type.</span></span> <span data-ttu-id="15a0e-967">Если заданные поля отсутствуют, возвращается пустой массив.</span><span class="sxs-lookup"><span data-stu-id="15a0e-967">An empty array is returned if there are no fields, as specified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-968">Метод <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> не возвращает поля в определенном порядке, таком как алфавит или порядок объявления.</span><span class="sxs-lookup"><span data-stu-id="15a0e-968">The <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="15a0e-969">Код не должен зависеть от порядка, в котором возвращаются поля, так как этот порядок может меняться.</span><span class="sxs-lookup"><span data-stu-id="15a0e-969">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 <span data-ttu-id="15a0e-970">Получите тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-970">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-971">Этот метод не реализован для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-971">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="override this.GetGenericArguments : unit -&gt; Type[]" Usage="typeBuilder.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="15a0e-972">Возвращает массив объектов <see cref="T:System.Type" />, которые представляют аргументы универсального типа или параметры определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-972">Returns an array of <see cref="T:System.Type" /> objects representing the type arguments of a generic type or the type parameters of a generic type definition.</span></span></summary>
        <returns><span data-ttu-id="15a0e-973">Массив объектов <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-973">An array of <see cref="T:System.Type" /> objects.</span></span> <span data-ttu-id="15a0e-974">Элементы массива, которые представляют аргументы универсального типа или параметры определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-974">The elements of the array represent the type arguments of a generic type or the type parameters of a generic type definition.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-975">Элементы возвращаемого массива находятся в том порядке, в котором они отображаются в списке параметров типа для определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-975">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic type definition.</span></span>  
  
 <span data-ttu-id="15a0e-976">Объект <xref:System.Reflection.Emit.TypeBuilder> представляет определение универсального типа, если для предоставления параметров универсального типа использовался метод <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-976">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="15a0e-977">Этот метод извлекает объекты <xref:System.Reflection.Emit.GenericTypeParameterBuilder>, представляющие параметры универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-977">This method retrieves the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objects that represent the generic type parameters.</span></span>  
  
 <span data-ttu-id="15a0e-978">Дополнительные сведения об универсальных типах в отражении и списке инвариантных условий для терминов, используемых в универсальном отражении, см. в описании свойства <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-978">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericArguments" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="typeBuilder.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="typeBuilder.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="15a0e-979">Возвращает объект <see cref="T:System.Type" />, представляющий определение универсального типа, на основе которого можно получить текущий тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-979">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current type can be obtained.</span></span></summary>
        <returns><span data-ttu-id="15a0e-980">Объект <see cref="T:System.Type" />, представляющий определение универсального типа, на основе которого можно получить текущий тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-980">A <see cref="T:System.Type" /> object representing a generic type definition from which the current type can be obtained.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-981">При вызове метода <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> для объекта <xref:System.Reflection.Emit.TypeBuilder>, для которого свойство @no__t 2 Возвращает значение `true`, свойство <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> возвращает текущий экземпляр.</span><span class="sxs-lookup"><span data-stu-id="15a0e-981">If you call the <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> object for which the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> property returns `true`, the <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> property returns the current instance.</span></span> <span data-ttu-id="15a0e-982">@No__t-0, представляющий универсальный тип, всегда является определением универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-982">A <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type is always a generic type definition.</span></span>  
  
 <span data-ttu-id="15a0e-983">Если для создания универсального типа из объекта <xref:System.Reflection.Emit.TypeBuilder>, который представляет определение универсального типа, использовался метод <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>, то при использовании метода <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> для сконструированного типа возвращается объект <xref:System.Reflection.Emit.TypeBuilder>, представляющий определение универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-983">If you used the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method to construct a generic type from a <xref:System.Reflection.Emit.TypeBuilder> object that represents a generic type definition, using the <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> method on the constructed type gets back the <xref:System.Reflection.Emit.TypeBuilder> object that represents the generic type definition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-984">Текущий тип не является универсальным.</span><span class="sxs-lookup"><span data-stu-id="15a0e-984">The current type is not generic.</span></span> <span data-ttu-id="15a0e-985">То есть <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> возвращает <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-985">That is, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> returns <see langword="false" />.</span></span></exception>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetInterface : string * bool -&gt; Type" Usage="typeBuilder.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-986">Имя интерфейса.</span><span class="sxs-lookup"><span data-stu-id="15a0e-986">The name of the interface.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="15a0e-987">Если значение <see langword="true" />, при поиске не учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="15a0e-987">If <see langword="true" />, the search is case-insensitive.</span></span> <span data-ttu-id="15a0e-988">Если значение <see langword="false" />, при поиске учитывается регистр.</span><span class="sxs-lookup"><span data-stu-id="15a0e-988">If <see langword="false" />, the search is case-sensitive.</span></span></param>
        <summary><span data-ttu-id="15a0e-989">Возвращает интерфейс, реализованный (прямо или косвенно) данным классом с полным именем, совпадающим с именем данного интерфейса.</span><span class="sxs-lookup"><span data-stu-id="15a0e-989">Returns the interface implemented (directly or indirectly) by this class with the fully qualified name matching the given interface name.</span></span></summary>
        <returns><span data-ttu-id="15a0e-990">Возвращает объект <see cref="T:System.Type" />, предоставляющий реализованный интерфейс.</span><span class="sxs-lookup"><span data-stu-id="15a0e-990">Returns a <see cref="T:System.Type" /> object representing the implemented interface.</span></span> <span data-ttu-id="15a0e-991">Возвращает значение null, если совпадающее имя интерфейса не найдено.</span><span class="sxs-lookup"><span data-stu-id="15a0e-991">Returns null if no interface matching name is found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-992">Получите тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-992">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-993">Этот метод не реализован для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-993">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="typeBuilder.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="interfaceType"><span data-ttu-id="15a0e-994">Тип <see cref="T:System.Type" /> интерфейса, для которого должно быть получено сопоставление.</span><span class="sxs-lookup"><span data-stu-id="15a0e-994">The <see cref="T:System.Type" /> of the interface for which the mapping is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="15a0e-995">Возвращает сопоставление для запрошенного интерфейса.</span><span class="sxs-lookup"><span data-stu-id="15a0e-995">Returns an interface mapping for the requested interface.</span></span></summary>
        <returns><span data-ttu-id="15a0e-996">Возвращает запрошенное сопоставление интерфейса.</span><span class="sxs-lookup"><span data-stu-id="15a0e-996">Returns the requested interface mapping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-997">Получите тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-997">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-998">Этот метод не реализован для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-998">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="override this.GetInterfaces : unit -&gt; Type[]" Usage="typeBuilder.GetInterfaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="15a0e-999">Возвращает массив всех интерфейсов, реализованных для данного типа и его базовых типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-999">Returns an array of all the interfaces implemented on this type and its base types.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1000">Возвращает массив объектов <see cref="T:System.Type" />, представляющих реализованные интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1000">Returns an array of <see cref="T:System.Type" /> objects representing the implemented interfaces.</span></span> <span data-ttu-id="15a0e-1001">Если они не определены, возвращается пустой массив.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1001">If none are defined, an empty array is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="typeBuilder.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-1002">Имя элемента.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1002">The name of the member.</span></span></param>
        <param name="type"><span data-ttu-id="15a0e-1003">Тип возвращаемого элемента.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1003">The type of the member to return.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="15a0e-1004">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />, как в <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1004">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="15a0e-1005">Возвращает все открытые и закрытые члены, объявленные или наследуемые данным типом, как указано.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1005">Returns all the public and non-public members declared or inherited by this type, as specified.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1006">Возвращает массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющих открытые и не являющиеся открытыми члены, определенные для данного типа, если используется <paramref name="nonPublic" />; в противном случае возвращаются только открытые члены.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1006">Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public and non-public members defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public members are returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1007">Получите тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1007">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-1008">Этот метод не реализован для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1008">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="typeBuilder.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="15a0e-1009">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />, например <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1009">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, such as <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="15a0e-1010">Возвращает открытые и не являющиеся открытыми члены, объявленные или наследуемые данным типом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1010">Returns the members for the public and non-public members declared or inherited by this type.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1011">Возвращает массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющих открытые и не являющиеся открытыми члены, объявленные или наследованные этим типом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1011">Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public and non-public members declared or inherited by this type.</span></span> <span data-ttu-id="15a0e-1012">Если соответствующие члены отсутствуют, возвращается пустой массив.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1012">An empty array is returned if there are no matching members.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1013">Получите тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1013">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-1014">Этот метод не реализован для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1014">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodInfo GetMethod (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodInfo GetMethod(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodInfo ^ GetMethod(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GetMethod : Type * System.Reflection.MethodInfo -&gt; System.Reflection.MethodInfo" Usage="System.Reflection.Emit.TypeBuilder.GetMethod (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="15a0e-1015">Сконструированный универсальный тип, метод которого возвращается.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1015">The constructed generic type whose method is returned.</span></span></param>
        <param name="method"><span data-ttu-id="15a0e-1016">Метод определения универсального типа <paramref name="type" />, который указывает, какой метод <paramref name="type" /> следует вернуть.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1016">A method on the generic type definition of <paramref name="type" />, which specifies which method of <paramref name="type" /> to return.</span></span></param>
        <summary><span data-ttu-id="15a0e-1017">Возвращает метод указанного сконструированного универсального типа, соответствующего указанному методу определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1017">Returns the method of the specified constructed generic type that corresponds to the specified method of the generic type definition.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1018">Объект <see cref="T:System.Reflection.MethodInfo" />, представляющий метод <paramref name="type" />, соответствующий <paramref name="method" />, который указывает метод, принадлежащий определению универсального типа <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1018">A <see cref="T:System.Reflection.MethodInfo" /> object that represents the method of <paramref name="type" /> corresponding to <paramref name="method" />, which specifies a method belonging to the generic type definition of <paramref name="type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1019">Метод <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> предоставляет способ получения объекта <xref:System.Reflection.MethodInfo>, который представляет метод сконструированного универсального типа, определение универсального типа которого представлено объектом <xref:System.Reflection.Emit.TypeBuilder>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1019">The <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method provides a way to get a <xref:System.Reflection.MethodInfo> object that represents a method of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="15a0e-1020">Например, предположим, что имеется объект <xref:System.Reflection.Emit.TypeBuilder>, представляющий тип `G<T>` в C# синтаксисе (`G(Of T)` в Visual Basic, `generic <T> ref class G` в C++) и объект <xref:System.Reflection.Emit.MethodBuilder>, представляющий метод `T M()` в C# синтаксисе (`Function M() As T` в Visual Basic, 0 в C++), определяемый 2.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1020">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.MethodBuilder> object that represents a method `T M()` in C# syntax (`Function M() As T` in Visual Basic, `T M()` in C++) that is defined by `G<T>`.</span></span> <span data-ttu-id="15a0e-1021">Предположим, что `G<T>` имеет универсальный метод с параметром типа `U`, который создает экземпляр сконструированного типа `G<U>` и вызывает метод `M` для этого экземпляра.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1021">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>` and calls method `M` on that instance.</span></span> <span data-ttu-id="15a0e-1022">Чтобы выдать вызов функции, необходим объект <xref:System.Reflection.MethodInfo>, представляющий `M` для сконструированного типа — другими словами, который возвращает тип `U`, а не тип `T`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1022">In order to emit the function call, you need a <xref:System.Reflection.MethodInfo> object that represents `M` on the constructed type - in other words, that returns type `U` rather than type `T`.</span></span> <span data-ttu-id="15a0e-1023">Для этого сначала вызовите метод <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> для объекта <xref:System.Reflection.Emit.TypeBuilder>, указав объект <xref:System.Reflection.Emit.GenericTypeParameterBuilder>, представляющий `U` в качестве аргумента типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1023">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="15a0e-1024">Затем вызовите метод <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> с возвращаемым значением метода <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> в качестве параметра `type` и объектом <xref:System.Reflection.Emit.MethodBuilder>, представляющим `T M()` в качестве параметра `method`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1024">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.MethodBuilder> object that represents `T M()` as parameter `method`.</span></span> <span data-ttu-id="15a0e-1025">Возвращаемое значение — это объект <xref:System.Reflection.MethodInfo>, для которого необходимо выдать вызов функции.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1025">The return value is the <xref:System.Reflection.MethodInfo> object you need to emit the function call.</span></span> <span data-ttu-id="15a0e-1026">В примере кода показан сценарий, аналогичный этому.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1026">The code example demonstrates a scenario similar to this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-1027">Следующий пример кода содержит исходный код для универсального класса с именем `Sample`, который имеет параметр типа с именем `T`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1027">The following code example contains source code for a generic class named `Sample` that has a type parameter named `T`.</span></span> <span data-ttu-id="15a0e-1028">Класс содержит поле с именем `Field`, типа `T` и универсальный метод с именем `GM` с собственным параметром типа с именем `U`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1028">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="15a0e-1029">Метод `GM` создает экземпляр `Sample`, подставив свой собственный параметр типа `U` для параметра типа `Sample` и сохраняет свой входной параметр в `Field`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1029">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="15a0e-1030">Этот исходный код скомпилирован, но не используется; можно просмотреть его с помощью программы [Ildasm. exe (ДИЗАССЕМБЛЕР IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) и сравнить его с кодом, созданным классом `Example`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1030">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="15a0e-1031">Код в классе `Example` демонстрирует использование метода <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> для выдачи универсального кода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1031">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method to emit generic code.</span></span> <span data-ttu-id="15a0e-1032">Метод `Main` класса `Example` создает динамическую сборку, содержащую класс с именем `Sample`, и использует метод <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>, чтобы сделать его универсальным, добавив параметр типа с именем `T`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1032">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample` and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="15a0e-1033">Конструктор без параметров и поле с именем `Field` типа `T` добавляются в класс `Sample`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1033">A parameterless constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="15a0e-1034">Метод `GM` добавляется и превращается в универсальный метод с помощью метода <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1034">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="15a0e-1035">Параметр типа `GM` имеет имя `U`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1035">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="15a0e-1036">После определения параметра типа сигнатура `GM` добавляется с помощью метода <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1036">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="15a0e-1037">Отсутствует тип возвращаемого значения, а также обязательные или настраиваемые модификаторы, поэтому все параметры этого метода имеют `null`, за исключением `parameterTypes`; `parameterTypes` задает тип единственного параметра метода равным `U`, параметр универсального типа метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1037">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="15a0e-1038">Тело метода создает экземпляр сконструированного типа `Sample<U>` (`Sample(Of U)` в Visual Basic), присваивает параметр метода `Field`, а затем выводит значение `Field`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1038">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="15a0e-1039">Фиктивный тип определяется для хранения метода точки входа `Main`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1039">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="15a0e-1040">В теле `Main` статический метод `GM` вызывается для сконструированного универсального типа `Sample<int>` (`Sample(Of Integer)` в Visual Basic) с типом <xref:System.String>, который заменяется на `U`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1040">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span> <span data-ttu-id="15a0e-1041">Метод <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> используется для создания <xref:System.Reflection.MethodInfo> для статического метода `GM` сконструированного универсального типа `Sample<U>`, а метод <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> используется для создания <xref:System.Reflection.MethodInfo>, который может выдаваться при вызове метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1041">The <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method is used to create a <xref:System.Reflection.MethodInfo> for the static `GM` method of the constructed generic type `Sample<U>`, and the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method is then used to create a <xref:System.Reflection.MethodInfo> that can emitted in a method call.</span></span>  
  
 <span data-ttu-id="15a0e-1042">Когда выполняется пример кода, выпущенная сборка сохраняется как Типебуилдержетфиелдексампле. exe.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1042">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="15a0e-1043">Вы можете запустить Типебуилдержетфиелдексампле. exe, и вы можете использовать программу [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md) , чтобы сравнить созданный код с кодом для класса `Sample`, который компилируется в самом примере кода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1043">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-1044"><paramref name="method" /> представляет универсальный метод, который не является определением универсального метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1044"><paramref name="method" /> is a generic method that is not a generic method definition.</span></span>  
  
<span data-ttu-id="15a0e-1045">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-1045">-or-</span></span> 
 <span data-ttu-id="15a0e-1046"><paramref name="type" /> не представляет универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1046"><paramref name="type" /> does not represent a generic type.</span></span>  
  
<span data-ttu-id="15a0e-1047">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-1047">-or-</span></span> 
 <span data-ttu-id="15a0e-1048">Параметр<paramref name="type" /> не является параметром типа <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1048"><paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span>  
  
<span data-ttu-id="15a0e-1049">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-1049">-or-</span></span> 
<span data-ttu-id="15a0e-1050">Объявляющий тип <paramref name="method" /> не является определением универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1050">The declaring type of <paramref name="method" /> is not a generic type definition.</span></span>  
  
<span data-ttu-id="15a0e-1051">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-1051">-or-</span></span> 
<span data-ttu-id="15a0e-1052">Объявляющий тип <paramref name="method" /> не является определением универсального типа <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1052">The declaring type of <paramref name="method" /> is not the generic type definition of <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="typeBuilder.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="typeBuilder.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="15a0e-1053">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />, как в <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1053">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="15a0e-1054">Возвращает все открытые и закрытые методы, объявленные или наследуемые данным типом, как указано.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1054">Returns all the public and non-public methods declared or inherited by this type, as specified.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1055">Возвращает массив объектов <see cref="T:System.Reflection.MethodInfo" />, представляющих открытые и закрытые методы, определенные для данного типа, если используется <paramref name="nonPublic" />; в противном случае возвращаются только открытые методы.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1055">Returns an array of <see cref="T:System.Reflection.MethodInfo" /> objects representing the public and non-public methods defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public methods are returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1056">Получите тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1056">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-1057">Этот метод не реализован для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1057">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="typeBuilder.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-1058">Строка <see cref="T:System.String" />, содержащая имя искомого вложенного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1058">The <see cref="T:System.String" /> containing the name of the nested type to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="15a0e-1059">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1059">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="15a0e-1060">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-1060">-or-</span></span> 
<span data-ttu-id="15a0e-1061">Нуль для выполнения поиска открытых методов с учетом регистра.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1061">Zero, to conduct a case-sensitive search for public methods.</span></span></param>
        <summary><span data-ttu-id="15a0e-1062">Возвращает открытые и не являющиеся открытыми вложенные типы, объявленные этим типом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1062">Returns the public and non-public nested types that are declared by this type.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1063">Если поиск выполнен успешно, возвращается объект <see cref="T:System.Type" />, предоставляющий вложенный тип, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1063">A <see cref="T:System.Type" /> object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1064">Получите тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1064">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 <span data-ttu-id="15a0e-1065">Если этот тип является полным, например, если для этого типа был вызван `CreateType`, но имеются незавершенные вложенные типы, то `GetNestedTypes` будет возвращать только те вложенные типы, для которых был вызван `CreateType`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1065">If this type is complete, for example, if `CreateType` has been called on this type, but there are nested types that are not complete, then `GetNestedTypes` will only return those nested types for which `CreateType` has been called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-1066">Этот метод не реализован для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1066">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="typeBuilder.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="15a0e-1067">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />, как в <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1067">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="15a0e-1068">Возвращает открытые и не являющиеся открытыми вложенные типы, объявленные или наследованные данным типом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1068">Returns the public and non-public nested types that are declared or inherited by this type.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1069">Массив объектов <see cref="T:System.Type" />, представляющий все типы, вложенные внутри текущего типа <see cref="T:System.Type" /> и удовлетворяющие указанным ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1069">An array of <see cref="T:System.Type" /> objects representing all the types nested within the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="15a0e-1070">Пустой массив типа <see cref="T:System.Type" />, если внутри текущего объекта <see cref="T:System.Type" /> нет вложенных типов, или ни один из вложенных типов не удовлетворяет ограничениям привязки.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1070">An empty array of type <see cref="T:System.Type" />, if no types are nested within the current <see cref="T:System.Type" />, or if none of the nested types match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1071">Получите тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1071">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 <span data-ttu-id="15a0e-1072">Если этот тип является полным, например, если для этого типа был вызван `CreateType`, но имеются незавершенные вложенные типы, то `GetNestedTypes` будет возвращать только те вложенные типы, для которых был вызван `CreateType`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1072">If this type is complete, for example, if `CreateType` has been called on this type, but there are nested types that are not complete, then `GetNestedTypes` will only return those nested types for which `CreateType` has been called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-1073">Этот метод не реализован для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1073">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="typeBuilder.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="15a0e-1074">Это атрибут вызова.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1074">This invocation attribute.</span></span> <span data-ttu-id="15a0e-1075">Это должен быть одноразрядный флаг из <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> и так далее.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1075">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="15a0e-1076">Возвращает все открытые и закрытые свойства, объявленные или наследуемые данным типом, как указано.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1076">Returns all the public and non-public properties declared or inherited by this type, as specified.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1077">Возвращает массив объектов <see langword="PropertyInfo" />, представляющих открытые и закрытые свойства, определенные для данного типа, если используется <paramref name="nonPublic" />; в противном случае возвращаются только открытые свойства.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1077">Returns an array of <see langword="PropertyInfo" /> objects representing the public and non-public properties defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public properties are returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1078">Получите тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1078">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-1079">Этот метод не реализован для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1079">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="typeBuilder.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="returnType">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1080">Получает идентификатор GUID этого типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1080">Retrieves the GUID of this type.</span></span></summary>
        <value><span data-ttu-id="15a0e-1081">Только для чтения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1081">Read-only.</span></span> <span data-ttu-id="15a0e-1082">Получает идентификатор GUID этого типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1082">Retrieves the GUID of this type</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1083">Получите тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1083">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-1084">В настоящее время этот метод не поддерживается для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1084">This method is not currently supported for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="override this.HasElementTypeImpl : unit -&gt; bool" Usage="typeBuilder.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="typeBuilder.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="namedParameters" Type="System.String[]" Index="7" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="15a0e-1085">Имя вызываемого члена.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1085">The name of the member to invoke.</span></span> <span data-ttu-id="15a0e-1086">Это может быть конструктор, метод, свойство или поле.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1086">This can be a constructor, method, property, or field.</span></span> <span data-ttu-id="15a0e-1087">Необходимо указать подходящий атрибут вызова.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1087">A suitable invocation attribute must be specified.</span></span> <span data-ttu-id="15a0e-1088">Обратите внимание, что можно вызвать член класса, заданный по умолчанию, передав в качестве имени члена пустую строку.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1088">Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="15a0e-1089">Атрибут вызова.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1089">The invocation attribute.</span></span> <span data-ttu-id="15a0e-1090">Это должен быть одноразрядный флаг из <see langword="BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1090">This must be a bit flag from <see langword="BindingFlags" />.</span></span></param>
        <param name="binder"><span data-ttu-id="15a0e-1091">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see langword="MemberInfo" /> с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1091">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="15a0e-1092">Если указан модуль привязки <see langword="null" />, используется модуль привязки по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1092">If binder is <see langword="null" />, the default binder is used.</span></span> <span data-ttu-id="15a0e-1093">См. раздел <see cref="T:System.Reflection.Binder" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1093">See <see cref="T:System.Reflection.Binder" />.</span></span></param>
        <param name="target"><span data-ttu-id="15a0e-1094">Объект, для которого следует вызвать указанный член.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1094">The object on which to invoke the specified member.</span></span> <span data-ttu-id="15a0e-1095">Если член является статическим, этот параметр игнорируется.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1095">If the member is static, this parameter is ignored.</span></span></param>
        <param name="args"><span data-ttu-id="15a0e-1096">Список аргументов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1096">An argument list.</span></span> <span data-ttu-id="15a0e-1097">Это массив объектов, содержащий число, порядок и тип параметров вызываемого члена.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1097">This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked.</span></span> <span data-ttu-id="15a0e-1098">Если параметров нет, должно быть указано значение NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1098">If there are no parameters this should be null.</span></span></param>
        <param name="modifiers"><span data-ttu-id="15a0e-1099">Массив с такой же длиной, как у <paramref name="args" /> с элементами, представляющими атрибуты, связанные с аргументами вызываемого члена.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1099">An array of the same length as <paramref name="args" /> with elements that represent the attributes associated with the arguments of the member to be invoked.</span></span> <span data-ttu-id="15a0e-1100">Параметр имеет атрибуты, связанные с ним в метаданных.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1100">A parameter has attributes associated with it in the metadata.</span></span> <span data-ttu-id="15a0e-1101">Они используются различными службами взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1101">They are used by various interoperability services.</span></span> <span data-ttu-id="15a0e-1102">Дополнительные сведения см. в спецификации метаданных.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1102">See the metadata specs for more details.</span></span></param>
        <param name="culture"><span data-ttu-id="15a0e-1103">Экземпляр объекта <see langword="CultureInfo" /> , используемого для управления приведением типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1103">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span></span> <span data-ttu-id="15a0e-1104">Если параметр имеет значение NULL, для текущего потока используется <see langword="CultureInfo" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1104">If this is null, the <see langword="CultureInfo" /> for the current thread is used.</span></span> <span data-ttu-id="15a0e-1105">(Обратите внимание, что необходимо, например, преобразовать строку, представляющую 1000, в число с двойной точностью, поскольку для разных языков и региональных параметров 1000 представляется по-разному.)</span><span class="sxs-lookup"><span data-stu-id="15a0e-1105">(Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.)</span></span></param>
        <param name="namedParameters"><span data-ttu-id="15a0e-1106">Каждый параметр в массиве <paramref name="namedParameters" /> получает значение в соответствующем элементе в массиве <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1106">Each parameter in the <paramref name="namedParameters" /> array gets the value in the corresponding element in the <paramref name="args" /> array.</span></span> <span data-ttu-id="15a0e-1107">Если длина <paramref name="args" /> превышает длину <paramref name="namedParameters" />, оставшиеся значения аргументов передаются по порядку.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1107">If the length of <paramref name="args" /> is greater than the length of <paramref name="namedParameters" />, the remaining argument values are passed in order.</span></span></param>
        <summary><span data-ttu-id="15a0e-1108">Вызывает указанный член.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1108">Invokes the specified member.</span></span> <span data-ttu-id="15a0e-1109">Вызываемый метод должен быть доступен и обеспечивать наиболее точное соответствие заданному списку аргументов с учетом ограничений заданного модуля привязки и атрибутов вызова.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1109">The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1110">Возвращает возвращаемое значение вызываемого члена.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1110">Returns the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1111">Метод будет вызываться, если число параметров в объявлении метода равно числу аргументов в указанном списке аргументов, а тип каждого аргумента может быть преобразован связывателем в тип параметра.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1111">A method will be invoked if the number of parameters in the method declaration equals the number of arguments in the specified argument list, and the type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="15a0e-1112">Связыватель найдет все методы сопоставления.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1112">The binder will find all of the matching methods.</span></span> <span data-ttu-id="15a0e-1113">Эти методы находятся в зависимости от типа запрашиваемой привязки (BindingFlags. InvokeMethod, BindingFlags.-Properties и т. д.).</span><span class="sxs-lookup"><span data-stu-id="15a0e-1113">These methods are found based on the type of binding requested (BindingFlags.InvokeMethod, BindingFlags.GetProperties, and so on.).</span></span> <span data-ttu-id="15a0e-1114">Набор методов фильтруется по имени, числу аргументов и набору модификаторов поиска, определенных в связывателе.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1114">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span> <span data-ttu-id="15a0e-1115">После выбора метода он будет вызван.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1115">After the method is selected, it will be invoked.</span></span> <span data-ttu-id="15a0e-1116">На этом этапе проверяется доступность.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1116">Accessibility is checked at that point.</span></span> <span data-ttu-id="15a0e-1117">Поиск может управлять тем, какой набор методов выполняется в зависимости от атрибута доступности, связанного с методом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1117">The search can control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="15a0e-1118">Метод `IBinder.BindToMethod` отвечает за выбор вызываемого метода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1118">The `IBinder.BindToMethod` method is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="15a0e-1119">Связыватель по умолчанию выбирает наиболее конкретное соответствие.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1119">The default binder selects the most specific match.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-1120">Ограничения доступа игнорируются для полностью доверенного кода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1120">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="15a0e-1121">Таким образом, закрытые конструкторы, методы, поля и свойства могут быть доступны и вызываться с помощью отражения всякий раз, когда код полностью надежен.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1121">That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="15a0e-1122">В настоящее время этот метод не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1122">This method is not currently supported.</span></span> <span data-ttu-id="15a0e-1123">Тип можно получить с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и использовать отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1123">You can retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-1124">В настоящее время этот метод не поддерживается для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1124">This method is not currently supported for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="override this.IsArrayImpl : unit -&gt; bool" Usage="typeBuilder.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAssignableFrom">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="15a0e-1125">Определяет, можно ли назначить указанный тип этому объекту.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1125">Determines whether a specified type can be assigned to this object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(System::Reflection::TypeInfo ^ typeInfo);" />
      <MemberSignature Language="F#" Value="override this.IsAssignableFrom : System.Reflection.TypeInfo -&gt; bool" Usage="typeBuilder.IsAssignableFrom typeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeInfo"><span data-ttu-id="15a0e-1126">Объект для тестирования.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1126">The object to test.</span></span></param>
        <summary><span data-ttu-id="15a0e-1127">Получает значение, указывающее, может ли заданный объект <see cref="T:System.Reflection.TypeInfo" /> быть назначен этому объекту.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1127">Gets a value that indicates whether a specified <see cref="T:System.Reflection.TypeInfo" /> object can be assigned to this object.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1128">Значение <see langword="true" />, если <paramref name="typeInfo" /> может быть назначен этому объекту. В противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1128"><see langword="true" /> if <paramref name="typeInfo" /> can be assigned to this object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="override this.IsAssignableFrom : Type -&gt; bool" Usage="typeBuilder.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="15a0e-1129">Объект для тестирования.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1129">The object to test.</span></span></param>
        <summary><span data-ttu-id="15a0e-1130">Возвращает значение, указывающее, может ли заданный <see cref="T:System.Type" /> быть назначен этому объекту.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1130">Gets a value that indicates whether a specified <see cref="T:System.Type" /> can be assigned to this object.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1131"><see langword="true" />, если параметр <paramref name="c" /> и текущий тип представляют один и тот же тип, или если текущий тип находится в иерархии наследования для <paramref name="c" />, или если текущий тип является интерфейсом, который поддерживает <paramref name="c" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1131"><see langword="true" /> if the <paramref name="c" /> parameter and the current type represent the same type, or if the current type is in the inheritance hierarchy of <paramref name="c" />, or if the current type is an interface that <paramref name="c" /> supports.</span></span> <span data-ttu-id="15a0e-1132">Значение <see langword="false" />, если не действует ни одно из этих условий или если значение параметра <paramref name="c" /> равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1132"><see langword="false" /> if none of these conditions are valid, or if <paramref name="c" /> is <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="override this.IsByRefImpl : unit -&gt; bool" Usage="typeBuilder.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public override bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="override this.IsCOMObjectImpl : unit -&gt; bool" Usage="typeBuilder.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1133">Возвращает значение, указывающее, представляет ли этот данный объект сконструированный универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1133">Gets a value that indicates whether this object represents a constructed generic type.</span></span></summary>
        <value><span data-ttu-id="15a0e-1134">Значение<see langword="true" /> , если этот объект представляет сконструированный универсальный тип; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1134"><see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCreated">
      <MemberSignature Language="C#" Value="public bool IsCreated ();" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsCreated() cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCreated" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCreated () As Boolean" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsCreated();" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsCreated : unit -&gt; bool" Usage="typeBuilder.IsCreated " FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="15a0e-1135">Возвращает значение, которое показывает, был ли создан текущий динамический тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1135">Returns a value that indicates whether the current dynamic type has been created.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1136">Значение <see langword="true" />, если был вызван метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />. В противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1136"><see langword="true" /> if the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has been called; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1137">После вызова метода <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> тип, представленный объектом <xref:System.Reflection.Emit.TypeBuilder>, будет завершен.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1137">After the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called, the type represented by the <xref:System.Reflection.Emit.TypeBuilder> object is complete.</span></span> <span data-ttu-id="15a0e-1138">Исключения возникают при последующих попытках добавить элементы или изменить другие характеристики типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1138">Exceptions are thrown on any further attempts to add members or change other characteristics of the type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="typeBuilder.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="15a0e-1139">Тип атрибута для поиска.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1139">The type of attribute to search for.</span></span> <span data-ttu-id="15a0e-1140">Возвращаются только те атрибуты, которые можно назначить этому типу.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1140">Only attributes that are assignable to this type are returned.</span></span></param>
        <param name="inherit"><span data-ttu-id="15a0e-1141">Указывает, следует ли выполнять поиск в цепочке наследования этого члена для нахождения атрибутов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1141">Specifies whether to search this member's inheritance chain to find the attributes.</span></span></param>
        <summary><span data-ttu-id="15a0e-1142">Определяет, применяется ли настраиваемый атрибут к текущему типу.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1142">Determines whether a custom attribute is applied to the current type.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1143"><see langword="true" />, если для данного типа определены один или несколько экземпляров <paramref name="attributeType" /> или атрибут является производным от <paramref name="attributeType" />; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1143"><see langword="true" /> if one or more instances of <paramref name="attributeType" />, or an attribute derived from <paramref name="attributeType" />, is defined on this type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1144">Этот метод не поддерживается для неполных параметров универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1144">This method is not supported for incomplete generic type parameters.</span></span> <span data-ttu-id="15a0e-1145">Получите тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1145">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-1146">В настоящее время этот метод не поддерживается для неполных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1146">This method is not currently supported for incomplete types.</span></span> <span data-ttu-id="15a0e-1147">Извлеките тип с помощью <see cref="M:System.Type.GetType" /> и вызовите <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> в возвращенном типе <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1147">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-1148"><paramref name="attributeType" /> не определен.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1148"><paramref name="attributeType" /> is not defined.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-1149">Свойство <paramref name="attributeType" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1149"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public override bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1150">Возвращает значение, указывающее, является ли текущий тип параметром универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1150">Gets a value indicating whether the current type is a generic type parameter.</span></span></summary>
        <value><span data-ttu-id="15a0e-1151">Значение <see langword="true" />, если текущий объект <see cref="T:System.Reflection.Emit.TypeBuilder" /> представляет параметр универсального типа; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1151"><see langword="true" /> if the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type parameter; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-1152">При выдаче кода параметр универсального типа представлен объектом <xref:System.Reflection.Emit.GenericTypeParameterBuilder>, а не объектом <xref:System.Reflection.Emit.TypeBuilder>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1152">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public override bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1153">Возвращает значение, указывающее, является ли текущий тип универсальным.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1153">Gets a value indicating whether the current type is a generic type.</span></span></summary>
        <value><span data-ttu-id="15a0e-1154">Значение <see langword="true" />, если тип, представленный текущим объектом <see cref="T:System.Reflection.Emit.TypeBuilder" />, является универсальным; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1154"><see langword="true" /> if the type represented by the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object is generic; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1155">Объект <xref:System.Reflection.Emit.TypeBuilder> представляет определение универсального типа, если для предоставления параметров универсального типа использовался метод <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1155">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="15a0e-1156">Экземпляр класса <xref:System.Reflection.Emit.TypeBuilder>, являющийся универсальным, всегда является определением универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1156">An instance of the <xref:System.Reflection.Emit.TypeBuilder> class that is generic is always a generic type definition.</span></span>  
  
 <span data-ttu-id="15a0e-1157">Дополнительные сведения об универсальных типах в отражении и списке инвариантных условий для терминов, используемых в универсальном отражении, см. в описании свойства <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1157">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1158">Возвращает значение, определяющее, представляет ли текущий объект <see cref="T:System.Reflection.Emit.TypeBuilder" /> определение универсального типа, на основе которого можно конструировать другие универсальные типы.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1158">Gets a value indicating whether the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> represents a generic type definition from which other generic types can be constructed.</span></span></summary>
        <value><span data-ttu-id="15a0e-1159">Значение <see langword="true" />, если этот объект <see cref="T:System.Reflection.Emit.TypeBuilder" /> представляет определение универсального типа. В противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1159"><see langword="true" /> if this <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1160">Объект <xref:System.Reflection.Emit.TypeBuilder> представляет определение универсального типа, если для предоставления параметров универсального типа использовался метод <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1160">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="15a0e-1161">Экземпляр класса <xref:System.Reflection.Emit.TypeBuilder>, являющийся универсальным, всегда является определением универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1161">An instance of the <xref:System.Reflection.Emit.TypeBuilder> class that is generic is always a generic type definition.</span></span>  
  
 <span data-ttu-id="15a0e-1162">@No__t-0 можно использовать для создания определений универсальных типов, но не сконструированных универсальных типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1162">A <xref:System.Reflection.Emit.TypeBuilder> can be used to build generic type definitions, but not constructed generic types.</span></span> <span data-ttu-id="15a0e-1163">Чтобы получить сконструированный универсальный тип, вызовите метод <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> для <xref:System.Reflection.Emit.TypeBuilder>, который представляет определение универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1163">To get a constructed generic type, call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type definition.</span></span>  
  
 <span data-ttu-id="15a0e-1164">Дополнительные сведения об универсальных типах в отражении и списке инвариантных условий для терминов, используемых в универсальном отражении, см. в описании свойства <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1164">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="override this.IsPointerImpl : unit -&gt; bool" Usage="typeBuilder.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="override this.IsPrimitiveImpl : unit -&gt; bool" Usage="typeBuilder.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1165">Получает значение, которое указывает, является ли текущий тип критическим с точки зрения безопасности или надежным с точки зрения безопасности и, следовательно, может ли он выполнять важные операции.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1165">Gets a value that indicates whether the current type is security-critical or security-safe-critical, and therefore can perform critical operations.</span></span></summary>
        <value><span data-ttu-id="15a0e-1166">Значение <see langword="true" />, если текущий тип является критическим с точки зрения безопасности или надежным с точки зрения безопасности; значение <see langword="false" />, если он является прозрачным.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1166"><see langword="true" /> if the current type is security-critical or security-safe-critical; <see langword="false" /> if it is transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1167">Свойства <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A> и <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> сообщают уровень прозрачности типа, как определено средой CLR.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1167">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="15a0e-1168">Сочетания этих свойств показаны в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1168">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="15a0e-1169">Уровень безопасности</span><span class="sxs-lookup"><span data-stu-id="15a0e-1169">Security level</span></span>|<span data-ttu-id="15a0e-1170">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="15a0e-1170">IsSecurityCritical</span></span>|<span data-ttu-id="15a0e-1171">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="15a0e-1171">IsSecuritySafeCritical</span></span>|<span data-ttu-id="15a0e-1172">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="15a0e-1172">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="15a0e-1173">Critical</span><span class="sxs-lookup"><span data-stu-id="15a0e-1173">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="15a0e-1174">Критический в плане безопасности</span><span class="sxs-lookup"><span data-stu-id="15a0e-1174">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="15a0e-1175">Прозрачный</span><span class="sxs-lookup"><span data-stu-id="15a0e-1175">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="15a0e-1176">Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1176">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="15a0e-1177">Среда выполнения начинает оценивать уровни прозрачности в сборке.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1177">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="15a0e-1178">Например, если динамическая сборка является критической для безопасности, аннотации для типов не учитываются, а все типы являются критически важными для безопасности.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1178">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="15a0e-1179">По умолчанию динамическая сборка наследует прозрачность сборки, которая ее создает.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1179">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="15a0e-1180">Это значение по умолчанию можно переопределить с помощью перегрузки метода <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> или <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, а также с указанием атрибутов безопасности.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1180">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="15a0e-1181">Вы не можете повысить уровень безопасности, сделав это. Это значит, что прозрачный код не может порождать критически важный для безопасности или безопасный код.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1181">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="15a0e-1182">Атрибуты должны быть указаны при создании динамической сборки или не вступают в силу до тех пор, пока сборка не будет сохранена на диск и не будет перезагружена.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1182">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-1183">Наследование по умолчанию ограничено оценкой прозрачности среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1183">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="15a0e-1184">К динамической сборке не применяются атрибуты.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1184">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="15a0e-1185">Если необходимо добавить атрибуты безопасности, необходимо применить их самостоятельно.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1185">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="15a0e-1186">Дополнительные сведения о порождении отражения и прозрачности см. [в разделе проблемы безопасности в порождении отражения](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="15a0e-1186">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="15a0e-1187">Сведения о прозрачности см. в разделе [изменения безопасности](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="15a0e-1187">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-1188">Текущий динамический тип не был создан путем вызова метода <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1188">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span></span></exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="15a0e-1189">Вопросы безопасности в порождаемом отражении</span><span class="sxs-lookup"><span data-stu-id="15a0e-1189">Security Issues in Reflection Emit</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="15a0e-1190">Соображения о безопасности для отражения</span><span class="sxs-lookup"><span data-stu-id="15a0e-1190">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="15a0e-1191">Изменения системы безопасности в платформе .NET Framework версии 4.0</span><span class="sxs-lookup"><span data-stu-id="15a0e-1191">Security Changes in the .NET Framework Version 4.0</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf"><span data-ttu-id="15a0e-1192">Прозрачный для системы безопасности код, уровень 1</span><span class="sxs-lookup"><span data-stu-id="15a0e-1192">Security-Transparent Code, Level 1</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0"><span data-ttu-id="15a0e-1193">Прозрачный с точки зрения безопасности код, уровень 2</span><span class="sxs-lookup"><span data-stu-id="15a0e-1193">Security-Transparent Code, Level 2</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1194">Получает значение, которое указывает, является ли текущий тип надежным с точки зрения безопасности и, следовательно, может ли он выполнять критически важные операции и предоставлять доступ прозрачному коду.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1194">Gets a value that indicates whether the current type is security-safe-critical; that is, whether it can perform critical operations and can be accessed by transparent code.</span></span></summary>
        <value><span data-ttu-id="15a0e-1195">Значение <see langword="true" />, если текущий тип является надежным с точки зрения безопасности; значение <see langword="false" />, если он является критическим с точки зрения безопасности или прозрачным.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1195"><see langword="true" /> if the current type is security-safe-critical; <see langword="false" /> if it is security-critical or transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1196">Свойства <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A> и <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> сообщают уровень прозрачности типа, как определено средой CLR.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1196">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="15a0e-1197">Сочетания этих свойств показаны в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1197">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="15a0e-1198">Уровень безопасности</span><span class="sxs-lookup"><span data-stu-id="15a0e-1198">Security level</span></span>|<span data-ttu-id="15a0e-1199">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="15a0e-1199">IsSecurityCritical</span></span>|<span data-ttu-id="15a0e-1200">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="15a0e-1200">IsSecuritySafeCritical</span></span>|<span data-ttu-id="15a0e-1201">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="15a0e-1201">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="15a0e-1202">Critical</span><span class="sxs-lookup"><span data-stu-id="15a0e-1202">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="15a0e-1203">Критический в плане безопасности</span><span class="sxs-lookup"><span data-stu-id="15a0e-1203">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="15a0e-1204">Прозрачный</span><span class="sxs-lookup"><span data-stu-id="15a0e-1204">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="15a0e-1205">Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1205">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="15a0e-1206">Среда выполнения начинает оценивать уровни прозрачности в сборке.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1206">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="15a0e-1207">Например, если динамическая сборка является критической для безопасности, аннотации для типов не учитываются, а все типы являются критически важными для безопасности.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1207">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="15a0e-1208">По умолчанию динамическая сборка наследует прозрачность сборки, которая ее создает.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1208">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="15a0e-1209">Это значение по умолчанию можно переопределить с помощью перегрузки метода <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> или <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, а также с указанием атрибутов безопасности.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1209">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="15a0e-1210">Вы не можете повысить уровень безопасности, сделав это. Это значит, что прозрачный код не может порождать критически важный для безопасности или безопасный код.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1210">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="15a0e-1211">Атрибуты должны быть указаны при создании динамической сборки или не вступают в силу до тех пор, пока сборка не будет сохранена на диск и не будет перезагружена.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1211">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-1212">Наследование по умолчанию ограничено оценкой прозрачности среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1212">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="15a0e-1213">К динамической сборке не применяются атрибуты.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1213">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="15a0e-1214">Если необходимо добавить атрибуты безопасности, необходимо применить их самостоятельно.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1214">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="15a0e-1215">Дополнительные сведения о порождении отражения и прозрачности см. [в разделе проблемы безопасности в порождении отражения](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="15a0e-1215">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="15a0e-1216">Сведения о прозрачности см. в разделе [изменения безопасности](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="15a0e-1216">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-1217">Текущий динамический тип не был создан путем вызова метода <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1217">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span></span></exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="15a0e-1218">Вопросы безопасности в порождаемом отражении</span><span class="sxs-lookup"><span data-stu-id="15a0e-1218">Security Issues in Reflection Emit</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="15a0e-1219">Соображения о безопасности для отражения</span><span class="sxs-lookup"><span data-stu-id="15a0e-1219">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="15a0e-1220">Изменения системы безопасности в платформе .NET Framework версии 4.0</span><span class="sxs-lookup"><span data-stu-id="15a0e-1220">Security Changes in the .NET Framework Version 4.0</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf"><span data-ttu-id="15a0e-1221">Прозрачный для системы безопасности код, уровень 1</span><span class="sxs-lookup"><span data-stu-id="15a0e-1221">Security-Transparent Code, Level 1</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0"><span data-ttu-id="15a0e-1222">Прозрачный с точки зрения безопасности код, уровень 2</span><span class="sxs-lookup"><span data-stu-id="15a0e-1222">Security-Transparent Code, Level 2</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1223">Получает значение, которое указывает, является ли текущий тип прозрачным и, следовательно, не может выполнять критические операции.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1223">Gets a value that indicates whether the current type is transparent, and therefore cannot perform critical operations.</span></span></summary>
        <value><span data-ttu-id="15a0e-1224">Значение <see langword="true" />, если тип является прозрачным; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1224"><see langword="true" /> if the type is security-transparent; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1225">Свойства <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A> и <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> сообщают уровень прозрачности типа, как определено средой CLR.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1225">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="15a0e-1226">Сочетания этих свойств показаны в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1226">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="15a0e-1227">Уровень безопасности</span><span class="sxs-lookup"><span data-stu-id="15a0e-1227">Security level</span></span>|<span data-ttu-id="15a0e-1228">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="15a0e-1228">IsSecurityCritical</span></span>|<span data-ttu-id="15a0e-1229">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="15a0e-1229">IsSecuritySafeCritical</span></span>|<span data-ttu-id="15a0e-1230">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="15a0e-1230">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="15a0e-1231">Critical</span><span class="sxs-lookup"><span data-stu-id="15a0e-1231">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="15a0e-1232">Критический в плане безопасности</span><span class="sxs-lookup"><span data-stu-id="15a0e-1232">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="15a0e-1233">Прозрачный</span><span class="sxs-lookup"><span data-stu-id="15a0e-1233">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="15a0e-1234">Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1234">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="15a0e-1235">Среда выполнения начинает оценивать уровни прозрачности в сборке.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1235">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="15a0e-1236">Например, если динамическая сборка является критической для безопасности, аннотации для типов не учитываются, а все типы являются критически важными для безопасности.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1236">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="15a0e-1237">По умолчанию динамическая сборка наследует прозрачность сборки, которая ее создает.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1237">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="15a0e-1238">Это значение по умолчанию можно переопределить с помощью перегрузки метода <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> или <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, а также с указанием атрибутов безопасности.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1238">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="15a0e-1239">Вы не можете повысить уровень безопасности, сделав это. Это значит, что прозрачный код не может порождать критически важный для безопасности или безопасный код.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1239">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="15a0e-1240">Атрибуты должны быть указаны при создании динамической сборки или не вступают в силу до тех пор, пока сборка не будет сохранена на диск и не будет перезагружена.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1240">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-1241">Наследование по умолчанию ограничено оценкой прозрачности среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1241">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="15a0e-1242">К динамической сборке не применяются атрибуты.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1242">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="15a0e-1243">Если необходимо добавить атрибуты безопасности, необходимо применить их самостоятельно.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1243">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="15a0e-1244">Дополнительные сведения о порождении отражения и прозрачности см. [в разделе проблемы безопасности в порождении отражения](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="15a0e-1244">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="15a0e-1245">Сведения о прозрачности см. в разделе [изменения безопасности](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="15a0e-1245">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-1246">Текущий динамический тип не был создан путем вызова метода <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1246">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span></span></exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="15a0e-1247">Вопросы безопасности в порождаемом отражении</span><span class="sxs-lookup"><span data-stu-id="15a0e-1247">Security Issues in Reflection Emit</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="15a0e-1248">Соображения о безопасности для отражения</span><span class="sxs-lookup"><span data-stu-id="15a0e-1248">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="15a0e-1249">Изменения системы безопасности в платформе .NET Framework версии 4.0</span><span class="sxs-lookup"><span data-stu-id="15a0e-1249">Security Changes in the .NET Framework Version 4.0</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf"><span data-ttu-id="15a0e-1250">Прозрачный для системы безопасности код, уровень 1</span><span class="sxs-lookup"><span data-stu-id="15a0e-1250">Security-Transparent Code, Level 1</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0"><span data-ttu-id="15a0e-1251">Прозрачный с точки зрения безопасности код, уровень 2</span><span class="sxs-lookup"><span data-stu-id="15a0e-1251">Security-Transparent Code, Level 2</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public override bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public override bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="override this.IsSubclassOf : Type -&gt; bool" Usage="typeBuilder.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="15a0e-1252">Проверяемый тип <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1252">A <see cref="T:System.Type" /> that is to be checked.</span></span></param>
        <summary><span data-ttu-id="15a0e-1253">Определяет, является ли этот тип производным от указанного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1253">Determines whether this type is derived from a specified type.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1254">Только для чтения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1254">Read-only.</span></span> <span data-ttu-id="15a0e-1255">Возвращает значение <see langword="true" />, если тип совпадает с типом <paramref name="c" /> или является подтипом типа <paramref name="c" />; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1255">Returns <see langword="true" /> if this type is the same as the type <paramref name="c" />, or is a subtype of type <paramref name="c" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="override this.IsValueTypeImpl : unit -&gt; bool" Usage="typeBuilder.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="15a0e-1256">Возвращает объект <see cref="T:System.Type" />, который представляет массив текущего типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1256">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="override this.MakeArrayType : unit -&gt; Type" Usage="typeBuilder.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="15a0e-1257">Возвращает объект <see cref="T:System.Type" />, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1257">Returns a <see cref="T:System.Type" /> object that represents a one-dimensional array of the current type, with a lower bound of zero.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1258">Объект <see cref="T:System.Type" />, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1258">A <see cref="T:System.Type" /> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1259">Метод <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> предоставляет способ создания типа массива с любым возможным типом элементов, включая универсальные типы.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1259">The <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method provides a way to generate an array type with any possible element type, including generic types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-1260">В следующем примере кода создается динамический модуль, абстрактный тип с именем `Sample` и абстрактный метод с именем `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1260">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="15a0e-1261">`TestMethod` принимает параметр `ref` (`ByRef` в Visual Basic) типа `Sample`, указатель на тип `Sample` и массив типа `Sample`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1261">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="15a0e-1262">Он возвращает двумерный массив типа `Sample`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1262">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="15a0e-1263">В примере кода динамический модуль сохраняется на диск, поэтому его можно проверить с помощью программы [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="15a0e-1263">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="override this.MakeArrayType : int -&gt; Type" Usage="typeBuilder.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rank"><span data-ttu-id="15a0e-1264">Размерность массива.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1264">The number of dimensions for the array.</span></span></param>
        <summary><span data-ttu-id="15a0e-1265">Возвращает объект <see cref="T:System.Type" />, представляющий массив текущего типа указанной размерности.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1265">Returns a <see cref="T:System.Type" /> object that represents an array of the current type, with the specified number of dimensions.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1266">Объект <see cref="T:System.Type" />, который представляет одномерный массив текущего типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1266">A <see cref="T:System.Type" /> object that represents a one-dimensional array of the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1267">Метод <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> предоставляет способ создания типа массива с любым возможным типом элементов, включая универсальные типы.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1267">The <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method provides a way to generate an array type with any possible element type, including generic types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-1268">В следующем примере кода создается динамический модуль, абстрактный тип с именем `Sample` и абстрактный метод с именем `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1268">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="15a0e-1269">`TestMethod` принимает параметр `ref` (`ByRef` в Visual Basic) типа `Sample`, указатель на тип `Sample` и массив типа `Sample`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1269">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="15a0e-1270">Он возвращает двумерный массив типа `Sample`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1270">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="15a0e-1271">В примере кода динамический модуль сохраняется на диск, поэтому его можно проверить с помощью программы [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="15a0e-1271">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="15a0e-1272"><paramref name="rank" /> не является допустимой размерностью массива.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1272"><paramref name="rank" /> is not a valid array dimension.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public override Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="override this.MakeByRefType : unit -&gt; Type" Usage="typeBuilder.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="15a0e-1273">Возвращает объект <see cref="T:System.Type" />, который представляет текущий тип при передаче в качестве параметра <see langword="ref" /> (параметра <see langword="ByRef" /> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="15a0e-1273">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic).</span></span></summary>
        <returns><span data-ttu-id="15a0e-1274">Объект <see cref="T:System.Type" />, который представляет текущий тип при передаче в качестве параметра <see langword="ref" /> (параметра <see langword="ByRef" /> в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="15a0e-1274">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1275">Метод <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> предоставляет способ создания `ref` типов (`ByRef` в Visual Basic) для списков параметров.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1275">The <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-1276">При использовании синтаксиса языка MSIL, если текущий <xref:System.Reflection.Emit.TypeBuilder> представляет `MyType`, тип, возвращаемый этим методом, будет `MyType&`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1276">Using Microsoft intermediate language (MSIL) syntax, if the current <xref:System.Reflection.Emit.TypeBuilder> represents `MyType`, then the type returned by this method would be `MyType&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-1277">В следующем примере кода создается динамический модуль, абстрактный тип с именем `Sample` и абстрактный метод с именем `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1277">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="15a0e-1278">`TestMethod` принимает параметр `ref` (`ByRef` в Visual Basic) типа `Sample`, указатель на тип `Sample` и массив типа `Sample`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1278">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="15a0e-1279">Он возвращает двумерный массив типа `Sample`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1279">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="15a0e-1280">В примере кода динамический модуль сохраняется на диск, поэтому его можно проверить с помощью программы [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="15a0e-1280">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public override Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="override this.MakeGenericType : Type[] -&gt; Type" Usage="typeBuilder.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-1.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments"><span data-ttu-id="15a0e-1281">Массив типов, который должен быть замещен параметрами типа определения текущего универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1281">An array of types to be substituted for the type parameters of the current generic type definition.</span></span></param>
        <summary><span data-ttu-id="15a0e-1282">Замещает элементы массива типов для параметров типа определения текущего универсального типа и возвращает результирующий сконструированный тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1282">Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns the resulting constructed type.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1283"><see cref="T:System.Type" /> представляет сконструированный тип, сформированный путем замещения элементов объекта <paramref name="typeArguments" /> параметрами текущего универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1283">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1284">Используйте этот метод, если для созданного кода требуется тип, созданный из текущего определения универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1284">Use this method when your emitted code requires a type constructed from the current generic type definition.</span></span> <span data-ttu-id="15a0e-1285">Не нужно вызывать метод <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> перед вызовом метода <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> в <xref:System.Reflection.Emit.TypeBuilder>, который представляет определение универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1285">It is not necessary to call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method before calling the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type definition.</span></span> <span data-ttu-id="15a0e-1286">Если текущий <xref:System.Reflection.Emit.TypeBuilder> не представляет определение универсального типа, выдается <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1286">If the current <xref:System.Reflection.Emit.TypeBuilder> does not represent the definition of a generic type, an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 <span data-ttu-id="15a0e-1287">Объект, возвращаемый этим методом, выступает в качестве заполнителя для сконструированного универсального типа в созданном коде.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1287">The object returned by this method functions as a placeholder for a constructed generic type in your emitted code.</span></span> <span data-ttu-id="15a0e-1288">Это экземпляр класса, производного от <xref:System.Type> с ограниченными возможностями.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1288">It is an instance of a class derived from <xref:System.Type> that has limited capabilities.</span></span> <span data-ttu-id="15a0e-1289">В частности:</span><span class="sxs-lookup"><span data-stu-id="15a0e-1289">In particular:</span></span>  
  
-   <span data-ttu-id="15a0e-1290">Чтобы получить методы, поля и конструкторы для этих сконструированных универсальных типов, используйте перегрузки методов <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29> и <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1290">To get methods, fields, and constructors for these constructed generic types, use the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, and <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> method overloads.</span></span>  
  
-   <span data-ttu-id="15a0e-1291">Два экземпляра, представляющие один и тот же сконструированный тип, не считаются равными.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1291">Two instances that represent the same constructed type do not compare as equal.</span></span> <span data-ttu-id="15a0e-1292">Например, в следующем коде `t1.Equals(t2)` возвращает `false`:</span><span class="sxs-lookup"><span data-stu-id="15a0e-1292">For example, in the following code `t1.Equals(t2)` returns `false`:</span></span>  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/vb/remarks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-1293">Текущий тип не представляет определение универсального типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1293">The current type does not represent the definition of a generic type.</span></span> <span data-ttu-id="15a0e-1294">То есть <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> возвращает <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1294">That is, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-1295"><paramref name="typeArguments" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1295"><paramref name="typeArguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="15a0e-1296">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-1296">-or-</span></span> 
<span data-ttu-id="15a0e-1297">Любой элемент <paramref name="typeArguments" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1297">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-1298">Свойство <see cref="P:System.Type.Module" /> любого элемента <paramref name="typeArguments" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1298">The <see cref="P:System.Type.Module" /> property of any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="15a0e-1299">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-1299">-or-</span></span> 
<span data-ttu-id="15a0e-1300">Свойство <see cref="P:System.Reflection.Module.Assembly" /> модуля любого элемента <paramref name="typeArguments" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1300">The <see cref="P:System.Reflection.Module.Assembly" /> property of the module of any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public override Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="override this.MakePointerType : unit -&gt; Type" Usage="typeBuilder.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="15a0e-1301">Возвращает объект <see cref="T:System.Type" />, который представляет тип неуправляемого указателя на текущий тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1301">Returns a <see cref="T:System.Type" /> object that represents the type of an unmanaged pointer to the current type.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1302">Объект <see cref="T:System.Type" />, который представляет тип неуправляемого указателя на текущий тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1302">A <see cref="T:System.Type" /> object that represents the type of an unmanaged pointer to the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1303">Метод <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> предоставляет способ создания типов указателей для списков параметров.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1303">The <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-1304">При использовании синтаксиса языка MSIL, если текущий <xref:System.Reflection.Emit.TypeBuilder> представляет `MyType`, тип, возвращаемый этим методом, будет `MyType*`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1304">Using Microsoft intermediate language (MSIL) syntax, if the current <xref:System.Reflection.Emit.TypeBuilder> represents `MyType`, then the type returned by this method would be `MyType*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="15a0e-1305">В следующем примере кода создается динамический модуль, абстрактный тип с именем `Sample` и абстрактный метод с именем `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1305">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="15a0e-1306">`TestMethod` принимает параметр `ref` (`ByRef` в Visual Basic) типа `Sample`, указатель на тип `Sample` и массив типа `Sample`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1306">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="15a0e-1307">Он возвращает двумерный массив типа `Sample`.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1307">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="15a0e-1308">В примере кода динамический модуль сохраняется на диск, поэтому его можно проверить с помощью программы [Ildasm. exe](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="15a0e-1308">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.TypeBuilder.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1309">Извлекает динамический модуль, который содержит определение данного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1309">Retrieves the dynamic module that contains this type definition.</span></span></summary>
        <value><span data-ttu-id="15a0e-1310">Только для чтения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1310">Read-only.</span></span> <span data-ttu-id="15a0e-1311">Извлекает динамический модуль, который содержит определение данного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1311">Retrieves the dynamic module that contains this type definition.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.TypeBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1312">Извлекает имя данного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1312">Retrieves the name of this type.</span></span></summary>
        <value><span data-ttu-id="15a0e-1313">Только для чтения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1313">Read-only.</span></span> <span data-ttu-id="15a0e-1314">Извлекает имя <see cref="T:System.String" /> данного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1314">Retrieves the <see cref="T:System.String" /> name of this type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1315">Получает пространство имен, в котором определен этот объект <see langword="TypeBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1315">Retrieves the namespace where this <see langword="TypeBuilder" /> is defined.</span></span></summary>
        <value><span data-ttu-id="15a0e-1316">Только для чтения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1316">Read-only.</span></span> <span data-ttu-id="15a0e-1317">Получает пространство имен, в котором определен этот объект <see langword="TypeBuilder" /> .</span><span class="sxs-lookup"><span data-stu-id="15a0e-1317">Retrieves the namespace where this <see langword="TypeBuilder" /> is defined.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PackingSize">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PackingSize PackingSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.PackingSize PackingSize" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackingSize As PackingSize" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::PackingSize PackingSize { System::Reflection::Emit::PackingSize get(); };" />
      <MemberSignature Language="F#" Value="member this.PackingSize : System.Reflection.Emit.PackingSize" Usage="System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PackingSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1318">Получает размер упаковки данного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1318">Retrieves the packing size of this type.</span></span></summary>
        <value><span data-ttu-id="15a0e-1319">Только для чтения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1319">Read-only.</span></span> <span data-ttu-id="15a0e-1320">Получает размер упаковки данного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1320">Retrieves the packing size of this type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1321">Возвращает тип, который был использован для получения этого типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1321">Returns the type that was used to obtain this type.</span></span></summary>
        <value><span data-ttu-id="15a0e-1322">Только для чтения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1322">Read-only.</span></span> <span data-ttu-id="15a0e-1323">Тип, который был использован для получения этого типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1323">The type that was used to obtain this type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="15a0e-1324">Задает пользовательский атрибут.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1324">Sets a custom attribute.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.Emit.CustomAttributeBuilder -&gt; unit" Usage="typeBuilder.SetCustomAttribute customBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder"><span data-ttu-id="15a0e-1325">Экземпляр вспомогательного класса для определения настраиваемого атрибута.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1325">An instance of a helper class to define the custom attribute.</span></span></param>
        <summary><span data-ttu-id="15a0e-1326">Задает настраиваемый атрибут с помощью построителя настраиваемых атрибутов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1326">Set a custom attribute using a custom attribute builder.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-1327">Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот член больше не требует <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1327">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="15a0e-1328">(См. раздел [вопросы безопасности в порождении отражения](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1328">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-1329">Свойство <paramref name="customBuilder" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1329"><paramref name="customBuilder" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-1330">Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1330">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.ConstructorInfo * byte[] -&gt; unit" Usage="typeBuilder.SetCustomAttribute (con, binaryAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con"><span data-ttu-id="15a0e-1331">Конструктор настраиваемого атрибута.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1331">The constructor for the custom attribute.</span></span></param>
        <param name="binaryAttribute"><span data-ttu-id="15a0e-1332">Большой двоичный объект байтов, предоставляющий атрибуты.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1332">A byte blob representing the attributes.</span></span></param>
        <summary><span data-ttu-id="15a0e-1333">Задает настраиваемый атрибут с помощью большого двоичного объекта пользовательских атрибутов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1333">Sets a custom attribute using a specified custom attribute blob.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1334">Дополнительные сведения о форматировании `binaryAttribute` см. в документации по Common Language Infrastructure (CLI), особенно в разделе "Partition II: Определение и семантика метаданных ".</span><span class="sxs-lookup"><span data-stu-id="15a0e-1334">For more information on how to format `binaryAttribute`, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="15a0e-1335">Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1335">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="15a0e-1336">Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот член больше не требует <xref:System.Security.Permissions.ReflectionPermission> с флагом <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1336">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="15a0e-1337">(См. раздел [вопросы безопасности в порождении отражения](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1337">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="15a0e-1338">Параметр <paramref name="con" /> или <paramref name="binaryAttribute" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1338"><paramref name="con" /> or <paramref name="binaryAttribute" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-1339">Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1339">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetParent">
      <MemberSignature Language="C#" Value="public void SetParent (Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParent(class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParent (parent As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParent(Type ^ parent);" />
      <MemberSignature Language="F#" Value="member this.SetParent : Type -&gt; unit" Usage="typeBuilder.SetParent parent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parent"><span data-ttu-id="15a0e-1340">Новый базовый тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1340">The new base type.</span></span></param>
        <summary><span data-ttu-id="15a0e-1341">Задает базовый тип конструируемого в настоящий момент типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1341">Sets the base type of the type currently under construction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1342">Если `parent` равно `null`, в качестве базового типа используется <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1342">If `parent` is `null`, <xref:System.Object> is used as the base type.</span></span>  
  
 <span data-ttu-id="15a0e-1343">В .NET Framework версиях 1,0 и 1,1 исключение не создается, если `parent` является типом интерфейса, но при вызове метода <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> возникает исключение <xref:System.TypeLoadException>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1343">In the .NET Framework versions 1.0 and 1.1, no exception is thrown if `parent` is an interface type, but a <xref:System.TypeLoadException> is thrown when the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span>  
  
 <span data-ttu-id="15a0e-1344">Метод <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> не проверяет наличие большинства недопустимых родительских типов.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1344">The <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> method does not check for most invalid parent types.</span></span> <span data-ttu-id="15a0e-1345">Например, он не отклоняет родительский тип, у которого нет конструктора без параметров, если текущий тип содержит конструктор без параметров, он не отклоняет Запечатанные типы и не отклоняет тип <xref:System.Delegate>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1345">For example, it does not reject a parent type that has no parameterless constructor when the current type has a parameterless constructor, it does not reject sealed types, and it does not reject the <xref:System.Delegate> type.</span></span> <span data-ttu-id="15a0e-1346">Во всех этих случаях исключения вызываются методом <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1346">In all these cases, exceptions are thrown by the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-1347">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1347">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="15a0e-1348">-или-</span><span class="sxs-lookup"><span data-stu-id="15a0e-1348">-or-</span></span> 
 <span data-ttu-id="15a0e-1349"><paramref name="parent" /> имеет значение <see langword="null" />, и текущий экземпляр представляет интерфейс, атрибуты которого не включают <see cref="F:System.Reflection.TypeAttributes.Abstract" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1349"><paramref name="parent" /> is <see langword="null" />, and the current instance represents an interface whose attributes do not include <see cref="F:System.Reflection.TypeAttributes.Abstract" />.</span></span>  
  
<span data-ttu-id="15a0e-1350">- или -</span><span class="sxs-lookup"><span data-stu-id="15a0e-1350">-or-</span></span> 
<span data-ttu-id="15a0e-1351">Для текущего динамического типа свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> имеет значение <see langword="true" />, но свойство <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> имеет значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1351">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="15a0e-1352"><paramref name="parent" /> является интерфейсом.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1352"><paramref name="parent" /> is an interface.</span></span> <span data-ttu-id="15a0e-1353">Это условие исключения было впервые представлено в .NET Framework 2.0.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1353">This exception condition is new in the .NET Framework version 2.0.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Size { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Size : int" Usage="System.Reflection.Emit.TypeBuilder.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1354">Получает общий размер типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1354">Retrieves the total size of a type.</span></span></summary>
        <value><span data-ttu-id="15a0e-1355">Только для чтения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1355">Read-only.</span></span> <span data-ttu-id="15a0e-1356">Получает общий размер этого типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1356">Retrieves this type's total size.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _TypeBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_TypeBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="15a0e-1357">Зарезервировано для будущего использования.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1357">Reserved for future use.</span></span> <span data-ttu-id="15a0e-1358">Должно быть равным IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1358">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="15a0e-1359">Переданный массив имен, которые необходимо сопоставить.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1359">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="15a0e-1360">Количество сопоставляемых имен.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1360">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="15a0e-1361">Контекст языкового стандарта для интерпретации имен.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1361">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="15a0e-1362">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1362">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="15a0e-1363">Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1363">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1364">Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1364">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="15a0e-1365">Дополнительные сведения о `IDispatch::GetIDsOfNames` см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1365">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="15a0e-1366">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1366">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _TypeBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="15a0e-1367">Возвращаемые сведения о типе.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1367">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="15a0e-1368">Идентификатор языкового стандарта для сведений о типе.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1368">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="15a0e-1369">Получает указатель на объект с запрошенными сведениями о типе.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1369">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="15a0e-1370">Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1370">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1371">Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1371">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="15a0e-1372">Дополнительные сведения о `IDispatch::GetTypeInfo` см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1372">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="15a0e-1373">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1373">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _TypeBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="15a0e-1374">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1374">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="15a0e-1375">Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</span><span class="sxs-lookup"><span data-stu-id="15a0e-1375">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1376">Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1376">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="15a0e-1377">Дополнительные сведения о `IDispatch::GetTypeInfoCount` см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1377">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="15a0e-1378">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1378">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _TypeBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _TypeBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_TypeBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="15a0e-1379">Идентифицирует член.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1379">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="15a0e-1380">Зарезервировано для будущего использования.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1380">Reserved for future use.</span></span> <span data-ttu-id="15a0e-1381">Должно быть равным IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1381">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="15a0e-1382">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1382">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="15a0e-1383">Флаги, описывающие контекст вызова.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1383">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="15a0e-1384">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1384">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="15a0e-1385">Указатель, по которому будет сохранен результат.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1385">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="15a0e-1386">Указатель на структуру, содержащую сведения об исключении.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1386">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="15a0e-1387">Индекс первого аргумента, вызвавшего ошибку.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1387">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="15a0e-1388">Предоставляет доступ к открытым свойствам и методам объекта.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1388">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1389">Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1389">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="15a0e-1390">Дополнительные сведения о `IDispatch::Invoke` см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1390">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="15a0e-1391">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1391">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="typeBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="15a0e-1392">Возвращает имя типа, исключая пространство имен.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1392">Returns the name of the type excluding the namespace.</span></span></summary>
        <returns><span data-ttu-id="15a0e-1393">Только для чтения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1393">Read-only.</span></span> <span data-ttu-id="15a0e-1394">Имя типа, исключая пространство имен.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1394">The name of the type excluding the namespace.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1395">Не поддерживается в динамических модулях.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1395">Not supported in dynamic modules.</span></span></summary>
        <value><span data-ttu-id="15a0e-1396">Только для чтения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1396">Read-only.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="15a0e-1397">Получите тип с помощью <xref:System.Type.GetType%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> и используйте отражение для полученного типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1397">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="15a0e-1398">Не поддерживается в динамических модулях.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1398">Not supported in dynamic modules.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken TypeToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.TypeToken TypeToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeToken As TypeToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::TypeToken TypeToken { System::Reflection::Emit::TypeToken get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeToken : System.Reflection.Emit.TypeToken" Usage="System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1399">Возвращает токен типа этого типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1399">Returns the type token of this type.</span></span></summary>
        <value><span data-ttu-id="15a0e-1400">Только для чтения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1400">Read-only.</span></span> <span data-ttu-id="15a0e-1401">Возвращает <see langword="TypeToken" /> этого типа.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1401">Returns the <see langword="TypeToken" /> of this type.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-1402">Этот тип был создан ранее с помощью <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1402">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1403">Возвращает базовый системный тип для данного <see langword="TypeBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1403">Returns the underlying system type for this <see langword="TypeBuilder" />.</span></span></summary>
        <value><span data-ttu-id="15a0e-1404">Только для чтения.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1404">Read-only.</span></span> <span data-ttu-id="15a0e-1405">Возвращает базовый системный тип.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1405">Returns the underlying system type.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="15a0e-1406">Этот тип является перечислением, но базовый системный тип отсутствует.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1406">This type is an enumeration, but there is no underlying system type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UnspecifiedTypeSize">
      <MemberSignature Language="C#" Value="public const int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 UnspecifiedTypeSize = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberSignature Language="VB.NET" Value="Public Const UnspecifiedTypeSize As Integer  = 0" />
      <MemberSignature Language="C++ CLI" Value="public: int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="F#" Value="val mutable UnspecifiedTypeSize : int" Usage="System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary><span data-ttu-id="15a0e-1407">Представляет, что общий размер для типа не указан.</span><span class="sxs-lookup"><span data-stu-id="15a0e-1407">Represents that total size for the type is not specified.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
