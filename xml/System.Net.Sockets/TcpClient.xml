<Type Name="TcpClient" FullName="System.Net.Sockets.TcpClient">
  <Metadata><Meta Name="ms.openlocfilehash" Value="507ad13c76bbf9c07a0fa6e73867b400985575aa" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68399306" /></Metadata><TypeSignature Language="C#" Value="public class TcpClient : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TcpClient extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.TcpClient" />
  <TypeSignature Language="VB.NET" Value="Public Class TcpClient&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class TcpClient : IDisposable" />
  <TypeSignature Language="F#" Value="type TcpClient = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Предоставляет клиентские подключения для сетевых служб протокола TCP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TcpClient` Класс предоставляет простые методы для подключения, отправки и получения потоковых данных по сети в синхронном блокирующем режиме.  
  
 Для подключения и обмена данными <xref:System.Net.Sockets.TcpListener> , или <xref:System.Net.Sockets.Socket> , созданный с помощью протокола TCP <xref:System.Net.Sockets.ProtocolType> , необходимо прослушивать входящие запросы на подключение. `TcpClient` Подключиться к этому прослушивателю можно одним из следующих двух способов:  
  
-   Создайте и вызовите один из трех доступных <xref:System.Net.Sockets.TcpClient.Connect%2A> методов. `TcpClient`  
  
-   `TcpClient` Создайте с помощью имени узла и номера порта удаленного узла. Этот конструктор будет автоматически пытаться установить соединение.  
  
> [!NOTE]
>  Если вы хотите отправить датаграммы без соединений в режиме синхронной блокировки, используйте <xref:System.Net.Sockets.UdpClient> класс.  
  
   
  
## Examples  
 В следующем примере кода устанавливается `TcpClient` соединение.  
  
 [!code-cpp[System.Net.Sockets.TcpClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/CPP/tcpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/CS/tcpclient.cs#1)]
 [!code-vb[System.Net.Sockets.TcpClient#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/VB/tcpclient.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Разрешение на установку исходящего подключения или принятие входящего запроса.</permission>
    <block subset="none" type="overrides"><para>Для отправки и получения данных используйте <see cref="M:System.Net.Sockets.TcpClient.GetStream" /> метод для <see cref="T:System.Net.Sockets.NetworkStream" />получения. Вызовите методы <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> <see cref="T:System.Net.Sockets.NetworkStream" /> и объекта, чтобы отправлять и получать данные с удаленного узла. <see cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" /> Используйте метод, чтобы освободить все ресурсы, <see cref="T:System.Net.Sockets.TcpClient" />связанные с. <see cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" /></para></block>
    <altmember cref="T:System.Net.Sockets.TcpListener" />
    <altmember cref="T:System.Net.Sockets.NetworkStream" />
    <altmember cref="T:System.Net.Sockets.Socket" />
    <altmember cref="T:System.Net.Sockets.ProtocolType" />
    <altmember cref="T:System.Net.IPEndPoint" />
    <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
    <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
    <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
    <related type="Article" href="~/docs/framework/network-programming/tcp-udp.md">TCP-UDP</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает новый <xref:System.Net.Sockets.TcpClient> и позволяет базовому поставщику служб назначить наиболее подходящий локальный IP-адрес и номер порта. Сначала необходимо вызвать <xref:System.Net.Sockets.TcpClient.Connect%2A> метод перед отправкой и получением данных.  
  
> [!NOTE]
>  Этот конструктор работает только с типами адресов IPv4.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать конструктор без параметров для создания нового <xref:System.Net.Sockets.TcpClient>.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient(System::Net::IPEndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpClient : System.Net.IPEndPoint -&gt; System.Net.Sockets.TcpClient" Usage="new System.Net.Sockets.TcpClient localEP" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="localEP">Объект <see cref="T:System.Net.IPEndPoint" />, с которым связан объект <see cref="T:System.Net.Sockets.Socket" />, работающий по протоколу TCP.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.TcpClient" /> и связывает его с заданной локальной конечной точкой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает новый <xref:System.Net.Sockets.TcpClient> объект и привязывает его к элементу, <xref:System.Net.IPEndPoint> заданному `localEP` параметром. Перед вызовом этого конструктора необходимо создать объект `IPEndPoint` с использованием IP-адреса и номера порта, из которого предполагается отправлять и получать данные. Перед подключением и связью не нужно указывать локальный IP-адрес и номер порта. При создании `TcpClient` с помощью любого другого конструктора базовый поставщик услуг присвоит наиболее подходящий локальный IP-адрес и номер порта.  
  
 Перед отправкой <xref:System.Net.Sockets.TcpClient.Connect%2A> и получением данных необходимо вызвать метод.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как создать экземпляр <xref:System.Net.Sockets.TcpClient> класса с помощью локальной конечной точки.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="localEP" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.Net.Sockets.AddressFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (family As AddressFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient(System::Net::Sockets::AddressFamily family);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpClient : System.Net.Sockets.AddressFamily -&gt; System.Net.Sockets.TcpClient" Usage="new System.Net.Sockets.TcpClient family" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="family">Параметр <see cref="P:System.Net.IPAddress.AddressFamily" /> протокола IP.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.TcpClient" /> с заданным семейством.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как создать экземпляр <xref:System.Net.Sockets.TcpClient> класса.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#15)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#15)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значением параметра <paramref name="family" /> не является AddressFamily.InterNetwork 
- или - 
Значением параметра <paramref name="family" /> не является AddressFamily.InterNetworkV6</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpClient : string * int -&gt; System.Net.Sockets.TcpClient" Usage="new System.Net.Sockets.TcpClient (hostname, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="hostname">DNS-имя удаленного узла, к которому планируется подключение.</param>
        <param name="port">Имя порта удаленного узла, к которому планируется подключение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.TcpClient" /> и подключает его к указанному порту заданного узла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор создает новый <xref:System.Net.Sockets.TcpClient> и выполняет синхронную попытку подключения к предоставленному имени узла и номеру порта. Базовый поставщик услуг присвоит наиболее подходящий локальный IP-адрес и номер порта. `TcpClient`блокируется до тех пор, пока не будет установлено соединение или сбой. Этот конструктор позволяет инициализировать, разрешать имя узла DNS и подключаться в одном удобном шаге.  
  
 Если включена поддержка протокола IPv6 и <xref:System.Net.Sockets.TcpClient.%23ctor%28System.String%2CSystem.Int32%29> вызывается метод для подключения к узлу, который разрешается как в IPv6, так и в IPv4-адресах, будет предпринята попытка подключения к IPv6-адресу до адреса IPv4. Это может привести к задержке времени для установления соединения, если узел не прослушивает IPv6-адрес.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода можно обратиться к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как создать экземпляр <xref:System.Net.Sockets.TcpClient> класса, используя имя узла и номер порта.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="hostname" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="port" /> не находится между <see cref="F:System.Net.IPEndPoint.MinPort" /> и <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при обращении к сокету.</exception>
        <altmember cref="Overload:System.Net.Sockets.TcpClient.#ctor" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Active" />
      <MemberSignature Language="VB.NET" Value="Protected Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Active : bool with get, set" Usage="System.Net.Sockets.TcpClient.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, установлено ли подключение.</summary>
        <value>Значение <see langword="true" />, если подключение установлено; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы, производные <xref:System.Net.Sockets.TcpClient> от, могут использовать это свойство, чтобы определить, успешно ли выполнена попытка подключения. Он не отслеживает текущее состояние `TcpClient`подключения. Если удаленный узел закрывает соединение, `Active` обновление не будет выполнено. Если вы наследуете от `TcpClient` и требует более близкого внимания к состоянию соединения, <xref:System.Net.Sockets.Socket.Connected%2A> используйте свойство <xref:System.Net.Sockets.TcpClient.Client%2A> объекта <xref:System.Net.Sockets.Socket> , возвращаемого свойством.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.Connected" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.TcpClient.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее количество полученных из сети и доступных для чтения данных.</summary>
        <value>Количество байтов данных, полученных из сети и доступных для чтения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Это `Available` свойство позволяет определить, помещаются ли данные в очередь для чтения. Если данные доступны, вызовите <xref:System.Net.Sockets.NetworkStream.Read%2A> для получения данных. Доступные данные — это общий объем данных, помещенных в очередь сетевого буфера для чтения. Если в сетевом буфере нет данных, `Available` функция возвращает 0.  
  
 Если удаленный узел завершает работу или закрывает соединение, `Available` может <xref:System.Net.Sockets.SocketException>вызвать исключение. Если вы получаете `SocketException`, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода можно обратиться к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
   
  
## Examples  
 В следующем примере кода показано использование `Available` свойства.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpClient1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpClient.BeginConnect (address, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Адрес <see cref="T:System.Net.IPAddress" /> удаленного узла.</param>
        <param name="port">Номер порта удаленного узла.</param>
        <param name="requestCallback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении данной операции.</param>
        <param name="state">Пользовательский объект, содержащий информацию об операции подключения. Этот объект передается делегату <paramref name="requestCallback" /> по завершении операции.</param>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу. Удаленный узел задается объектом <see cref="T:System.Net.IPAddress" /> и номером порта (<see cref="T:System.Int32" />).</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное подключение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная `BeginConnect` операция должна быть завершена путем <xref:System.Net.Sockets.TcpClient.EndConnect%2A> вызова метода. Как правило, метод вызывается `asyncCallback` делегатом.  
  
 Этот метод не блокируется до завершения операции. Для блокировки до завершения операции используйте одну из <xref:System.Net.Sockets.TcpClient.Connect%2A> перегрузок метода.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Net.Sockets.TcpClient> и подключается к удаленному узлу.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpClient1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="address" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Номер порта недействителен.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpClient.BeginConnect (addresses, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses">По крайней мере, один объект <see cref="T:System.Net.IPAddress" />, определяющий удаленные узлы.</param>
        <param name="port">Номер порта удаленных узлов.</param>
        <param name="requestCallback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении данной операции.</param>
        <param name="state">Пользовательский объект, содержащий информацию об операции подключения. Этот объект передается делегату <paramref name="requestCallback" /> по завершении операции.</param>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу. Удаленный узел задается массивом <see cref="T:System.Net.IPAddress" /> и номером порта (<see cref="T:System.Int32" />).</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное подключение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная `BeginConnect` операция должна быть завершена путем <xref:System.Net.Sockets.TcpClient.EndConnect%2A> вызова метода. Как правило, метод вызывается `asyncCallback` делегатом.  
  
 Этот метод не блокируется до завершения операции. Для блокировки до завершения операции используйте одну из <xref:System.Net.Sockets.TcpClient.Connect%2A> перегрузок метода.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 Этот метод обычно используется сразу после вызова <xref:System.Net.Dns.BeginGetHostAddresses%2A> метода, который может возвращать несколько IP-адресов для одного узла.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Net.Sockets.TcpClient> и подключается к удаленному узлу.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpClient1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="addresses" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Номер порта недействителен.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpClient.BeginConnect (host, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host">Имя удаленного узла.</param>
        <param name="port">Номер порта удаленного узла.</param>
        <param name="requestCallback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении данной операции.</param>
        <param name="state">Пользовательский объект, содержащий информацию об операции подключения. Этот объект передается делегату <paramref name="requestCallback" /> по завершении операции.</param>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу. Удаленный узел задается именем узла (<see cref="T:System.String" />) и номером порта (<see cref="T:System.Int32" />).</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное подключение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная `BeginConnect` операция должна быть завершена путем <xref:System.Net.Sockets.TcpClient.EndConnect%2A> вызова метода. Как правило, метод вызывается `asyncCallback` делегатом.  
  
 Этот метод не блокируется до завершения операции. Для блокировки до завершения операции используйте одну из <xref:System.Net.Sockets.TcpClient.Connect%2A> перегрузок метода.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Net.Sockets.TcpClient> и подключается к удаленному узлу.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#6)]
 [!code-csharp[System.Net.Sockets.TcpClient1#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="host" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Номер порта недействителен.</exception>
      </Docs>
    </Member>
    <Member MemberName="Client">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Client { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Client" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Client" />
      <MemberSignature Language="VB.NET" Value="Public Property Client As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Client { System::Net::Sockets::Socket ^ get(); void set(System::Net::Sockets::Socket ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Client : System.Net.Sockets.Socket with get, set" Usage="System.Net.Sockets.TcpClient.Client" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает базовый объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Базовый сетевой объект <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpClient><xref:System.Net.Sockets.Socket> создает для отправки и получения данных по сети. Классы, производные `TcpClient` от, могут использовать это свойство для получения или `Socket`задания этого свойства. Используйте базовый `Socket` `TcpClient` возвращаемый параметр, Еслитребуетсядоступзапределами,которыйпредоставляет.`Client` Можно также использовать `Client` , чтобы задать базовое `Socket` значение для существующего `Socket`. Это может быть полезно, если вы хотите воспользоваться преимуществами простоты `TcpClient` использования уже существующего. `Socket`  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование `Client` свойство. В этом примере изменяется размер буфера приема базового <xref:System.Net.Sockets.Socket> объекта.  
  
 [!code-csharp[TcpClientProtectedMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpClientProtectedMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[TcpClientProtectedMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpClientProtectedMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="tcpClient.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет данный экземпляр <see cref="T:System.Net.Sockets.TcpClient" /> и запрашивает закрытие базового подключения TCP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод помечает экземпляр как ликвидированный и запрашивает, что связанное <xref:System.Net.Sockets.Socket> закрытие TCP-подключения. `Close` В зависимости `Close` от СвойстваTCP-соединениеможетоставатьсяоткрытымвтечениенекотороговременипослевызоваметода,когдаданные<xref:System.Net.Sockets.TcpClient.LingerState%2A> остаются для отправки. При завершении закрытия базового соединения уведомление не предоставляется.  
  
 Вызов этого метода в конечном итоге приведет к закрытию связанного `Socket` объекта и также закроет связанный <xref:System.Net.Sockets.NetworkStream> объект, который используется для отправки и получения данных, если он был создан.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется закрытие <xref:System.Net.Sockets.TcpClient> с помощью `Close` вызова метода.  
  
 [!code-cpp[NCLTCPClientSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLTcpClientSync/CPP/tcpclient.cpp#1)]
 [!code-csharp[NCLTCPClientSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLTcpClientSync/CS/tcpclient.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Подключает клиента к удаленному TCP-узлу, используя заданное имя узла и номер порта.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPEndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPEndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPEndPoint -&gt; unit" Usage="tcpClient.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP">Объект <see cref="T:System.Net.IPEndPoint" />, к которому выполняется подключение.</param>
        <summary>Подключает клиента к удаленному TCP-узлу, используя указанную удаленную сетевую конечную точка.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод, чтобы установить синхронное подключение к удаленному <xref:System.Net.IPEndPoint>узлу с указанным. Перед вызовом `Connect`необходимо создать экземпляр `IPEndPoint` класса, используя IP-адрес и номер порта. Используйте его `IPEndPoint` в `remoteEP` качестве параметра. `Connect` Метод блокируется до тех пор, пока он не будет подключен или завершается ошибкой. После подключения к удаленному узлу используйте <xref:System.Net.Sockets.TcpClient.GetStream%2A> метод для получения базового. <xref:System.Net.Sockets.NetworkStream> Используйте его `NetworkStream` для отправки и получения данных.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода можно обратиться к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md)  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.IPEndPoint> для подключения к удаленному узлу.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#7)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#7)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="remoteEp" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при обращении к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.TcpClient" /> закрыт.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="tcpClient.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Объект <see cref="T:System.Net.IPAddress" /> узла, к которому выполняется подключение.</param>
        <param name="port">Номер порта, к которому выполняется подключение.</param>
        <summary>Подключает клиента к удаленному TCP-узлу, используя указанный IP-адрес и номер порта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод, чтобы установить синхронное соединение с удаленным <xref:System.Net.IPAddress> узлом к указанному номеру порта и. <xref:System.Net.Sockets.TcpClient.Connect%2A> Метод блокируется до тех пор, пока он не будет подключен или завершается ошибкой. После подключения к удаленному узлу используйте <xref:System.Net.Sockets.TcpClient.GetStream%2A> метод для получения базового. <xref:System.Net.Sockets.NetworkStream> Используйте его `NetworkStream` для отправки и получения данных.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода можно обратиться к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода для подключения к удаленному узлу используется IP-адрес и номер порта.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#6)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#6)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="address" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="port" /> имеет значение, не лежащее в диапазоне между <see cref="F:System.Net.IPEndPoint.MinPort" /> и <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при обращении к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] ipAddresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] ipAddresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (ipAddresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ ipAddresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="tcpClient.Connect (ipAddresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipAddresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ipAddresses">Массив <see cref="T:System.Net.IPAddress" /> узла, к которому выполняется подключение.</param>
        <param name="port">Номер порта, к которому выполняется подключение.</param>
        <summary>Подключает клиента к удаленному TCP-узлу, используя указанный IP-адрес и номер порта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод обычно используется сразу после вызова <xref:System.Net.Dns.BeginGetHostAddresses%2A> метода, который может возвращать несколько IP-адресов для одного узла. Вызовите <xref:System.Net.IPAddress> метод, чтобы установить синхронное соединение с удаленным узлом к узлу, заданному массивом элементов, и номером порта. `Connect` `Connect` Метод блокируется до тех пор, пока он не будет подключен или завершается ошибкой. После подключения к удаленному узлу используйте <xref:System.Net.Sockets.TcpClient.GetStream%2A> метод для получения базового. <xref:System.Net.Sockets.NetworkStream> Используйте его `NetworkStream` для отправки и получения данных.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода можно обратиться к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода для подключения к удаленному узлу используется IP-адрес и номер порта.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#8)]
 [!code-csharp[System.Net.Sockets.TcpClient1#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="ipAddresses" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Номер порта недействителен.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод может быть применен только для сокетов, которые используют флаг <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <altmember cref="T:System.Net.Sockets.TcpListener" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="tcpClient.Connect (hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="hostname">DNS-имя удаленного узла, к которому планируется подключение.</param>
        <param name="port">Имя порта удаленного узла, к которому планируется подключение.</param>
        <summary>Подключает клиента к указанному порту заданного узла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод, чтобы установить синхронное соединение с удаленным узлом к указанному имени узла и номеру порта. `Connect` Метод блокируется до тех пор, пока он не будет подключен или завершается ошибкой. После подключения к удаленному узлу используйте <xref:System.Net.Sockets.TcpClient.GetStream%2A> метод для получения базового. <xref:System.Net.Sockets.NetworkStream> Используйте его `NetworkStream` для отправки и получения данных.  
  
 Если включена поддержка протокола IPv6 и `Connect(String, Int32)` вызывается метод для подключения к узлу, который разрешается как в IPv6, так и в IPv4-адресах, будет предпринята попытка подключения к IPv6-адресу до адреса IPv4. Это может привести к задержке времени для установления соединения, если узел не прослушивает IPv6-адрес.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода можно обратиться к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода имя узла и номер порта используются для подключения к удаленному узлу.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#5)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#5)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="hostname" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="port" /> не находится между <see cref="F:System.Net.IPEndPoint.MinPort" /> и <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при обращении к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Подключает клиента к удаленному TCP-узлу, используя заданное имя узла и номер порта в асинхронной операции.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (address As IPAddress, port As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.IPAddress * int -&gt; System.Threading.Tasks.Task" Usage="tcpClient.ConnectAsync (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">Объект <see cref="T:System.Net.IPAddress" /> узла, к которому выполняется подключение.</param>
        <param name="port">Номер порта, к которому выполняется подключение.</param>
        <summary>Подключает клиента к удаленному TCP-узлу, используя заданный IP-адрес и номер порта как асинхронная операция.</summary>
        <returns>Объект задачи, представляющий асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта операция не будет блокироваться. Возвращаемый объект <xref:System.Threading.Tasks.Task> Returns будет завершен после установления соединения TCP. Этот метод не блокирует вызывающий поток во время выполнения запроса на соединение.  
  
 Вызовите этот метод, чтобы установить синхронное подключение удаленного узла к <xref:System.Net.IPAddress> указанному номеру порта и асинхронной операции. После подключения к удаленному узлу используйте <xref:System.Net.Sockets.TcpClient.GetStream%2A> метод для получения базового. <xref:System.Net.Sockets.NetworkStream> Используйте его `NetworkStream` для отправки и получения данных.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода можно обратиться к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="address" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="port" /> имеет значение, не лежащее в диапазоне между <see cref="F:System.Net.IPEndPoint.MinPort" /> и <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при обращении к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (addresses As IPAddress(), port As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.IPAddress[] * int -&gt; System.Threading.Tasks.Task" Usage="tcpClient.ConnectAsync (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="addresses">Массив <see cref="T:System.Net.IPAddress" /> узла, к которому выполняется подключение.</param>
        <param name="port">Номер порта, к которому выполняется подключение.</param>
        <summary>Подключает клиента к удаленному TCP-узлу, используя заданные IP-адреса и номер порта как асинхронная операция.</summary>
        <returns>Объект задачи, представляющий асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта операция не будет блокироваться. Возвращаемый объект <xref:System.Threading.Tasks.Task> Returns будет завершен после установления соединения TCP. Этот метод не блокирует вызывающий поток во время выполнения запроса на соединение.  
  
 Этот метод обычно используется сразу после вызова <xref:System.Net.Dns.BeginGetHostAddresses%2A> метода, который может возвращать несколько IP-адресов для одного узла. Вызовите этот метод, чтобы установить синхронное соединение с удаленным узлом к узлу, заданному массивом <xref:System.Net.IPAddress> элементов, и номером порта в качестве асинхронной операции. После подключения к удаленному узлу используйте <xref:System.Net.Sockets.TcpClient.GetStream%2A> метод для получения базового. <xref:System.Net.Sockets.NetworkStream> Используйте его `NetworkStream` для отправки и получения данных.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода можно обратиться к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="ipAddresses" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Номер порта недействителен.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод может быть применен только для сокетов, которые используют флаг <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <altmember cref="T:System.Net.Sockets.TcpListener" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (host As String, port As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : string * int -&gt; System.Threading.Tasks.Task" Usage="tcpClient.ConnectAsync (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="host">DNS-имя удаленного узла, к которому планируется подключение.</param>
        <param name="port">Имя порта удаленного узла, к которому планируется подключение.</param>
        <summary>Подключает клиента к указанному порту TCP заданного узла как асинхронная операция.</summary>
        <returns>Объект задачи, представляющий асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта операция не будет блокироваться. Возвращаемый объект <xref:System.Threading.Tasks.Task> Returns будет завершен после установления соединения TCP. Этот метод не блокирует вызывающий поток во время выполнения запроса на соединение.  
  
 Вызовите этот метод, чтобы установить синхронное подключение удаленного узла к указанному имени узла и номеру порта в качестве асинхронной операции. После подключения к удаленному узлу используйте <xref:System.Net.Sockets.TcpClient.GetStream%2A> метод для получения базового. <xref:System.Net.Sockets.NetworkStream> Используйте его `NetworkStream` для отправки и получения данных.  
  
 Если включена поддержка протокола IPv6 и <xref:System.Net.Sockets.TcpClient.ConnectAsync%28System.String%2CSystem.Int32%29> вызывается метод для подключения к узлу, который разрешается как в IPv6, так и в IPv4-адресах, будет предпринята попытка подключения к IPv6-адресу до адреса IPv4. Это может привести к задержке времени для установления соединения, если узел не прослушивает IPv6-адрес.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода можно обратиться к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="hostname" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="port" /> не находится между <see cref="F:System.Net.IPEndPoint.MinPort" /> и <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при обращении к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.TcpClient.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, подключен ли основной объект <see cref="T:System.Net.Sockets.Socket" /> для объекта <see cref="T:System.Net.Sockets.TcpClient" /> к удаленному узлу.</summary>
        <value>Значение <see langword="true" />, если сокет <see cref="P:System.Net.Sockets.TcpClient.Client" /> был подключен к удаленному узлу в результате последней операции; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство возвращает состояние <xref:System.Net.Sockets.TcpClient.Client%2A> соединения сокета с последней операцией ввода-вывода. `Connected` При возвращении `false` `Client` сокет либо не был подключен, либо больше не подключен.  
  
 `Connected` Поскольку свойство отражает только состояние соединения в последней операции, следует попытаться отправить или получить сообщение, чтобы определить текущее состояние. После сбоя отправки сообщения это свойство больше не возвращает значение `true`. Обратите внимание, что это поведение характерно для разработки. Вы не можете надежно проверить состояние соединения, так как, за время между тестом и отправкой и получением, подключение могло быть потеряно. В коде необходимо предположить, что сокет подключен, и правильно обработать неудачные передачи.  
  
   
  
## Examples  
 Следующий пример кода подключается к удаленной конечной точке, а затем проверяет подключение.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#2)]
 [!code-csharp[System.Net.Sockets.TcpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="tcpClient.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все управляемые и неуправляемые ресурсы, используемые <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="tcpClient.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Задайте значение <see langword="true" /> для освобождения управляемых и неуправляемых ресурсов; значение <see langword="false" /> для освобождения только неуправляемых ресурсов.</param>
        <summary>Освобождает неуправляемые ресурсы, используемые объектом <see cref="T:System.Net.Sockets.TcpClient" />, а при необходимости освобождает также управляемые ресурсы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается открытым `Dispose()` методом <xref:System.Object.Finalize%2A> и методом. `Dispose()`вызывает этот метод с параметром `disposing` , для `true`которого задано значение. `Finalize`вызывает этот метод с `disposing` `false`параметром, имеющим значение.  
  
 Если параметр `disposing` имеет значение `true`, то данный метод освобождает все ресурсы, занятые любыми управляемыми объектами, на которые ссылается этот объект <xref:System.Net.Sockets.TcpClient>. Это достигается путем вызова `Dispose()` метода для каждого упоминаемого объекта.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Метод 
            <see langword="Dispose" /> может вызываться несколько раз другими объектами. При переопределении метода <see langword="Dispose(Boolean)" /> нужно избегать ссылок на объекты, которые были уничтожены предыдущими вызовами метода <see langword="Dispose" />. Дополнительные сведения о реализации <see langword="Dispose(Boolean)" />см. в разделе [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
<see langword="Dispose" /> Дополнительные сведения о <see cref="M:System.Object.Finalize" />и см. в разделе Очистка неуправляемых [ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и переопределение [метода Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="tcpClient.EndConnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, возвращаемый при вызове объекта <see cref="Overload:System.Net.Sockets.TcpClient.BeginConnect" />.</param>
        <summary>Завершает ожидающий асинхронную попытку на подключение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до завершения операции. Чтобы выполнить эту операцию синхронно, используйте <xref:System.Net.Sockets.TcpClient.Connect%2A> метод.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода можно обратиться к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
   
  
## Examples  
 В следующем примере кода завершается асинхронная попытки подключения.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#7)]
 [!code-csharp[System.Net.Sockets.TcpClient1#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="asyncResult" /> не было возвращено при вызове метода <see cref="Overload:System.Net.Sockets.TcpClient.BeginConnect" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.TcpClient.EndConnect(System.IAsyncResult)" /> был ранее вызван для асинхронного подключения.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к объекту <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Основной объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.TcpClient.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, разрешает ли объект <see cref="T:System.Net.Sockets.TcpClient" /> использовать порт только одному клиенту.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.TcpClient" /> разрешает только одному клиенту использовать конкретный порт; в противном случае — значение <see langword="false" />. По умолчанию используется значение <see langword="true" /> для Windows Server 2003 и Windows XP с пакетом обновления 2 (SP2) и более поздней версии; для всех остальных версий по умолчанию используется значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию несколько клиентов могут использовать конкретный порт. Однако только один из клиентов может выполнять операции с сетевым трафиком, отправляемым на порт. `ExclusiveAddressUse` Свойство можно использовать для предотвращения использования определенного порта несколькими клиентами.  
  
 Это свойство должно быть установлено до привязки базового сокета к порту клиента. Если <xref:System.Net.Sockets.TcpClient.Connect%2A>вызвать метод, <xref:System.Net.Sockets.TcpClient.BeginConnect%2A>, <xref:System.Net.Sockets.TcpClient.%23ctor%28System.Net.IPEndPoint%29>или <xref:System.Net.Sockets.TcpClient.%23ctor%28System.String%2CSystem.Int32%29>, клиентский порт будет привязан как побочный `ExclusiveAddressUse` результат метода, и впоследствии нельзя будет задать свойство.
  
   
  
## Examples  
 В следующем примере кода создается объект <xref:System.Net.Sockets.TcpClient> и получается и задается значение `ExclusiveAddressUse` свойства.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpClient1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к основному сокету.</exception>
        <exception cref="T:System.ObjectDisposedException">Основной объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TcpClient ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="tcpClient.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает ресурсы, используемые классом <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. Код приложения не должен вызывать этот метод; `Finalize` метод объекта автоматически вызывается во время сборки мусора, если окончательное завершение сборщика мусора не было отключено вызовом <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> метода.  
  
 Метод завершения `TcpClient`класса закрывает TCP-соединение и освобождает все управляемые ресурсы, связанные с. <xref:System.Net.Sockets.TcpClient> Эти ресурсы включают в себя <xref:System.Net.Sockets.Socket> базовый компонент, используемый для подключения к удаленному узлу <xref:System.Net.Sockets.NetworkStream> , и используемый для отправки и получения данных. Метод завершения не освобождает неуправляемые ресурсы.  
  
 Дополнительные сведения см. в статьях [методы Finalize и деструкторы](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v%3dvs.100)), [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md)и переопределение [метода Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpClient.Close" />
        <related type="Article" href="~/docs/standard/garbage-collection/index.md">Сборка мусора</related>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.NetworkStream GetStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.NetworkStream GetStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.GetStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream () As NetworkStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::NetworkStream ^ GetStream();" />
      <MemberSignature Language="F#" Value="member this.GetStream : unit -&gt; System.Net.Sockets.NetworkStream" Usage="tcpClient.GetStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.NetworkStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Net.Sockets.NetworkStream" />, используемый для отправки и получения данных.</summary>
        <returns>Базовый объект <see cref="T:System.Net.Sockets.NetworkStream" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Метод возвращает объект <xref:System.Net.Sockets.NetworkStream> , который можно использовать для отправки и получения данных. `GetStream` Класс наследует от класса, который предоставляет обширную коллекцию методов и свойств, используемых для упрощения сетевого взаимодействия. <xref:System.IO.Stream> `NetworkStream`  
  
 Сначала необходимо вызвать <xref:System.Net.Sockets.TcpClient.Connect%2A> метод, <xref:System.Net.Sockets.TcpClient.GetStream%2A> иначе метод <xref:System.InvalidOperationException>вызовет исключение. После получения `NetworkStream` <xref:System.Net.Sockets.NetworkStream.Write%2A> метода вызовите метод для отправки данных на удаленный узел. Вызовите <xref:System.Net.Sockets.NetworkStream.Read%2A> метод, чтобы получить данные, поступающие от удаленного узла. Оба этих метода блокируются до выполнения указанной операции. Вы можете избежать блокировки операции чтения, проверив <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> свойство. `true` Значение означает, что данные поступили с удаленного узла и доступны для чтения. В этом случае <xref:System.Net.Sockets.NetworkStream.Read%2A> гарантируется немедленное завершение. Если удаленный узел отключил подключение, <xref:System.Net.Sockets.NetworkStream.Read%2A> будет немедленно возвращаться с нулевым числом байтов.  
  
> [!NOTE]
>  `NetworkStream` При отправке и получении данных необходимо закрыть. При <xref:System.Net.Sockets.TcpClient> закрытии не `NetworkStream`освобождается.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода можно обратиться к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода используется `GetStream` для получения базового. <xref:System.Net.Sockets.NetworkStream> После получения объект <xref:System.Net.Sockets.NetworkStream>отправляется и получается <xref:System.Net.Sockets.NetworkStream.Write%2A> с помощью методов <xref:System.Net.Sockets.NetworkStream.Read%2A> и.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#14](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#14)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#14](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#14)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Net.Sockets.TcpClient" /> не подключен к удаленному узлу.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> был закрыт.</exception>
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.DataAvailable" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.TcpClient.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает информацию о состоянии задержки связанного сокета.</summary>
        <value>Объект <see cref="T:System.Net.Sockets.LingerOption" />. По умолчанию режим задержки отключен.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство изменяет способ <xref:System.Net.Sockets.Socket.Close%2A> , которым ведет себя метод. `LingerState` Это свойство задается при изменении условий, при которых подключение может быть сброшено с помощью Winsock. Сброс соединения по-прежнему может происходить в зависимости от поведения протокола IP.  
  
 Это свойство определяет период времени, в течение которого TCP-соединение будет оставаться открытым после вызова <xref:System.Net.Sockets.TcpClient.Close%2A> , когда данные будут отправлены. При вызове <xref:System.Net.Sockets.NetworkStream.Write%2A> метода данные помещаются в исходящий сетевой буфер. Это свойство можно использовать, чтобы убедиться, что эти данные отправляются на удаленный узел перед <xref:System.Net.Sockets.TcpClient.Close%2A> тем, как метод удалит подключение.  
  
 Чтобы включить ожидание, создайте <xref:System.Net.Sockets.LingerOption> экземпляр, содержащий нужные значения, и `LingerState` присвойте свойству значение этого экземпляра.  
  
 В следующей таблице описывается <xref:System.Net.Sockets.TcpClient.Close%2A> поведение метода для возможных значений <xref:System.Net.Sockets.LingerOption.Enabled%2A> свойства и <xref:System.Net.Sockets.LingerOption.LingerTime%2A> свойство, хранящееся в `LingerState` свойстве.  
  
|Линжерстате. Enabled|Линжерстате. Линжертиме|Поведение|  
|-------------------------|----------------------------|--------------|  
|`false`(отключено), значение по умолчанию|Время ожидания неприменимо (по умолчанию).|Пытается отправить ожидающие данные до истечения времени ожидания протокола IP по умолчанию.|  
|`true`доступной|Ненулевое время ожидания|Пытается отправить ожидающие данные до истечения заданного времени ожидания. Если попытка не удалась, Winsock сбрасывает подключение.|  
|`true`доступной|Нулевое время ожидания.|Отменяет все ожидающие данные и Winsock сбрасывает подключение.|  
  
 В стеке IP-адресов используется период ожидания протокола IP по умолчанию, используемый в зависимости от времени кругового пути соединения. В большинстве случаев время ожидания, вычисленное стеком, больше релевантно, чем определено приложением. Это поведение по умолчанию для сокета, если `LingerState` свойство не задано.  
  
 Если свойство, хранящееся в свойстве, задано больше, чем время ожидания протокола IP по умолчанию, по умолчанию время ожидания протокола IP по-прежнему будет применяться и переопределено. `LingerState` <xref:System.Net.Sockets.LingerOption.LingerTime%2A>  
  
   
  
## Examples  
 В следующем примере кода задается и получается время ожидания сокетов.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#12](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#12)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#12](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#12)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.LingerOption" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Close" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.TcpClient.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое отключает задержку в том случае, когда буферы отправки и получения не заполнены.</summary>
        <value><see langword="true" />значение, если задержка отключена; в противном случае —. <see langword="false" /> Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `NoDelay` имеет `false`значение, <xref:System.Net.Sockets.TcpClient> то не отправляет пакет по сети, пока не будет собран значительный объем исходящих данных. Из-за объема издержек в сегменте TCP отправка небольших объемов данных неэффективна. Однако существуют ситуации, когда необходимо отправить очень небольшой объем данных или ожидаются немедленные ответы от каждого отправляемого пакета. Решение должно учитывать относительную важность эффективности сети и требований приложений.  
  
   
  
## Examples  
 В следующем примере кода отключается задержка. Затем он проверяет значение `NoDelay` , чтобы убедиться, что свойство было успешно задано.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#13)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#13)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.TcpClient.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает размер приемного буфера.</summary>
        <value>Размер приемного буфера (в байтах). Значение по умолчанию — 8192 байта.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ReceiveBufferSize` Свойство возвращает или задает число байтов, которое ожидается хранить в буфере приема для каждой операции чтения. Это свойство фактически управляет пространством сетевого буфера, выделенным для получения входящих данных.  
  
 Ваш сетевой буфер должен быть не меньше размера буфера приложения, чтобы обеспечить доступность нужных данных при вызове <xref:System.Net.Sockets.NetworkStream.Read%2A?displayProperty=nameWithType> метода. Чтобы задать этот размер, используйте свойство.<xref:System.Net.Sockets.TcpClient.ReceiveBufferSize%2A> Если приложение будет получать данные большого объема, следует передать `Read` методу очень большой буфер приложения.  
  
 Если размер сетевого буфера меньше, чем количество данных, запрошенных в `Read` методе, вы не сможете получить требуемый объем данных в одной операции чтения. Это влечет за собой дополнительные издержки, вызванные дополнительными вызовами `Read` метода.  
  
   
  
## Examples  
 В следующем примере кода задается и получается размер буфера приема.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#8)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#8)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при задании размера буфера.  
  
 -или-  
  
 В приложениях .NET Compact Framework это свойство задать нельзя. Обходные пути см. в примечании, относящемся к платформам, в разделе "Примечания".</exception>
        <altmember cref="P:System.Net.Sockets.TcpClient.SendBufferSize" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.TcpClient.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает длительность временного интервала, в течение которого объект <see cref="T:System.Net.Sockets.TcpClient" /> будет ожидать получение данных после инициации операции чтения.</summary>
        <value>Значение тайм-аута подключения в миллисекундах. Значение по умолчанию — 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство определяет период времени <xref:System.Net.Sockets.NetworkStream.Read%2A> , в течение которого метод будет блокироваться, пока он не сможет получать данные. `ReceiveTimeout` Это время измеряется в миллисекундах. Если время ожидания истекает до `Read` успешного завершения, <xref:System.Net.Sockets.TcpClient> вызывает исключение <xref:System.IO.IOException>. По умолчанию время ожидания отсутствует.  
  
   
  
## Examples  
 В следующем примере кода задается и получается время ожидания получения.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#10)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#10)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.TcpClient.SendTimeout" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.TcpClient.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает размер буфера отправки.</summary>
        <value>Размер буфера передачи (в байтах). Значение по умолчанию — 8192 байта.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство возвращает или задает число байтов, которое ожидается отправить при каждом вызове <xref:System.Net.Sockets.NetworkStream.Write%2A?displayProperty=nameWithType> метода. `SendBufferSize` Это свойство фактически управляет пространством сетевого буфера, выделенным для операции отправки.  
  
 Ваш сетевой буфер должен быть не меньше размера буфера приложения, чтобы гарантировать, что нужные данные будут сохранены и отправлены в рамках одной операции. Чтобы задать этот размер, используйте свойство.<xref:System.Net.Sockets.TcpClient.SendBufferSize%2A> Если приложение будет отправлять групповые данные, следует передать `Write` методу очень большой буфер приложения.  
  
 Если размер сетевого буфера меньше, чем объем данных, предоставляемых `Write` методом, для каждого вызова `Write` метода будет выполняться несколько операций сетевой отправки. Вы можете достичь большей пропускной способности данных, убедившись, что размер сетевого буфера не меньше размера буфера приложения.  
  
   
  
## Examples  
 В следующем примере кода задается и получается размер буфера отправки.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#9)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#9)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.TcpClient.ReceiveBufferSize" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.TcpClient.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает длительность временного интервала, в течение которого объект <see cref="T:System.Net.Sockets.TcpClient" /> будет ожидать успешного завершения операции отправки данных.</summary>
        <value>Значение тайм-аута передачи (в миллисекундах). Значение по умолчанию — 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство определяет период времени <xref:System.Net.Sockets.Socket.Send%2A> , в течение которого метод будет блокироваться до тех пор, пока он не сможет успешно вернуть. `SendTimeout` Это время измеряется в миллисекундах.  
  
 После вызова <xref:System.Net.Sockets.NetworkStream.Write%2A> метода базовый <xref:System.Net.Sockets.Socket> возвращает число байтов, фактически отправленных на узел. Свойство определяет время ожидания, <xref:System.Net.Sockets.TcpClient> по истечении которого будет получено число возвращаемых байтов. `SendTimeout` Если время ожидания истекает до `Send` успешного завершения метода, `TcpClient` выдает исключение <xref:System.Net.Sockets.SocketException>. По умолчанию время ожидания отсутствует.  
  
   
  
## Examples  
 В следующем примере кода задается и `SendTimeout` получается значение.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#11)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#11)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.TcpClient.ReceiveTimeout" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, занятые модулем <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Вызовите IDisposable. Dispose по завершении использования <xref:System.Net.Sockets.TcpClient>. Метод IDisposable. Dispose оставляет в непригодном для <xref:System.Net.Sockets.TcpClient> использования состоянии. После вызова IDisposable. Dispose необходимо освободить все ссылки на, <xref:System.Net.Sockets.TcpClient> чтобы сборщик мусора мог высвободить память, занимаемую заданной. <xref:System.Net.Sockets.TcpClient> Дополнительные сведения см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).

> [!NOTE] 
> Всегда вызывайте IDisposable. Dispose перед освобождением последней ссылки <xref:System.Net.Sockets.TcpClient>на. В противном случае ресурсы, которые он использует, не будут освобождены до тех пор <xref:System.Net.Sockets.TcpClient> , пока сборщик мусора не вызовет метод **Finalize** объекта.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
  </Members>
</Type>